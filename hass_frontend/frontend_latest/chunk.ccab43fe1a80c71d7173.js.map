{"version":3,"sources":["webpack:///./node_modules/@polymer/iron-checked-element-behavior/iron-checked-element-behavior.js","webpack:///./node_modules/@polymer/paper-behaviors/paper-checked-element-behavior.js","webpack:///./node_modules/@polymer/iron-selector/iron-multi-selectable.js","webpack:///./node_modules/@polymer/iron-menu-behavior/iron-menu-behavior.js","webpack:///./node_modules/@polymer/iron-selector/iron-selection.js","webpack:///./node_modules/@polymer/iron-selector/iron-selectable.js"],"names":["IronCheckedElementBehaviorImpl","properties","checked","type","Boolean","value","reflectToAttribute","notify","observer","toggles","String","observers","created","this","_hasIronCheckedElementBehavior","_getValidity","_value","disabled","required","_requiredChanged","setAttribute","removeAttribute","_checkedChanged","active","fire","_valueChanged","undefined","IronCheckedElementBehavior","IronFormElementBehavior","IronValidatableBehavior","__webpack_require__","d","__webpack_exports__","PaperCheckedElementBehavior","PaperCheckedElementBehaviorImpl","call","hasRipple","_ripple","_buttonStateChanged","PaperRippleBehavior","isAttached","PaperInkyFocusBehavior","IronMultiSelectableBehaviorImpl","multi","selectedValues","Array","selectedItems","readOnly","select","_toggleSelected","selected","multiChanged","_selection","_updateSelected","_shouldUpdateSelection","length","_updateAttrForSelected","map","selectedItem","_indexToValue","indexOf","filter","unfilteredValue","IronSelectableBehavior","apply","_selectMulti","_selectSelected","values","_valuesToItems","item","clear","i","setItemSelected","fallbackSelection","get","_valueToItem","_selectionChange","s","_setSelectedItems","_setSelectedItem","push","splice","IronMultiSelectableBehavior","IronMenuBehaviorImpl","IronMenuBehavior","focusedItem","Object","attrForItemTitle","_MODIFIER_KEYS","_SEARCH_RESET_TIMEOUT_MS","_previousTabIndex","hostAttributes","role","listeners","focus","keydown","iron-items-changed","keyBindings","up","down","esc","shift+tab:keydown","attached","_resetTabindices","_defaultFocusAsync","cancelAsync","hasAttribute","_setFocusedItem","arguments","firstSelectedItem","items","forEach","isSelected","_updateMultiselectable","_focusWithKeyboardEvent","event","key","cancelDebouncer","searchText","_searchText","searchLength","fromCharCode","keyCode","toLocaleLowerCase","attr","title","getAttribute","trim","slice","debounce","_clearSearchText","_focusPrevious","curFocusIndex","Number","owner","dom","getOwnerRoot","document","activeElement","_focusNext","_applySelection","_focusedItemChanged","old","_onIronItemsChanged","detail","addedNodes","_onShiftTabDown","oldTabIndex","_shiftTabPressed","async","_onFocus","rootTarget","tabIndex","isLightDescendant","_onUpKey","keyboardEvent","preventDefault","_onDownKey","_onEscKey","blur","_onKeydown","keyboardEventMatchesKeys","stopPropagation","_activateHandler","_disabledChanged","IronA11yKeysBehavior","IronSelection","constructor","selectCallback","selection","excludes","toggle","attrForSelected","activateEvent","selectable","selectedClass","selectedAttribute","_excludedLocalNames","template","dom-bind","dom-if","dom-repeat","_bindFilterItem","_filterItem","bind","_observer","_observeItems","_addListener","detached","unobserveNodes","_removeListener","selectPrevious","index","_valueToIndex","selectNext","selectIndex","forceSynchronousItemUpdate","flush","_updateItems","_checkFallback","eventName","listen","unlisten","_activateEventChanged","nodes","queryDistributedElements","prototype","_setItems","_valueForItem","node","localName","propValue","dashToCamelCase","toggleClass","toggleAttribute","observeNodes","mutation","bubbles","cancelable","e","t","target","_itemActivate","parentNode","defaultPrevented"],"mappings":";mHAwBO,MAAMA,EAAiC,CAE5CC,WAAY,CAUVC,QAAS,CACPC,KAAMC,QACNC,OAAO,EACPC,oBAAoB,EACpBC,QAAQ,EACRC,SAAU,mBAOZC,QAAS,CAACN,KAAMC,QAASC,OAAO,EAAMC,oBAAoB,GAG1DD,MAAO,CAACF,KAAMO,OAAQL,MAAO,KAAMG,SAAU,kBAG/CG,UAAW,CAAC,8BAEZC,QAAS,WAIPC,KAAKC,gCAAiC,GASxCC,aAAc,SAASC,GACrB,OAAOH,KAAKI,WAAaJ,KAAKK,UAAYL,KAAKX,SAMjDiB,iBAAkB,WACZN,KAAKK,SACPL,KAAKO,aAAa,gBAAiB,QAEnCP,KAAKQ,gBAAgB,kBAOzBC,gBAAiB,WACfT,KAAKU,OAASV,KAAKX,QACnBW,KAAKW,KAAK,gBAMZC,cAAe,gBACMC,IAAfb,KAAKR,OAAsC,OAAfQ,KAAKR,QACnCQ,KAAKR,MAAQ,QAMNsB,EAA6B,CACxCC,IACAC,IACA7B,uBC1GF8B,EAAAC,EAAAC,EAAA,sBAAAC,IAuBO,MAAMC,EAAkC,CAI7CZ,gBAAiB,WACftB,EAA+BsB,gBAAgBa,KAAKtB,MAChDA,KAAKuB,cACHvB,KAAKX,QACPW,KAAKwB,QAAQjB,aAAa,UAAW,IAErCP,KAAKwB,QAAQhB,gBAAgB,aAQnCiB,oBAAqB,WACnBC,IAAoBD,oBAAoBH,KAAKtB,MACzCA,KAAKI,UAGLJ,KAAK2B,aACP3B,KAAKX,QAAUW,KAAKU,UAMbU,EAA8B,CACzCQ,IACAd,EACAO,8DCvCK,MAAMQ,EAAkC,CAC7CzC,WAAY,CAKV0C,MAAO,CAACxC,KAAMC,QAASC,OAAO,EAAOG,SAAU,gBAM/CoC,eAAgB,CACdzC,KAAM0C,MACNtC,QAAQ,EACRF,MAAO,WACL,MAAO,KAOXyC,cAAe,CACb3C,KAAM0C,MACNE,UAAU,EACVxC,QAAQ,EACRF,MAAO,WACL,MAAO,MAMbM,UAAW,CAAC,2CAUZqC,OAAQ,SAAS3C,GACXQ,KAAK8B,MACP9B,KAAKoC,gBAAgB5C,GAErBQ,KAAKqC,SAAW7C,GAIpB8C,aAAc,SAASR,GACrB9B,KAAKuC,WAAWT,MAAQA,EACxB9B,KAAKwC,mBAIPC,6BACE,OAAwB,MAAjBzC,KAAKqC,UACgB,MAAvBrC,KAAK+B,gBAA0B/B,KAAK+B,eAAeW,QAG1DC,uBAAwB,WACjB3C,KAAK8B,MAEC9B,KAAKiC,eAAiBjC,KAAKiC,cAAcS,OAAS,IAC3D1C,KAAK+B,eACD/B,KAAKiC,cACAW,IACG,SAASC,GACP,OAAO7C,KAAK8C,cAAc9C,KAAK+C,QAAQF,KAEzC7C,MACHgD,OAAO,SAASC,GACf,OAA0B,MAAnBA,GACNjD,OAXXkD,IAAuBP,uBAAuBQ,MAAMnD,OAexDwC,gBAAiB,WACXxC,KAAK8B,MACP9B,KAAKoD,aAAapD,KAAK+B,gBAEvB/B,KAAKqD,gBAAgBrD,KAAKqC,WAI9Be,aAAc,SAASE,GACrBA,EAASA,GAAU,GAEnB,IAAIrB,GACCjC,KAAKuD,eAAeD,IAAW,IAAIN,OAAO,SAASQ,GAClD,OAAOA,UAIbxD,KAAKuC,WAAWkB,MAAMxB,GAGtB,IAAK,IAAIyB,EAAI,EAAGA,EAAIzB,EAAcS,OAAQgB,IACxC1D,KAAKuC,WAAWoB,gBAAgB1B,EAAcyB,IAAI,GAIhD1D,KAAK4D,oBAAsB5D,KAAKuC,WAAWsB,MAAMnB,SACpC1C,KAAK8D,aAAa9D,KAAK4D,oBAEpC5D,KAAKmC,OAAOnC,KAAK4D,qBAKvBG,iBAAkB,WAChB,IAAIC,EAAIhE,KAAKuC,WAAWsB,MACpB7D,KAAK8B,OACP9B,KAAKiE,kBAAkBD,GACvBhE,KAAKkE,iBAAiBF,EAAEtB,OAASsB,EAAE,GAAK,OAEpCA,SACFhE,KAAKiE,kBAAkB,CAACD,IACxBhE,KAAKkE,iBAAiBF,KAEtBhE,KAAKiE,kBAAkB,IACvBjE,KAAKkE,iBAAiB,QAK5B9B,gBAAiB,SAAS5C,GACxB,IAAIkE,EAAI1D,KAAK+B,eAAegB,QAAQvD,GACnBkE,EAAI,EAEnB1D,KAAKmE,KAAK,iBAAkB3E,GAE5BQ,KAAKoE,OAAO,iBAAkBV,EAAG,IAIrCH,eAAgB,SAASD,GACvB,OAAkB,MAAVA,EAAkB,KAAOA,EAAOV,IAAI,SAASpD,GACnD,OAAOQ,KAAK8D,aAAatE,IACxBQ,QAKMqE,EACT,CAACnB,IAAwBrB,cCrK7BZ,EAAAC,EAAAC,EAAA,sBAAAmD,IAAArD,EAAAC,EAAAC,EAAA,sBAAAoD,IAuBO,MAAMD,EAAuB,CAElClF,WAAY,CAMVoF,YACI,CAAC7E,SAAU,sBAAuBuC,UAAU,EAAM5C,KAAMmF,QAO5DC,iBAAkB,CAACpF,KAAMO,QAKzBO,SAAU,CACRd,KAAMC,QACNC,OAAO,EACPG,SAAU,qBASdgF,eAAgB,CACd,MACA,WACA,WACA,UACA,KACA,SACA,QACA,OACA,UACA,KACA,aACA,QACA,QACA,SACA,cAIFC,yBAA0B,IAG1BC,kBAAmB,EAEnBC,eAAgB,CACdC,KAAQ,QAGVjF,UAAW,CAAC,iCAEZkF,UAAW,CACTC,MAAS,WACTC,QAAW,aACXC,qBAAsB,uBAMxBC,YAAa,CACXC,GAAM,WACNC,KAAQ,aACRC,IAAO,YACPC,oBAAqB,mBAGvBC,SAAU,WACRzF,KAAK0F,oBAUPvD,OAAQ,SAAS3C,GAGXQ,KAAK2F,qBACP3F,KAAK4F,YAAY5F,KAAK2F,oBACtB3F,KAAK2F,mBAAqB,MAE5B,IAAInC,EAAOxD,KAAK8D,aAAatE,GACzBgE,GAAQA,EAAKqC,aAAa,cAE9B7F,KAAK8F,gBAAgBtC,GACrB3B,EAAgCM,OAAOgB,MAAMnD,KAAM+F,aAUrDL,iBAAkB,WAChB,IAAIM,EAAoBhG,KAAK8B,MACxB9B,KAAKiC,eAAiBjC,KAAKiC,cAAc,GAC1CjC,KAAK6C,aAET7C,KAAKiG,MAAMC,QAAQ,SAAS1C,GAC1BA,EAAKjD,aAAa,WAAYiD,IAASwC,EAAoB,IAAM,MACjExC,EAAKjD,aAAa,gBAAiBP,KAAKuC,WAAW4D,WAAW3C,KAC7DxD,OASLoG,uBAAwB,SAAStE,GAC3BA,EACF9B,KAAKO,aAAa,uBAAwB,QAE1CP,KAAKQ,gBAAgB,yBAUzB6F,wBAAyB,SAASC,GAIhC,IAAgD,IAA5CtG,KAAK2E,eAAe5B,QAAQuD,EAAMC,KAAtC,CAGAvG,KAAKwG,gBAAgB,oBAUrB,IARA,IAQgBhD,EARZiD,EAAazG,KAAK0G,aAAe,GAMjCC,GAFJF,IAHUH,EAAMC,KAA2B,GAApBD,EAAMC,IAAI7D,OAC7B4D,EAAMC,IACN1G,OAAO+G,aAAaN,EAAMO,UACZC,qBAEYpE,OAErBgB,EAAI,EAASF,EAAOxD,KAAKiG,MAAMvC,GAAIA,IAC1C,IAAIF,EAAKqC,aAAa,YAAtB,CAIA,IAAIkB,EAAO/G,KAAK0E,kBAAoB,cAChCsC,GAASxD,EAAKuD,IAASvD,EAAKyD,aAAaF,IAAS,IAAIG,OAE1D,KAAIF,EAAMtE,OAASiE,IAIfK,EAAMG,MAAM,EAAGR,GAAcG,qBAAuBL,EAAY,CAClEzG,KAAK8F,gBAAgBtC,GACrB,OAIJxD,KAAK0G,YAAcD,EACnBzG,KAAKoH,SACD,mBACApH,KAAKqH,iBACLrH,KAAK4E,4BAGXyC,iBAAkB,WAChBrH,KAAK0G,YAAc,IAQrBY,eAAgB,WAId,IAHA,IAAI5E,EAAS1C,KAAKiG,MAAMvD,OACpB6E,EAAgBC,OAAOxH,KAAK+C,QAAQ/C,KAAKwE,cAEpCd,EAAI,EAAGA,EAAIhB,EAAS,EAAGgB,IAAK,CACnC,IAAIF,EAAOxD,KAAKiG,OAAOsB,EAAgB7D,EAAIhB,GAAUA,GACrD,IAAKc,EAAKqC,aAAa,YAAa,CAClC,IAAI4B,EAAQC,YAAIlE,GAAMmE,gBAAkBC,SAKxC,GAJA5H,KAAK8F,gBAAgBtC,GAIjBkE,YAAID,GAAOI,eAAiBrE,EAC9B,UAWRsE,WAAY,WAIV,IAHA,IAAIpF,EAAS1C,KAAKiG,MAAMvD,OACpB6E,EAAgBC,OAAOxH,KAAK+C,QAAQ/C,KAAKwE,cAEpCd,EAAI,EAAGA,EAAIhB,EAAS,EAAGgB,IAAK,CACnC,IAAIF,EAAOxD,KAAKiG,OAAOsB,EAAgB7D,GAAKhB,GAC5C,IAAKc,EAAKqC,aAAa,YAAa,CAClC,IAAI4B,EAAQC,YAAIlE,GAAMmE,gBAAkBC,SAKxC,GAJA5H,KAAK8F,gBAAgBtC,GAIjBkE,YAAID,GAAOI,eAAiBrE,EAC9B,UAcRuE,gBAAiB,SAASvE,EAAM2C,GAC1BA,EACF3C,EAAKjD,aAAa,gBAAiB,QAEnCiD,EAAKjD,aAAa,gBAAiB,SAErC2C,IAAuB6E,gBAAgB5E,MAAMnD,KAAM+F,YAWrDiC,oBAAqB,SAASxD,EAAayD,GACzCA,GAAOA,EAAI1H,aAAa,WAAY,OAChCiE,GAAgBA,EAAYqB,aAAa,aACxC7F,KAAKI,WACRoE,EAAYjE,aAAa,WAAY,KACrCiE,EAAYS,UAWhBiD,oBAAqB,SAAS5B,GACxBA,EAAM6B,OAAOC,WAAW1F,QAC1B1C,KAAK0F,oBAST2C,gBAAiB,SAAS/B,GACxB,IAAIgC,EAActI,KAAKiH,aAAa,YAEpC3C,EAAqBiE,kBAAmB,EAExCvI,KAAK8F,gBAAgB,MAErB9F,KAAKO,aAAa,WAAY,MAE9BP,KAAKwI,MAAM,WACTxI,KAAKO,aAAa,WAAY+H,GAC9BhE,EAAqBiE,kBAAmB,GAEvC,IAQLE,SAAU,SAASnC,GACjB,IAAIhC,EAAqBiE,iBAAzB,CAOA,IAAIG,EAC6BhB,YAAIpB,GAAOoC,YACxCA,IAAe1I,WAAuC,IAAxB0I,EAAWC,UACxC3I,KAAK4I,kBAAkBF,MAK5B1I,KAAK2F,mBAAqB3F,KAAKwI,MAAM,WAGnC,IAAIxC,EAAoBhG,KAAK8B,MACxB9B,KAAKiC,eAAiBjC,KAAKiC,cAAc,GAC1CjC,KAAK6C,aAET7C,KAAK8F,gBAAgB,MAEjBE,EACFhG,KAAK8F,gBAAgBE,GACZhG,KAAKiG,MAAM,IAEpBjG,KAAK8H,kBAUXe,SAAU,SAASvC,GAEjBtG,KAAKsH,iBACLhB,EAAM6B,OAAOW,cAAcC,kBAQ7BC,WAAY,SAAS1C,GACnBtG,KAAK8H,aACLxB,EAAM6B,OAAOW,cAAcC,kBAQ7BE,UAAW,SAAS3C,GAClB,IAAI9B,EAAcxE,KAAKwE,YACnBA,GACFA,EAAY0E,QAShBC,WAAY,SAAS7C,GACdtG,KAAKoJ,yBAAyB9C,EAAO,gBAExCtG,KAAKqG,wBAAwBC,GAE/BA,EAAM+C,mBAIRC,iBAAkB,SAAShD,GACzBpD,IAAuBoG,iBAAiBhI,KAAKtB,KAAMsG,GACnDA,EAAM+C,mBAORE,iBAAkB,SAASnJ,GACrBA,GACFJ,KAAK6E,kBACD7E,KAAK6F,aAAa,YAAc7F,KAAK2I,SAAW,EACpD3I,KAAKQ,gBACD,aACMR,KAAK6F,aAAa,aAC5B7F,KAAKO,aAAa,WAAYP,KAAK6E,oBAKzCP,kBAAwC,GAG3BC,EACT,CAACF,EAA6BmF,IAAsBlF,4DC1ajD,MAAMmF,EAKXC,YAAYC,GACV3J,KAAK4J,UAAY,GACjB5J,KAAK2J,eAAiBA,EAUxB9F,MACE,OAAO7D,KAAK8B,MAAQ9B,KAAK4J,UAAUzC,QAAUnH,KAAK4J,UAAU,GAQ9DnG,MAAMoG,GACJ7J,KAAK4J,UAAUzC,QAAQjB,QAAQ,SAAS1C,KACjCqG,GAAYA,EAAS9G,QAAQS,GAAQ,IACxCxD,KAAK2D,gBAAgBH,GAAM,IAE5BxD,MASLmG,WAAW3C,GACT,OAAOxD,KAAK4J,UAAU7G,QAAQS,IAAS,EASzCG,gBAAgBH,EAAM2C,GACpB,GAAY,MAAR3C,GACE2C,IAAenG,KAAKmG,WAAW3C,GAAO,CAGxC,GAAI2C,EACFnG,KAAK4J,UAAUzF,KAAKX,OACf,CACL,IAAIE,EAAI1D,KAAK4J,UAAU7G,QAAQS,GAC3BE,GAAK,GACP1D,KAAK4J,UAAUxF,OAAOV,EAAG,GAGzB1D,KAAK2J,gBACP3J,KAAK2J,eAAenG,EAAM2C,IAalChE,OAAOqB,GACDxD,KAAK8B,MACP9B,KAAK8J,OAAOtG,GACHxD,KAAK6D,QAAUL,IACxBxD,KAAK2D,gBAAgB3D,KAAK6D,OAAO,GACjC7D,KAAK2D,gBAAgBH,GAAM,IAS/BsG,OAAOtG,GACLxD,KAAK2D,gBAAgBH,GAAOxD,KAAKmG,WAAW3C,KCxGhDvC,EAAAC,EAAAC,EAAA,sBAAA+B,IAoBO,MAAMA,EAAyB,CA8BpC9D,WAAY,CAYV2K,gBAAiB,CAACzK,KAAMO,OAAQL,MAAO,MAOvC6C,SAAU,CAAC/C,KAAMO,OAAQH,QAAQ,GAOjCmD,aAAc,CAACvD,KAAMmF,OAAQvC,UAAU,EAAMxC,QAAQ,GAOrDsK,cACI,CAAC1K,KAAMO,OAAQL,MAAO,MAAOG,SAAU,yBAM3CsK,WAAYpK,OAKZqK,cAAe,CAAC5K,KAAMO,OAAQL,MAAO,iBAKrC2K,kBAAmB,CAAC7K,KAAMO,OAAQL,MAAO,MAMzCoE,kBAAmB,CAACtE,KAAMO,OAAQL,MAAO,MAKzCyG,MAAO,CACL3G,KAAM0C,MACNE,UAAU,EACVxC,QAAQ,EACRF,MAAO,WACL,MAAO,KAUX4K,oBAAqB,CACnB9K,KAAMmF,OACNjF,MAAO,WACL,MAAO,CACL6K,SAAY,EACZC,WAAY,EACZC,SAAU,EACVC,aAAc,MAMtB1K,UAAW,CACT,0CACA,4BACA,qCAGFC,QAAS,WACPC,KAAKyK,gBAAkBzK,KAAK0K,YAAYC,KAAK3K,MAC7CA,KAAKuC,WAAa,IAAIkH,EAAczJ,KAAK+H,gBAAgB4C,KAAK3K,QAGhEyF,SAAU,WACRzF,KAAK4K,UAAY5K,KAAK6K,cAAc7K,MACpCA,KAAK8K,aAAa9K,KAAKgK,gBAGzBe,SAAU,WACJ/K,KAAK4K,WACPlD,YAAI1H,MAAMgL,eAAehL,KAAK4K,WAEhC5K,KAAKiL,gBAAgBjL,KAAKgK,gBAU5BjH,QAAS,SAASS,GAChB,OAAOxD,KAAKiG,MAAQjG,KAAKiG,MAAMlD,QAAQS,IAAS,GASlDrB,OAAQ,SAAS3C,GACfQ,KAAKqC,SAAW7C,GAQlB0L,eAAgB,WACd,IAAIxI,EAAS1C,KAAKiG,MAAMvD,OACpByI,EAAQzI,EAAS,OACC7B,IAAlBb,KAAKqC,WACP8I,GAAS3D,OAAOxH,KAAKoL,cAAcpL,KAAKqC,WAAa,EAAIK,GAAUA,GAErE1C,KAAKqC,SAAWrC,KAAK8C,cAAcqI,IAQrCE,WAAY,WACV,IAAIF,EAAQ,OACUtK,IAAlBb,KAAKqC,WACP8I,GACK3D,OAAOxH,KAAKoL,cAAcpL,KAAKqC,WAAa,GAAKrC,KAAKiG,MAAMvD,QAEnE1C,KAAKqC,SAAWrC,KAAK8C,cAAcqI,IAQrCG,YAAa,SAASH,GACpBnL,KAAKmC,OAAOnC,KAAK8C,cAAcqI,KAejCI,2BAA4B,WACtBvL,KAAK4K,WAA6C,mBAAzB5K,KAAK4K,UAAUY,MAO1CxL,KAAK4K,UAAUY,QAEfxL,KAAKyL,gBAKThJ,6BACE,OAAwB,MAAjBzC,KAAKqC,UAGdqJ,eAAgB,WACd1L,KAAKwC,mBAGPsI,aAAc,SAASa,GACrB3L,KAAK4L,OAAO5L,KAAM2L,EAAW,qBAG/BV,gBAAiB,SAASU,GACxB3L,KAAK6L,SAAS7L,KAAM2L,EAAW,qBAGjCG,sBAAuB,SAASH,EAAW1D,GACzCjI,KAAKiL,gBAAgBhD,GACrBjI,KAAK8K,aAAaa,IAGpBF,aAAc,WACZ,IAAIM,EAAQrE,YAAI1H,MAAMgM,yBAAyBhM,KAAKiK,YAAc,KAClE8B,EAAQ/J,MAAMiK,UAAUjJ,OAAO1B,KAAKyK,EAAO/L,KAAKyK,iBAChDzK,KAAKkM,UAAUH,IAGjBpJ,uBAAwB,WAClB3C,KAAK6C,eACP7C,KAAKqC,SAAWrC,KAAKmM,cAAcnM,KAAK6C,gBAI5CL,gBAAiB,WACfxC,KAAKqD,gBAAgBrD,KAAKqC,WAG5BgB,gBAAiB,SAAShB,GACxB,GAAKrC,KAAKiG,MAAV,CAIA,IAAIzC,EAAOxD,KAAK8D,aAAa9D,KAAKqC,UAC9BmB,EACFxD,KAAKuC,WAAWJ,OAAOqB,GAEvBxD,KAAKuC,WAAWkB,QAIdzD,KAAK4D,mBAAqB5D,KAAKiG,MAAMvD,aACV7B,IAA1Bb,KAAKuC,WAAWsB,QACnB7D,KAAKqC,SAAWrC,KAAK4D,qBAIzB8G,YAAa,SAAS0B,GACpB,OAAQpM,KAAKoK,oBAAoBgC,EAAKC,YAGxCvI,aAAc,SAAStE,GACrB,OAAiB,MAATA,EAAiB,KAAOQ,KAAKiG,MAAMjG,KAAKoL,cAAc5L,KAGhE4L,cAAe,SAAS5L,GACtB,IAAIQ,KAAK+J,gBAOP,OAAOvC,OAAOhI,GANd,IAAK,IAAWgE,EAAPE,EAAI,EAASF,EAAOxD,KAAKiG,MAAMvC,GAAIA,IAC1C,GAAI1D,KAAKmM,cAAc3I,IAAShE,EAC9B,OAAOkE,GAQfZ,cAAe,SAASqI,GACtB,IAAInL,KAAK+J,gBAMP,OAAOoB,EALP,IAAI3H,EAAOxD,KAAKiG,MAAMkF,GACtB,OAAI3H,EACKxD,KAAKmM,cAAc3I,QAD5B,GAQJ2I,cAAe,SAAS3I,GACtB,IAAKA,EACH,OAAO,KAET,IAAKxD,KAAK+J,gBAAiB,CACzB,IAAIrG,EAAI1D,KAAK+C,QAAQS,GACrB,OAAc,IAAPE,EAAW,KAAOA,EAE3B,IAAI4I,EAAY9I,EAAK+I,YAAgBvM,KAAK+J,kBAC1C,OAAoBlJ,MAAbyL,EAAyBA,EACA9I,EAAKyD,aAAajH,KAAK+J,kBAGzDhC,gBAAiB,SAASvE,EAAM2C,GAC1BnG,KAAKkK,eACPlK,KAAKwM,YAAYxM,KAAKkK,cAAe/D,EAAY3C,GAE/CxD,KAAKmK,mBACPnK,KAAKyM,gBAAgBzM,KAAKmK,kBAAmBhE,EAAY3C,GAE3DxD,KAAK+D,mBACL/D,KAAKW,KAAK,SAAWwF,EAAa,SAAW,YAAa,CAAC3C,KAAMA,KAGnEO,iBAAkB,WAChB/D,KAAKkE,iBAAiBlE,KAAKuC,WAAWsB,QAIxCgH,cAAe,SAASuB,GACtB,OAAO1E,YAAI0E,GAAMM,aAAa,SAASC,GACrC3M,KAAKyL,eACLzL,KAAKwC,kBAILxC,KAAKW,KACD,qBAAsBgM,EAAU,CAACC,SAAS,EAAOC,YAAY,OAIrEvD,iBAAkB,SAASwD,GAGzB,IAFA,IAAIC,EAAID,EAAEE,OACN/G,EAAQjG,KAAKiG,MACV8G,GAAKA,GAAK/M,MAAM,CACrB,IAAI0D,EAAIuC,EAAMlD,QAAQgK,GACtB,GAAIrJ,GAAK,EAAG,CACV,IAAIlE,EAAQQ,KAAK8C,cAAcY,GAE/B,YADA1D,KAAKiN,cAAczN,EAAOuN,GAG5BA,EAAIA,EAAEG,aAIVD,cAAe,SAASzN,EAAOgE,GACxBxD,KAAKW,KAAK,gBAAiB,CAAC0B,SAAU7C,EAAOgE,KAAMA,GAAO,CACpDqJ,YAAY,IAEbM,kBACRnN,KAAKmC,OAAO3C","file":"chunk.ccab43fe1a80c71d7173.js","sourcesContent":["/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\n\nimport {IronFormElementBehavior} from '@polymer/iron-form-element-behavior/iron-form-element-behavior.js';\nimport {IronValidatableBehavior} from '@polymer/iron-validatable-behavior/iron-validatable-behavior.js';\n\n/**\n * Use `IronCheckedElementBehavior` to implement a custom element that has a\n * `checked` property, which can be used for validation if the element is also\n * `required`. Element instances implementing this behavior will also be\n * registered for use in an `iron-form` element.\n *\n * @demo demo/index.html\n * @polymerBehavior IronCheckedElementBehavior\n */\nexport const IronCheckedElementBehaviorImpl = {\n\n  properties: {\n    /**\n     * Fired when the checked state changes.\n     *\n     * @event iron-change\n     */\n\n    /**\n     * Gets or sets the state, `true` is checked and `false` is unchecked.\n     */\n    checked: {\n      type: Boolean,\n      value: false,\n      reflectToAttribute: true,\n      notify: true,\n      observer: '_checkedChanged'\n    },\n\n    /**\n     * If true, the button toggles the active state with each tap or press\n     * of the spacebar.\n     */\n    toggles: {type: Boolean, value: true, reflectToAttribute: true},\n\n    /* Overriden from IronFormElementBehavior */\n    value: {type: String, value: 'on', observer: '_valueChanged'}\n  },\n\n  observers: ['_requiredChanged(required)'],\n\n  created: function() {\n    // Used by `iron-form` to handle the case that an element with this behavior\n    // doesn't have a role of 'checkbox' or 'radio', but should still only be\n    // included when the form is serialized if `this.checked === true`.\n    this._hasIronCheckedElementBehavior = true;\n  },\n\n  /**\n   * Returns false if the element is required and not checked, and true\n   * otherwise.\n   * @param {*=} _value Ignored.\n   * @return {boolean} true if `required` is false or if `checked` is true.\n   */\n  _getValidity: function(_value) {\n    return this.disabled || !this.required || this.checked;\n  },\n\n  /**\n   * Update the aria-required label when `required` is changed.\n   */\n  _requiredChanged: function() {\n    if (this.required) {\n      this.setAttribute('aria-required', 'true');\n    } else {\n      this.removeAttribute('aria-required');\n    }\n  },\n\n  /**\n   * Fire `iron-changed` when the checked state changes.\n   */\n  _checkedChanged: function() {\n    this.active = this.checked;\n    this.fire('iron-change');\n  },\n\n  /**\n   * Reset value to 'on' if it is set to `undefined`.\n   */\n  _valueChanged: function() {\n    if (this.value === undefined || this.value === null) {\n      this.value = 'on';\n    }\n  }\n};\n\n/** @polymerBehavior */\nexport const IronCheckedElementBehavior = [\n  IronFormElementBehavior,\n  IronValidatableBehavior,\n  IronCheckedElementBehaviorImpl\n];\n","/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\n\nimport {IronCheckedElementBehavior, IronCheckedElementBehaviorImpl} from '@polymer/iron-checked-element-behavior/iron-checked-element-behavior.js';\n\nimport {PaperInkyFocusBehavior} from './paper-inky-focus-behavior.js';\nimport {PaperRippleBehavior} from './paper-ripple-behavior.js';\n\n/**\n * Use `PaperCheckedElementBehavior` to implement a custom element that has a\n * `checked` property similar to `IronCheckedElementBehavior` and is compatible\n * with having a ripple effect.\n * @polymerBehavior PaperCheckedElementBehavior\n */\nexport const PaperCheckedElementBehaviorImpl = {\n  /**\n   * Synchronizes the element's checked state with its ripple effect.\n   */\n  _checkedChanged: function() {\n    IronCheckedElementBehaviorImpl._checkedChanged.call(this);\n    if (this.hasRipple()) {\n      if (this.checked) {\n        this._ripple.setAttribute('checked', '');\n      } else {\n        this._ripple.removeAttribute('checked');\n      }\n    }\n  },\n\n  /**\n   * Synchronizes the element's `active` and `checked` state.\n   */\n  _buttonStateChanged: function() {\n    PaperRippleBehavior._buttonStateChanged.call(this);\n    if (this.disabled) {\n      return;\n    }\n    if (this.isAttached) {\n      this.checked = this.active;\n    }\n  }\n};\n\n/** @polymerBehavior */\nexport const PaperCheckedElementBehavior = [\n  PaperInkyFocusBehavior,\n  IronCheckedElementBehavior,\n  PaperCheckedElementBehaviorImpl\n];\n","/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\n\nimport {IronSelectableBehavior} from './iron-selectable.js';\n\n/**\n * @polymerBehavior IronMultiSelectableBehavior\n */\nexport const IronMultiSelectableBehaviorImpl = {\n  properties: {\n\n    /**\n     * If true, multiple selections are allowed.\n     */\n    multi: {type: Boolean, value: false, observer: 'multiChanged'},\n\n    /**\n     * Gets or sets the selected elements. This is used instead of `selected`\n     * when `multi` is true.\n     */\n    selectedValues: {\n      type: Array,\n      notify: true,\n      value: function() {\n        return [];\n      }\n    },\n\n    /**\n     * Returns an array of currently selected items.\n     */\n    selectedItems: {\n      type: Array,\n      readOnly: true,\n      notify: true,\n      value: function() {\n        return [];\n      }\n    },\n\n  },\n\n  observers: ['_updateSelected(selectedValues.splices)'],\n\n  /**\n   * Selects the given value. If the `multi` property is true, then the selected\n   * state of the `value` will be toggled; otherwise the `value` will be\n   * selected.\n   *\n   * @method select\n   * @param {string|number} value the value to select.\n   */\n  select: function(value) {\n    if (this.multi) {\n      this._toggleSelected(value);\n    } else {\n      this.selected = value;\n    }\n  },\n\n  multiChanged: function(multi) {\n    this._selection.multi = multi;\n    this._updateSelected();\n  },\n\n  // UNUSED, FOR API COMPATIBILITY\n  get _shouldUpdateSelection() {\n    return this.selected != null ||\n        (this.selectedValues != null && this.selectedValues.length);\n  },\n\n  _updateAttrForSelected: function() {\n    if (!this.multi) {\n      IronSelectableBehavior._updateAttrForSelected.apply(this);\n    } else if (this.selectedItems && this.selectedItems.length > 0) {\n      this.selectedValues =\n          this.selectedItems\n              .map(\n                  function(selectedItem) {\n                    return this._indexToValue(this.indexOf(selectedItem));\n                  },\n                  this)\n              .filter(function(unfilteredValue) {\n                return unfilteredValue != null;\n              }, this);\n    }\n  },\n\n  _updateSelected: function() {\n    if (this.multi) {\n      this._selectMulti(this.selectedValues);\n    } else {\n      this._selectSelected(this.selected);\n    }\n  },\n\n  _selectMulti: function(values) {\n    values = values || [];\n\n    var selectedItems =\n        (this._valuesToItems(values) || []).filter(function(item) {\n          return item !== null && item !== undefined;\n        });\n\n    // clear all but the current selected items\n    this._selection.clear(selectedItems);\n\n    // select only those not selected yet\n    for (var i = 0; i < selectedItems.length; i++) {\n      this._selection.setItemSelected(selectedItems[i], true);\n    }\n\n    // Check for items, since this array is populated only when attached\n    if (this.fallbackSelection && !this._selection.get().length) {\n      var fallback = this._valueToItem(this.fallbackSelection);\n      if (fallback) {\n        this.select(this.fallbackSelection);\n      }\n    }\n  },\n\n  _selectionChange: function() {\n    var s = this._selection.get();\n    if (this.multi) {\n      this._setSelectedItems(s);\n      this._setSelectedItem(s.length ? s[0] : null);\n    } else {\n      if (s !== null && s !== undefined) {\n        this._setSelectedItems([s]);\n        this._setSelectedItem(s);\n      } else {\n        this._setSelectedItems([]);\n        this._setSelectedItem(null);\n      }\n    }\n  },\n\n  _toggleSelected: function(value) {\n    var i = this.selectedValues.indexOf(value);\n    var unselected = i < 0;\n    if (unselected) {\n      this.push('selectedValues', value);\n    } else {\n      this.splice('selectedValues', i, 1);\n    }\n  },\n\n  _valuesToItems: function(values) {\n    return (values == null) ? null : values.map(function(value) {\n      return this._valueToItem(value);\n    }, this);\n  }\n};\n\n/** @polymerBehavior */\nexport const IronMultiSelectableBehavior =\n    [IronSelectableBehavior, IronMultiSelectableBehaviorImpl];\n","/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\n\nimport {IronA11yKeysBehavior} from '@polymer/iron-a11y-keys-behavior/iron-a11y-keys-behavior.js';\nimport {IronMultiSelectableBehavior, IronMultiSelectableBehaviorImpl} from '@polymer/iron-selector/iron-multi-selectable.js';\nimport {IronSelectableBehavior} from '@polymer/iron-selector/iron-selectable.js';\nimport {dom} from '@polymer/polymer/lib/legacy/polymer.dom.js';\n\n/**\n * `IronMenuBehavior` implements accessible menu behavior.\n *\n * @demo demo/index.html\n * @polymerBehavior IronMenuBehavior\n */\nexport const IronMenuBehaviorImpl = {\n\n  properties: {\n\n    /**\n     * Returns the currently focused item.\n     * @type {?Object}\n     */\n    focusedItem:\n        {observer: '_focusedItemChanged', readOnly: true, type: Object},\n\n    /**\n     * The attribute to use on menu items to look up the item title. Typing the\n     * first letter of an item when the menu is open focuses that item. If\n     * unset, `textContent` will be used.\n     */\n    attrForItemTitle: {type: String},\n\n    /**\n     * @type {boolean}\n     */\n    disabled: {\n      type: Boolean,\n      value: false,\n      observer: '_disabledChanged',\n    },\n  },\n\n  /**\n   * The list of keys has been taken from\n   * https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/getModifierState\n   * @private\n   */\n  _MODIFIER_KEYS: [\n    'Alt',\n    'AltGraph',\n    'CapsLock',\n    'Control',\n    'Fn',\n    'FnLock',\n    'Hyper',\n    'Meta',\n    'NumLock',\n    'OS',\n    'ScrollLock',\n    'Shift',\n    'Super',\n    'Symbol',\n    'SymbolLock'\n  ],\n\n  /** @private */\n  _SEARCH_RESET_TIMEOUT_MS: 1000,\n\n  /** @private */\n  _previousTabIndex: 0,\n\n  hostAttributes: {\n    'role': 'menu',\n  },\n\n  observers: ['_updateMultiselectable(multi)'],\n\n  listeners: {\n    'focus': '_onFocus',\n    'keydown': '_onKeydown',\n    'iron-items-changed': '_onIronItemsChanged'\n  },\n\n  /**\n   * @type {!Object}\n   */\n  keyBindings: {\n    'up': '_onUpKey',\n    'down': '_onDownKey',\n    'esc': '_onEscKey',\n    'shift+tab:keydown': '_onShiftTabDown'\n  },\n\n  attached: function() {\n    this._resetTabindices();\n  },\n\n  /**\n   * Selects the given value. If the `multi` property is true, then the selected\n   * state of the `value` will be toggled; otherwise the `value` will be\n   * selected.\n   *\n   * @param {string|number} value the value to select.\n   */\n  select: function(value) {\n    // Cancel automatically focusing a default item if the menu received focus\n    // through a user action selecting a particular item.\n    if (this._defaultFocusAsync) {\n      this.cancelAsync(this._defaultFocusAsync);\n      this._defaultFocusAsync = null;\n    }\n    var item = this._valueToItem(value);\n    if (item && item.hasAttribute('disabled'))\n      return;\n    this._setFocusedItem(item);\n    IronMultiSelectableBehaviorImpl.select.apply(this, arguments);\n  },\n\n  /**\n   * Resets all tabindex attributes to the appropriate value based on the\n   * current selection state. The appropriate value is `0` (focusable) for\n   * the default selected item, and `-1` (not keyboard focusable) for all\n   * other items. Also sets the correct initial values for aria-selected\n   * attribute, true for default selected item and false for others.\n   */\n  _resetTabindices: function() {\n    var firstSelectedItem = this.multi ?\n        (this.selectedItems && this.selectedItems[0]) :\n        this.selectedItem;\n\n    this.items.forEach(function(item) {\n      item.setAttribute('tabindex', item === firstSelectedItem ? '0' : '-1');\n      item.setAttribute('aria-selected', this._selection.isSelected(item));\n    }, this);\n  },\n\n  /**\n   * Sets appropriate ARIA based on whether or not the menu is meant to be\n   * multi-selectable.\n   *\n   * @param {boolean} multi True if the menu should be multi-selectable.\n   */\n  _updateMultiselectable: function(multi) {\n    if (multi) {\n      this.setAttribute('aria-multiselectable', 'true');\n    } else {\n      this.removeAttribute('aria-multiselectable');\n    }\n  },\n\n  /**\n   * Given a KeyboardEvent, this method will focus the appropriate item in the\n   * menu (if there is a relevant item, and it is possible to focus it).\n   *\n   * @param {KeyboardEvent} event A KeyboardEvent.\n   */\n  _focusWithKeyboardEvent: function(event) {\n    // Make sure that the key pressed is not a modifier key.\n    // getModifierState is not being used, as it is not available in Safari\n    // earlier than 10.0.2 (https://trac.webkit.org/changeset/206725/webkit)\n    if (this._MODIFIER_KEYS.indexOf(event.key) !== -1)\n      return;\n\n    this.cancelDebouncer('_clearSearchText');\n\n    var searchText = this._searchText || '';\n    var key = event.key && event.key.length == 1 ?\n        event.key :\n        String.fromCharCode(event.keyCode);\n    searchText += key.toLocaleLowerCase();\n\n    var searchLength = searchText.length;\n\n    for (var i = 0, item; item = this.items[i]; i++) {\n      if (item.hasAttribute('disabled')) {\n        continue;\n      }\n\n      var attr = this.attrForItemTitle || 'textContent';\n      var title = (item[attr] || item.getAttribute(attr) || '').trim();\n\n      if (title.length < searchLength) {\n        continue;\n      }\n\n      if (title.slice(0, searchLength).toLocaleLowerCase() == searchText) {\n        this._setFocusedItem(item);\n        break;\n      }\n    }\n\n    this._searchText = searchText;\n    this.debounce(\n        '_clearSearchText',\n        this._clearSearchText,\n        this._SEARCH_RESET_TIMEOUT_MS);\n  },\n\n  _clearSearchText: function() {\n    this._searchText = '';\n  },\n\n  /**\n   * Focuses the previous item (relative to the currently focused item) in the\n   * menu, disabled items will be skipped.\n   * Loop until length + 1 to handle case of single item in menu.\n   */\n  _focusPrevious: function() {\n    var length = this.items.length;\n    var curFocusIndex = Number(this.indexOf(this.focusedItem));\n\n    for (var i = 1; i < length + 1; i++) {\n      var item = this.items[(curFocusIndex - i + length) % length];\n      if (!item.hasAttribute('disabled')) {\n        var owner = dom(item).getOwnerRoot() || document;\n        this._setFocusedItem(item);\n\n        // Focus might not have worked, if the element was hidden or not\n        // focusable. In that case, try again.\n        if (dom(owner).activeElement == item) {\n          return;\n        }\n      }\n    }\n  },\n\n  /**\n   * Focuses the next item (relative to the currently focused item) in the\n   * menu, disabled items will be skipped.\n   * Loop until length + 1 to handle case of single item in menu.\n   */\n  _focusNext: function() {\n    var length = this.items.length;\n    var curFocusIndex = Number(this.indexOf(this.focusedItem));\n\n    for (var i = 1; i < length + 1; i++) {\n      var item = this.items[(curFocusIndex + i) % length];\n      if (!item.hasAttribute('disabled')) {\n        var owner = dom(item).getOwnerRoot() || document;\n        this._setFocusedItem(item);\n\n        // Focus might not have worked, if the element was hidden or not\n        // focusable. In that case, try again.\n        if (dom(owner).activeElement == item) {\n          return;\n        }\n      }\n    }\n  },\n\n  /**\n   * Mutates items in the menu based on provided selection details, so that\n   * all items correctly reflect selection state.\n   *\n   * @param {Element} item An item in the menu.\n   * @param {boolean} isSelected True if the item should be shown in a\n   * selected state, otherwise false.\n   */\n  _applySelection: function(item, isSelected) {\n    if (isSelected) {\n      item.setAttribute('aria-selected', 'true');\n    } else {\n      item.setAttribute('aria-selected', 'false');\n    }\n    IronSelectableBehavior._applySelection.apply(this, arguments);\n  },\n\n  /**\n   * Discretely updates tabindex values among menu items as the focused item\n   * changes.\n   *\n   * @param {Element} focusedItem The element that is currently focused.\n   * @param {?Element} old The last element that was considered focused, if\n   * applicable.\n   */\n  _focusedItemChanged: function(focusedItem, old) {\n    old && old.setAttribute('tabindex', '-1');\n    if (focusedItem && !focusedItem.hasAttribute('disabled') &&\n        !this.disabled) {\n      focusedItem.setAttribute('tabindex', '0');\n      focusedItem.focus();\n    }\n  },\n\n  /**\n   * A handler that responds to mutation changes related to the list of items\n   * in the menu.\n   *\n   * @param {CustomEvent} event An event containing mutation records as its\n   * detail.\n   */\n  _onIronItemsChanged: function(event) {\n    if (event.detail.addedNodes.length) {\n      this._resetTabindices();\n    }\n  },\n\n  /**\n   * Handler that is called when a shift+tab keypress is detected by the menu.\n   *\n   * @param {CustomEvent} event A key combination event.\n   */\n  _onShiftTabDown: function(event) {\n    var oldTabIndex = this.getAttribute('tabindex');\n\n    IronMenuBehaviorImpl._shiftTabPressed = true;\n\n    this._setFocusedItem(null);\n\n    this.setAttribute('tabindex', '-1');\n\n    this.async(function() {\n      this.setAttribute('tabindex', oldTabIndex);\n      IronMenuBehaviorImpl._shiftTabPressed = false;\n      // NOTE(cdata): polymer/polymer#1305\n    }, 1);\n  },\n\n  /**\n   * Handler that is called when the menu receives focus.\n   *\n   * @param {FocusEvent} event A focus event.\n   */\n  _onFocus: function(event) {\n    if (IronMenuBehaviorImpl._shiftTabPressed) {\n      // do not focus the menu itself\n      return;\n    }\n\n    // Do not focus the selected tab if the deepest target is part of the\n    // menu element's local DOM and is focusable.\n    var rootTarget =\n        /** @type {?HTMLElement} */ (dom(event).rootTarget);\n    if (rootTarget !== this && typeof rootTarget.tabIndex !== 'undefined' &&\n        !this.isLightDescendant(rootTarget)) {\n      return;\n    }\n\n    // clear the cached focus item\n    this._defaultFocusAsync = this.async(function() {\n      // focus the selected item when the menu receives focus, or the first item\n      // if no item is selected\n      var firstSelectedItem = this.multi ?\n          (this.selectedItems && this.selectedItems[0]) :\n          this.selectedItem;\n\n      this._setFocusedItem(null);\n\n      if (firstSelectedItem) {\n        this._setFocusedItem(firstSelectedItem);\n      } else if (this.items[0]) {\n        // We find the first none-disabled item (if one exists)\n        this._focusNext();\n      }\n    });\n  },\n\n  /**\n   * Handler that is called when the up key is pressed.\n   *\n   * @param {CustomEvent} event A key combination event.\n   */\n  _onUpKey: function(event) {\n    // up and down arrows moves the focus\n    this._focusPrevious();\n    event.detail.keyboardEvent.preventDefault();\n  },\n\n  /**\n   * Handler that is called when the down key is pressed.\n   *\n   * @param {CustomEvent} event A key combination event.\n   */\n  _onDownKey: function(event) {\n    this._focusNext();\n    event.detail.keyboardEvent.preventDefault();\n  },\n\n  /**\n   * Handler that is called when the esc key is pressed.\n   *\n   * @param {CustomEvent} event A key combination event.\n   */\n  _onEscKey: function(event) {\n    var focusedItem = this.focusedItem;\n    if (focusedItem) {\n      focusedItem.blur();\n    }\n  },\n\n  /**\n   * Handler that is called when a keydown event is detected.\n   *\n   * @param {KeyboardEvent} event A keyboard event.\n   */\n  _onKeydown: function(event) {\n    if (!this.keyboardEventMatchesKeys(event, 'up down esc')) {\n      // all other keys focus the menu item starting with that character\n      this._focusWithKeyboardEvent(event);\n    }\n    event.stopPropagation();\n  },\n\n  // override _activateHandler\n  _activateHandler: function(event) {\n    IronSelectableBehavior._activateHandler.call(this, event);\n    event.stopPropagation();\n  },\n\n  /**\n   * Updates this element's tab index when it's enabled/disabled.\n   * @param {boolean} disabled\n   */\n  _disabledChanged: function(disabled) {\n    if (disabled) {\n      this._previousTabIndex =\n          this.hasAttribute('tabindex') ? this.tabIndex : 0;\n      this.removeAttribute(\n          'tabindex');  // No tabindex means not tab-able or select-able.\n    } else if (!this.hasAttribute('tabindex')) {\n      this.setAttribute('tabindex', this._previousTabIndex);\n    }\n  }\n};\n\nIronMenuBehaviorImpl._shiftTabPressed = false;\n\n/** @polymerBehavior */\nexport const IronMenuBehavior =\n    [IronMultiSelectableBehavior, IronA11yKeysBehavior, IronMenuBehaviorImpl];\n","/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\n\nexport class IronSelection {\n  /**\n   * @param {!Function} selectCallback\n   * @suppress {missingProvide}\n   */\n  constructor(selectCallback) {\n    this.selection = [];\n    this.selectCallback = selectCallback;\n  }\n\n  /**\n   * Retrieves the selected item(s).\n   *\n   * @returns Returns the selected item(s). If the multi property is true,\n   * `get` will return an array, otherwise it will return\n   * the selected item or undefined if there is no selection.\n   */\n  get() {\n    return this.multi ? this.selection.slice() : this.selection[0];\n  }\n\n  /**\n   * Clears all the selection except the ones indicated.\n   *\n   * @param {Array} excludes items to be excluded.\n   */\n  clear(excludes) {\n    this.selection.slice().forEach(function(item) {\n      if (!excludes || excludes.indexOf(item) < 0) {\n        this.setItemSelected(item, false);\n      }\n    }, this);\n  }\n\n  /**\n   * Indicates if a given item is selected.\n   *\n   * @param {*} item The item whose selection state should be checked.\n   * @return {boolean} Returns true if `item` is selected.\n   */\n  isSelected(item) {\n    return this.selection.indexOf(item) >= 0;\n  }\n\n  /**\n   * Sets the selection state for a given item to either selected or deselected.\n   *\n   * @param {*} item The item to select.\n   * @param {boolean} isSelected True for selected, false for deselected.\n   */\n  setItemSelected(item, isSelected) {\n    if (item != null) {\n      if (isSelected !== this.isSelected(item)) {\n        // proceed to update selection only if requested state differs from\n        // current\n        if (isSelected) {\n          this.selection.push(item);\n        } else {\n          var i = this.selection.indexOf(item);\n          if (i >= 0) {\n            this.selection.splice(i, 1);\n          }\n        }\n        if (this.selectCallback) {\n          this.selectCallback(item, isSelected);\n        }\n      }\n    }\n  }\n\n  /**\n   * Sets the selection state for a given item. If the `multi` property\n   * is true, then the selected state of `item` will be toggled; otherwise\n   * the `item` will be selected.\n   *\n   * @param {*} item The item to select.\n   */\n  select(item) {\n    if (this.multi) {\n      this.toggle(item);\n    } else if (this.get() !== item) {\n      this.setItemSelected(this.get(), false);\n      this.setItemSelected(item, true);\n    }\n  }\n\n  /**\n   * Toggles the selection state for `item`.\n   *\n   * @param {*} item The item to toggle.\n   */\n  toggle(item) {\n    this.setItemSelected(item, !this.isSelected(item));\n  }\n};\n","/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\n\nimport {dom} from '@polymer/polymer/lib/legacy/polymer.dom.js';\nimport {dashToCamelCase} from '@polymer/polymer/lib/utils/case-map.js';\n\nimport {IronSelection} from './iron-selection.js';\n\n/**\n * @polymerBehavior\n */\nexport const IronSelectableBehavior = {\n\n  /**\n   * Fired when iron-selector is activated (selected or deselected).\n   * It is fired before the selected items are changed.\n   * Cancel the event to abort selection.\n   *\n   * @event iron-activate\n   */\n\n  /**\n   * Fired when an item is selected\n   *\n   * @event iron-select\n   */\n\n  /**\n   * Fired when an item is deselected\n   *\n   * @event iron-deselect\n   */\n\n  /**\n   * Fired when the list of selectable items changes (e.g., items are\n   * added or removed). The detail of the event is a mutation record that\n   * describes what changed.\n   *\n   * @event iron-items-changed\n   */\n\n  properties: {\n\n    /**\n     * If you want to use an attribute value or property of an element for\n     * `selected` instead of the index, set this to the name of the attribute\n     * or property. Hyphenated values are converted to camel case when used to\n     * look up the property of a selectable element. Camel cased values are\n     * *not* converted to hyphenated values for attribute lookup. It's\n     * recommended that you provide the hyphenated form of the name so that\n     * selection works in both cases. (Use `attr-or-property-name` instead of\n     * `attrOrPropertyName`.)\n     */\n    attrForSelected: {type: String, value: null},\n\n    /**\n     * Gets or sets the selected element. The default is to use the index of the\n     * item.\n     * @type {string|number}\n     */\n    selected: {type: String, notify: true},\n\n    /**\n     * Returns the currently selected item.\n     *\n     * @type {?Object}\n     */\n    selectedItem: {type: Object, readOnly: true, notify: true},\n\n    /**\n     * The event that fires from items when they are selected. Selectable\n     * will listen for this event from items and update the selection state.\n     * Set to empty string to listen to no events.\n     */\n    activateEvent:\n        {type: String, value: 'tap', observer: '_activateEventChanged'},\n\n    /**\n     * This is a CSS selector string.  If this is set, only items that match the\n     * CSS selector are selectable.\n     */\n    selectable: String,\n\n    /**\n     * The class to set on elements when selected.\n     */\n    selectedClass: {type: String, value: 'iron-selected'},\n\n    /**\n     * The attribute to set on elements when selected.\n     */\n    selectedAttribute: {type: String, value: null},\n\n    /**\n     * Default fallback if the selection based on selected with\n     * `attrForSelected` is not found.\n     */\n    fallbackSelection: {type: String, value: null},\n\n    /**\n     * The list of items from which a selection can be made.\n     */\n    items: {\n      type: Array,\n      readOnly: true,\n      notify: true,\n      value: function() {\n        return [];\n      }\n    },\n\n    /**\n     * The set of excluded elements where the key is the `localName`\n     * of the element that will be ignored from the item list.\n     *\n     * @default {template: 1}\n     */\n    _excludedLocalNames: {\n      type: Object,\n      value: function() {\n        return {\n          'template': 1,\n          'dom-bind': 1,\n          'dom-if': 1,\n          'dom-repeat': 1,\n        };\n      }\n    }\n  },\n\n  observers: [\n    '_updateAttrForSelected(attrForSelected)',\n    '_updateSelected(selected)',\n    '_checkFallback(fallbackSelection)'\n  ],\n\n  created: function() {\n    this._bindFilterItem = this._filterItem.bind(this);\n    this._selection = new IronSelection(this._applySelection.bind(this));\n  },\n\n  attached: function() {\n    this._observer = this._observeItems(this);\n    this._addListener(this.activateEvent);\n  },\n\n  detached: function() {\n    if (this._observer) {\n      dom(this).unobserveNodes(this._observer);\n    }\n    this._removeListener(this.activateEvent);\n  },\n\n  /**\n   * Returns the index of the given item.\n   *\n   * @method indexOf\n   * @param {Object} item\n   * @returns Returns the index of the item\n   */\n  indexOf: function(item) {\n    return this.items ? this.items.indexOf(item) : -1;\n  },\n\n  /**\n   * Selects the given value.\n   *\n   * @method select\n   * @param {string|number} value the value to select.\n   */\n  select: function(value) {\n    this.selected = value;\n  },\n\n  /**\n   * Selects the previous item.\n   *\n   * @method selectPrevious\n   */\n  selectPrevious: function() {\n    var length = this.items.length;\n    var index = length - 1;\n    if (this.selected !== undefined) {\n      index = (Number(this._valueToIndex(this.selected)) - 1 + length) % length;\n    }\n    this.selected = this._indexToValue(index);\n  },\n\n  /**\n   * Selects the next item.\n   *\n   * @method selectNext\n   */\n  selectNext: function() {\n    var index = 0;\n    if (this.selected !== undefined) {\n      index =\n          (Number(this._valueToIndex(this.selected)) + 1) % this.items.length;\n    }\n    this.selected = this._indexToValue(index);\n  },\n\n  /**\n   * Selects the item at the given index.\n   *\n   * @method selectIndex\n   */\n  selectIndex: function(index) {\n    this.select(this._indexToValue(index));\n  },\n\n  /**\n   * Force a synchronous update of the `items` property.\n   *\n   * NOTE: Consider listening for the `iron-items-changed` event to respond to\n   * updates to the set of selectable items after updates to the DOM list and\n   * selection state have been made.\n   *\n   * WARNING: If you are using this method, you should probably consider an\n   * alternate approach. Synchronously querying for items is potentially\n   * slow for many use cases. The `items` property will update asynchronously\n   * on its own to reflect selectable items in the DOM.\n   */\n  forceSynchronousItemUpdate: function() {\n    if (this._observer && typeof this._observer.flush === 'function') {\n      // NOTE(bicknellr): `dom.flush` above is no longer sufficient to trigger\n      // `observeNodes` callbacks. Polymer 2.x returns an object from\n      // `observeNodes` with a `flush` that synchronously gives the callback any\n      // pending MutationRecords (retrieved with `takeRecords`). Any case where\n      // ShadyDOM flushes were expected to synchronously trigger item updates\n      // will now require calling `forceSynchronousItemUpdate`.\n      this._observer.flush();\n    } else {\n      this._updateItems();\n    }\n  },\n\n  // UNUSED, FOR API COMPATIBILITY\n  get _shouldUpdateSelection() {\n    return this.selected != null;\n  },\n\n  _checkFallback: function() {\n    this._updateSelected();\n  },\n\n  _addListener: function(eventName) {\n    this.listen(this, eventName, '_activateHandler');\n  },\n\n  _removeListener: function(eventName) {\n    this.unlisten(this, eventName, '_activateHandler');\n  },\n\n  _activateEventChanged: function(eventName, old) {\n    this._removeListener(old);\n    this._addListener(eventName);\n  },\n\n  _updateItems: function() {\n    var nodes = dom(this).queryDistributedElements(this.selectable || '*');\n    nodes = Array.prototype.filter.call(nodes, this._bindFilterItem);\n    this._setItems(nodes);\n  },\n\n  _updateAttrForSelected: function() {\n    if (this.selectedItem) {\n      this.selected = this._valueForItem(this.selectedItem);\n    }\n  },\n\n  _updateSelected: function() {\n    this._selectSelected(this.selected);\n  },\n\n  _selectSelected: function(selected) {\n    if (!this.items) {\n      return;\n    }\n\n    var item = this._valueToItem(this.selected);\n    if (item) {\n      this._selection.select(item);\n    } else {\n      this._selection.clear();\n    }\n    // Check for items, since this array is populated only when attached\n    // Since Number(0) is falsy, explicitly check for undefined\n    if (this.fallbackSelection && this.items.length &&\n        (this._selection.get() === undefined)) {\n      this.selected = this.fallbackSelection;\n    }\n  },\n\n  _filterItem: function(node) {\n    return !this._excludedLocalNames[node.localName];\n  },\n\n  _valueToItem: function(value) {\n    return (value == null) ? null : this.items[this._valueToIndex(value)];\n  },\n\n  _valueToIndex: function(value) {\n    if (this.attrForSelected) {\n      for (var i = 0, item; item = this.items[i]; i++) {\n        if (this._valueForItem(item) == value) {\n          return i;\n        }\n      }\n    } else {\n      return Number(value);\n    }\n  },\n\n  _indexToValue: function(index) {\n    if (this.attrForSelected) {\n      var item = this.items[index];\n      if (item) {\n        return this._valueForItem(item);\n      }\n    } else {\n      return index;\n    }\n  },\n\n  _valueForItem: function(item) {\n    if (!item) {\n      return null;\n    }\n    if (!this.attrForSelected) {\n      var i = this.indexOf(item);\n      return i === -1 ? null : i;\n    }\n    var propValue = item[dashToCamelCase(this.attrForSelected)];\n    return propValue != undefined ? propValue :\n                                    item.getAttribute(this.attrForSelected);\n  },\n\n  _applySelection: function(item, isSelected) {\n    if (this.selectedClass) {\n      this.toggleClass(this.selectedClass, isSelected, item);\n    }\n    if (this.selectedAttribute) {\n      this.toggleAttribute(this.selectedAttribute, isSelected, item);\n    }\n    this._selectionChange();\n    this.fire('iron-' + (isSelected ? 'select' : 'deselect'), {item: item});\n  },\n\n  _selectionChange: function() {\n    this._setSelectedItem(this._selection.get());\n  },\n\n  // observe items change under the given node.\n  _observeItems: function(node) {\n    return dom(node).observeNodes(function(mutation) {\n      this._updateItems();\n      this._updateSelected();\n\n      // Let other interested parties know about the change so that\n      // we don't have to recreate mutation observers everywhere.\n      this.fire(\n          'iron-items-changed', mutation, {bubbles: false, cancelable: false});\n    });\n  },\n\n  _activateHandler: function(e) {\n    var t = e.target;\n    var items = this.items;\n    while (t && t != this) {\n      var i = items.indexOf(t);\n      if (i >= 0) {\n        var value = this._indexToValue(i);\n        this._itemActivate(value, t);\n        return;\n      }\n      t = t.parentNode;\n    }\n  },\n\n  _itemActivate: function(value, item) {\n    if (!this.fire('iron-activate', {selected: value, item: item}, {\n               cancelable: true\n             })\n             .defaultPrevented) {\n      this.select(value);\n    }\n  }\n\n};\n"],"sourceRoot":""}