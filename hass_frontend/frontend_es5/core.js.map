{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///../node_modules/babel-plugin-transform-async-to-promises/helpers.js","webpack:///../lib/errors.ts","webpack:///../lib/messages.ts","webpack:///../lib/socket.ts","webpack:///../lib/connection.ts","webpack:///../lib/auth.ts","webpack:///../lib/util.ts","webpack:///../lib/store.ts","webpack:///../lib/collection.ts","webpack:///../lib/commands.ts","webpack:///../lib/config.ts","webpack:///../lib/services.ts","webpack:///../lib/entities.ts","webpack:///../lib/index.ts","webpack:///./src/common/auth/token_storage.ts","webpack:///./src/data/auth.ts","webpack:///./src/data/ws-panels.ts","webpack:///./src/data/ws-themes.ts","webpack:///./src/data/ws-user.ts","webpack:///./src/entrypoints/core.ts"],"names":["_catch","body","recover","result","e","then","ERR_CANNOT_CONNECT","ERR_INVALID_AUTH","ERR_CONNECTION_LOST","ERR_HASS_HOST_REQUIRED","unsubscribeEvents","subscription","type","const","Connection","constructor","socket","options","commandId","commands","Map","eventListeners","closeRequested","setSocket","oldSocket","this","addEventListener","ev","_handleMessage","_handleClose","oldCommands","forEach","info","subscribe","unsub","unsubscribe","resolve","fireEvent","eventType","callback","listeners","get","set","push","removeEventListener","index","indexOf","splice","eventData","close","subscribeEvents","subscribeMessage","message","event_type","messages","ping","sendMessagePromise","sendMessage","_genCmdId","id","send","JSON","stringify","Promise","reject","_this2","err","event","parse","data","warn","success","error","Object","setupRetry","reconnect","tries","createSocket","Math","min","getAuth","Auth","saveTokens","undefined","hassUrl","clientId","redirectUrl","state","includes","document","location","href","authorizeUrl","encodeURIComponent","genAuthorizeUrl","redirectAuthorize","btoa","loadTokens","query","queryString","items","search","substr","split","i","length","item","key","decodeURIComponent","value","parseQuery","atob","fetchToken","code","console","log","genClientId","authCode","tokenRequest","formData","FormData","append","keys","fetch","method","credentials","resp","ok","status","Error","json","tokens","expires","genExpires","expires_in","Date","now","grant_type","_saveTokens","prototypeAccessors","wsUrl","accessToken","access_token","expired","refreshAccessToken","_this","refresh_token","revoke","getCollection","conn","fetchCollection","subscribeUpdates","unsubProm","active","store","setState","update","overwrite","assign","currentListeners","action","apply","args","arguments","ret","listener","out","createStore","refresh","refreshSwallow","catch","readyState","OPEN","subscriber","setTimeout","createCollection","onChange","getStates","connection","getServices","getConfig","getUser","callService","domain","service","serviceData","service_data","processComponentLoaded","components","concat","component","fetchConfig","all","config","unsubs","subscribeConfig","configColl","processServiceRegistered","domainInfo","description","fields","processServiceRemoved","curDomainInfo","sKey","fetchServices","fn","subscribeServices","servicesColl","fetchEntities","states","entities","entity_id","new_state","newEntities","processEvent","entitiesColl","subscribeEntities","createConnection","connOptions","defaultConnectionOptions","auth","authRefreshTask","url","connect","triesLeft","promResolve","promReject","WebSocket","invalidAuth","closeMessage","newTries","handleOpen","handleMessage","storage","window","localStorage","tokenCache","__tokenCache","writeEnabled","askWrite","hassTokens","enableWrite","protocol","host","getSignedPath","hass","path","callWS","fetchAuthProviders","fetchPanels","panels","subscribePanels","fetchThemes","subscribeThemes","userCollection","subscribeUser","isExternal","authProm","createExternalAuth","connProm","history","replaceState","pathname","hassConnection","noop","homeAssistant","querySelector","logger","__DEV__","__BUILD__","__VERSION__","replace","filename","lineno","colno"],"mappings":";AAAA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,gBAAQ,oBAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA,iDAAyC,gCAAgC;AACzE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA,yCAAiC;;AAEjC;AACA;AACA;AACA,aAAK;AACL;AACA;AACA;AACA,cAAM;AACN;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAwB,kCAAkC;AAC1D,cAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA,kDAA0C,oBAAoB,WAAW;;AAEzE;AACA;AACA;AACA;AACA,wBAAgB,uBAAuB;AACvC;;;AAGA;AACA;;;;;;;;;;;;;ACgXO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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","file":"core.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t};\n\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t\"core\": 0\n \t};\n\n\n\n \t// script path function\n \tfunction jsonpScriptSrc(chunkId) {\n \t\treturn __webpack_require__.p + \"\" + ({\"external_auth\":\"external_auth\"}[chunkId]||chunkId) + \".chunk.js\"\n \t}\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId) {\n \t\tvar promises = [];\n\n\n \t\t// JSONP chunk loading for javascript\n\n \t\tvar installedChunkData = installedChunks[chunkId];\n \t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n \t\t\t// a Promise means \"currently loading\".\n \t\t\tif(installedChunkData) {\n \t\t\t\tpromises.push(installedChunkData[2]);\n \t\t\t} else {\n \t\t\t\t// setup Promise in chunk cache\n \t\t\t\tvar promise = new Promise(function(resolve, reject) {\n \t\t\t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n \t\t\t\t});\n \t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n \t\t\t\t// start chunk loading\n \t\t\t\tvar script = document.createElement('script');\n \t\t\t\tvar onScriptComplete;\n\n \t\t\t\tscript.charset = 'utf-8';\n \t\t\t\tscript.timeout = 120;\n \t\t\t\tif (__webpack_require__.nc) {\n \t\t\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n \t\t\t\t}\n \t\t\t\tscript.src = jsonpScriptSrc(chunkId);\n\n \t\t\t\t// create error before stack unwound to get useful stacktrace later\n \t\t\t\tvar error = new Error();\n \t\t\t\tonScriptComplete = function (event) {\n \t\t\t\t\t// avoid mem leaks in IE.\n \t\t\t\t\tscript.onerror = script.onload = null;\n \t\t\t\t\tclearTimeout(timeout);\n \t\t\t\t\tvar chunk = installedChunks[chunkId];\n \t\t\t\t\tif(chunk !== 0) {\n \t\t\t\t\t\tif(chunk) {\n \t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n \t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n \t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n \t\t\t\t\t\t\terror.type = errorType;\n \t\t\t\t\t\t\terror.request = realSrc;\n \t\t\t\t\t\t\tchunk[1](error);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tinstalledChunks[chunkId] = undefined;\n \t\t\t\t\t}\n \t\t\t\t};\n \t\t\t\tvar timeout = setTimeout(function(){\n \t\t\t\t\tonScriptComplete({ type: 'timeout', target: script });\n \t\t\t\t}, 120000);\n \t\t\t\tscript.onerror = script.onload = onScriptComplete;\n \t\t\t\tdocument.head.appendChild(script);\n \t\t\t}\n \t\t}\n \t\treturn Promise.all(promises);\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/frontend_es5/\";\n\n \t// on error function for async loading\n \t__webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/entrypoints/core.ts\");\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof Symbol !== \"undefined\") {\n\t\tvar iteratorSymbol = Symbol.iterator;\n\t\tif (iteratorSymbol && (iteratorSymbol in target)) {\n\t\t\tvar iterator = target[iteratorSymbol](), step, pact, reject;\n\t\t\tfunction _cycle(result) {\n\t\t\t\ttry {\n\t\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (pact) {\n\t\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpact = result;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t\t\t}\n\t\t\t}\n\t\t\t_cycle();\n\t\t\tif (iterator.return) {\n\t\t\t\tvar _fixup = function(value) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\t\titerator.return();\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\tif (pact && pact.then) {\n\t\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t_fixup();\n\t\t\t}\n\t\t\treturn pact;\n\t\t}\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"value is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof Symbol !== \"undefined\") {\n\t\tvar asyncIteratorSymbol = Symbol.asyncIterator;\n\t\tif (asyncIteratorSymbol && (asyncIteratorSymbol in target)) {\n\t\t\tvar pact = new _Pact();\n\t\t\tvar iterator = target[asyncIteratorSymbol]();\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t\treturn pact;\n\t\t\tfunction _resumeAfterBody(result) {\n\t\t\t\tif (check && !check()) {\n\t\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t\t}\n\t\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t\t}\n\t\t\tfunction _resumeAfterNext(step) {\n\t\t\t\tif (step.done) {\n\t\t\t\t\t_settle(pact, 1);\n\t\t\t\t} else {\n\t\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfunction _reject(error) {\n\t\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t\t}\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, value);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t\tthis[Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))] = function() {\n\t\t\treturn this;\n\t\t};\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\t_entry(_this).then(returnValue, function(error) {\n\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","export const ERR_CANNOT_CONNECT = 1;\nexport const ERR_INVALID_AUTH = 2;\nexport const ERR_CONNECTION_LOST = 3;\nexport const ERR_HASS_HOST_REQUIRED = 4;\n","import { Error } from \"./types\";\n\nexport function auth(accessToken: string) {\n  return {\n    type: \"auth\",\n    access_token: accessToken\n  };\n}\n\nexport function states() {\n  return {\n    type: \"get_states\"\n  };\n}\n\nexport function config() {\n  return {\n    type: \"get_config\"\n  };\n}\n\nexport function services() {\n  return {\n    type: \"get_services\"\n  };\n}\n\nexport function user() {\n  return {\n    type: \"auth/current_user\"\n  };\n}\n\ntype ServiceCallMessage = {\n  type: \"call_service\";\n  domain: string;\n  service: string;\n  service_data?: object;\n};\n\nexport function callService(\n  domain: string,\n  service: string,\n  serviceData?: object\n) {\n  const message: ServiceCallMessage = {\n    type: \"call_service\",\n    domain,\n    service\n  };\n\n  if (serviceData) {\n    message.service_data = serviceData;\n  }\n\n  return message;\n}\n\ntype SubscribeEventMessage = {\n  type: \"subscribe_events\";\n  event_type?: string;\n};\n\nexport function subscribeEvents(eventType?: string) {\n  const message: SubscribeEventMessage = {\n    type: \"subscribe_events\"\n  };\n\n  if (eventType) {\n    message.event_type = eventType;\n  }\n\n  return message;\n}\n\nexport function unsubscribeEvents(subscription: number) {\n  return {\n    type: \"unsubscribe_events\",\n    subscription\n  };\n}\n\nexport function ping() {\n  return {\n    type: \"ping\"\n  };\n}\n\nexport function error(code: Error, message: string) {\n  return {\n    type: \"result\",\n    success: false,\n    error: {\n      code,\n      message\n    }\n  };\n}\n","/**\n * Create a web socket connection with a Home Assistant instance.\n */\nimport {\n  ERR_INVALID_AUTH,\n  ERR_CANNOT_CONNECT,\n  ERR_HASS_HOST_REQUIRED\n} from \"./errors\";\nimport { ConnectionOptions, Error } from \"./types\";\nimport * as messages from \"./messages\";\n\nconst DEBUG = false;\n\nconst MSG_TYPE_AUTH_REQUIRED = \"auth_required\";\nconst MSG_TYPE_AUTH_INVALID = \"auth_invalid\";\nconst MSG_TYPE_AUTH_OK = \"auth_ok\";\n\nexport function createSocket(options: ConnectionOptions): Promise<WebSocket> {\n  if (!options.auth) {\n    throw ERR_HASS_HOST_REQUIRED;\n  }\n  const auth = options.auth;\n\n  // Start refreshing expired tokens even before the WS connection is open.\n  // We know that we will need auth anyway.\n  let authRefreshTask = auth.expired\n    ? auth.refreshAccessToken().then(\n        () => {\n          authRefreshTask = undefined;\n        },\n        () => {\n          authRefreshTask = undefined;\n        }\n      )\n    : undefined;\n\n  // Convert from http:// -> ws://, https:// -> wss://\n  const url = auth.wsUrl;\n\n  if (DEBUG) {\n    console.log(\"[Auth phase] Initializing\", url);\n  }\n\n  function connect(\n    triesLeft: number,\n    promResolve: (socket: WebSocket) => void,\n    promReject: (err: Error) => void\n  ) {\n    if (DEBUG) {\n      console.log(\"[Auth Phase] New connection\", url);\n    }\n\n    const socket = new WebSocket(url);\n\n    // If invalid auth, we will not try to reconnect.\n    let invalidAuth = false;\n\n    const closeMessage = () => {\n      // If we are in error handler make sure close handler doesn't also fire.\n      socket.removeEventListener(\"close\", closeMessage);\n      if (invalidAuth) {\n        promReject(ERR_INVALID_AUTH);\n        return;\n      }\n\n      // Reject if we no longer have to retry\n      if (triesLeft === 0) {\n        // We never were connected and will not retry\n        promReject(ERR_CANNOT_CONNECT);\n        return;\n      }\n\n      const newTries = triesLeft === -1 ? -1 : triesLeft - 1;\n      // Try again in a second\n      setTimeout(\n        () =>\n          connect(\n            newTries,\n            promResolve,\n            promReject\n          ),\n        1000\n      );\n    };\n\n    // Auth is mandatory, so we can send the auth message right away.\n    const handleOpen = async (event: MessageEventInit) => {\n      try {\n        if (auth.expired) {\n          await (authRefreshTask ? authRefreshTask : auth.refreshAccessToken());\n        }\n        socket.send(JSON.stringify(messages.auth(auth.accessToken)));\n      } catch (err) {\n        // Refresh token failed\n        invalidAuth = err === ERR_INVALID_AUTH;\n        socket.close();\n      }\n    };\n\n    const handleMessage = async (event: MessageEvent) => {\n      const message = JSON.parse(event.data);\n\n      if (DEBUG) {\n        console.log(\"[Auth phase] Received\", message);\n      }\n      switch (message.type) {\n        case MSG_TYPE_AUTH_INVALID:\n          invalidAuth = true;\n          socket.close();\n          break;\n\n        case MSG_TYPE_AUTH_OK:\n          socket.removeEventListener(\"open\", handleOpen);\n          socket.removeEventListener(\"message\", handleMessage);\n          socket.removeEventListener(\"close\", closeMessage);\n          socket.removeEventListener(\"error\", closeMessage);\n          promResolve(socket);\n          break;\n\n        default:\n          if (DEBUG) {\n            // We already send this message when socket opens\n            if (message.type !== MSG_TYPE_AUTH_REQUIRED) {\n              console.warn(\"[Auth phase] Unhandled message\", message);\n            }\n          }\n      }\n    };\n\n    socket.addEventListener(\"open\", handleOpen);\n    socket.addEventListener(\"message\", handleMessage);\n    socket.addEventListener(\"close\", closeMessage);\n    socket.addEventListener(\"error\", closeMessage);\n  }\n\n  return new Promise((resolve, reject) =>\n    connect(\n      options.setupRetry,\n      resolve,\n      reject\n    )\n  );\n}\n","/**\n * Connection that wraps a socket and provides an interface to interact with\n * the Home Assistant websocket API.\n */\nimport * as messages from \"./messages\";\nimport { ERR_INVALID_AUTH, ERR_CONNECTION_LOST } from \"./errors\";\nimport { ConnectionOptions, HassEvent, MessageBase } from \"./types\";\n\nconst DEBUG = false;\n\nexport type ConnectionEventListener = (\n  conn: Connection,\n  eventData?: any\n) => void;\n\ntype Events = \"ready\" | \"disconnected\" | \"reconnect-error\";\n\ntype WebSocketPongResponse = {\n  id: number;\n  type: \"pong\";\n};\n\ntype WebSocketEventResponse = {\n  id: number;\n  type: \"event\";\n  event: HassEvent;\n};\n\ntype WebSocketResultResponse = {\n  id: number;\n  type: \"result\";\n  success: true;\n  result: any;\n};\n\ntype WebSocketResultErrorResponse = {\n  id: number;\n  type: \"result\";\n  success: false;\n  error: {\n    code: string;\n    message: string;\n  };\n};\n\ntype WebSocketResponse =\n  | WebSocketPongResponse\n  | WebSocketEventResponse\n  | WebSocketResultResponse\n  | WebSocketResultErrorResponse;\n\ntype SubscriptionUnsubscribe = () => Promise<void>;\n\ninterface SubscribeEventCommmandInFlight<T> {\n  resolve: (result?: any) => void;\n  reject: (err: any) => void;\n  callback: (ev: T) => void;\n  subscribe: () => Promise<SubscriptionUnsubscribe>;\n  unsubscribe: SubscriptionUnsubscribe;\n}\n\ntype CommandWithAnswerInFlight = {\n  resolve: (result?: any) => void;\n  reject: (err: any) => void;\n};\n\ntype CommandInFlight =\n  | SubscribeEventCommmandInFlight<any>\n  | CommandWithAnswerInFlight;\n\nexport class Connection {\n  options: ConnectionOptions;\n  commandId: number;\n  commands: Map<number, CommandInFlight>;\n  eventListeners: Map<string, ConnectionEventListener[]>;\n  closeRequested: boolean;\n  // @ts-ignore: incorrectly claiming it's not set in constructor.\n  socket: WebSocket;\n\n  constructor(socket: WebSocket, options: ConnectionOptions) {\n    // connection options\n    //  - setupRetry: amount of ms to retry when unable to connect on initial setup\n    //  - createSocket: create a new Socket connection\n    this.options = options;\n    // id if next command to send\n    this.commandId = 1;\n    // info about active subscriptions and commands in flight\n    this.commands = new Map();\n    // map of event listeners\n    this.eventListeners = new Map();\n    // true if a close is requested by the user\n    this.closeRequested = false;\n\n    this.setSocket(socket);\n  }\n\n  setSocket(socket: WebSocket) {\n    const oldSocket = this.socket;\n    this.socket = socket;\n    socket.addEventListener(\"message\", ev => this._handleMessage(ev));\n    socket.addEventListener(\"close\", ev => this._handleClose(ev));\n\n    if (oldSocket) {\n      const oldCommands = this.commands;\n\n      // reset to original state\n      this.commandId = 1;\n      this.commands = new Map();\n\n      oldCommands.forEach(info => {\n        if (\"subscribe\" in info) {\n          info.subscribe().then(unsub => {\n            info.unsubscribe = unsub;\n            // We need to resolve this in case it wasn't resolved yet.\n            // This allows us to subscribe while we're disconnected\n            // and recover properly.\n            info.resolve();\n          });\n        }\n      });\n\n      this.fireEvent(\"ready\");\n    }\n  }\n\n  addEventListener(eventType: Events, callback: ConnectionEventListener) {\n    let listeners = this.eventListeners.get(eventType);\n\n    if (!listeners) {\n      listeners = [];\n      this.eventListeners.set(eventType, listeners);\n    }\n\n    listeners.push(callback);\n  }\n\n  removeEventListener(eventType: Events, callback: ConnectionEventListener) {\n    const listeners = this.eventListeners.get(eventType);\n\n    if (!listeners) {\n      return;\n    }\n\n    const index = listeners.indexOf(callback);\n\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n  }\n\n  fireEvent(eventType: Events, eventData?: any) {\n    (this.eventListeners.get(eventType) || []).forEach(callback =>\n      callback(this, eventData)\n    );\n  }\n\n  close() {\n    this.closeRequested = true;\n    this.socket.close();\n  }\n\n  /**\n   * Subscribe to a specific or all events.\n   *\n   * @param callback Callback  to be called when a new event fires\n   * @param eventType\n   * @returns promise that resolves to an unsubscribe function\n   */\n  async subscribeEvents<EventType>(\n    callback: (ev: EventType) => void,\n    eventType?: string\n  ): Promise<SubscriptionUnsubscribe> {\n    return this.subscribeMessage(callback, messages.subscribeEvents(eventType));\n  }\n\n  ping() {\n    return this.sendMessagePromise(messages.ping());\n  }\n\n  sendMessage(message: MessageBase, commandId?: number): void {\n    if (DEBUG) {\n      console.log(\"Sending\", message);\n    }\n\n    if (!commandId) {\n      commandId = this._genCmdId();\n    }\n    message.id = commandId;\n\n    this.socket.send(JSON.stringify(message));\n  }\n\n  sendMessagePromise<Result>(message: MessageBase): Promise<Result> {\n    return new Promise((resolve, reject) => {\n      const commandId = this._genCmdId();\n      this.commands.set(commandId, { resolve, reject });\n      this.sendMessage(message, commandId);\n    });\n  }\n\n  /**\n   * Call a websocket command that starts a subscription on the backend.\n   *\n   * @param message the message to start the subscription\n   * @param callback the callback to be called when a new item arrives\n   * @returns promise that resolves to an unsubscribe function\n   */\n  async subscribeMessage<Result>(\n    callback: (result: Result) => void,\n    subscribeMessage: MessageBase\n  ): Promise<SubscriptionUnsubscribe> {\n    // Command ID that will be used\n    const commandId = this._genCmdId();\n    let info: SubscribeEventCommmandInFlight<Result>;\n\n    await new Promise((resolve, reject) => {\n      // We store unsubscribe on info object. That way we can overwrite it in case\n      // we get disconnected and we have to subscribe again.\n      info = {\n        resolve,\n        reject,\n        callback,\n        subscribe: () => this.subscribeMessage(callback, subscribeMessage),\n        unsubscribe: async () => {\n          await this.sendMessagePromise(messages.unsubscribeEvents(commandId));\n          this.commands.delete(commandId);\n        }\n      };\n      this.commands.set(commandId, info);\n\n      try {\n        this.sendMessage(subscribeMessage, commandId);\n      } catch (err) {\n        // Happens when the websocket is already closing.\n        // Don't have to handle the error, reconnect logic will pick it up.\n      }\n    });\n\n    return () => info.unsubscribe();\n  }\n\n  private _handleMessage(event: MessageEvent) {\n    const message: WebSocketResponse = JSON.parse(event.data);\n\n    if (DEBUG) {\n      console.log(\"Received\", message);\n    }\n\n    const info = this.commands.get(message.id);\n\n    switch (message.type) {\n      case \"event\":\n        if (info) {\n          (info as SubscribeEventCommmandInFlight<any>).callback(message.event);\n        } else {\n          console.warn(\n            `Received event for unknown subscription ${\n              message.id\n            }. Unsubscribing.`\n          );\n          this.sendMessagePromise(messages.unsubscribeEvents(message.id));\n        }\n        break;\n\n      case \"result\":\n        // No info is fine. If just sendMessage is used, we did not store promise for result\n        if (info) {\n          if (message.success) {\n            info.resolve(message.result);\n\n            // Don't remove subscriptions.\n            if (!(\"subscribe\" in info)) {\n              this.commands.delete(message.id);\n            }\n          } else {\n            info.reject(message.error);\n            this.commands.delete(message.id);\n          }\n        }\n        break;\n\n      case \"pong\":\n        if (info) {\n          info.resolve();\n          this.commands.delete(message.id);\n        } else {\n          console.warn(`Received unknown pong response ${message.id}`);\n        }\n        break;\n\n      default:\n        if (DEBUG) {\n          console.warn(\"Unhandled message\", message);\n        }\n    }\n  }\n\n  private _handleClose(ev: CloseEvent) {\n    // Reject in-flight sendMessagePromise requests\n    this.commands.forEach(info => {\n      // We don't cancel subscribeEvents commands in flight\n      // as we will be able to recover them.\n      if (!(\"subscribe\" in info)) {\n        info.reject(messages.error(ERR_CONNECTION_LOST, \"Connection lost\"));\n      }\n    });\n\n    if (this.closeRequested) {\n      return;\n    }\n\n    this.fireEvent(\"disconnected\");\n\n    // Disable setupRetry, we control it here with auto-backoff\n    const options = { ...this.options, setupRetry: 0 };\n\n    const reconnect = (tries: number) => {\n      setTimeout(async () => {\n        if (DEBUG) {\n          console.log(\"Trying to reconnect\");\n        }\n        try {\n          const socket = await options.createSocket(options);\n          this.setSocket(socket);\n        } catch (err) {\n          if (err === ERR_INVALID_AUTH) {\n            this.fireEvent(\"reconnect-error\", err);\n          } else {\n            reconnect(tries + 1);\n          }\n        }\n      }, Math.min(tries, 5) * 1000);\n    };\n\n    reconnect(0);\n  }\n\n  private _genCmdId() {\n    return ++this.commandId;\n  }\n}\n","import { parseQuery } from \"./util\";\nimport { ERR_HASS_HOST_REQUIRED, ERR_INVALID_AUTH } from \"./errors\";\n\nexport type AuthData = {\n  hassUrl: string;\n  clientId: string;\n  expires: number;\n  refresh_token: string;\n  access_token: string;\n  expires_in: number;\n};\n\nexport type SaveTokensFunc = (data: AuthData | null) => void;\nexport type LoadTokensFunc = () => Promise<AuthData | null | undefined>;\n\nexport type getAuthOptions = {\n  hassUrl?: string;\n  clientId?: string;\n  redirectUrl?: string;\n  authCode?: string;\n  saveTokens?: SaveTokensFunc;\n  loadTokens?: LoadTokensFunc;\n};\n\ntype QueryCallbackData =\n  | {}\n  | {\n      state: string;\n      code: string;\n      auth_callback: string;\n    };\n\ntype OAuthState = {\n  hassUrl: string;\n  clientId: string;\n};\n\ntype AuthorizationCodeRequest = {\n  grant_type: \"authorization_code\";\n  code: string;\n};\n\ntype RefreshTokenRequest = {\n  grant_type: \"refresh_token\";\n  refresh_token: string;\n};\n\nexport const genClientId = (): string =>\n  `${location.protocol}//${location.host}/`;\n\nexport const genExpires = (expires_in: number): number => {\n  return expires_in * 1000 + Date.now();\n};\n\nfunction genRedirectUrl() {\n  // Get current url but without # part.\n  const { protocol, host, pathname, search } = location;\n  return `${protocol}//${host}${pathname}${search}`;\n}\n\nfunction genAuthorizeUrl(\n  hassUrl: string,\n  clientId: string,\n  redirectUrl: string,\n  state: string\n) {\n  let authorizeUrl = `${hassUrl}/auth/authorize?response_type=code&client_id=${encodeURIComponent(\n    clientId\n  )}&redirect_uri=${encodeURIComponent(redirectUrl)}`;\n\n  if (state) {\n    authorizeUrl += `&state=${encodeURIComponent(state)}`;\n  }\n  return authorizeUrl;\n}\n\nfunction redirectAuthorize(\n  hassUrl: string,\n  clientId: string,\n  redirectUrl: string,\n  state: string\n) {\n  // Add either ?auth_callback=1 or &auth_callback=1\n  redirectUrl += (redirectUrl.includes(\"?\") ? \"&\" : \"?\") + \"auth_callback=1\";\n\n  document.location!.href = genAuthorizeUrl(\n    hassUrl,\n    clientId,\n    redirectUrl,\n    state\n  );\n}\n\nasync function tokenRequest(\n  hassUrl: string,\n  clientId: string,\n  data: AuthorizationCodeRequest | RefreshTokenRequest\n) {\n  const formData = new FormData();\n  formData.append(\"client_id\", clientId);\n  Object.keys(data).forEach(key => {\n    formData.append(key, data[key]);\n  });\n\n  const resp = await fetch(`${hassUrl}/auth/token`, {\n    method: \"POST\",\n    credentials: \"same-origin\",\n    body: formData\n  });\n\n  if (!resp.ok) {\n    throw resp.status === 400 /* auth invalid */ ||\n    resp.status === 403 /* user not active */\n      ? ERR_INVALID_AUTH\n      : new Error(\"Unable to fetch tokens\");\n  }\n\n  const tokens: AuthData = await resp.json();\n  tokens.hassUrl = hassUrl;\n  tokens.clientId = clientId;\n  tokens.expires = genExpires(tokens.expires_in);\n  return tokens;\n}\n\nfunction fetchToken(hassUrl: string, clientId: string, code: string) {\n  return tokenRequest(hassUrl, clientId, {\n    code,\n    grant_type: \"authorization_code\"\n  });\n}\n\nfunction encodeOAuthState(state: OAuthState): string {\n  return btoa(JSON.stringify(state));\n}\n\nfunction decodeOAuthState(encoded: string): OAuthState {\n  return JSON.parse(atob(encoded));\n}\n\nexport class Auth {\n  private _saveTokens?: SaveTokensFunc;\n  data: AuthData;\n\n  constructor(data: AuthData, saveTokens?: SaveTokensFunc) {\n    this.data = data;\n    this._saveTokens = saveTokens;\n  }\n\n  get wsUrl() {\n    // Convert from http:// -> ws://, https:// -> wss://\n    return `ws${this.data.hassUrl.substr(4)}/api/websocket`;\n  }\n\n  get accessToken() {\n    return this.data.access_token;\n  }\n\n  get expired() {\n    return Date.now() > this.data.expires;\n  }\n\n  /**\n   * Refresh the access token.\n   */\n  async refreshAccessToken() {\n    const data = await tokenRequest(this.data.hassUrl, this.data.clientId, {\n      grant_type: \"refresh_token\",\n      refresh_token: this.data.refresh_token\n    });\n    // Access token response does not contain refresh token.\n    data.refresh_token = this.data.refresh_token;\n    this.data = data;\n    if (this._saveTokens) this._saveTokens(data);\n  }\n\n  /**\n   * Revoke the refresh & access tokens.\n   */\n  async revoke() {\n    const formData = new FormData();\n    formData.append(\"action\", \"revoke\");\n    formData.append(\"token\", this.data.refresh_token);\n\n    // There is no error checking, as revoke will always return 200\n    await fetch(`${this.data.hassUrl}/auth/token`, {\n      method: \"POST\",\n      credentials: \"same-origin\",\n      body: formData\n    });\n\n    if (this._saveTokens) {\n      this._saveTokens(null);\n    }\n  }\n}\n\nexport async function getAuth(options: getAuthOptions = {}): Promise<Auth> {\n  let data: AuthData | null | undefined;\n\n  let hassUrl = options.hassUrl;\n  // Strip trailing slash.\n  if (hassUrl && hassUrl[hassUrl.length - 1] === \"/\") {\n    hassUrl = hassUrl.substr(0, hassUrl.length - 1);\n  }\n  const clientId = options.clientId || genClientId();\n\n  // Use auth code if it was passed in\n  if (!data && options.authCode && hassUrl && clientId) {\n    try {\n      data = await fetchToken(hassUrl, clientId, options.authCode);\n      if (options.saveTokens) {\n        options.saveTokens(data);\n      }\n    } catch (err) {\n      // Do we want to tell user we were unable to fetch tokens?\n      // For now we don't do anything, having rest of code pick it up.\n      console.log(\"Unable to fetch access token\", err);\n    }\n  }\n\n  // Check if we came back from an authorize redirect\n  if (!data) {\n    const query = parseQuery<QueryCallbackData>(location.search.substr(1));\n\n    // Check if we got redirected here from authorize page\n    if (\"auth_callback\" in query) {\n      // Restore state\n      const state = decodeOAuthState(query.state);\n      try {\n        data = await fetchToken(state.hassUrl, state.clientId, query.code);\n        if (options.saveTokens) {\n          options.saveTokens(data);\n        }\n      } catch (err) {\n        // Do we want to tell user we were unable to fetch tokens?\n        // For now we don't do anything, having rest of code pick it up.\n        console.log(\"Unable to fetch access token\", err);\n      }\n    }\n  }\n\n  // Check for stored tokens\n  if (!data && options.loadTokens) {\n    data = await options.loadTokens();\n  }\n\n  if (data) {\n    return new Auth(data, options.saveTokens);\n  }\n\n  if (hassUrl === undefined) {\n    throw ERR_HASS_HOST_REQUIRED;\n  }\n\n  // If no tokens found but a hassUrl was passed in, let's go get some tokens!\n  redirectAuthorize(\n    hassUrl,\n    clientId,\n    options.redirectUrl || genRedirectUrl(),\n    encodeOAuthState({\n      hassUrl,\n      clientId\n    })\n  );\n  // Just don't resolve while we navigate to next page\n  return new Promise<Auth>(() => {});\n}\n","export function parseQuery<T>(queryString: string) {\n  const query: any = {};\n  const items = queryString.split(\"&\");\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i].split(\"=\");\n    const key = decodeURIComponent(item[0]);\n    const value = item.length > 1 ? decodeURIComponent(item[1]) : undefined;\n    query[key] = value;\n  }\n  return query as T;\n}\n","import { UnsubscribeFunc } from \"./types\";\n\n// (c) Jason Miller\n// Unistore - MIT license\n// And then adopted to our needs + typescript\n\ntype Listener<State> = (state: State) => void;\ntype Action<State> = (\n  state: State,\n  ...args: any[]\n) => Partial<State> | Promise<Partial<State>> | null;\ntype BoundAction<State> = (...args: any[]) => void;\n\nexport type Store<State> = {\n  state: State | undefined;\n  action(action: Action<State>): BoundAction<State>;\n  setState(update: Partial<State>, overwrite?: boolean): void;\n  subscribe(listener: Listener<State>): UnsubscribeFunc;\n};\n\nexport const createStore = <State>(state?: State): Store<State> => {\n  let listeners: Listener<State>[] = [];\n\n  function unsubscribe(listener: Listener<State> | null) {\n    let out = [];\n    for (let i = 0; i < listeners.length; i++) {\n      if (listeners[i] === listener) {\n        listener = null;\n      } else {\n        out.push(listeners[i]);\n      }\n    }\n    listeners = out;\n  }\n\n  function setState(update: Partial<State>, overwrite: boolean): void {\n    state = overwrite ? (update as State) : Object.assign({}, state, update);\n    let currentListeners = listeners;\n    for (let i = 0; i < currentListeners.length; i++) {\n      currentListeners[i](state);\n    }\n  }\n\n  /**\n   * An observable state container, returned from {@link createStore}\n   * @name store\n   */\n\n  return {\n    get state() {\n      return state;\n    },\n\n    /**\n     * Create a bound copy of the given action function.\n     * The bound returned function invokes action() and persists the result back to the store.\n     * If the return value of `action` is a Promise, the resolved value will be used as state.\n     * @param {Function} action\tAn action of the form `action(state, ...args) -> stateUpdate`\n     * @returns {Function} boundAction()\n     */\n    action(action: Action<State>): BoundAction<State> {\n      function apply(result: Partial<State>) {\n        setState(result, false);\n      }\n\n      // Note: perf tests verifying this implementation: https://esbench.com/bench/5a295e6299634800a0349500\n      return function() {\n        let args = [state];\n        for (let i = 0; i < arguments.length; i++) args.push(arguments[i]);\n        // @ts-ignore\n        let ret = action.apply(this, args);\n        if (ret != null) {\n          if (ret.then) return ret.then(apply);\n          return apply(ret);\n        }\n      };\n    },\n\n    /**\n     * Apply a partial state object to the current state, invoking registered listeners.\n     * @param {Object} update\t\t\t\tAn object with properties to be merged into state\n     * @param {Boolean} [overwrite=false]\tIf `true`, update will replace state instead of being merged into it\n     */\n    setState,\n\n    /**\n     * Register a listener function to be called whenever state is changed. Returns an `unsubscribe()` function.\n     * @param {Function} listener\tA function to call when state changes. Gets passed the new state.\n     * @returns {Function} unsubscribe()\n     */\n    subscribe(listener: Listener<State>) {\n      listeners.push(listener);\n      return () => {\n        unsubscribe(listener);\n      };\n    }\n\n    // /**\n    //  * Remove a previously-registered listener function.\n    //  * @param {Function} listener\tThe callback previously passed to `subscribe()` that should be removed.\n    //  * @function\n    //  */\n    // unsubscribe,\n  };\n};\n","import { Store, createStore } from \"./store\";\nimport { Connection } from \"./connection\";\nimport { UnsubscribeFunc } from \"./types\";\n\nexport type Collection<State> = {\n  state: State;\n  refresh(): Promise<void>;\n  subscribe(subscriber: (state: State) => void): UnsubscribeFunc;\n};\n\nexport const getCollection = <State>(\n  conn: Connection,\n  key: string,\n  fetchCollection: (conn: Connection) => Promise<State>,\n  subscribeUpdates?: (\n    conn: Connection,\n    store: Store<State>\n  ) => Promise<UnsubscribeFunc>\n): Collection<State> => {\n  if (conn[key]) {\n    return conn[key];\n  }\n\n  let active = 0;\n  let unsubProm: Promise<UnsubscribeFunc>;\n  let store = createStore<State>();\n\n  const refresh = () =>\n    fetchCollection(conn).then(state => store.setState(state, true));\n\n  const refreshSwallow = () =>\n    refresh().catch((err: unknown) => {\n      // Swallow errors if socket is connecting, closing or closed.\n      // We will automatically call refresh again when we re-establish the connection.\n      // Using conn.socket.OPEN instead of WebSocket for better node support\n      if (conn.socket.readyState == conn.socket.OPEN) {\n        throw err;\n      }\n    });\n\n  conn[key] = {\n    get state() {\n      return store.state;\n    },\n\n    refresh,\n\n    subscribe(subscriber: (state: State) => void): UnsubscribeFunc {\n      active++;\n\n      // If this was the first subscriber, attach collection\n      if (active === 1) {\n        if (subscribeUpdates) {\n          unsubProm = subscribeUpdates(conn, store);\n        }\n\n        // Fetch when connection re-established.\n        conn.addEventListener(\"ready\", refreshSwallow);\n\n        refreshSwallow();\n      }\n\n      const unsub = store.subscribe(subscriber);\n\n      if (store.state !== undefined) {\n        // Don't call it right away so that caller has time\n        // to initialize all the things.\n        setTimeout(() => subscriber(store.state!), 0);\n      }\n\n      return () => {\n        unsub();\n        active--;\n        if (!active) {\n          // Unsubscribe from changes\n          if (unsubProm)\n            unsubProm.then(unsub => {\n              unsub();\n            });\n          conn.removeEventListener(\"ready\", refresh);\n        }\n      };\n    }\n  };\n\n  return conn[key];\n};\n\n// Legacy name. It gets a collection and subscribes.\nexport const createCollection = <State>(\n  key: string,\n  fetchCollection: (conn: Connection) => Promise<State>,\n  subscribeUpdates:\n    | ((conn: Connection, store: Store<State>) => Promise<UnsubscribeFunc>)\n    | undefined,\n  conn: Connection,\n  onChange: (state: State) => void\n): UnsubscribeFunc =>\n  getCollection(conn, key, fetchCollection, subscribeUpdates).subscribe(\n    onChange\n  );\n","import { Connection } from \"./connection\";\nimport * as messages from \"./messages\";\nimport { HassEntity, HassServices, HassConfig, HassUser } from \"./types\";\n\nexport const getStates = (connection: Connection) =>\n  connection.sendMessagePromise<HassEntity[]>(messages.states());\n\nexport const getServices = (connection: Connection) =>\n  connection.sendMessagePromise<HassServices>(messages.services());\n\nexport const getConfig = (connection: Connection) =>\n  connection.sendMessagePromise<HassConfig>(messages.config());\n\nexport const getUser = (connection: Connection) =>\n  connection.sendMessagePromise<HassUser>(messages.user());\n\nexport const callService = (\n  connection: Connection,\n  domain: string,\n  service: string,\n  serviceData?: object\n) =>\n  connection.sendMessagePromise(\n    messages.callService(domain, service, serviceData)\n  );\n","import { getCollection } from \"./collection\";\nimport { HassConfig, UnsubscribeFunc } from \"./types\";\nimport { Connection } from \"./connection\";\nimport { Store } from \"./store\";\nimport { getConfig } from \"./commands\";\n\ntype ComponentLoadedEvent = {\n  data: {\n    component: string;\n  };\n};\n\nfunction processComponentLoaded(\n  state: HassConfig,\n  event: ComponentLoadedEvent\n): Partial<HassConfig> | null {\n  if (state === undefined) return null;\n\n  return {\n    components: state.components.concat(event.data.component)\n  };\n}\n\nconst fetchConfig = (conn: Connection) => getConfig(conn);\nconst subscribeUpdates = (conn: Connection, store: Store<HassConfig>) =>\n  Promise.all([\n    conn.subscribeEvents(\n      store.action(processComponentLoaded),\n      \"component_loaded\"\n    ),\n    conn.subscribeEvents(\n      () => fetchConfig(conn).then(config => store.setState(config, true)),\n      \"core_config_updated\"\n    )\n  ]).then(unsubs => () => unsubs.forEach(unsub => unsub()));\n\nconst configColl = (conn: Connection) =>\n  getCollection(conn, \"_cnf\", fetchConfig, subscribeUpdates);\n\nexport const subscribeConfig = (\n  conn: Connection,\n  onChange: (state: HassConfig) => void\n): UnsubscribeFunc => configColl(conn).subscribe(onChange);\n","import { getCollection } from \"./collection\";\nimport { HassServices, HassDomainServices, UnsubscribeFunc } from \"./types\";\nimport { Connection } from \"./connection\";\nimport { Store } from \"./store\";\nimport { getServices } from \"./commands\";\n\ntype ServiceRegisteredEvent = {\n  data: {\n    domain: string;\n    service: string;\n  };\n};\n\ntype ServiceRemovedEvent = {\n  data: {\n    domain: string;\n    service: string;\n  };\n};\n\nfunction processServiceRegistered(\n  state: HassServices,\n  event: ServiceRegisteredEvent\n) {\n  if (state === undefined) return null;\n\n  const { domain, service } = event.data;\n\n  const domainInfo = Object.assign({}, state[domain], {\n    [service]: { description: \"\", fields: {} }\n  });\n\n  return { [domain]: domainInfo };\n}\n\nfunction processServiceRemoved(\n  state: HassServices,\n  event: ServiceRemovedEvent\n) {\n  if (state === undefined) return null;\n\n  const { domain, service } = event.data;\n  const curDomainInfo = state[domain];\n\n  if (!curDomainInfo || !(service in curDomainInfo)) return null;\n\n  const domainInfo: HassDomainServices = {};\n  Object.keys(curDomainInfo).forEach(sKey => {\n    if (sKey !== service) domainInfo[sKey] = curDomainInfo[sKey];\n  });\n\n  return { [domain]: domainInfo };\n}\n\nconst fetchServices = (conn: Connection) => getServices(conn);\nconst subscribeUpdates = (conn: Connection, store: Store<HassServices>) =>\n  Promise.all([\n    conn.subscribeEvents<ServiceRegisteredEvent>(\n      store.action(processServiceRegistered),\n      \"service_registered\"\n    ),\n    conn.subscribeEvents<ServiceRemovedEvent>(\n      store.action(processServiceRemoved),\n      \"service_removed\"\n    )\n  ]).then(unsubs => () => unsubs.forEach(fn => fn()));\n\nconst servicesColl = (conn: Connection) =>\n  getCollection(conn, \"_srv\", fetchServices, subscribeUpdates);\n\nexport const subscribeServices = (\n  conn: Connection,\n  onChange: (state: HassServices) => void\n): UnsubscribeFunc => servicesColl(conn).subscribe(onChange);\n","import { getCollection } from \"./collection\";\nimport { HassEntities, StateChangedEvent, UnsubscribeFunc } from \"./types\";\nimport { Connection } from \"./connection\";\nimport { Store } from \"./store\";\nimport { getStates } from \"./commands\";\n\nfunction processEvent(store: Store<HassEntities>, event: StateChangedEvent) {\n  const state = store.state;\n  if (state === undefined) return;\n\n  const { entity_id, new_state } = event.data;\n  if (new_state) {\n    store.setState({ [new_state.entity_id]: new_state });\n  } else {\n    const newEntities = Object.assign({}, state);\n    delete newEntities[entity_id];\n    store.setState(newEntities, true);\n  }\n}\n\nasync function fetchEntities(conn: Connection): Promise<HassEntities> {\n  const states = await getStates(conn);\n  const entities: HassEntities = {};\n  for (let i = 0; i < states.length; i++) {\n    const state = states[i];\n    entities[state.entity_id] = state;\n  }\n  return entities;\n}\n\nconst subscribeUpdates = (conn: Connection, store: Store<HassEntities>) =>\n  conn.subscribeEvents<StateChangedEvent>(\n    ev => processEvent(store, ev as StateChangedEvent),\n    \"state_changed\"\n  );\n\nexport const entitiesColl = (conn: Connection) =>\n  getCollection(conn, \"_ent\", fetchEntities, subscribeUpdates);\n\nexport const subscribeEntities = (\n  conn: Connection,\n  onChange: (state: HassEntities) => void\n): UnsubscribeFunc => entitiesColl(conn).subscribe(onChange);\n","import { ConnectionOptions } from \"./types\";\nimport { createSocket } from \"./socket\";\nimport { Connection } from \"./connection\";\n\nexport * from \"./auth\";\nexport * from \"./collection\";\nexport * from \"./connection\";\nexport * from \"./config\";\nexport * from \"./services\";\nexport * from \"./entities\";\nexport * from \"./errors\";\nexport * from \"./types\";\nexport * from \"./commands\";\n\nconst defaultConnectionOptions: ConnectionOptions = {\n  setupRetry: 0,\n  createSocket\n};\n\nexport async function createConnection(options?: Partial<ConnectionOptions>) {\n  const connOptions: ConnectionOptions = Object.assign(\n    {},\n    defaultConnectionOptions,\n    options\n  );\n  const socket = await connOptions.createSocket(connOptions);\n  const conn = new Connection(socket, connOptions);\n  return conn;\n}\n","import { AuthData } from \"home-assistant-js-websocket\";\n\nconst storage = window.localStorage || {};\n\ndeclare global {\n  interface Window {\n    __tokenCache: {\n      // undefined: we haven't loaded yet\n      // null: none stored\n      tokens?: AuthData | null;\n      writeEnabled?: boolean;\n    };\n  }\n}\n\n// So that core.js and main app hit same shared object.\nlet tokenCache = window.__tokenCache;\nif (!tokenCache) {\n  tokenCache = window.__tokenCache = {\n    tokens: undefined,\n    writeEnabled: undefined,\n  };\n}\n\nexport function askWrite() {\n  return (\n    tokenCache.tokens !== undefined && tokenCache.writeEnabled === undefined\n  );\n}\n\nexport function saveTokens(tokens: AuthData | null) {\n  tokenCache.tokens = tokens;\n  if (tokenCache.writeEnabled) {\n    try {\n      storage.hassTokens = JSON.stringify(tokens);\n    } catch (err) {\n      // write failed, ignore it. Happens if storage is full or private mode.\n    }\n  }\n}\n\nexport function enableWrite() {\n  tokenCache.writeEnabled = true;\n  if (tokenCache.tokens) {\n    saveTokens(tokenCache.tokens);\n  }\n}\n\nexport function loadTokens() {\n  if (tokenCache.tokens === undefined) {\n    try {\n      // Delete the old token cache.\n      delete storage.tokens;\n      const tokens = storage.hassTokens;\n      if (tokens) {\n        tokenCache.tokens = JSON.parse(tokens);\n        tokenCache.writeEnabled = true;\n      } else {\n        tokenCache.tokens = null;\n      }\n    } catch (err) {\n      tokenCache.tokens = null;\n    }\n  }\n  return tokenCache.tokens;\n}\n","import { HomeAssistant } from \"../types\";\n\nexport interface AuthProvider {\n  name: string;\n  id: string;\n  type: string;\n}\n\nexport interface Credential {\n  type: string;\n}\n\nexport interface SignedPath {\n  path: string;\n}\n\nexport const hassUrl = `${location.protocol}//${location.host}`;\n\nexport const getSignedPath = (\n  hass: HomeAssistant,\n  path: string\n): Promise<SignedPath> => hass.callWS({ type: \"auth/sign_path\", path });\n\nexport const fetchAuthProviders = () =>\n  fetch(\"/auth/providers\", {\n    credentials: \"same-origin\",\n  });\n","import { createCollection, Connection } from \"home-assistant-js-websocket\";\nimport { Panels } from \"../types\";\n\nconst fetchPanels = (conn) =>\n  conn.sendMessagePromise({\n    type: \"get_panels\",\n  });\n\nconst subscribeUpdates = (conn, store) =>\n  conn.subscribeEvents(\n    () => fetchPanels(conn).then((panels) => store.setState(panels, true)),\n    \"panels_updated\"\n  );\n\nexport const subscribePanels = (\n  conn: Connection,\n  onChange: (panels: Panels) => void\n) =>\n  createCollection<Panels>(\n    \"_pnl\",\n    fetchPanels,\n    subscribeUpdates,\n    conn,\n    onChange\n  );\n","import { createCollection, Connection } from \"home-assistant-js-websocket\";\nimport { Themes } from \"../types\";\n\nconst fetchThemes = (conn) =>\n  conn.sendMessagePromise({\n    type: \"frontend/get_themes\",\n  });\n\nconst subscribeUpdates = (conn, store) =>\n  conn.subscribeEvents(\n    (event) => store.setState(event.data, true),\n    \"themes_updated\"\n  );\n\nexport const subscribeThemes = (\n  conn: Connection,\n  onChange: (themes: Themes) => void\n) =>\n  createCollection<Themes>(\n    \"_thm\",\n    fetchThemes,\n    subscribeUpdates,\n    conn,\n    onChange\n  );\n","import {\n  getUser,\n  Connection,\n  getCollection,\n} from \"home-assistant-js-websocket\";\nimport { CurrentUser } from \"../types\";\n\nexport const userCollection = (conn: Connection) =>\n  getCollection(\n    conn,\n    \"_usr\",\n    () => getUser(conn) as Promise<CurrentUser>,\n    undefined\n  );\n\nexport const subscribeUser = (\n  conn: Connection,\n  onChange: (user: CurrentUser) => void\n) => userCollection(conn).subscribe(onChange);\n","import {\n  getAuth,\n  createConnection,\n  subscribeConfig,\n  subscribeEntities,\n  subscribeServices,\n  ERR_INVALID_AUTH,\n  Auth,\n  Connection,\n} from \"home-assistant-js-websocket\";\n\nimport { loadTokens, saveTokens } from \"../common/auth/token_storage\";\nimport { subscribePanels } from \"../data/ws-panels\";\nimport { subscribeThemes } from \"../data/ws-themes\";\nimport { subscribeUser } from \"../data/ws-user\";\nimport { HomeAssistant } from \"../types\";\nimport { hassUrl } from \"../data/auth\";\n\ndeclare global {\n  interface Window {\n    hassConnection: Promise<{ auth: Auth; conn: Connection }>;\n  }\n}\n\nconst isExternal = location.search.includes(\"external_auth=1\");\n\nconst authProm = isExternal\n  ? () =>\n      import(/* webpackChunkName: \"external_auth\" */ \"../external_app/external_auth\").then(\n        ({ createExternalAuth }) => createExternalAuth(hassUrl)\n      )\n  : () =>\n      getAuth({\n        hassUrl,\n        saveTokens,\n        loadTokens: () => Promise.resolve(loadTokens()),\n      });\n\nconst connProm = async (auth) => {\n  try {\n    const conn = await createConnection({ auth });\n\n    // Clear url if we have been able to establish a connection\n    if (location.search.includes(\"auth_callback=1\")) {\n      history.replaceState(null, \"\", location.pathname);\n    }\n\n    return { auth, conn };\n  } catch (err) {\n    if (err !== ERR_INVALID_AUTH) {\n      throw err;\n    }\n    // We can get invalid auth if auth tokens were stored that are no longer valid\n    // Clear stored tokens.\n    if (!isExternal) {\n      saveTokens(null);\n    }\n    auth = await authProm();\n    const conn = await createConnection({ auth });\n    return { auth, conn };\n  }\n};\n\nwindow.hassConnection = authProm().then(connProm);\n\n// Start fetching some of the data that we will need.\nwindow.hassConnection.then(({ conn }) => {\n  const noop = () => {\n    // do nothing\n  };\n  subscribeEntities(conn, noop);\n  subscribeConfig(conn, noop);\n  subscribeServices(conn, noop);\n  subscribePanels(conn, noop);\n  subscribeThemes(conn, noop);\n  subscribeUser(conn, noop);\n});\n\nwindow.addEventListener(\"error\", (e) => {\n  const homeAssistant = document.querySelector(\"home-assistant\") as any;\n  if (\n    homeAssistant &&\n    homeAssistant.hass &&\n    (homeAssistant.hass as HomeAssistant).callService\n  ) {\n    homeAssistant.hass.callService(\"system_log\", \"write\", {\n      logger: `frontend.${\n        __DEV__ ? \"js_dev\" : \"js\"\n      }.${__BUILD__}.${__VERSION__.replace(\".\", \"\")}`,\n      message: `${e.filename}:${e.lineno}:${e.colno} ${e.message}`,\n    });\n  }\n});\n"],"sourceRoot":""}