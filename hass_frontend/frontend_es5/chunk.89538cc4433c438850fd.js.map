{"version":3,"sources":["webpack:///./node_modules/superstruct/lib/index.es.js","webpack:///./node_modules/@polymer/iron-autogrow-textarea/iron-autogrow-textarea.js","webpack:///./node_modules/@polymer/paper-input/paper-textarea.js"],"names":["__webpack_require__","d","__webpack_exports__","superstruct","StructError","TypeError","[object Object]","attrs","type","path","value","length","join","JSON","stringify","super","format","data","reason","errors","this","push","Error","captureStackTrace","constructor","stack","toString","Object","prototype","kindOf","val","ctorName","Array","isArray","isBuffer","callee","err","message","indexOf","isArguments","Date","toDateString","getDate","setDate","isDate","stackTraceLimit","isError","RegExp","flags","ignoreCase","multiline","global","isRegexp","throw","return","next","isGeneratorObj","call","slice","toLowerCase","replace","name","IS_STRUCT","KIND","isStruct","resolveDefaults","defaults","_extends","assign","target","i","arguments","source","key","hasOwnProperty","Kind","validate","any","schema","defaults$$1","options","tuple","list","func","object","required","endsWith","includes","union","split","intersection","scalar","optional","undefined","en","map","s","e","String","result","isValid","failure","array","element","error","ret","v","r","forEach","singleE","concat","first","obj","ks","properties","kind","valueKeys","keys","propertiesKeys","Set","types","fn","kinds","k","Math","max","t","Kinds","dict","values","resolved","e2","r2","enum","enums","function","instance","interface","lazy","struct","literal","partial","dynamic","createSchema","Types","config","Struct","assert","defineProperty","test","date","isNaN","polymer_fn","_template","html_tag","is","behaviors","iron_validatable_behavior","iron_control_state","observer","notify","bindValue","rows","Number","maxRows","autocomplete","autofocus","Boolean","inputmode","placeholder","readonly","minlength","maxlength","label","listeners","input","textarea","$","selectionStart","selectionEnd","attached","navigator","userAgent","match","style","marginLeft","valid","validity","hasValidator","invalid","fire","_bindValueChanged","_valueChanged","mirror","innerHTML","_valueForMirror","_onInput","event","eventPath","polymer_dom","_constrain","tokens","_tokens","_updateCached","paper_input_behavior","iron_form_element_behavior","_ariaLabelledBy","_ariaDescribedBy","start","end","_ariaLabelledByChanged","ariaLabelledBy","_focusableElement","setAttribute","_ariaDescribedByChanged","ariaDescribedBy","inputElement"],"mappings":"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","file":"chunk.89538cc4433c438850fd.js","sourcesContent":["/**\n * Define a struct error.\n *\n * @type {StructError}\n */\n\nclass StructError extends TypeError {\n  static format(attrs) {\n    const { type, path, value } = attrs;\n    const message = `Expected a value of type \\`${type}\\`${path.length ? ` for \\`${path.join('.')}\\`` : ''} but received \\`${JSON.stringify(value)}\\`.`;\n    return message;\n  }\n\n  constructor(attrs) {\n    const message = StructError.format(attrs);\n    super(message);\n\n    const { data, path, value, reason, type, errors = [] } = attrs;\n    this.data = data;\n    this.path = path;\n    this.value = value;\n    this.reason = reason;\n    this.type = type;\n    this.errors = errors;\n\n    if (!errors.length) {\n      errors.push(this);\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    } else {\n      this.stack = new Error().stack;\n    }\n  }\n}\n\nvar toString = Object.prototype.toString;\n\nvar kindOf = function kindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n\n  var type = typeof val;\n  if (type === 'boolean') return 'boolean';\n  if (type === 'string') return 'string';\n  if (type === 'number') return 'number';\n  if (type === 'symbol') return 'symbol';\n  if (type === 'function') {\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\n  }\n\n  if (isArray(val)) return 'array';\n  if (isBuffer(val)) return 'buffer';\n  if (isArguments(val)) return 'arguments';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  if (isRegexp(val)) return 'regexp';\n\n  switch (ctorName(val)) {\n    case 'Symbol': return 'symbol';\n    case 'Promise': return 'promise';\n\n    // Set, Map, WeakSet, WeakMap\n    case 'WeakMap': return 'weakmap';\n    case 'WeakSet': return 'weakset';\n    case 'Map': return 'map';\n    case 'Set': return 'set';\n\n    // 8-bit typed arrays\n    case 'Int8Array': return 'int8array';\n    case 'Uint8Array': return 'uint8array';\n    case 'Uint8ClampedArray': return 'uint8clampedarray';\n\n    // 16-bit typed arrays\n    case 'Int16Array': return 'int16array';\n    case 'Uint16Array': return 'uint16array';\n\n    // 32-bit typed arrays\n    case 'Int32Array': return 'int32array';\n    case 'Uint32Array': return 'uint32array';\n    case 'Float32Array': return 'float32array';\n    case 'Float64Array': return 'float64array';\n  }\n\n  if (isGeneratorObj(val)) {\n    return 'generator';\n  }\n\n  // Non-plain objects\n  type = toString.call(val);\n  switch (type) {\n    case '[object Object]': return 'object';\n    // iterators\n    case '[object Map Iterator]': return 'mapiterator';\n    case '[object Set Iterator]': return 'setiterator';\n    case '[object String Iterator]': return 'stringiterator';\n    case '[object Array Iterator]': return 'arrayiterator';\n  }\n\n  // other\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n};\n\nfunction ctorName(val) {\n  return val.constructor ? val.constructor.name : null;\n}\n\nfunction isArray(val) {\n  if (Array.isArray) return Array.isArray(val);\n  return val instanceof Array;\n}\n\nfunction isError(val) {\n  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function'\n    && typeof val.getDate === 'function'\n    && typeof val.setDate === 'function';\n}\n\nfunction isRegexp(val) {\n  if (val instanceof RegExp) return true;\n  return typeof val.flags === 'string'\n    && typeof val.ignoreCase === 'boolean'\n    && typeof val.multiline === 'boolean'\n    && typeof val.global === 'boolean';\n}\n\nfunction isGeneratorFn(name, val) {\n  return ctorName(name) === 'GeneratorFunction';\n}\n\nfunction isGeneratorObj(val) {\n  return typeof val.throw === 'function'\n    && typeof val.return === 'function'\n    && typeof val.next === 'function';\n}\n\nfunction isArguments(val) {\n  try {\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\n      return true;\n    }\n  } catch (err) {\n    if (err.message.indexOf('callee') !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * If you need to support Safari 5-7 (8-10 yr-old browser),\n * take a look at https://github.com/feross/is-buffer\n */\n\nfunction isBuffer(val) {\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\n    return val.constructor.isBuffer(val);\n  }\n  return false;\n}\n\n/**\n * A private string to identify structs by.\n *\n * @type {String}\n */\n\nconst IS_STRUCT = '@@__STRUCT__@@';\n\n/**\n * A private string to refer to a struct's kind.\n *\n * @type {String}\n */\n\nconst KIND = '@@__KIND__@@';\n\n/**\n * Check if a `value` is a struct.\n *\n * @param {Any} value\n * @return {Boolean}\n */\n\nfunction isStruct(value) {\n  return !!(value && value[IS_STRUCT]);\n}\n\n/**\n * Resolve `defaults`, for an optional `value`.\n *\n * @param {Function|Any} defaults\n * @param {Any} value\n * @return {Any}\n */\n\nfunction resolveDefaults(defaults, value) {\n  return typeof defaults === 'function' ? defaults(value) : defaults;\n}\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n * Kind.\n *\n * @type {Kind}\n */\n\nclass Kind {\n  constructor(name, type, validate) {\n    this.name = name;\n    this.type = type;\n    this.validate = validate;\n  }\n}\n\n/**\n * Any.\n *\n * @param {Array|Function|Object|String} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction any(schema, defaults$$1, options) {\n  if (isStruct(schema)) {\n    return schema[KIND];\n  }\n\n  if (schema instanceof Kind) {\n    return schema;\n  }\n\n  switch (kindOf(schema)) {\n    case 'array':\n      {\n        return schema.length > 1 ? tuple(schema, defaults$$1, options) : list(schema, defaults$$1, options);\n      }\n\n    case 'function':\n      {\n        return func(schema, defaults$$1, options);\n      }\n\n    case 'object':\n      {\n        return object(schema, defaults$$1, options);\n      }\n\n    case 'string':\n      {\n        let required = true;\n        let type;\n\n        if (schema.endsWith('?')) {\n          required = false;\n          schema = schema.slice(0, -1);\n        }\n\n        if (schema.includes('|')) {\n          const scalars = schema.split(/\\s*\\|\\s*/g);\n          type = union(scalars, defaults$$1, options);\n        } else if (schema.includes('&')) {\n          const scalars = schema.split(/\\s*&\\s*/g);\n          type = intersection(scalars, defaults$$1, options);\n        } else {\n          type = scalar(schema, defaults$$1, options);\n        }\n\n        if (!required) {\n          type = optional(type, undefined, options);\n        }\n\n        return type;\n      }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    throw new Error(`A schema definition must be an object, array, string or function, but you passed: ${schema}`);\n  } else {\n    throw new Error(`Invalid schema: ${schema}`);\n  }\n}\n\n/**\n * Dict.\n *\n * @param {Array} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction dict(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array' || schema.length !== 2) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Dict structs must be defined as an array with two elements, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const obj = scalar('object', undefined, options);\n  const keys = any(schema[0], undefined, options);\n  const values = any(schema[1], undefined, options);\n  const name = 'dict';\n  const type = `dict<${keys.type},${values.type}>`;\n  const validate = value => {\n    const resolved = resolveDefaults(defaults$$1);\n    value = resolved ? _extends({}, resolved, value) : value;\n    const [error] = obj.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    const ret = {};\n    const errors = [];\n\n    for (let k in value) {\n      const v = value[k];\n      const [e, r] = keys.validate(k);\n\n      if (e) {\n        const allE = e.errors || [e];\n        allE.forEach(singleE => {\n          singleE.path = [k].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        continue;\n      }\n\n      k = r;\n      const [e2, r2] = values.validate(v);\n\n      if (e2) {\n        const allE2 = e2.errors || [e2];\n        allE2.forEach(singleE => {\n          singleE.path = [k].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        continue;\n      }\n\n      ret[k] = r2;\n    }\n\n    if (errors.length) {\n      const first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Enum.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction en(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Enum structs must be defined as an array, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const name = 'enum';\n  const type = schema.map(s => {\n    try {\n      return JSON.stringify(s);\n    } catch (e) {\n      return String(s);\n    }\n  }).join(' | ');\n\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    return schema.includes(value) ? [undefined, value] : [{ data: value, path: [], value, type }];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Enums.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction enums(schema, defaults$$1, options) {\n  const e = en(schema, undefined, options);\n  const l = list([e], defaults$$1, options);\n  return l;\n}\n\n/**\n * Function.\n *\n * @param {Function} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction func(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Function structs must be defined as a function, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const name = 'function';\n  const type = '<function>';\n  const validate = (value = resolveDefaults(defaults$$1), data) => {\n    const result = schema(value, data);\n    let failure = { path: [], reason: null };\n    let isValid;\n\n    switch (kindOf(result)) {\n      case 'boolean':\n        {\n          isValid = result;\n          break;\n        }\n      case 'string':\n        {\n          isValid = false;\n          failure.reason = result;\n          break;\n        }\n      case 'object':\n        {\n          isValid = false;\n          failure = _extends({}, failure, result);\n          break;\n        }\n      default:\n        {\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(`Validator functions must return a boolean, an error reason string or an error reason object, but you passed: ${schema}`);\n          } else {\n            throw new Error(`Invalid result: ${result}`);\n          }\n        }\n    }\n\n    return isValid ? [undefined, value] : [_extends({ type, value, data: value }, failure)];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Instance.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction instance(schema, defaults$$1, options) {\n  const name = 'instance';\n  const type = `instance<${schema.name}>`;\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    return value instanceof schema ? [undefined, value] : [{ data: value, path: [], value, type }];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Interface.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction inter(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Interface structs must be defined as an object, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const ks = [];\n  const properties = {};\n\n  for (const key in schema) {\n    ks.push(key);\n    const s = schema[key];\n    const kind = any(s, undefined, options);\n    properties[key] = kind;\n  }\n\n  const name = 'interface';\n  const type = `{${ks.join()}}`;\n  const validate = value => {\n    const resolved = resolveDefaults(defaults$$1);\n    value = resolved ? _extends({}, resolved, value) : value;\n    const errors = [];\n    const ret = value;\n\n    for (const key in properties) {\n      let v = value[key];\n      const kind = properties[key];\n\n      if (v === undefined) {\n        const d = defaults$$1 && defaults$$1[key];\n        v = resolveDefaults(d, value);\n      }\n\n      const [e, r] = kind.validate(v, value);\n\n      if (e) {\n        const allE = e.errors || [e];\n        allE.forEach(singleE => {\n          singleE.path = [key].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        continue;\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r;\n      }\n    }\n\n    if (errors.length) {\n      const first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Lazy.\n *\n * @param {Function} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction lazy(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Lazy structs must be defined as an function that returns a schema, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  let kind;\n  let struct;\n  const name = 'lazy';\n  const type = `lazy...`;\n  const compile = value => {\n    struct = schema();\n    kind.name = struct.kind;\n    kind.type = struct.type;\n    kind.validate = struct.validate;\n    return kind.validate(value);\n  };\n\n  kind = new Kind(name, type, compile);\n  return kind;\n}\n\n/**\n * Dynamic.\n *\n * @param {Function} createSchema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction dynamic(createSchema, defaults$$1, options) {\n  if (kindOf(createSchema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Dynamic structs must be defined as a function, but you passed: ${createSchema}`);\n    } else {\n      throw new Error(`Invalid schema: ${createSchema}`);\n    }\n  }\n\n  const name = 'dynamic';\n  const type = 'dynamic...';\n  const validate = (value = resolveDefaults(defaults$$1), data) => {\n    const schema = createSchema(value, data);\n\n    if (kindOf(schema) !== 'function') {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new Error(`Dynamic structs must return a schema, but you passed: ${schema}`);\n      } else {\n        throw new Error(`Invalid schema: ${schema}`);\n      }\n    }\n\n    const [error, result] = schema.validate(value);\n\n    if (error) {\n      return [error];\n    }\n\n    return [undefined, result];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * List.\n *\n * @param {Array} schema\n * @param {Array} defaults\n * @param {Object} options\n */\n\nfunction list(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array' || schema.length !== 1) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`List structs must be defined as an array with a single element, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const array = scalar('array', undefined, options);\n  const element = any(schema[0], undefined, options);\n  const name = 'list';\n  const type = `[${element.type}]`;\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    const [error, result] = array.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    value = result;\n    const errors = [];\n    const ret = [];\n\n    for (let i = 0; i < value.length; i++) {\n      const v = value[i];\n      const [e, r] = element.validate(v);\n\n      if (e) {\n        const allE = e.errors || [e];\n        allE.forEach(singleE => {\n          singleE.path = [i].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        continue;\n      }\n\n      ret[i] = r;\n    }\n\n    if (errors.length) {\n      const first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Literal.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction literal(schema, defaults$$1, options) {\n  const name = 'literal';\n  const type = `literal: ${JSON.stringify(schema)}`;\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    return value === schema ? [undefined, value] : [{ data: value, path: [], value, type }];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Object.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction object(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Object structs must be defined as an object, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const obj = scalar('object', undefined, options);\n  const ks = [];\n  const properties = {};\n\n  for (const key in schema) {\n    ks.push(key);\n    const s = schema[key];\n    const kind = any(s, undefined, options);\n    properties[key] = kind;\n  }\n\n  const name = 'object';\n  const type = `{${ks.join()}}`;\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    const [error] = obj.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    const errors = [];\n    const ret = {};\n    const valueKeys = Object.keys(value);\n    const propertiesKeys = Object.keys(properties);\n    const keys = new Set(valueKeys.concat(propertiesKeys));\n\n    keys.forEach(key => {\n      let v = value[key];\n      const kind = properties[key];\n\n      if (v === undefined) {\n        const d = defaults$$1 && defaults$$1[key];\n        v = resolveDefaults(d, value);\n      }\n\n      if (!kind) {\n        const e = { data: value, path: [key], value: v };\n        errors.push(e);\n        return;\n      }\n\n      const [e, r] = kind.validate(v, value);\n\n      if (e) {\n        const allE = e.errors || [e];\n        allE.forEach(singleE => {\n          singleE.path = [key].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        return;\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r;\n      }\n    });\n\n    if (errors.length) {\n      const first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Optional.\n *\n * @param {Any} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction optional(schema, defaults$$1, options) {\n  return union([schema, 'undefined'], defaults$$1, options);\n}\n\n/**\n * Partial.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction partial(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Partial structs must be defined as an object, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const obj = scalar('object', undefined, options);\n  const ks = [];\n  const properties = {};\n\n  for (const key in schema) {\n    ks.push(key);\n    const s = schema[key];\n    const kind = any(s, undefined, options);\n    properties[key] = kind;\n  }\n\n  const name = 'partial';\n  const type = `{${ks.join()},...}`;\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    const [error] = obj.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    const errors = [];\n    const ret = {};\n\n    for (const key in properties) {\n      let v = value[key];\n      const kind = properties[key];\n\n      if (v === undefined) {\n        const d = defaults$$1 && defaults$$1[key];\n        v = resolveDefaults(d, value);\n      }\n\n      const [e, r] = kind.validate(v, value);\n\n      if (e) {\n        const allE = e.errors || [e];\n        allE.forEach(singleE => {\n          singleE.path = [key].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        continue;\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r;\n      }\n    }\n\n    if (errors.length) {\n      const first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Scalar.\n *\n * @param {String} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction scalar(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'string') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Scalar structs must be defined as a string, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const { types } = options;\n  const fn = types[schema];\n\n  if (kindOf(fn) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`No struct validator function found for type \"${schema}\".`);\n    } else {\n      throw new Error(`Invalid type: ${schema}`);\n    }\n  }\n\n  const kind = func(fn, defaults$$1, options);\n  const name = 'scalar';\n  const type = schema;\n  const validate = value => {\n    const [error, result] = kind.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    return [undefined, result];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Tuple.\n *\n * @param {Array} schema\n * @param {Array} defaults\n * @param {Object} options\n */\n\nfunction tuple(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Tuple structs must be defined as an array, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const kinds = schema.map(s => any(s, undefined, options));\n  const array = scalar('array', undefined, options);\n  const name = 'tuple';\n  const type = `[${kinds.map(k => k.type).join()}]`;\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    const [error] = array.validate(value);\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    const ret = [];\n    const errors = [];\n    const length = Math.max(value.length, kinds.length);\n\n    for (let i = 0; i < length; i++) {\n      const kind = kinds[i];\n      const v = value[i];\n\n      if (!kind) {\n        const e = { data: value, path: [i], value: v };\n        errors.push(e);\n        continue;\n      }\n\n      const [e, r] = kind.validate(v);\n\n      if (e) {\n        const allE = e.errors || [e];\n        allE.forEach(singleE => {\n          singleE.path = [i].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        continue;\n      }\n\n      ret[i] = r;\n    }\n\n    if (errors.length) {\n      const first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Union.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction union(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Union structs must be defined as an array, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const kinds = schema.map(s => any(s, undefined, options));\n  const name = 'union';\n  const type = kinds.map(k => k.type).join(' | ');\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    const errors = [];\n\n    for (const k of kinds) {\n      const [e, r] = k.validate(value);\n\n      if (!e) {\n        return [undefined, r];\n      }\n\n      errors.push(e);\n    }\n    errors[0].type = type;\n    return errors;\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Intersection.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction intersection(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Intersection structs must be defined as an array, but you passed: ${schema}`);\n    } else {\n      throw new Error(`Invalid schema: ${schema}`);\n    }\n  }\n\n  const types = schema.map(s => any(s, undefined, options));\n  const name = 'intersection';\n  const type = types.map(t => t.type).join(' & ');\n  const validate = (value = resolveDefaults(defaults$$1)) => {\n    let v = value;\n\n    for (const t of types) {\n      const [e, r] = t.validate(v);\n\n      if (e) {\n        e.type = type;\n        return [e];\n      }\n\n      v = r;\n    }\n\n    return [undefined, v];\n  };\n\n  return new Kind(name, type, validate);\n}\n\n/**\n * Kinds.\n *\n * @type {Object}\n */\n\nconst Kinds = {\n  any,\n  dict,\n  enum: en,\n  enums,\n  function: func,\n  instance,\n  interface: inter,\n  lazy,\n  list,\n  literal,\n  object,\n  optional,\n  partial,\n  scalar,\n  tuple,\n  union,\n  intersection,\n  dynamic\n\n  /**\n   * Export.\n   *\n   * @type {Object}\n   */\n\n};\n\n/**\n * The types that `kind-of` supports.\n *\n * @type {Array}\n */\n\nconst TYPES = ['arguments', 'array', 'boolean', 'buffer', 'error', 'float32array', 'float64array', 'function', 'generatorfunction', 'int16array', 'int32array', 'int8array', 'map', 'null', 'number', 'object', 'promise', 'regexp', 'set', 'string', 'symbol', 'uint16array', 'uint32array', 'uint8array', 'uint8clampedarray', 'undefined', 'weakmap', 'weakset'];\n\n/**\n * The default types that Superstruct ships with.\n *\n * @type {Object}\n */\n\nconst Types = {\n  any: value => value !== undefined\n};\n\nTYPES.forEach(type => {\n  Types[type] = value => kindOf(value) === type;\n});\n\n/**\n * Handle the 'date' case specially, to throw out invalid `Date` objects.\n *\n * @param {Mixed} value\n * @return {Boolean}\n */\n\nTypes.date = value => kindOf(value) === 'date' && !isNaN(value);\n\n/**\n * Create a struct factory with a `config`.\n *\n * @param {Object} config\n * @return {Function}\n */\n\nfunction superstruct(config = {}) {\n  const types = _extends({}, Types, config.types || {});\n\n  /**\n   * Create a `kind` struct with `schema`, `defaults` and `options`.\n   *\n   * @param {Any} schema\n   * @param {Any} defaults\n   * @param {Object} options\n   * @return {Function}\n   */\n\n  function struct(schema, defaults$$1, options = {}) {\n    if (isStruct(schema)) {\n      schema = schema.schema;\n    }\n\n    const kind = Kinds.any(schema, defaults$$1, _extends({}, options, { types }));\n\n    function Struct(data) {\n      if (this instanceof Struct) {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error('The `Struct` creation function should not be used with the `new` keyword.');\n        } else {\n          throw new Error('Invalid `new` keyword!');\n        }\n      }\n\n      return Struct.assert(data);\n    }\n\n    Object.defineProperty(Struct, IS_STRUCT, { value: true });\n    Object.defineProperty(Struct, KIND, { value: kind });\n\n    Struct.kind = kind.name;\n    Struct.type = kind.type;\n    Struct.schema = schema;\n    Struct.defaults = defaults$$1;\n    Struct.options = options;\n\n    Struct.assert = value => {\n      const [error, result] = kind.validate(value);\n\n      if (error) {\n        throw new StructError(error);\n      }\n\n      return result;\n    };\n\n    Struct.test = value => {\n      const [error] = kind.validate(value);\n      return !error;\n    };\n\n    Struct.validate = value => {\n      const [error, result] = kind.validate(value);\n\n      if (error) {\n        return [new StructError(error)];\n      }\n\n      return [undefined, result];\n    };\n\n    return Struct;\n  }\n\n  /**\n   * Mix in a factory for each specific kind of struct.\n   */\n\n  Object.keys(Kinds).forEach(name => {\n    const kind = Kinds[name];\n\n    struct[name] = (schema, defaults$$1, options) => {\n      const type = kind(schema, defaults$$1, _extends({}, options, { types }));\n      const s = struct(type, defaults$$1, options);\n      return s;\n    };\n  });\n\n  /**\n   * Return the struct factory.\n   */\n\n  return struct;\n}\n\n/**\n * Create a convenience `struct` factory for the default types.\n *\n * @type {Function}\n */\n\nconst struct = superstruct();\n\nexport { struct, superstruct, isStruct, StructError };\n//# sourceMappingURL=index.es.js.map\n","/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\nimport '@polymer/iron-flex-layout/iron-flex-layout.js';\n\nimport {IronControlState} from '@polymer/iron-behaviors/iron-control-state.js';\nimport {IronValidatableBehavior} from '@polymer/iron-validatable-behavior/iron-validatable-behavior.js';\nimport {Polymer} from '@polymer/polymer/lib/legacy/polymer-fn.js';\nimport {dom} from '@polymer/polymer/lib/legacy/polymer.dom.js';\nimport {html} from '@polymer/polymer/lib/utils/html-tag.js';\n\n/**\n`iron-autogrow-textarea` is an element containing a textarea that grows in\nheight as more lines of input are entered. Unless an explicit height or the\n`maxRows` property is set, it will never scroll.\n\nExample:\n\n    <iron-autogrow-textarea></iron-autogrow-textarea>\n\n### Styling\n\nThe following custom properties and mixins are available for styling:\n\nCustom property | Description | Default\n----------------|-------------|----------\n`--iron-autogrow-textarea` | Mixin applied to the textarea | `{}`\n`--iron-autogrow-textarea-placeholder` | Mixin applied to the textarea placeholder | `{}`\n\n@group Iron Elements\n@hero hero.svg\n@demo demo/index.html\n*/\nPolymer({\n  _template: html`\n    <style>\n      :host {\n        display: inline-block;\n        position: relative;\n        width: 400px;\n        border: 1px solid;\n        padding: 2px;\n        -moz-appearance: textarea;\n        -webkit-appearance: textarea;\n        overflow: hidden;\n      }\n\n      .mirror-text {\n        visibility: hidden;\n        word-wrap: break-word;\n        @apply --iron-autogrow-textarea;\n      }\n\n      .fit {\n        @apply --layout-fit;\n      }\n\n      textarea {\n        position: relative;\n        outline: none;\n        border: none;\n        resize: none;\n        background: inherit;\n        color: inherit;\n        /* see comments in template */\n        width: 100%;\n        height: 100%;\n        font-size: inherit;\n        font-family: inherit;\n        line-height: inherit;\n        text-align: inherit;\n        @apply --iron-autogrow-textarea;\n      }\n\n      textarea::-webkit-input-placeholder {\n        @apply --iron-autogrow-textarea-placeholder;\n      }\n\n      textarea:-moz-placeholder {\n        @apply --iron-autogrow-textarea-placeholder;\n      }\n\n      textarea::-moz-placeholder {\n        @apply --iron-autogrow-textarea-placeholder;\n      }\n\n      textarea:-ms-input-placeholder {\n        @apply --iron-autogrow-textarea-placeholder;\n      }\n    </style>\n\n    <!-- the mirror sizes the input/textarea so it grows with typing -->\n    <!-- use &#160; instead &nbsp; of to allow this element to be used in XHTML -->\n    <div id=\"mirror\" class=\"mirror-text\" aria-hidden=\"true\">&nbsp;</div>\n\n    <!-- size the input/textarea with a div, because the textarea has intrinsic size in ff -->\n    <div class=\"textarea-container fit\">\n      <textarea id=\"textarea\" name\\$=\"[[name]]\" aria-label\\$=\"[[label]]\" autocomplete\\$=\"[[autocomplete]]\" autofocus\\$=\"[[autofocus]]\" inputmode\\$=\"[[inputmode]]\" placeholder\\$=\"[[placeholder]]\" readonly\\$=\"[[readonly]]\" required\\$=\"[[required]]\" disabled\\$=\"[[disabled]]\" rows\\$=\"[[rows]]\" minlength\\$=\"[[minlength]]\" maxlength\\$=\"[[maxlength]]\"></textarea>\n    </div>\n`,\n\n  is: 'iron-autogrow-textarea',\n  behaviors: [IronValidatableBehavior, IronControlState],\n\n  properties: {\n    /**\n     * Use this property instead of `bind-value` for two-way data binding.\n     * @type {string|number}\n     */\n    value: {observer: '_valueChanged', type: String, notify: true},\n\n    /**\n     * This property is deprecated, and just mirrors `value`. Use `value`\n     * instead.\n     * @type {string|number}\n     */\n    bindValue: {observer: '_bindValueChanged', type: String, notify: true},\n\n    /**\n     * The initial number of rows.\n     *\n     * @attribute rows\n     * @type number\n     * @default 1\n     */\n    rows: {type: Number, value: 1, observer: '_updateCached'},\n\n    /**\n     * The maximum number of rows this element can grow to until it\n     * scrolls. 0 means no maximum.\n     *\n     * @attribute maxRows\n     * @type number\n     * @default 0\n     */\n    maxRows: {type: Number, value: 0, observer: '_updateCached'},\n\n    /**\n     * Bound to the textarea's `autocomplete` attribute.\n     */\n    autocomplete: {type: String, value: 'off'},\n\n    /**\n     * Bound to the textarea's `autofocus` attribute.\n     */\n    autofocus: {type: Boolean, value: false},\n\n    /**\n     * Bound to the textarea's `inputmode` attribute.\n     */\n    inputmode: {type: String},\n\n    /**\n     * Bound to the textarea's `placeholder` attribute.\n     */\n    placeholder: {type: String},\n\n    /**\n     * Bound to the textarea's `readonly` attribute.\n     */\n    readonly: {type: String},\n\n    /**\n     * Set to true to mark the textarea as required.\n     */\n    required: {type: Boolean},\n\n    /**\n     * The minimum length of the input value.\n     */\n    minlength: {type: Number},\n\n    /**\n     * The maximum length of the input value.\n     */\n    maxlength: {type: Number},\n\n    /**\n     * Bound to the textarea's `aria-label` attribute.\n     */\n    label: {type: String}\n\n  },\n\n  listeners: {'input': '_onInput'},\n\n  /**\n   * Returns the underlying textarea.\n   * @return {!HTMLTextAreaElement}\n   */\n  get textarea() {\n    return this.$.textarea;\n  },\n\n  /**\n   * Returns textarea's selection start.\n   * @return {number}\n   */\n  get selectionStart() {\n    return this.$.textarea.selectionStart;\n  },\n\n  /**\n   * Returns textarea's selection end.\n   * @return {number}\n   */\n  get selectionEnd() {\n    return this.$.textarea.selectionEnd;\n  },\n\n  /**\n   * Sets the textarea's selection start.\n   */\n  set selectionStart(value) {\n    this.$.textarea.selectionStart = value;\n  },\n\n  /**\n   * Sets the textarea's selection end.\n   */\n  set selectionEnd(value) {\n    this.$.textarea.selectionEnd = value;\n  },\n\n  attached: function() {\n    /* iOS has an arbitrary left margin of 3px that isn't present\n     * in any other browser, and means that the paper-textarea's cursor\n     * overlaps the label.\n     * See https://github.com/PolymerElements/paper-input/issues/468.\n     */\n    var IS_IOS = navigator.userAgent.match(/iP(?:[oa]d|hone)/);\n    if (IS_IOS) {\n      this.$.textarea.style.marginLeft = '-3px';\n    }\n  },\n\n  /**\n   * Returns true if `value` is valid. The validator provided in `validator`\n   * will be used first, if it exists; otherwise, the `textarea`'s validity\n   * is used.\n   * @return {boolean} True if the value is valid.\n   */\n  validate: function() {\n    // Use the nested input's native validity.\n    var valid = this.$.textarea.validity.valid;\n\n    // Only do extra checking if the browser thought this was valid.\n    if (valid) {\n      // Empty, required input is invalid\n      if (this.required && this.value === '') {\n        valid = false;\n      } else if (this.hasValidator()) {\n        valid = IronValidatableBehavior.validate.call(this, this.value);\n      }\n    }\n\n    this.invalid = !valid;\n    this.fire('iron-input-validate');\n    return valid;\n  },\n\n  _bindValueChanged: function(bindValue) {\n    this.value = bindValue;\n  },\n\n  _valueChanged: function(value) {\n    var textarea = this.textarea;\n    if (!textarea) {\n      return;\n    }\n\n    // If the bindValue changed manually, then we need to also update\n    // the underlying textarea's value. Otherwise this change was probably\n    // generated from the _onInput handler, and the two values are already\n    // the same.\n    if (textarea.value !== value) {\n      textarea.value = !(value || value === 0) ? '' : value;\n    }\n\n    this.bindValue = value;\n    this.$.mirror.innerHTML = this._valueForMirror();\n\n    // Manually notify because we don't want to notify until after setting\n    // value.\n    this.fire('bind-value-changed', {value: this.bindValue});\n  },\n\n  _onInput: function(event) {\n    var eventPath = dom(event).path;\n    this.value = eventPath ? eventPath[0].value : event.target.value;\n  },\n\n  _constrain: function(tokens) {\n    var _tokens;\n    tokens = tokens || [''];\n    // Enforce the min and max heights for a multiline input to avoid\n    // measurement\n    if (this.maxRows > 0 && tokens.length > this.maxRows) {\n      _tokens = tokens.slice(0, this.maxRows);\n    } else {\n      _tokens = tokens.slice(0);\n    }\n    while (this.rows > 0 && _tokens.length < this.rows) {\n      _tokens.push('');\n    }\n    // Use &#160; instead &nbsp; of to allow this element to be used in XHTML.\n    return _tokens.join('<br/>') + '&#160;';\n  },\n\n  _valueForMirror: function() {\n    var input = this.textarea;\n    if (!input) {\n      return;\n    }\n    this.tokens = (input && input.value) ? input.value.replace(/&/gm, '&amp;')\n                                               .replace(/\"/gm, '&quot;')\n                                               .replace(/'/gm, '&#39;')\n                                               .replace(/</gm, '&lt;')\n                                               .replace(/>/gm, '&gt;')\n                                               .split('\\n') :\n                                           [''];\n    return this._constrain(this.tokens);\n  },\n\n  _updateCached: function() {\n    this.$.mirror.innerHTML = this._constrain(this.tokens);\n  }\n});\n","/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\nimport '@polymer/iron-autogrow-textarea/iron-autogrow-textarea.js';\nimport './paper-input-char-counter.js';\nimport './paper-input-container.js';\nimport './paper-input-error.js';\n\nimport {IronFormElementBehavior} from '@polymer/iron-form-element-behavior/iron-form-element-behavior.js';\nimport {Polymer} from '@polymer/polymer/lib/legacy/polymer-fn.js';\nimport {html} from '@polymer/polymer/lib/utils/html-tag.js';\n\nimport {PaperInputBehavior} from './paper-input-behavior.js';\n\n/*\n`<paper-textarea>` is a multi-line text field with Material Design styling.\n\n    <paper-textarea label=\"Textarea label\"></paper-textarea>\n\nSee `Polymer.PaperInputBehavior` for more API docs.\n\n### Validation\n\nCurrently only `required` and `maxlength` validation is supported.\n\n### Styling\n\nSee `Polymer.PaperInputContainer` for a list of custom properties used to\nstyle this element.\n*/\nPolymer({\n  _template: html`\n    <style>\n      :host {\n        display: block;\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      label {\n        pointer-events: none;\n      }\n    </style>\n\n    <paper-input-container no-label-float$=\"[[noLabelFloat]]\" always-float-label=\"[[_computeAlwaysFloatLabel(alwaysFloatLabel,placeholder)]]\" auto-validate$=\"[[autoValidate]]\" disabled$=\"[[disabled]]\" invalid=\"[[invalid]]\">\n\n      <label hidden$=\"[[!label]]\" aria-hidden=\"true\" for$=\"[[_inputId]]\" slot=\"label\">[[label]]</label>\n\n      <iron-autogrow-textarea class=\"paper-input-input\" slot=\"input\" id$=\"[[_inputId]]\" aria-labelledby$=\"[[_ariaLabelledBy]]\" aria-describedby$=\"[[_ariaDescribedBy]]\" bind-value=\"{{value}}\" invalid=\"{{invalid}}\" validator$=\"[[validator]]\" disabled$=\"[[disabled]]\" autocomplete$=\"[[autocomplete]]\" autofocus$=\"[[autofocus]]\" inputmode$=\"[[inputmode]]\" name$=\"[[name]]\" placeholder$=\"[[placeholder]]\" readonly$=\"[[readonly]]\" required$=\"[[required]]\" minlength$=\"[[minlength]]\" maxlength$=\"[[maxlength]]\" autocapitalize$=\"[[autocapitalize]]\" rows$=\"[[rows]]\" max-rows$=\"[[maxRows]]\" on-change=\"_onChange\"></iron-autogrow-textarea>\n\n      <template is=\"dom-if\" if=\"[[errorMessage]]\">\n        <paper-input-error aria-live=\"assertive\" slot=\"add-on\">[[errorMessage]]</paper-input-error>\n      </template>\n\n      <template is=\"dom-if\" if=\"[[charCounter]]\">\n        <paper-input-char-counter slot=\"add-on\"></paper-input-char-counter>\n      </template>\n\n    </paper-input-container>\n`,\n\n  is: 'paper-textarea',\n\n  behaviors: [\n    PaperInputBehavior,\n    IronFormElementBehavior,\n  ],\n\n  properties: {\n    _ariaLabelledBy: {\n      observer: '_ariaLabelledByChanged',\n      type: String,\n    },\n\n    _ariaDescribedBy: {\n      observer: '_ariaDescribedByChanged',\n      type: String,\n    },\n\n    value: {\n      // Required for the correct TypeScript type-generation\n      type: String,\n    },\n\n    /**\n     * The initial number of rows.\n     *\n     * @attribute rows\n     * @type {number}\n     * @default 1\n     */\n    rows: {\n      type: Number,\n      value: 1,\n    },\n\n    /**\n     * The maximum number of rows this element can grow to until it\n     * scrolls. 0 means no maximum.\n     *\n     * @attribute maxRows\n     * @type {number}\n     * @default 0\n     */\n    maxRows: {\n      type: Number,\n      value: 0,\n    },\n  },\n\n  /**\n   * @return {number}\n   */\n  get selectionStart() {\n    return this.$.input.textarea.selectionStart;\n  },\n\n  set selectionStart(start) {\n    this.$.input.textarea.selectionStart = start;\n  },\n\n  /**\n   * @return {number}\n   */\n  get selectionEnd() {\n    return this.$.input.textarea.selectionEnd;\n  },\n\n  set selectionEnd(end) {\n    this.$.input.textarea.selectionEnd = end;\n  },\n\n  _ariaLabelledByChanged: function(ariaLabelledBy) {\n    this._focusableElement.setAttribute('aria-labelledby', ariaLabelledBy);\n  },\n\n  _ariaDescribedByChanged: function(ariaDescribedBy) {\n    this._focusableElement.setAttribute('aria-describedby', ariaDescribedBy);\n  },\n\n  get _focusableElement() {\n    return this.inputElement.textarea;\n  }\n});\n"],"sourceRoot":""}