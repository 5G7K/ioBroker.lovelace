(self["webpackJsonp"] = self["webpackJsonp"] || []).push([["vendors~panel-calendar"],{

/***/ "./node_modules/@fullcalendar/common/main.css":
/*!****************************************************!*\
  !*** ./node_modules/@fullcalendar/common/main.css ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"\\n/* classes attached to <body> */\\n\\n.fc-not-allowed,\\n.fc-not-allowed .fc-event { /* override events' custom cursors */\\n  cursor: not-allowed;\\n}\\n\\n.fc-unselectable {\\n  user-select: none;\\n  -webkit-touch-callout: none;\\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\\n}\\n.fc {\\n  /* layout of immediate children */\\n  display: flex;\\n  flex-direction: column;\\n\\n  font-size: 1em\\n}\\n.fc,\\n  .fc *,\\n  .fc *:before,\\n  .fc *:after {\\n    box-sizing: border-box;\\n  }\\n.fc table {\\n    border-collapse: collapse;\\n    border-spacing: 0;\\n    font-size: 1em; /* normalize cross-browser */\\n  }\\n.fc th {\\n    text-align: center;\\n  }\\n.fc th,\\n  .fc td {\\n    vertical-align: top;\\n    padding: 0;\\n  }\\n.fc a[data-navlink] {\\n    cursor: pointer;\\n  }\\n.fc a[data-navlink]:hover {\\n    text-decoration: underline;\\n  }\\n.fc-direction-ltr {\\n  direction: ltr;\\n  text-align: left;\\n}\\n.fc-direction-rtl {\\n  direction: rtl;\\n  text-align: right;\\n}\\n.fc-theme-standard td,\\n  .fc-theme-standard th {\\n    border: 1px solid #ddd;\\n    border: 1px solid var(--fc-border-color, #ddd);\\n  }\\n/* for FF, which doesn't expand a 100% div within a table cell. use absolute positioning */\\n/* inner-wrappers are responsible for being absolute */\\n/* TODO: best place for this? */\\n.fc-liquid-hack td,\\n  .fc-liquid-hack th {\\n    position: relative;\\n  }\\n\\n@font-face {\\n  font-family: 'fcicons';\\n  src: url(\\\"data:application/x-font-ttf;charset=utf-8;base64,AAEAAAALAIAAAwAwT1MvMg8SBfAAAAC8AAAAYGNtYXAXVtKNAAABHAAAAFRnYXNwAAAAEAAAAXAAAAAIZ2x5ZgYydxIAAAF4AAAFNGhlYWQUJ7cIAAAGrAAAADZoaGVhB20DzAAABuQAAAAkaG10eCIABhQAAAcIAAAALGxvY2ED4AU6AAAHNAAAABhtYXhwAA8AjAAAB0wAAAAgbmFtZXsr690AAAdsAAABhnBvc3QAAwAAAAAI9AAAACAAAwPAAZAABQAAApkCzAAAAI8CmQLMAAAB6wAzAQkAAAAAAAAAAAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAABAAADpBgPA/8AAQAPAAEAAAAABAAAAAAAAAAAAAAAgAAAAAAADAAAAAwAAABwAAQADAAAAHAADAAEAAAAcAAQAOAAAAAoACAACAAIAAQAg6Qb//f//AAAAAAAg6QD//f//AAH/4xcEAAMAAQAAAAAAAAAAAAAAAQAB//8ADwABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAQAAAAAAAAAAAAIAADc5AQAAAAABAWIAjQKeAskAEwAAJSc3NjQnJiIHAQYUFwEWMjc2NCcCnuLiDQ0MJAz/AA0NAQAMJAwNDcni4gwjDQwM/wANIwz/AA0NDCMNAAAAAQFiAI0CngLJABMAACUBNjQnASYiBwYUHwEHBhQXFjI3AZ4BAA0N/wAMJAwNDeLiDQ0MJAyNAQAMIw0BAAwMDSMM4uINIwwNDQAAAAIA4gC3Ax4CngATACcAACUnNzY0JyYiDwEGFB8BFjI3NjQnISc3NjQnJiIPAQYUHwEWMjc2NCcB87e3DQ0MIw3VDQ3VDSMMDQ0BK7e3DQ0MJAzVDQ3VDCQMDQ3zuLcMJAwNDdUNIwzWDAwNIwy4twwkDA0N1Q0jDNYMDA0jDAAAAgDiALcDHgKeABMAJwAAJTc2NC8BJiIHBhQfAQcGFBcWMjchNzY0LwEmIgcGFB8BBwYUFxYyNwJJ1Q0N1Q0jDA0Nt7cNDQwjDf7V1Q0N1QwkDA0Nt7cNDQwkDLfWDCMN1Q0NDCQMt7gMIw0MDNYMIw3VDQ0MJAy3uAwjDQwMAAADAFUAAAOrA1UAMwBoAHcAABMiBgcOAQcOAQcOARURFBYXHgEXHgEXHgEzITI2Nz4BNz4BNz4BNRE0JicuAScuAScuASMFITIWFx4BFx4BFx4BFREUBgcOAQcOAQcOASMhIiYnLgEnLgEnLgE1ETQ2Nz4BNz4BNz4BMxMhMjY1NCYjISIGFRQWM9UNGAwLFQkJDgUFBQUFBQ4JCRULDBgNAlYNGAwLFQkJDgUFBQUFBQ4JCRULDBgN/aoCVgQIBAQHAwMFAQIBAQIBBQMDBwQECAT9qgQIBAQHAwMFAQIBAQIBBQMDBwQECASAAVYRGRkR/qoRGRkRA1UFBAUOCQkVDAsZDf2rDRkLDBUJCA4FBQUFBQUOCQgVDAsZDQJVDRkLDBUJCQ4FBAVVAgECBQMCBwQECAX9qwQJAwQHAwMFAQICAgIBBQMDBwQDCQQCVQUIBAQHAgMFAgEC/oAZEhEZGRESGQAAAAADAFUAAAOrA1UAMwBoAIkAABMiBgcOAQcOAQcOARURFBYXHgEXHgEXHgEzITI2Nz4BNz4BNz4BNRE0JicuAScuAScuASMFITIWFx4BFx4BFx4BFREUBgcOAQcOAQcOASMhIiYnLgEnLgEnLgE1ETQ2Nz4BNz4BNz4BMxMzFRQWMzI2PQEzMjY1NCYrATU0JiMiBh0BIyIGFRQWM9UNGAwLFQkJDgUFBQUFBQ4JCRULDBgNAlYNGAwLFQkJDgUFBQUFBQ4JCRULDBgN/aoCVgQIBAQHAwMFAQIBAQIBBQMDBwQECAT9qgQIBAQHAwMFAQIBAQIBBQMDBwQECASAgBkSEhmAERkZEYAZEhIZgBEZGREDVQUEBQ4JCRUMCxkN/asNGQsMFQkIDgUFBQUFBQ4JCBUMCxkNAlUNGQsMFQkJDgUEBVUCAQIFAwIHBAQIBf2rBAkDBAcDAwUBAgICAgEFAwMHBAMJBAJVBQgEBAcCAwUCAQL+gIASGRkSgBkSERmAEhkZEoAZERIZAAABAOIAjQMeAskAIAAAExcHBhQXFjI/ARcWMjc2NC8BNzY0JyYiDwEnJiIHBhQX4uLiDQ0MJAzi4gwkDA0N4uINDQwkDOLiDCQMDQ0CjeLiDSMMDQ3h4Q0NDCMN4uIMIw0MDOLiDAwNIwwAAAABAAAAAQAAa5n0y18PPPUACwQAAAAAANivOVsAAAAA2K85WwAAAAADqwNVAAAACAACAAAAAAAAAAEAAAPA/8AAAAQAAAAAAAOrAAEAAAAAAAAAAAAAAAAAAAALBAAAAAAAAAAAAAAAAgAAAAQAAWIEAAFiBAAA4gQAAOIEAABVBAAAVQQAAOIAAAAAAAoAFAAeAEQAagCqAOoBngJkApoAAQAAAAsAigADAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAA4ArgABAAAAAAABAAcAAAABAAAAAAACAAcAYAABAAAAAAADAAcANgABAAAAAAAEAAcAdQABAAAAAAAFAAsAFQABAAAAAAAGAAcASwABAAAAAAAKABoAigADAAEECQABAA4ABwADAAEECQACAA4AZwADAAEECQADAA4APQADAAEECQAEAA4AfAADAAEECQAFABYAIAADAAEECQAGAA4AUgADAAEECQAKADQApGZjaWNvbnMAZgBjAGkAYwBvAG4Ac1ZlcnNpb24gMS4wAFYAZQByAHMAaQBvAG4AIAAxAC4AMGZjaWNvbnMAZgBjAGkAYwBvAG4Ac2ZjaWNvbnMAZgBjAGkAYwBvAG4Ac1JlZ3VsYXIAUgBlAGcAdQBsAGEAcmZjaWNvbnMAZgBjAGkAYwBvAG4Ac0ZvbnQgZ2VuZXJhdGVkIGJ5IEljb01vb24uAEYAbwBuAHQAIABnAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAEkAYwBvAE0AbwBvAG4ALgAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\\\") format('truetype');\\n  font-weight: normal;\\n  font-style: normal;\\n}\\n\\n.fc-icon {\\n  /* added for fc */\\n  display: inline-block;\\n  width: 1em;\\n  height: 1em;\\n  text-align: center;\\n  user-select: none;\\n\\n  /* use !important to prevent issues with browser extensions that change fonts */\\n  font-family: 'fcicons' !important;\\n  speak: none;\\n  font-style: normal;\\n  font-weight: normal;\\n  font-variant: normal;\\n  text-transform: none;\\n  line-height: 1;\\n\\n  /* Better Font Rendering =========== */\\n  -webkit-font-smoothing: antialiased;\\n  -moz-osx-font-smoothing: grayscale;\\n}\\n\\n.fc-icon-chevron-left:before {\\n  content: \\\"\\\\e900\\\";\\n}\\n\\n.fc-icon-chevron-right:before {\\n  content: \\\"\\\\e901\\\";\\n}\\n\\n.fc-icon-chevrons-left:before {\\n  content: \\\"\\\\e902\\\";\\n}\\n\\n.fc-icon-chevrons-right:before {\\n  content: \\\"\\\\e903\\\";\\n}\\n\\n.fc-icon-minus-square:before {\\n  content: \\\"\\\\e904\\\";\\n}\\n\\n.fc-icon-plus-square:before {\\n  content: \\\"\\\\e905\\\";\\n}\\n\\n.fc-icon-x:before {\\n  content: \\\"\\\\e906\\\";\\n}\\n/*\\nLots taken from Flatly (MIT): https://bootswatch.com/4/flatly/bootstrap.css\\n\\nThese styles only apply when the standard-theme is activated.\\nWhen it's NOT activated, the fc-button classes won't even be in the DOM.\\n*/\\n.fc {\\n\\n  /* reset */\\n\\n}\\n.fc .fc-button {\\n    border-radius: 0;\\n    overflow: visible;\\n    text-transform: none;\\n    margin: 0;\\n    font-family: inherit;\\n    font-size: inherit;\\n    line-height: inherit;\\n  }\\n.fc .fc-button:focus {\\n    outline: 1px dotted;\\n    outline: 5px auto -webkit-focus-ring-color;\\n  }\\n.fc .fc-button {\\n    -webkit-appearance: button;\\n  }\\n.fc .fc-button:not(:disabled) {\\n    cursor: pointer;\\n  }\\n.fc .fc-button::-moz-focus-inner {\\n    padding: 0;\\n    border-style: none;\\n  }\\n.fc {\\n\\n  /* theme */\\n\\n}\\n.fc .fc-button {\\n    display: inline-block;\\n    font-weight: 400;\\n    text-align: center;\\n    vertical-align: middle;\\n    user-select: none;\\n    background-color: transparent;\\n    border: 1px solid transparent;\\n    padding: 0.4em 0.65em;\\n    font-size: 1em;\\n    line-height: 1.5;\\n    border-radius: 0.25em;\\n  }\\n.fc .fc-button:hover {\\n    text-decoration: none;\\n  }\\n.fc .fc-button:focus {\\n    outline: 0;\\n    box-shadow: 0 0 0 0.2rem rgba(44, 62, 80, 0.25);\\n  }\\n.fc .fc-button:disabled {\\n    opacity: 0.65;\\n  }\\n.fc {\\n\\n  /* \\\"primary\\\" coloring */\\n\\n}\\n.fc .fc-button-primary {\\n    color: #fff;\\n    color: var(--fc-button-text-color, #fff);\\n    background-color: #2C3E50;\\n    background-color: var(--fc-button-bg-color, #2C3E50);\\n    border-color: #2C3E50;\\n    border-color: var(--fc-button-border-color, #2C3E50);\\n  }\\n.fc .fc-button-primary:hover {\\n    color: #fff;\\n    color: var(--fc-button-text-color, #fff);\\n    background-color: #1e2b37;\\n    background-color: var(--fc-button-hover-bg-color, #1e2b37);\\n    border-color: #1a252f;\\n    border-color: var(--fc-button-hover-border-color, #1a252f);\\n  }\\n.fc .fc-button-primary:disabled { /* not DRY */\\n    color: #fff;\\n    color: var(--fc-button-text-color, #fff);\\n    background-color: #2C3E50;\\n    background-color: var(--fc-button-bg-color, #2C3E50);\\n    border-color: #2C3E50;\\n    border-color: var(--fc-button-border-color, #2C3E50); /* overrides :hover */\\n  }\\n.fc .fc-button-primary:focus {\\n    box-shadow: 0 0 0 0.2rem rgba(76, 91, 106, 0.5);\\n  }\\n.fc .fc-button-primary:not(:disabled):active,\\n  .fc .fc-button-primary:not(:disabled).fc-button-active {\\n    color: #fff;\\n    color: var(--fc-button-text-color, #fff);\\n    background-color: #1a252f;\\n    background-color: var(--fc-button-active-bg-color, #1a252f);\\n    border-color: #151e27;\\n    border-color: var(--fc-button-active-border-color, #151e27);\\n  }\\n.fc .fc-button-primary:not(:disabled):active:focus,\\n  .fc .fc-button-primary:not(:disabled).fc-button-active:focus {\\n    box-shadow: 0 0 0 0.2rem rgba(76, 91, 106, 0.5);\\n  }\\n.fc {\\n\\n  /* icons within buttons */\\n\\n}\\n.fc .fc-button .fc-icon {\\n    vertical-align: middle;\\n    font-size: 1.5em; /* bump up the size (but don't make it bigger than line-height of button, which is 1.5em also) */\\n  }\\n.fc .fc-button-group {\\n    position: relative;\\n    display: inline-flex;\\n    vertical-align: middle;\\n  }\\n.fc .fc-button-group > .fc-button {\\n    position: relative;\\n    flex: 1 1 auto;\\n  }\\n.fc .fc-button-group > .fc-button:hover {\\n    z-index: 1;\\n  }\\n.fc .fc-button-group > .fc-button:focus,\\n  .fc .fc-button-group > .fc-button:active,\\n  .fc .fc-button-group > .fc-button.fc-button-active {\\n    z-index: 1;\\n  }\\n.fc-direction-ltr .fc-button-group > .fc-button:not(:first-child) {\\n    margin-left: -1px;\\n    border-top-left-radius: 0;\\n    border-bottom-left-radius: 0;\\n  }\\n.fc-direction-ltr .fc-button-group > .fc-button:not(:last-child) {\\n    border-top-right-radius: 0;\\n    border-bottom-right-radius: 0;\\n  }\\n.fc-direction-rtl .fc-button-group > .fc-button:not(:first-child) {\\n    margin-right: -1px;\\n    border-top-right-radius: 0;\\n    border-bottom-right-radius: 0;\\n  }\\n.fc-direction-rtl .fc-button-group > .fc-button:not(:last-child) {\\n    border-top-left-radius: 0;\\n    border-bottom-left-radius: 0;\\n  }\\n.fc .fc-toolbar {\\n    display: flex;\\n    justify-content: space-between;\\n    align-items: center;\\n  }\\n.fc .fc-toolbar.fc-header-toolbar {\\n    margin-bottom: 1.5em;\\n  }\\n.fc .fc-toolbar.fc-footer-toolbar {\\n    margin-top: 1.5em;\\n  }\\n.fc .fc-toolbar-title {\\n    font-size: 1.75em;\\n    margin: 0;\\n  }\\n.fc-direction-ltr .fc-toolbar > * > :not(:first-child) {\\n    margin-left: .75em; /* space between */\\n  }\\n.fc-direction-rtl .fc-toolbar > * > :not(:first-child) {\\n    margin-right: .75em; /* space between */\\n  }\\n.fc-direction-rtl .fc-toolbar-ltr { /* when the toolbar-chunk positioning system is explicitly left-to-right */\\n    flex-direction: row-reverse;\\n  }\\n.fc .fc-scroller {\\n    -webkit-overflow-scrolling: touch;\\n    position: relative; /* for abs-positioned elements within */\\n  }\\n.fc .fc-scroller-liquid {\\n    height: 100%;\\n  }\\n.fc .fc-scroller-liquid-absolute {\\n    position: absolute;\\n    top: 0;\\n    right: 0;\\n    left: 0;\\n    bottom: 0;\\n  }\\n.fc .fc-scroller-harness {\\n    position: relative;\\n    overflow: hidden;\\n    direction: ltr;\\n      /* hack for chrome computing the scroller's right/left wrong for rtl. undone below... */\\n      /* TODO: demonstrate in codepen */\\n  }\\n.fc .fc-scroller-harness-liquid {\\n    height: 100%;\\n  }\\n.fc-direction-rtl .fc-scroller-harness > .fc-scroller { /* undo above hack */\\n    direction: rtl;\\n  }\\n.fc-theme-standard .fc-scrollgrid {\\n    border: 1px solid #ddd;\\n    border: 1px solid var(--fc-border-color, #ddd); /* bootstrap does this. match */\\n  }\\n.fc .fc-scrollgrid,\\n    .fc .fc-scrollgrid table { /* all tables (self included) */\\n      width: 100%; /* because tables don't normally do this */\\n      table-layout: fixed;\\n    }\\n.fc .fc-scrollgrid table { /* inner tables */\\n      border-top-style: hidden;\\n      border-left-style: hidden;\\n      border-right-style: hidden;\\n    }\\n.fc .fc-scrollgrid > tbody table,\\n    .fc .fc-scrollgrid > tfoot table {\\n      border-bottom-style: hidden; /* head keeps its bottom border tho */\\n    }\\n.fc .fc-scrollgrid {\\n\\n    border-collapse: separate;\\n    border-right-width: 0;\\n    border-bottom-width: 0\\n  }\\n.fc .fc-scrollgrid > * > tr > * {\\n      border-top-width: 0;\\n      border-left-width: 0;\\n    }\\n.fc .fc-scrollgrid > thead > tr > *,\\n    .fc .fc-scrollgrid > tfoot > tr > * {\\n      border-bottom-width: 0;\\n    }\\n.fc .fc-scrollgrid-liquid {\\n    height: 100%;\\n  }\\n.fc .fc-scrollgrid-section { /* a <tr> */\\n    height: 0\\n\\n  }\\n.fc .fc-scrollgrid-section > td {\\n      height: 0; /* needs a height so inner div within grow */\\n    }\\n.fc .fc-scrollgrid-section table {\\n      height: 1px;\\n        /* for most browsers, if a height isn't set on the table, can't do liquid-height within cells */\\n        /* serves as a min-height. harmless */\\n    }\\n.fc .fc-scrollgrid-section-liquid {\\n    height: auto\\n\\n  }\\n.fc .fc-scrollgrid-section-liquid > td {\\n      height: 100%; /* FF needs this instead of auto */\\n    }\\n.fc {\\n\\n  /* stickiness */\\n\\n}\\n.fc .fc-scrollgrid-section-sticky > * {\\n    background: #fff; /* TODO: var */\\n    position: sticky;\\n    z-index: 2; /* TODO: var */\\n    /* TODO: box-shadow when sticking */\\n  }\\n.fc .fc-scrollgrid > thead > .fc-scrollgrid-section-sticky > * {\\n    top: 0; /* because border-sharing causes a gap at the top */\\n      /* TODO: give safari -1. has bug */\\n  }\\n.fc .fc-scrollgrid > tfoot > .fc-scrollgrid-section-sticky > * {\\n    bottom: 0; /* known bug: bottom-stickiness doesn't work in safari */\\n  }\\n.fc .fc-scrollgrid-sticky-shim { /* for horizontal scrollbar */\\n    height: 1px; /* needs height to create scrollbars */\\n    margin-bottom: -1px;\\n  }\\n.fc .fc-sticky {\\n    position: sticky;\\n  }\\n.fc .fc-view-harness {\\n    flex-grow: 1; /* because this harness is WITHIN the .fc's flexbox */\\n    position: relative;\\n  }\\n.fc {\\n\\n  /* when the harness controls the height, make the view liquid */\\n\\n}\\n.fc .fc-view-harness-active > .fc-view {\\n    position: absolute;\\n    top: 0;\\n    right: 0;\\n    bottom: 0;\\n    left: 0;\\n  }\\n.fc .fc-col-header-cell-cushion {\\n    display: inline-block; /* x-browser for when sticky (when multi-tier header) */\\n    padding: 2px 4px;\\n  }\\n.fc .fc-bg-event,\\n  .fc .fc-non-business,\\n  .fc .fc-highlight {\\n    /* will always have a harness with position:relative/absolute, so absolutely expand */\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    right: 0;\\n    bottom: 0;\\n  }\\n.fc .fc-non-business {\\n    background: rgba(215, 215, 215, 0.3);\\n    background: var(--fc-non-business-color, rgba(215, 215, 215, 0.3));\\n  }\\n.fc .fc-bg-event {\\n    background: rgb(143, 223, 130);\\n    background: var(--fc-bg-event-color, rgb(143, 223, 130));\\n    opacity: 0.3;\\n    opacity: var(--fc-bg-event-opacity, 0.3)\\n  }\\n.fc .fc-bg-event .fc-event-title {\\n      margin: .5em;\\n      font-size: .85em;\\n      font-size: var(--fc-small-font-size, .85em);\\n      font-style: italic;\\n    }\\n.fc .fc-highlight {\\n    background: rgba(188, 232, 241, 0.3);\\n    background: var(--fc-highlight-color, rgba(188, 232, 241, 0.3));\\n  }\\n.fc .fc-day-today {\\n    background: rgba(255, 220, 40, 0.15);\\n    background: var(--fc-today-bg-color, rgba(255, 220, 40, 0.15)); /* for all themes. bootstrap didn't provide a good semi-transparent color for this */\\n  }\\n.fc .fc-cell-shaded,\\n  .fc .fc-day-disabled {\\n    background: rgba(208, 208, 208, 0.3);\\n    background: var(--fc-neutral-bg-color, rgba(208, 208, 208, 0.3));\\n  }\\n/* link resets */\\n/* ---------------------------------------------------------------------------------------------------- */\\na.fc-event {\\n  display: block;\\n}\\na.fc-event,\\na.fc-event:hover {\\n  text-decoration: none;\\n}\\n/* cursor */\\n.fc-event[href],\\n.fc-event.fc-event-draggable {\\n  cursor: pointer;\\n}\\n/* event text content */\\n/* ---------------------------------------------------------------------------------------------------- */\\n.fc-event .fc-event-main {\\n    position: relative;\\n    z-index: 2;\\n  }\\n/* dragging */\\n/* ---------------------------------------------------------------------------------------------------- */\\n.fc-event-dragging:not(.fc-event-selected) { /* MOUSE */\\n    opacity: 0.75;\\n  }\\n.fc-event-dragging.fc-event-selected { /* TOUCH */\\n    box-shadow: 0 2px 7px rgba(0, 0, 0, 0.3);\\n  }\\n/* resizing */\\n/* ---------------------------------------------------------------------------------------------------- */\\n/* (subclasses should hone positioning for touch and non-touch) */\\n.fc-event .fc-event-resizer {\\n    display: none;\\n    position: absolute;\\n    z-index: 4;\\n  }\\n.fc-event:hover, /* MOUSE */\\n.fc-event-selected { /* TOUCH */\\n\\n}\\n.fc-event:hover .fc-event-resizer, .fc-event-selected .fc-event-resizer {\\n    display: block;\\n  }\\n.fc-event-selected .fc-event-resizer {\\n    border-radius: 4px;\\n    border-radius: calc(var(--fc-event-resizer-dot-total-width, 8px) / 2);\\n    border-width: 1px;\\n    border-width: var(--fc-event-resizer-dot-border-width, 1px);\\n    width: 8px;\\n    width: var(--fc-event-resizer-dot-total-width, 8px);\\n    height: 8px;\\n    height: var(--fc-event-resizer-dot-total-width, 8px);\\n    border-style: solid;\\n    border-color: inherit;\\n    background: #fff;\\n    background: var(--fc-page-bg-color, #fff)\\n\\n    /* expand hit area */\\n\\n  }\\n.fc-event-selected .fc-event-resizer:before {\\n      content: '';\\n      position: absolute;\\n      top: -20px;\\n      left: -20px;\\n      right: -20px;\\n      bottom: -20px;\\n    }\\n/* selecting (always TOUCH) */\\n/* ---------------------------------------------------------------------------------------------------- */\\n.fc-event-selected {\\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2)\\n\\n  /* expand hit area (subclasses should expand) */\\n\\n}\\n.fc-event-selected:before {\\n    content: \\\"\\\";\\n    position: absolute;\\n    z-index: 3;\\n    top: 0;\\n    left: 0;\\n    right: 0;\\n    bottom: 0;\\n  }\\n.fc-event-selected {\\n\\n  /* dimmer effect */\\n\\n}\\n.fc-event-selected:after {\\n    content: \\\"\\\";\\n    background: rgba(0, 0, 0, 0.25);\\n    background: var(--fc-event-selected-overlay-color, rgba(0, 0, 0, 0.25));\\n    position: absolute;\\n    z-index: 1;\\n\\n    /* assume there's a border on all sides. overcome it. */\\n    /* sometimes there's NOT a border, in which case the dimmer will go over */\\n    /* an adjacent border, which looks fine. */\\n    top: -1px;\\n    left: -1px;\\n    right: -1px;\\n    bottom: -1px;\\n  }\\n/*\\nA HORIZONTAL event\\n*/\\n.fc-h-event { /* allowed to be top-level */\\n\\n  border: 1px solid #3788d8;\\n\\n  border: 1px solid var(--fc-event-bg-color, #3788d8);\\n  background-color: #3788d8;\\n  background-color: var(--fc-event-border-color, #3788d8)\\n\\n}\\n.fc-h-event .fc-event-main {\\n    color: #fff;\\n    color: var(--fc-event-text-color, #fff);\\n    display: flex;\\n  }\\n.fc-h-event .fc-event-title-frame { /* serves as a container for the sticky cushion */\\n    flex-grow: 1;\\n    flex-shrink: 1;\\n    min-width: 0; /* important for allowing to shrink all the way */\\n  }\\n.fc-h-event .fc-event-title {\\n    display: inline-block; /* need this to be sticky cross-browser */\\n    vertical-align: top; /* for not messing up line-height */\\n    left: 0;  /* for sticky */\\n    right: 0; /* for sticky */\\n    max-width: 100%; /* clip overflow on this element */\\n    overflow: hidden;\\n  }\\n.fc-h-event.fc-event-selected:before {\\n    /* expand hit area */\\n    top: -10px;\\n    bottom: -10px;\\n  }\\n/* adjust border and border-radius (if there is any) for non-start/end */\\n.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-start),\\n.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-end) {\\n  border-top-left-radius: 0;\\n  border-bottom-left-radius: 0;\\n  border-left-width: 0;\\n}\\n.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-end),\\n.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-start) {\\n  border-top-right-radius: 0;\\n  border-bottom-right-radius: 0;\\n  border-right-width: 0;\\n}\\n/* resizers */\\n.fc-h-event:not(.fc-event-selected) .fc-event-resizer {\\n  top: 0;\\n  bottom: 0;\\n  width: 8px;\\n  width: var(--fc-event-resizer-thickness, 8px);\\n}\\n.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start,\\n.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end {\\n  cursor: w-resize;\\n  left: -4px;\\n  left: calc(var(--fc-event-resizer-thickness, 8px) / -2);\\n}\\n.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end,\\n.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start {\\n  cursor: e-resize;\\n  right: -4px;\\n  right: calc(var(--fc-event-resizer-thickness, 8px) / -2);\\n}\\n/* resizers for TOUCH */\\n.fc-h-event.fc-event-selected .fc-event-resizer {\\n  top: 50%;\\n  margin-top: -4px;\\n  margin-top: calc(var(--fc-event-resizer-dot-total-width, 8px) / -2);\\n}\\n.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-start,\\n.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-end {\\n  left: -4px;\\n  left: calc(var(--fc-event-resizer-dot-total-width, 8px) / -2);\\n}\\n.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-end,\\n.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-start {\\n  right: -4px;\\n  right: calc(var(--fc-event-resizer-dot-total-width, 8px) / -2);\\n}\\n\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb21tb24vbWFpbi5jc3MuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb21tb24vbWFpbi5jc3M/M2QzZiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIlxcbi8qIGNsYXNzZXMgYXR0YWNoZWQgdG8gPGJvZHk+ICovXFxuXFxuLmZjLW5vdC1hbGxvd2VkLFxcbi5mYy1ub3QtYWxsb3dlZCAuZmMtZXZlbnQgeyAvKiBvdmVycmlkZSBldmVudHMnIGN1c3RvbSBjdXJzb3JzICovXFxuICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcbn1cXG5cXG4uZmMtdW5zZWxlY3RhYmxlIHtcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbiAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lO1xcbiAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApO1xcbn1cXG4uZmMge1xcbiAgLyogbGF5b3V0IG9mIGltbWVkaWF0ZSBjaGlsZHJlbiAqL1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuXFxuICBmb250LXNpemU6IDFlbVxcbn1cXG4uZmMsXFxuICAuZmMgKixcXG4gIC5mYyAqOmJlZm9yZSxcXG4gIC5mYyAqOmFmdGVyIHtcXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIH1cXG4uZmMgdGFibGUge1xcbiAgICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbiAgICBib3JkZXItc3BhY2luZzogMDtcXG4gICAgZm9udC1zaXplOiAxZW07IC8qIG5vcm1hbGl6ZSBjcm9zcy1icm93c2VyICovXFxuICB9XFxuLmZjIHRoIHtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgfVxcbi5mYyB0aCxcXG4gIC5mYyB0ZCB7XFxuICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7XFxuICAgIHBhZGRpbmc6IDA7XFxuICB9XFxuLmZjIGFbZGF0YS1uYXZsaW5rXSB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gIH1cXG4uZmMgYVtkYXRhLW5hdmxpbmtdOmhvdmVyIHtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxuICB9XFxuLmZjLWRpcmVjdGlvbi1sdHIge1xcbiAgZGlyZWN0aW9uOiBsdHI7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbn1cXG4uZmMtZGlyZWN0aW9uLXJ0bCB7XFxuICBkaXJlY3Rpb246IHJ0bDtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbn1cXG4uZmMtdGhlbWUtc3RhbmRhcmQgdGQsXFxuICAuZmMtdGhlbWUtc3RhbmRhcmQgdGgge1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjZGRkO1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1mYy1ib3JkZXItY29sb3IsICNkZGQpO1xcbiAgfVxcbi8qIGZvciBGRiwgd2hpY2ggZG9lc24ndCBleHBhbmQgYSAxMDAlIGRpdiB3aXRoaW4gYSB0YWJsZSBjZWxsLiB1c2UgYWJzb2x1dGUgcG9zaXRpb25pbmcgKi9cXG4vKiBpbm5lci13cmFwcGVycyBhcmUgcmVzcG9uc2libGUgZm9yIGJlaW5nIGFic29sdXRlICovXFxuLyogVE9ETzogYmVzdCBwbGFjZSBmb3IgdGhpcz8gKi9cXG4uZmMtbGlxdWlkLWhhY2sgdGQsXFxuICAuZmMtbGlxdWlkLWhhY2sgdGgge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB9XFxuXFxuQGZvbnQtZmFjZSB7XFxuICBmb250LWZhbWlseTogJ2ZjaWNvbnMnO1xcbiAgc3JjOiB1cmwoXFxcImRhdGE6YXBwbGljYXRpb24veC1mb250LXR0ZjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxBQUVBQUFBTEFJQUFBd0F3VDFNdk1nOFNCZkFBQUFDOEFBQUFZR050WVhBWFZ0S05BQUFCSEFBQUFGUm5ZWE53QUFBQUVBQUFBWEFBQUFBSVoyeDVaZ1l5ZHhJQUFBRjRBQUFGTkdobFlXUVVKN2NJQUFBR3JBQUFBRFpvYUdWaEIyMER6QUFBQnVRQUFBQWthRzEwZUNJQUJoUUFBQWNJQUFBQUxHeHZZMkVENEFVNkFBQUhOQUFBQUJodFlYaHdBQThBakFBQUIwd0FBQUFnYm1GdFpYc3I2OTBBQUFkc0FBQUJobkJ2YzNRQUF3QUFBQUFJOUFBQUFDQUFBd1BBQVpBQUJRQUFBcGtDekFBQUFJOENtUUxNQUFBQjZ3QXpBUWtBQUFBQUFBQUFBQUFBQUFBQUFBQUJFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFBQURwQmdQQS84QUFRQVBBQUVBQUFBQUJBQUFBQUFBQUFBQUFBQUFnQUFBQUFBQURBQUFBQXdBQUFCd0FBUUFEQUFBQUhBQURBQUVBQUFBY0FBUUFPQUFBQUFvQUNBQUNBQUlBQVFBZzZRYi8vZi8vQUFBQUFBQWc2UUQvL2YvL0FBSC80eGNFQUFNQUFRQUFBQUFBQUFBQUFBQUFBUUFCLy84QUR3QUJBQUFBQUFBQUFBQUFBZ0FBTnprQkFBQUFBQUVBQUFBQUFBQUFBQUFDQUFBM09RRUFBQUFBQVFBQUFBQUFBQUFBQUFJQUFEYzVBUUFBQUFBQkFXSUFqUUtlQXNrQUV3QUFKU2MzTmpRbkppSUhBUVlVRndFV01qYzJOQ2NDbnVMaURRME1KQXovQUEwTkFRQU1KQXdORGNuaTRnd2pEUXdNL3dBTkl3ei9BQTBORENNTkFBQUFBUUZpQUkwQ25nTEpBQk1BQUNVQk5qUW5BU1lpQndZVUh3RUhCaFFYRmpJM0FaNEJBQTBOL3dBTUpBd05EZUxpRFEwTUpBeU5BUUFNSXcwQkFBd01EU01NNHVJTkl3d05EUUFBQUFJQTRnQzNBeDRDbmdBVEFDY0FBQ1VuTnpZMEp5WWlEd0VHRkI4QkZqSTNOalFuSVNjM05qUW5KaUlQQVFZVUh3RVdNamMyTkNjQjg3ZTNEUTBNSXczVkRRM1ZEU01NRFEwQks3ZTNEUTBNSkF6VkRRM1ZEQ1FNRFEzenVMY01KQXdORGRVTkl3eldEQXdOSXd5NHR3d2tEQTBOMVEwakROWU1EQTBqREFBQUFnRGlBTGNESGdLZUFCTUFKd0FBSlRjMk5DOEJKaUlIQmhRZkFRY0dGQmNXTWpjaE56WTBMd0VtSWdjR0ZCOEJCd1lVRnhZeU53SkoxUTBOMVEwakRBME50N2NORFF3akRmN1YxUTBOMVF3a0RBME50N2NORFF3a0RMZldEQ01OMVEwTkRDUU10N2dNSXcwTUROWU1JdzNWRFEwTUpBeTN1QXdqRFF3TUFBQURBRlVBQUFPckExVUFNd0JvQUhjQUFCTWlCZ2NPQVFjT0FRY09BUlVSRkJZWEhnRVhIZ0VYSGdFeklUSTJOejRCTno0Qk56NEJOUkUwSmljdUFTY3VBU2N1QVNNRklUSVdGeDRCRng0QkZ4NEJGUkVVQmdjT0FRY09BUWNPQVNNaElpWW5MZ0VuTGdFbkxnRTFFVFEyTno0Qk56NEJOejRCTXhNaE1qWTFOQ1lqSVNJR0ZSUVdNOVVOR0F3TEZRa0pEZ1VGQlFVRkJRNEpDUlVMREJnTkFsWU5HQXdMRlFrSkRnVUZCUVVGQlE0SkNSVUxEQmdOL2FvQ1ZnUUlCQVFIQXdNRkFRSUJBUUlCQlFNREJ3UUVDQVQ5cWdRSUJBUUhBd01GQVFJQkFRSUJCUU1EQndRRUNBU0FBVllSR1JrUi9xb1JHUmtSQTFVRkJBVU9DUWtWREFzWkRmMnJEUmtMREJVSkNBNEZCUVVGQlFVT0NRZ1ZEQXNaRFFKVkRSa0xEQlVKQ1E0RkJBVlZBZ0VDQlFNQ0J3UUVDQVg5cXdRSkF3UUhBd01GQVFJQ0FnSUJCUU1EQndRRENRUUNWUVVJQkFRSEFnTUZBZ0VDL29BWkVoRVpHUkVTR1FBQUFBQURBRlVBQUFPckExVUFNd0JvQUlrQUFCTWlCZ2NPQVFjT0FRY09BUlVSRkJZWEhnRVhIZ0VYSGdFeklUSTJOejRCTno0Qk56NEJOUkUwSmljdUFTY3VBU2N1QVNNRklUSVdGeDRCRng0QkZ4NEJGUkVVQmdjT0FRY09BUWNPQVNNaElpWW5MZ0VuTGdFbkxnRTFFVFEyTno0Qk56NEJOejRCTXhNekZSUVdNekkyUFFFek1qWTFOQ1lyQVRVMEppTWlCaDBCSXlJR0ZSUVdNOVVOR0F3TEZRa0pEZ1VGQlFVRkJRNEpDUlVMREJnTkFsWU5HQXdMRlFrSkRnVUZCUVVGQlE0SkNSVUxEQmdOL2FvQ1ZnUUlCQVFIQXdNRkFRSUJBUUlCQlFNREJ3UUVDQVQ5cWdRSUJBUUhBd01GQVFJQkFRSUJCUU1EQndRRUNBU0FnQmtTRWhtQUVSa1pFWUFaRWhJWmdCRVpHUkVEVlFVRUJRNEpDUlVNQ3hrTi9hc05HUXNNRlFrSURnVUZCUVVGQlE0SkNCVU1DeGtOQWxVTkdRc01GUWtKRGdVRUJWVUNBUUlGQXdJSEJBUUlCZjJyQkFrREJBY0RBd1VCQWdJQ0FnRUZBd01IQkFNSkJBSlZCUWdFQkFjQ0F3VUNBUUwrZ0lBU0dSa1NnQmtTRVJtQUVoa1pFb0FaRVJJWkFBQUJBT0lBalFNZUFza0FJQUFBRXhjSEJoUVhGakkvQVJjV01qYzJOQzhCTnpZMEp5WWlEd0VuSmlJSEJoUVg0dUxpRFEwTUpBemk0Z3drREEwTjR1SU5EUXdrRE9MaURDUU1EUTBDamVMaURTTU1EUTNoNFEwTkRDTU40dUlNSXcwTURPTGlEQXdOSXd3QUFBQUJBQUFBQVFBQWE1bjB5MThQUFBVQUN3UUFBQUFBQU5pdk9Wc0FBQUFBMks4NVd3QUFBQUFEcXdOVkFBQUFDQUFDQUFBQUFBQUFBQUVBQUFQQS84QUFBQVFBQUFBQUFBT3JBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUxCQUFBQUFBQUFBQUFBQUFBQWdBQUFBUUFBV0lFQUFGaUJBQUE0Z1FBQU9JRUFBQlZCQUFBVlFRQUFPSUFBQUFBQUFvQUZBQWVBRVFBYWdDcUFPb0JuZ0prQXBvQUFRQUFBQXNBaWdBREFBQUFBQUFDQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUE0QXJnQUJBQUFBQUFBQkFBY0FBQUFCQUFBQUFBQUNBQWNBWUFBQkFBQUFBQUFEQUFjQU5nQUJBQUFBQUFBRUFBY0FkUUFCQUFBQUFBQUZBQXNBRlFBQkFBQUFBQUFHQUFjQVN3QUJBQUFBQUFBS0FCb0FpZ0FEQUFFRUNRQUJBQTRBQndBREFBRUVDUUFDQUE0QVp3QURBQUVFQ1FBREFBNEFQUUFEQUFFRUNRQUVBQTRBZkFBREFBRUVDUUFGQUJZQUlBQURBQUVFQ1FBR0FBNEFVZ0FEQUFFRUNRQUtBRFFBcEdaamFXTnZibk1BWmdCakFHa0FZd0J2QUc0QWMxWmxjbk5wYjI0Z01TNHdBRllBWlFCeUFITUFhUUJ2QUc0QUlBQXhBQzRBTUdaamFXTnZibk1BWmdCakFHa0FZd0J2QUc0QWMyWmphV052Ym5NQVpnQmpBR2tBWXdCdkFHNEFjMUpsWjNWc1lYSUFVZ0JsQUdjQWRRQnNBR0VBY21aamFXTnZibk1BWmdCakFHa0FZd0J2QUc0QWMwWnZiblFnWjJWdVpYSmhkR1ZrSUdKNUlFbGpiMDF2YjI0dUFFWUFid0J1QUhRQUlBQm5BR1VBYmdCbEFISUFZUUIwQUdVQVpBQWdBR0lBZVFBZ0FFa0FZd0J2QUUwQWJ3QnZBRzRBTGdBQUFBTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUE9XFxcIikgZm9ybWF0KCd0cnVldHlwZScpO1xcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG59XFxuXFxuLmZjLWljb24ge1xcbiAgLyogYWRkZWQgZm9yIGZjICovXFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB3aWR0aDogMWVtO1xcbiAgaGVpZ2h0OiAxZW07XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG5cXG4gIC8qIHVzZSAhaW1wb3J0YW50IHRvIHByZXZlbnQgaXNzdWVzIHdpdGggYnJvd3NlciBleHRlbnNpb25zIHRoYXQgY2hhbmdlIGZvbnRzICovXFxuICBmb250LWZhbWlseTogJ2ZjaWNvbnMnICFpbXBvcnRhbnQ7XFxuICBzcGVhazogbm9uZTtcXG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuICBmb250LXZhcmlhbnQ6IG5vcm1hbDtcXG4gIHRleHQtdHJhbnNmb3JtOiBub25lO1xcbiAgbGluZS1oZWlnaHQ6IDE7XFxuXFxuICAvKiBCZXR0ZXIgRm9udCBSZW5kZXJpbmcgPT09PT09PT09PT0gKi9cXG4gIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xcbiAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGdyYXlzY2FsZTtcXG59XFxuXFxuLmZjLWljb24tY2hldnJvbi1sZWZ0OmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwiXFxcXGU5MDBcXFwiO1xcbn1cXG5cXG4uZmMtaWNvbi1jaGV2cm9uLXJpZ2h0OmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwiXFxcXGU5MDFcXFwiO1xcbn1cXG5cXG4uZmMtaWNvbi1jaGV2cm9ucy1sZWZ0OmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwiXFxcXGU5MDJcXFwiO1xcbn1cXG5cXG4uZmMtaWNvbi1jaGV2cm9ucy1yaWdodDpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIlxcXFxlOTAzXFxcIjtcXG59XFxuXFxuLmZjLWljb24tbWludXMtc3F1YXJlOmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwiXFxcXGU5MDRcXFwiO1xcbn1cXG5cXG4uZmMtaWNvbi1wbHVzLXNxdWFyZTpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIlxcXFxlOTA1XFxcIjtcXG59XFxuXFxuLmZjLWljb24teDpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIlxcXFxlOTA2XFxcIjtcXG59XFxuLypcXG5Mb3RzIHRha2VuIGZyb20gRmxhdGx5IChNSVQpOiBodHRwczovL2Jvb3Rzd2F0Y2guY29tLzQvZmxhdGx5L2Jvb3RzdHJhcC5jc3NcXG5cXG5UaGVzZSBzdHlsZXMgb25seSBhcHBseSB3aGVuIHRoZSBzdGFuZGFyZC10aGVtZSBpcyBhY3RpdmF0ZWQuXFxuV2hlbiBpdCdzIE5PVCBhY3RpdmF0ZWQsIHRoZSBmYy1idXR0b24gY2xhc3NlcyB3b24ndCBldmVuIGJlIGluIHRoZSBET00uXFxuKi9cXG4uZmMge1xcblxcbiAgLyogcmVzZXQgKi9cXG5cXG59XFxuLmZjIC5mYy1idXR0b24ge1xcbiAgICBib3JkZXItcmFkaXVzOiAwO1xcbiAgICBvdmVyZmxvdzogdmlzaWJsZTtcXG4gICAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgZm9udC1mYW1pbHk6IGluaGVyaXQ7XFxuICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcXG4gICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XFxuICB9XFxuLmZjIC5mYy1idXR0b246Zm9jdXMge1xcbiAgICBvdXRsaW5lOiAxcHggZG90dGVkO1xcbiAgICBvdXRsaW5lOiA1cHggYXV0byAtd2Via2l0LWZvY3VzLXJpbmctY29sb3I7XFxuICB9XFxuLmZjIC5mYy1idXR0b24ge1xcbiAgICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjtcXG4gIH1cXG4uZmMgLmZjLWJ1dHRvbjpub3QoOmRpc2FibGVkKSB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gIH1cXG4uZmMgLmZjLWJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lciB7XFxuICAgIHBhZGRpbmc6IDA7XFxuICAgIGJvcmRlci1zdHlsZTogbm9uZTtcXG4gIH1cXG4uZmMge1xcblxcbiAgLyogdGhlbWUgKi9cXG5cXG59XFxuLmZjIC5mYy1idXR0b24ge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIGZvbnQtd2VpZ2h0OiA0MDA7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcXG4gICAgcGFkZGluZzogMC40ZW0gMC42NWVtO1xcbiAgICBmb250LXNpemU6IDFlbTtcXG4gICAgbGluZS1oZWlnaHQ6IDEuNTtcXG4gICAgYm9yZGVyLXJhZGl1czogMC4yNWVtO1xcbiAgfVxcbi5mYyAuZmMtYnV0dG9uOmhvdmVyIHtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgfVxcbi5mYyAuZmMtYnV0dG9uOmZvY3VzIHtcXG4gICAgb3V0bGluZTogMDtcXG4gICAgYm94LXNoYWRvdzogMCAwIDAgMC4ycmVtIHJnYmEoNDQsIDYyLCA4MCwgMC4yNSk7XFxuICB9XFxuLmZjIC5mYy1idXR0b246ZGlzYWJsZWQge1xcbiAgICBvcGFjaXR5OiAwLjY1O1xcbiAgfVxcbi5mYyB7XFxuXFxuICAvKiBcXFwicHJpbWFyeVxcXCIgY29sb3JpbmcgKi9cXG5cXG59XFxuLmZjIC5mYy1idXR0b24tcHJpbWFyeSB7XFxuICAgIGNvbG9yOiAjZmZmO1xcbiAgICBjb2xvcjogdmFyKC0tZmMtYnV0dG9uLXRleHQtY29sb3IsICNmZmYpO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMkMzRTUwO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1mYy1idXR0b24tYmctY29sb3IsICMyQzNFNTApO1xcbiAgICBib3JkZXItY29sb3I6ICMyQzNFNTA7XFxuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tZmMtYnV0dG9uLWJvcmRlci1jb2xvciwgIzJDM0U1MCk7XFxuICB9XFxuLmZjIC5mYy1idXR0b24tcHJpbWFyeTpob3ZlciB7XFxuICAgIGNvbG9yOiAjZmZmO1xcbiAgICBjb2xvcjogdmFyKC0tZmMtYnV0dG9uLXRleHQtY29sb3IsICNmZmYpO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMWUyYjM3O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1mYy1idXR0b24taG92ZXItYmctY29sb3IsICMxZTJiMzcpO1xcbiAgICBib3JkZXItY29sb3I6ICMxYTI1MmY7XFxuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tZmMtYnV0dG9uLWhvdmVyLWJvcmRlci1jb2xvciwgIzFhMjUyZik7XFxuICB9XFxuLmZjIC5mYy1idXR0b24tcHJpbWFyeTpkaXNhYmxlZCB7IC8qIG5vdCBEUlkgKi9cXG4gICAgY29sb3I6ICNmZmY7XFxuICAgIGNvbG9yOiB2YXIoLS1mYy1idXR0b24tdGV4dC1jb2xvciwgI2ZmZik7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMyQzNFNTA7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWZjLWJ1dHRvbi1iZy1jb2xvciwgIzJDM0U1MCk7XFxuICAgIGJvcmRlci1jb2xvcjogIzJDM0U1MDtcXG4gICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1mYy1idXR0b24tYm9yZGVyLWNvbG9yLCAjMkMzRTUwKTsgLyogb3ZlcnJpZGVzIDpob3ZlciAqL1xcbiAgfVxcbi5mYyAuZmMtYnV0dG9uLXByaW1hcnk6Zm9jdXMge1xcbiAgICBib3gtc2hhZG93OiAwIDAgMCAwLjJyZW0gcmdiYSg3NiwgOTEsIDEwNiwgMC41KTtcXG4gIH1cXG4uZmMgLmZjLWJ1dHRvbi1wcmltYXJ5Om5vdCg6ZGlzYWJsZWQpOmFjdGl2ZSxcXG4gIC5mYyAuZmMtYnV0dG9uLXByaW1hcnk6bm90KDpkaXNhYmxlZCkuZmMtYnV0dG9uLWFjdGl2ZSB7XFxuICAgIGNvbG9yOiAjZmZmO1xcbiAgICBjb2xvcjogdmFyKC0tZmMtYnV0dG9uLXRleHQtY29sb3IsICNmZmYpO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMWEyNTJmO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1mYy1idXR0b24tYWN0aXZlLWJnLWNvbG9yLCAjMWEyNTJmKTtcXG4gICAgYm9yZGVyLWNvbG9yOiAjMTUxZTI3O1xcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWZjLWJ1dHRvbi1hY3RpdmUtYm9yZGVyLWNvbG9yLCAjMTUxZTI3KTtcXG4gIH1cXG4uZmMgLmZjLWJ1dHRvbi1wcmltYXJ5Om5vdCg6ZGlzYWJsZWQpOmFjdGl2ZTpmb2N1cyxcXG4gIC5mYyAuZmMtYnV0dG9uLXByaW1hcnk6bm90KDpkaXNhYmxlZCkuZmMtYnV0dG9uLWFjdGl2ZTpmb2N1cyB7XFxuICAgIGJveC1zaGFkb3c6IDAgMCAwIDAuMnJlbSByZ2JhKDc2LCA5MSwgMTA2LCAwLjUpO1xcbiAgfVxcbi5mYyB7XFxuXFxuICAvKiBpY29ucyB3aXRoaW4gYnV0dG9ucyAqL1xcblxcbn1cXG4uZmMgLmZjLWJ1dHRvbiAuZmMtaWNvbiB7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgIGZvbnQtc2l6ZTogMS41ZW07IC8qIGJ1bXAgdXAgdGhlIHNpemUgKGJ1dCBkb24ndCBtYWtlIGl0IGJpZ2dlciB0aGFuIGxpbmUtaGVpZ2h0IG9mIGJ1dHRvbiwgd2hpY2ggaXMgMS41ZW0gYWxzbykgKi9cXG4gIH1cXG4uZmMgLmZjLWJ1dHRvbi1ncm91cCB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgZGlzcGxheTogaW5saW5lLWZsZXg7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICB9XFxuLmZjIC5mYy1idXR0b24tZ3JvdXAgPiAuZmMtYnV0dG9uIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBmbGV4OiAxIDEgYXV0bztcXG4gIH1cXG4uZmMgLmZjLWJ1dHRvbi1ncm91cCA+IC5mYy1idXR0b246aG92ZXIge1xcbiAgICB6LWluZGV4OiAxO1xcbiAgfVxcbi5mYyAuZmMtYnV0dG9uLWdyb3VwID4gLmZjLWJ1dHRvbjpmb2N1cyxcXG4gIC5mYyAuZmMtYnV0dG9uLWdyb3VwID4gLmZjLWJ1dHRvbjphY3RpdmUsXFxuICAuZmMgLmZjLWJ1dHRvbi1ncm91cCA+IC5mYy1idXR0b24uZmMtYnV0dG9uLWFjdGl2ZSB7XFxuICAgIHotaW5kZXg6IDE7XFxuICB9XFxuLmZjLWRpcmVjdGlvbi1sdHIgLmZjLWJ1dHRvbi1ncm91cCA+IC5mYy1idXR0b246bm90KDpmaXJzdC1jaGlsZCkge1xcbiAgICBtYXJnaW4tbGVmdDogLTFweDtcXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMDtcXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMDtcXG4gIH1cXG4uZmMtZGlyZWN0aW9uLWx0ciAuZmMtYnV0dG9uLWdyb3VwID4gLmZjLWJ1dHRvbjpub3QoOmxhc3QtY2hpbGQpIHtcXG4gICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDA7XFxuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAwO1xcbiAgfVxcbi5mYy1kaXJlY3Rpb24tcnRsIC5mYy1idXR0b24tZ3JvdXAgPiAuZmMtYnV0dG9uOm5vdCg6Zmlyc3QtY2hpbGQpIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtMXB4O1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMDtcXG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDA7XFxuICB9XFxuLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWJ1dHRvbi1ncm91cCA+IC5mYy1idXR0b246bm90KDpsYXN0LWNoaWxkKSB7XFxuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDA7XFxuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDA7XFxuICB9XFxuLmZjIC5mYy10b29sYmFyIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgfVxcbi5mYyAuZmMtdG9vbGJhci5mYy1oZWFkZXItdG9vbGJhciB7XFxuICAgIG1hcmdpbi1ib3R0b206IDEuNWVtO1xcbiAgfVxcbi5mYyAuZmMtdG9vbGJhci5mYy1mb290ZXItdG9vbGJhciB7XFxuICAgIG1hcmdpbi10b3A6IDEuNWVtO1xcbiAgfVxcbi5mYyAuZmMtdG9vbGJhci10aXRsZSB7XFxuICAgIGZvbnQtc2l6ZTogMS43NWVtO1xcbiAgICBtYXJnaW46IDA7XFxuICB9XFxuLmZjLWRpcmVjdGlvbi1sdHIgLmZjLXRvb2xiYXIgPiAqID4gOm5vdCg6Zmlyc3QtY2hpbGQpIHtcXG4gICAgbWFyZ2luLWxlZnQ6IC43NWVtOyAvKiBzcGFjZSBiZXR3ZWVuICovXFxuICB9XFxuLmZjLWRpcmVjdGlvbi1ydGwgLmZjLXRvb2xiYXIgPiAqID4gOm5vdCg6Zmlyc3QtY2hpbGQpIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAuNzVlbTsgLyogc3BhY2UgYmV0d2VlbiAqL1xcbiAgfVxcbi5mYy1kaXJlY3Rpb24tcnRsIC5mYy10b29sYmFyLWx0ciB7IC8qIHdoZW4gdGhlIHRvb2xiYXItY2h1bmsgcG9zaXRpb25pbmcgc3lzdGVtIGlzIGV4cGxpY2l0bHkgbGVmdC10by1yaWdodCAqL1xcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93LXJldmVyc2U7XFxuICB9XFxuLmZjIC5mYy1zY3JvbGxlciB7XFxuICAgIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaDtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlOyAvKiBmb3IgYWJzLXBvc2l0aW9uZWQgZWxlbWVudHMgd2l0aGluICovXFxuICB9XFxuLmZjIC5mYy1zY3JvbGxlci1saXF1aWQge1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICB9XFxuLmZjIC5mYy1zY3JvbGxlci1saXF1aWQtYWJzb2x1dGUge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gIH1cXG4uZmMgLmZjLXNjcm9sbGVyLWhhcm5lc3Mge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgIGRpcmVjdGlvbjogbHRyO1xcbiAgICAgIC8qIGhhY2sgZm9yIGNocm9tZSBjb21wdXRpbmcgdGhlIHNjcm9sbGVyJ3MgcmlnaHQvbGVmdCB3cm9uZyBmb3IgcnRsLiB1bmRvbmUgYmVsb3cuLi4gKi9cXG4gICAgICAvKiBUT0RPOiBkZW1vbnN0cmF0ZSBpbiBjb2RlcGVuICovXFxuICB9XFxuLmZjIC5mYy1zY3JvbGxlci1oYXJuZXNzLWxpcXVpZCB7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gIH1cXG4uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtc2Nyb2xsZXItaGFybmVzcyA+IC5mYy1zY3JvbGxlciB7IC8qIHVuZG8gYWJvdmUgaGFjayAqL1xcbiAgICBkaXJlY3Rpb246IHJ0bDtcXG4gIH1cXG4uZmMtdGhlbWUtc3RhbmRhcmQgLmZjLXNjcm9sbGdyaWQge1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjZGRkO1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1mYy1ib3JkZXItY29sb3IsICNkZGQpOyAvKiBib290c3RyYXAgZG9lcyB0aGlzLiBtYXRjaCAqL1xcbiAgfVxcbi5mYyAuZmMtc2Nyb2xsZ3JpZCxcXG4gICAgLmZjIC5mYy1zY3JvbGxncmlkIHRhYmxlIHsgLyogYWxsIHRhYmxlcyAoc2VsZiBpbmNsdWRlZCkgKi9cXG4gICAgICB3aWR0aDogMTAwJTsgLyogYmVjYXVzZSB0YWJsZXMgZG9uJ3Qgbm9ybWFsbHkgZG8gdGhpcyAqL1xcbiAgICAgIHRhYmxlLWxheW91dDogZml4ZWQ7XFxuICAgIH1cXG4uZmMgLmZjLXNjcm9sbGdyaWQgdGFibGUgeyAvKiBpbm5lciB0YWJsZXMgKi9cXG4gICAgICBib3JkZXItdG9wLXN0eWxlOiBoaWRkZW47XFxuICAgICAgYm9yZGVyLWxlZnQtc3R5bGU6IGhpZGRlbjtcXG4gICAgICBib3JkZXItcmlnaHQtc3R5bGU6IGhpZGRlbjtcXG4gICAgfVxcbi5mYyAuZmMtc2Nyb2xsZ3JpZCA+IHRib2R5IHRhYmxlLFxcbiAgICAuZmMgLmZjLXNjcm9sbGdyaWQgPiB0Zm9vdCB0YWJsZSB7XFxuICAgICAgYm9yZGVyLWJvdHRvbS1zdHlsZTogaGlkZGVuOyAvKiBoZWFkIGtlZXBzIGl0cyBib3R0b20gYm9yZGVyIHRobyAqL1xcbiAgICB9XFxuLmZjIC5mYy1zY3JvbGxncmlkIHtcXG5cXG4gICAgYm9yZGVyLWNvbGxhcHNlOiBzZXBhcmF0ZTtcXG4gICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAwO1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiAwXFxuICB9XFxuLmZjIC5mYy1zY3JvbGxncmlkID4gKiA+IHRyID4gKiB7XFxuICAgICAgYm9yZGVyLXRvcC13aWR0aDogMDtcXG4gICAgICBib3JkZXItbGVmdC13aWR0aDogMDtcXG4gICAgfVxcbi5mYyAuZmMtc2Nyb2xsZ3JpZCA+IHRoZWFkID4gdHIgPiAqLFxcbiAgICAuZmMgLmZjLXNjcm9sbGdyaWQgPiB0Zm9vdCA+IHRyID4gKiB7XFxuICAgICAgYm9yZGVyLWJvdHRvbS13aWR0aDogMDtcXG4gICAgfVxcbi5mYyAuZmMtc2Nyb2xsZ3JpZC1saXF1aWQge1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICB9XFxuLmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24geyAvKiBhIDx0cj4gKi9cXG4gICAgaGVpZ2h0OiAwXFxuXFxuICB9XFxuLmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24gPiB0ZCB7XFxuICAgICAgaGVpZ2h0OiAwOyAvKiBuZWVkcyBhIGhlaWdodCBzbyBpbm5lciBkaXYgd2l0aGluIGdyb3cgKi9cXG4gICAgfVxcbi5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uIHRhYmxlIHtcXG4gICAgICBoZWlnaHQ6IDFweDtcXG4gICAgICAgIC8qIGZvciBtb3N0IGJyb3dzZXJzLCBpZiBhIGhlaWdodCBpc24ndCBzZXQgb24gdGhlIHRhYmxlLCBjYW4ndCBkbyBsaXF1aWQtaGVpZ2h0IHdpdGhpbiBjZWxscyAqL1xcbiAgICAgICAgLyogc2VydmVzIGFzIGEgbWluLWhlaWdodC4gaGFybWxlc3MgKi9cXG4gICAgfVxcbi5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWxpcXVpZCB7XFxuICAgIGhlaWdodDogYXV0b1xcblxcbiAgfVxcbi5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWxpcXVpZCA+IHRkIHtcXG4gICAgICBoZWlnaHQ6IDEwMCU7IC8qIEZGIG5lZWRzIHRoaXMgaW5zdGVhZCBvZiBhdXRvICovXFxuICAgIH1cXG4uZmMge1xcblxcbiAgLyogc3RpY2tpbmVzcyAqL1xcblxcbn1cXG4uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbi1zdGlja3kgPiAqIHtcXG4gICAgYmFja2dyb3VuZDogI2ZmZjsgLyogVE9ETzogdmFyICovXFxuICAgIHBvc2l0aW9uOiBzdGlja3k7XFxuICAgIHotaW5kZXg6IDI7IC8qIFRPRE86IHZhciAqL1xcbiAgICAvKiBUT0RPOiBib3gtc2hhZG93IHdoZW4gc3RpY2tpbmcgKi9cXG4gIH1cXG4uZmMgLmZjLXNjcm9sbGdyaWQgPiB0aGVhZCA+IC5mYy1zY3JvbGxncmlkLXNlY3Rpb24tc3RpY2t5ID4gKiB7XFxuICAgIHRvcDogMDsgLyogYmVjYXVzZSBib3JkZXItc2hhcmluZyBjYXVzZXMgYSBnYXAgYXQgdGhlIHRvcCAqL1xcbiAgICAgIC8qIFRPRE86IGdpdmUgc2FmYXJpIC0xLiBoYXMgYnVnICovXFxuICB9XFxuLmZjIC5mYy1zY3JvbGxncmlkID4gdGZvb3QgPiAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLXN0aWNreSA+ICoge1xcbiAgICBib3R0b206IDA7IC8qIGtub3duIGJ1ZzogYm90dG9tLXN0aWNraW5lc3MgZG9lc24ndCB3b3JrIGluIHNhZmFyaSAqL1xcbiAgfVxcbi5mYyAuZmMtc2Nyb2xsZ3JpZC1zdGlja3ktc2hpbSB7IC8qIGZvciBob3Jpem9udGFsIHNjcm9sbGJhciAqL1xcbiAgICBoZWlnaHQ6IDFweDsgLyogbmVlZHMgaGVpZ2h0IHRvIGNyZWF0ZSBzY3JvbGxiYXJzICovXFxuICAgIG1hcmdpbi1ib3R0b206IC0xcHg7XFxuICB9XFxuLmZjIC5mYy1zdGlja3kge1xcbiAgICBwb3NpdGlvbjogc3RpY2t5O1xcbiAgfVxcbi5mYyAuZmMtdmlldy1oYXJuZXNzIHtcXG4gICAgZmxleC1ncm93OiAxOyAvKiBiZWNhdXNlIHRoaXMgaGFybmVzcyBpcyBXSVRISU4gdGhlIC5mYydzIGZsZXhib3ggKi9cXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgfVxcbi5mYyB7XFxuXFxuICAvKiB3aGVuIHRoZSBoYXJuZXNzIGNvbnRyb2xzIHRoZSBoZWlnaHQsIG1ha2UgdGhlIHZpZXcgbGlxdWlkICovXFxuXFxufVxcbi5mYyAuZmMtdmlldy1oYXJuZXNzLWFjdGl2ZSA+IC5mYy12aWV3IHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDA7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICBib3R0b206IDA7XFxuICAgIGxlZnQ6IDA7XFxuICB9XFxuLmZjIC5mYy1jb2wtaGVhZGVyLWNlbGwtY3VzaGlvbiB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jazsgLyogeC1icm93c2VyIGZvciB3aGVuIHN0aWNreSAod2hlbiBtdWx0aS10aWVyIGhlYWRlcikgKi9cXG4gICAgcGFkZGluZzogMnB4IDRweDtcXG4gIH1cXG4uZmMgLmZjLWJnLWV2ZW50LFxcbiAgLmZjIC5mYy1ub24tYnVzaW5lc3MsXFxuICAuZmMgLmZjLWhpZ2hsaWdodCB7XFxuICAgIC8qIHdpbGwgYWx3YXlzIGhhdmUgYSBoYXJuZXNzIHdpdGggcG9zaXRpb246cmVsYXRpdmUvYWJzb2x1dGUsIHNvIGFic29sdXRlbHkgZXhwYW5kICovXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgfVxcbi5mYyAuZmMtbm9uLWJ1c2luZXNzIHtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgyMTUsIDIxNSwgMjE1LCAwLjMpO1xcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1mYy1ub24tYnVzaW5lc3MtY29sb3IsIHJnYmEoMjE1LCAyMTUsIDIxNSwgMC4zKSk7XFxuICB9XFxuLmZjIC5mYy1iZy1ldmVudCB7XFxuICAgIGJhY2tncm91bmQ6IHJnYigxNDMsIDIyMywgMTMwKTtcXG4gICAgYmFja2dyb3VuZDogdmFyKC0tZmMtYmctZXZlbnQtY29sb3IsIHJnYigxNDMsIDIyMywgMTMwKSk7XFxuICAgIG9wYWNpdHk6IDAuMztcXG4gICAgb3BhY2l0eTogdmFyKC0tZmMtYmctZXZlbnQtb3BhY2l0eSwgMC4zKVxcbiAgfVxcbi5mYyAuZmMtYmctZXZlbnQgLmZjLWV2ZW50LXRpdGxlIHtcXG4gICAgICBtYXJnaW46IC41ZW07XFxuICAgICAgZm9udC1zaXplOiAuODVlbTtcXG4gICAgICBmb250LXNpemU6IHZhcigtLWZjLXNtYWxsLWZvbnQtc2l6ZSwgLjg1ZW0pO1xcbiAgICAgIGZvbnQtc3R5bGU6IGl0YWxpYztcXG4gICAgfVxcbi5mYyAuZmMtaGlnaGxpZ2h0IHtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgxODgsIDIzMiwgMjQxLCAwLjMpO1xcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1mYy1oaWdobGlnaHQtY29sb3IsIHJnYmEoMTg4LCAyMzIsIDI0MSwgMC4zKSk7XFxuICB9XFxuLmZjIC5mYy1kYXktdG9kYXkge1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjIwLCA0MCwgMC4xNSk7XFxuICAgIGJhY2tncm91bmQ6IHZhcigtLWZjLXRvZGF5LWJnLWNvbG9yLCByZ2JhKDI1NSwgMjIwLCA0MCwgMC4xNSkpOyAvKiBmb3IgYWxsIHRoZW1lcy4gYm9vdHN0cmFwIGRpZG4ndCBwcm92aWRlIGEgZ29vZCBzZW1pLXRyYW5zcGFyZW50IGNvbG9yIGZvciB0aGlzICovXFxuICB9XFxuLmZjIC5mYy1jZWxsLXNoYWRlZCxcXG4gIC5mYyAuZmMtZGF5LWRpc2FibGVkIHtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgyMDgsIDIwOCwgMjA4LCAwLjMpO1xcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1mYy1uZXV0cmFsLWJnLWNvbG9yLCByZ2JhKDIwOCwgMjA4LCAyMDgsIDAuMykpO1xcbiAgfVxcbi8qIGxpbmsgcmVzZXRzICovXFxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xcbmEuZmMtZXZlbnQge1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcbmEuZmMtZXZlbnQsXFxuYS5mYy1ldmVudDpob3ZlciB7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxufVxcbi8qIGN1cnNvciAqL1xcbi5mYy1ldmVudFtocmVmXSxcXG4uZmMtZXZlbnQuZmMtZXZlbnQtZHJhZ2dhYmxlIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuLyogZXZlbnQgdGV4dCBjb250ZW50ICovXFxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xcbi5mYy1ldmVudCAuZmMtZXZlbnQtbWFpbiB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgei1pbmRleDogMjtcXG4gIH1cXG4vKiBkcmFnZ2luZyAqL1xcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cXG4uZmMtZXZlbnQtZHJhZ2dpbmc6bm90KC5mYy1ldmVudC1zZWxlY3RlZCkgeyAvKiBNT1VTRSAqL1xcbiAgICBvcGFjaXR5OiAwLjc1O1xcbiAgfVxcbi5mYy1ldmVudC1kcmFnZ2luZy5mYy1ldmVudC1zZWxlY3RlZCB7IC8qIFRPVUNIICovXFxuICAgIGJveC1zaGFkb3c6IDAgMnB4IDdweCByZ2JhKDAsIDAsIDAsIDAuMyk7XFxuICB9XFxuLyogcmVzaXppbmcgKi9cXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXFxuLyogKHN1YmNsYXNzZXMgc2hvdWxkIGhvbmUgcG9zaXRpb25pbmcgZm9yIHRvdWNoIGFuZCBub24tdG91Y2gpICovXFxuLmZjLWV2ZW50IC5mYy1ldmVudC1yZXNpemVyIHtcXG4gICAgZGlzcGxheTogbm9uZTtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB6LWluZGV4OiA0O1xcbiAgfVxcbi5mYy1ldmVudDpob3ZlciwgLyogTU9VU0UgKi9cXG4uZmMtZXZlbnQtc2VsZWN0ZWQgeyAvKiBUT1VDSCAqL1xcblxcbn1cXG4uZmMtZXZlbnQ6aG92ZXIgLmZjLWV2ZW50LXJlc2l6ZXIsIC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplciB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgfVxcbi5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplciB7XFxuICAgIGJvcmRlci1yYWRpdXM6IDRweDtcXG4gICAgYm9yZGVyLXJhZGl1czogY2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCwgOHB4KSAvIDIpO1xcbiAgICBib3JkZXItd2lkdGg6IDFweDtcXG4gICAgYm9yZGVyLXdpZHRoOiB2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC1ib3JkZXItd2lkdGgsIDFweCk7XFxuICAgIHdpZHRoOiA4cHg7XFxuICAgIHdpZHRoOiB2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCwgOHB4KTtcXG4gICAgaGVpZ2h0OiA4cHg7XFxuICAgIGhlaWdodDogdmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgsIDhweCk7XFxuICAgIGJvcmRlci1zdHlsZTogc29saWQ7XFxuICAgIGJvcmRlci1jb2xvcjogaW5oZXJpdDtcXG4gICAgYmFja2dyb3VuZDogI2ZmZjtcXG4gICAgYmFja2dyb3VuZDogdmFyKC0tZmMtcGFnZS1iZy1jb2xvciwgI2ZmZilcXG5cXG4gICAgLyogZXhwYW5kIGhpdCBhcmVhICovXFxuXFxuICB9XFxuLmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVyOmJlZm9yZSB7XFxuICAgICAgY29udGVudDogJyc7XFxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgIHRvcDogLTIwcHg7XFxuICAgICAgbGVmdDogLTIwcHg7XFxuICAgICAgcmlnaHQ6IC0yMHB4O1xcbiAgICAgIGJvdHRvbTogLTIwcHg7XFxuICAgIH1cXG4vKiBzZWxlY3RpbmcgKGFsd2F5cyBUT1VDSCkgKi9cXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXFxuLmZjLWV2ZW50LXNlbGVjdGVkIHtcXG4gIGJveC1zaGFkb3c6IDAgMnB4IDVweCByZ2JhKDAsIDAsIDAsIDAuMilcXG5cXG4gIC8qIGV4cGFuZCBoaXQgYXJlYSAoc3ViY2xhc3NlcyBzaG91bGQgZXhwYW5kKSAqL1xcblxcbn1cXG4uZmMtZXZlbnQtc2VsZWN0ZWQ6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXCI7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgei1pbmRleDogMztcXG4gICAgdG9wOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgfVxcbi5mYy1ldmVudC1zZWxlY3RlZCB7XFxuXFxuICAvKiBkaW1tZXIgZWZmZWN0ICovXFxuXFxufVxcbi5mYy1ldmVudC1zZWxlY3RlZDphZnRlciB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuMjUpO1xcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1mYy1ldmVudC1zZWxlY3RlZC1vdmVybGF5LWNvbG9yLCByZ2JhKDAsIDAsIDAsIDAuMjUpKTtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB6LWluZGV4OiAxO1xcblxcbiAgICAvKiBhc3N1bWUgdGhlcmUncyBhIGJvcmRlciBvbiBhbGwgc2lkZXMuIG92ZXJjb21lIGl0LiAqL1xcbiAgICAvKiBzb21ldGltZXMgdGhlcmUncyBOT1QgYSBib3JkZXIsIGluIHdoaWNoIGNhc2UgdGhlIGRpbW1lciB3aWxsIGdvIG92ZXIgKi9cXG4gICAgLyogYW4gYWRqYWNlbnQgYm9yZGVyLCB3aGljaCBsb29rcyBmaW5lLiAqL1xcbiAgICB0b3A6IC0xcHg7XFxuICAgIGxlZnQ6IC0xcHg7XFxuICAgIHJpZ2h0OiAtMXB4O1xcbiAgICBib3R0b206IC0xcHg7XFxuICB9XFxuLypcXG5BIEhPUklaT05UQUwgZXZlbnRcXG4qL1xcbi5mYy1oLWV2ZW50IHsgLyogYWxsb3dlZCB0byBiZSB0b3AtbGV2ZWwgKi9cXG5cXG4gIGJvcmRlcjogMXB4IHNvbGlkICMzNzg4ZDg7XFxuXFxuICBib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1mYy1ldmVudC1iZy1jb2xvciwgIzM3ODhkOCk7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMzc4OGQ4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZmMtZXZlbnQtYm9yZGVyLWNvbG9yLCAjMzc4OGQ4KVxcblxcbn1cXG4uZmMtaC1ldmVudCAuZmMtZXZlbnQtbWFpbiB7XFxuICAgIGNvbG9yOiAjZmZmO1xcbiAgICBjb2xvcjogdmFyKC0tZmMtZXZlbnQtdGV4dC1jb2xvciwgI2ZmZik7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICB9XFxuLmZjLWgtZXZlbnQgLmZjLWV2ZW50LXRpdGxlLWZyYW1lIHsgLyogc2VydmVzIGFzIGEgY29udGFpbmVyIGZvciB0aGUgc3RpY2t5IGN1c2hpb24gKi9cXG4gICAgZmxleC1ncm93OiAxO1xcbiAgICBmbGV4LXNocmluazogMTtcXG4gICAgbWluLXdpZHRoOiAwOyAvKiBpbXBvcnRhbnQgZm9yIGFsbG93aW5nIHRvIHNocmluayBhbGwgdGhlIHdheSAqL1xcbiAgfVxcbi5mYy1oLWV2ZW50IC5mYy1ldmVudC10aXRsZSB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jazsgLyogbmVlZCB0aGlzIHRvIGJlIHN0aWNreSBjcm9zcy1icm93c2VyICovXFxuICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7IC8qIGZvciBub3QgbWVzc2luZyB1cCBsaW5lLWhlaWdodCAqL1xcbiAgICBsZWZ0OiAwOyAgLyogZm9yIHN0aWNreSAqL1xcbiAgICByaWdodDogMDsgLyogZm9yIHN0aWNreSAqL1xcbiAgICBtYXgtd2lkdGg6IDEwMCU7IC8qIGNsaXAgb3ZlcmZsb3cgb24gdGhpcyBlbGVtZW50ICovXFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICB9XFxuLmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQ6YmVmb3JlIHtcXG4gICAgLyogZXhwYW5kIGhpdCBhcmVhICovXFxuICAgIHRvcDogLTEwcHg7XFxuICAgIGJvdHRvbTogLTEwcHg7XFxuICB9XFxuLyogYWRqdXN0IGJvcmRlciBhbmQgYm9yZGVyLXJhZGl1cyAoaWYgdGhlcmUgaXMgYW55KSBmb3Igbm9uLXN0YXJ0L2VuZCAqL1xcbi5mYy1kaXJlY3Rpb24tbHRyIC5mYy1kYXlncmlkLWJsb2NrLWV2ZW50Om5vdCguZmMtZXZlbnQtc3RhcnQpLFxcbi5mYy1kaXJlY3Rpb24tcnRsIC5mYy1kYXlncmlkLWJsb2NrLWV2ZW50Om5vdCguZmMtZXZlbnQtZW5kKSB7XFxuICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAwO1xcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMDtcXG4gIGJvcmRlci1sZWZ0LXdpZHRoOiAwO1xcbn1cXG4uZmMtZGlyZWN0aW9uLWx0ciAuZmMtZGF5Z3JpZC1ibG9jay1ldmVudDpub3QoLmZjLWV2ZW50LWVuZCksXFxuLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtYmxvY2stZXZlbnQ6bm90KC5mYy1ldmVudC1zdGFydCkge1xcbiAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDA7XFxuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMDtcXG4gIGJvcmRlci1yaWdodC13aWR0aDogMDtcXG59XFxuLyogcmVzaXplcnMgKi9cXG4uZmMtaC1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplciB7XFxuICB0b3A6IDA7XFxuICBib3R0b206IDA7XFxuICB3aWR0aDogOHB4O1xcbiAgd2lkdGg6IHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItdGhpY2tuZXNzLCA4cHgpO1xcbn1cXG4uZmMtZGlyZWN0aW9uLWx0ciAuZmMtaC1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1zdGFydCxcXG4uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtaC1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1lbmQge1xcbiAgY3Vyc29yOiB3LXJlc2l6ZTtcXG4gIGxlZnQ6IC00cHg7XFxuICBsZWZ0OiBjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItdGhpY2tuZXNzLCA4cHgpIC8gLTIpO1xcbn1cXG4uZmMtZGlyZWN0aW9uLWx0ciAuZmMtaC1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1lbmQsXFxuLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWgtZXZlbnQ6bm90KC5mYy1ldmVudC1zZWxlY3RlZCkgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnQge1xcbiAgY3Vyc29yOiBlLXJlc2l6ZTtcXG4gIHJpZ2h0OiAtNHB4O1xcbiAgcmlnaHQ6IGNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci10aGlja25lc3MsIDhweCkgLyAtMik7XFxufVxcbi8qIHJlc2l6ZXJzIGZvciBUT1VDSCAqL1xcbi5mYy1oLWV2ZW50LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVyIHtcXG4gIHRvcDogNTAlO1xcbiAgbWFyZ2luLXRvcDogLTRweDtcXG4gIG1hcmdpbi10b3A6IGNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgsIDhweCkgLyAtMik7XFxufVxcbi5mYy1kaXJlY3Rpb24tbHRyIC5mYy1oLWV2ZW50LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVyLXN0YXJ0LFxcbi5mYy1kaXJlY3Rpb24tcnRsIC5mYy1oLWV2ZW50LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVyLWVuZCB7XFxuICBsZWZ0OiAtNHB4O1xcbiAgbGVmdDogY2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCwgOHB4KSAvIC0yKTtcXG59XFxuLmZjLWRpcmVjdGlvbi1sdHIgLmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXItZW5kLFxcbi5mYy1kaXJlY3Rpb24tcnRsIC5mYy1oLWV2ZW50LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVyLXN0YXJ0IHtcXG4gIHJpZ2h0OiAtNHB4O1xcbiAgcmlnaHQ6IGNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgsIDhweCkgLyAtMik7XFxufVxcblwiIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/common/main.css\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/common/main.js":
/*!***************************************************!*\
  !*** ./node_modules/@fullcalendar/common/main.js ***!
  \***************************************************/
/*! exports provided: Component, createElement, render, createRef, Fragment, createContext, flushToDom, BASE_OPTION_DEFAULTS, BASE_OPTION_REFINERS, BaseComponent, BgEvent, CalendarApi, CalendarContent, CalendarDataManager, CalendarDataProvider, CalendarRoot, ContentHook, CustomContentRenderContext, DateComponent, DateEnv, DateProfileGenerator, DayCellContent, DayCellRoot, DayHeader, DaySeriesModel, DayTableModel, DelayedRunner, ElementDragging, ElementScrollController, Emitter, EventApi, EventRoot, EventSourceApi, Interaction, MountHook, NamedTimeZoneImpl, NowIndicatorRoot, NowTimer, PositionCache, RefMap, RenderHook, ScrollController, ScrollResponder, Scroller, SimpleScrollGrid, Slicer, Splitter, StandardEvent, TableDateCell, TableDowCell, Theme, ViewApi, ViewContextType, ViewRoot, WeekNumberRoot, WindowScrollController, addDays, addDurations, addMs, addWeeks, allowContextMenu, allowSelection, applyMutationToEventStore, applyStyle, applyStyleProp, asRoughMinutes, asRoughMs, asRoughSeconds, buildClassNameNormalizer, buildEventApis, buildEventRangeKey, buildHashFromArray, buildNavLinkData, buildSegCompareObj, buildSegTimeText, collectFromHash, combineEventUis, compareByFieldSpec, compareByFieldSpecs, compareNumbers, compareObjs, computeEdges, computeFallbackHeaderFormat, computeHeightAndMargins, computeInnerRect, computeRect, computeSegDraggable, computeSegEndResizable, computeSegStartResizable, computeShrinkWidth, computeSmallestCellWidth, computeVisibleDayRange, config, constrainPoint, createDuration, createEmptyEventStore, createEventInstance, createEventUi, createFormatter, createPlugin, diffDates, diffDayAndTime, diffDays, diffPoints, diffWeeks, diffWholeDays, diffWholeWeeks, disableCursor, elementClosest, elementMatches, enableCursor, eventTupleToStore, filterEventStoreDefs, filterHash, findDirectChildren, findElements, flexibleCompare, formatDate, formatDayString, formatIsoTimeString, formatRange, getAllowYScrolling, getClippingParents, getDateMeta, getDayClassNames, getDefaultEventEnd, getElSeg, getEventClassNames, getIsRtlScrollbarOnLeft, getRectCenter, getRelevantEvents, getScrollGridClassNames, getScrollbarWidths, getSectionClassNames, getSectionHasLiquidHeight, getSegMeta, getSlotClassNames, getStickyFooterScrollbar, getStickyHeaderDates, getUnequalProps, globalLocales, globalPlugins, greatestDurationDenominator, guid, hasBgRendering, hasShrinkWidth, htmlToElement, identity, interactionSettingsStore, interactionSettingsToStore, intersectRanges, intersectRects, isArraysEqual, isColPropsEqual, isDateSpansEqual, isElVisible, isInt, isInteractionValid, isMultiDayRange, isPropsEqual, isPropsValid, isSingleDay, isValidDate, listenBySelector, mapHash, memoize, memoizeArraylike, memoizeHashlike, memoizeObjArg, mergeEventStores, multiplyDuration, padStart, parseBusinessHours, parseClassNames, parseDragMeta, parseEventDef, parseFieldSpecs, parseMarker, pointInsideRect, preventContextMenu, preventDefault, preventSelection, rangeContainsMarker, rangeContainsRange, rangesEqual, rangesIntersect, refineEventDef, refineProps, removeElement, removeExact, renderChunkContent, renderFill, renderMicroColGroup, renderScrollShim, requestJson, sanitizeShrinkWidth, setElSeg, setRef, sliceEventStore, sliceEvents, sortEventSegs, startOfDay, translateRect, triggerDateSelect, unpromisify, version, whenTransitionDone, wholeDivideDurations */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BASE_OPTION_DEFAULTS\", function() { return BASE_OPTION_DEFAULTS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BASE_OPTION_REFINERS\", function() { return BASE_OPTION_REFINERS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BaseComponent\", function() { return BaseComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BgEvent\", function() { return BgEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CalendarApi\", function() { return CalendarApi; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CalendarContent\", function() { return CalendarContent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CalendarDataManager\", function() { return CalendarDataManager; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CalendarDataProvider\", function() { return CalendarDataProvider; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CalendarRoot\", function() { return CalendarRoot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ContentHook\", function() { return ContentHook; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CustomContentRenderContext\", function() { return CustomContentRenderContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DateComponent\", function() { return DateComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DateEnv\", function() { return DateEnv; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DateProfileGenerator\", function() { return DateProfileGenerator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DayCellContent\", function() { return DayCellContent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DayCellRoot\", function() { return DayCellRoot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DayHeader\", function() { return DayHeader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DaySeriesModel\", function() { return DaySeriesModel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DayTableModel\", function() { return DayTableModel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DelayedRunner\", function() { return DelayedRunner; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ElementDragging\", function() { return ElementDragging; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ElementScrollController\", function() { return ElementScrollController; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Emitter\", function() { return Emitter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EventApi\", function() { return EventApi; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EventRoot\", function() { return EventRoot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EventSourceApi\", function() { return EventSourceApi; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Interaction\", function() { return Interaction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MountHook\", function() { return MountHook; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NamedTimeZoneImpl\", function() { return NamedTimeZoneImpl; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NowIndicatorRoot\", function() { return NowIndicatorRoot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NowTimer\", function() { return NowTimer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PositionCache\", function() { return PositionCache; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RefMap\", function() { return RefMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RenderHook\", function() { return RenderHook; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScrollController\", function() { return ScrollController; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScrollResponder\", function() { return ScrollResponder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Scroller\", function() { return Scroller; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SimpleScrollGrid\", function() { return SimpleScrollGrid; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Slicer\", function() { return Slicer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Splitter\", function() { return Splitter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StandardEvent\", function() { return StandardEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TableDateCell\", function() { return TableDateCell; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TableDowCell\", function() { return TableDowCell; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Theme\", function() { return Theme; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ViewApi\", function() { return ViewApi; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ViewContextType\", function() { return ViewContextType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ViewRoot\", function() { return ViewRoot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WeekNumberRoot\", function() { return WeekNumberRoot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WindowScrollController\", function() { return WindowScrollController; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addDays\", function() { return addDays; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addDurations\", function() { return addDurations; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addMs\", function() { return addMs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addWeeks\", function() { return addWeeks; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"allowContextMenu\", function() { return allowContextMenu; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"allowSelection\", function() { return allowSelection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"applyMutationToEventStore\", function() { return applyMutationToEventStore; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"applyStyle\", function() { return applyStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"applyStyleProp\", function() { return applyStyleProp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"asRoughMinutes\", function() { return asRoughMinutes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"asRoughMs\", function() { return asRoughMs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"asRoughSeconds\", function() { return asRoughSeconds; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildClassNameNormalizer\", function() { return buildClassNameNormalizer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildEventApis\", function() { return buildEventApis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildEventRangeKey\", function() { return buildEventRangeKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildHashFromArray\", function() { return buildHashFromArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildNavLinkData\", function() { return buildNavLinkData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildSegCompareObj\", function() { return buildSegCompareObj; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildSegTimeText\", function() { return buildSegTimeText; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"collectFromHash\", function() { return collectFromHash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"combineEventUis\", function() { return combineEventUis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compareByFieldSpec\", function() { return compareByFieldSpec; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compareByFieldSpecs\", function() { return compareByFieldSpecs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compareNumbers\", function() { return compareNumbers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compareObjs\", function() { return compareObjs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeEdges\", function() { return computeEdges; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeFallbackHeaderFormat\", function() { return computeFallbackHeaderFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeHeightAndMargins\", function() { return computeHeightAndMargins; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeInnerRect\", function() { return computeInnerRect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeRect\", function() { return computeRect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeSegDraggable\", function() { return computeSegDraggable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeSegEndResizable\", function() { return computeSegEndResizable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeSegStartResizable\", function() { return computeSegStartResizable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeShrinkWidth\", function() { return computeShrinkWidth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeSmallestCellWidth\", function() { return computeSmallestCellWidth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeVisibleDayRange\", function() { return computeVisibleDayRange; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"config\", function() { return config; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"constrainPoint\", function() { return constrainPoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createDuration\", function() { return createDuration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createEmptyEventStore\", function() { return createEmptyEventStore; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createEventInstance\", function() { return createEventInstance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createEventUi\", function() { return createEventUi; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createFormatter\", function() { return createFormatter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createPlugin\", function() { return createPlugin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"diffDates\", function() { return diffDates; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"diffDayAndTime\", function() { return diffDayAndTime; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"diffDays\", function() { return diffDays; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"diffPoints\", function() { return diffPoints; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"diffWeeks\", function() { return diffWeeks; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"diffWholeDays\", function() { return diffWholeDays; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"diffWholeWeeks\", function() { return diffWholeWeeks; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"disableCursor\", function() { return disableCursor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"elementClosest\", function() { return elementClosest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"elementMatches\", function() { return elementMatches; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"enableCursor\", function() { return enableCursor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"eventTupleToStore\", function() { return eventTupleToStore; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"filterEventStoreDefs\", function() { return filterEventStoreDefs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"filterHash\", function() { return filterHash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findDirectChildren\", function() { return findDirectChildren; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findElements\", function() { return findElements; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"flexibleCompare\", function() { return flexibleCompare; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"formatDate\", function() { return formatDate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"formatDayString\", function() { return formatDayString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"formatIsoTimeString\", function() { return formatIsoTimeString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"formatRange\", function() { return formatRange; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAllowYScrolling\", function() { return getAllowYScrolling; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getClippingParents\", function() { return getClippingParents; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDateMeta\", function() { return getDateMeta; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDayClassNames\", function() { return getDayClassNames; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDefaultEventEnd\", function() { return getDefaultEventEnd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getElSeg\", function() { return getElSeg; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getEventClassNames\", function() { return getEventClassNames; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getIsRtlScrollbarOnLeft\", function() { return getIsRtlScrollbarOnLeft; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getRectCenter\", function() { return getRectCenter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getRelevantEvents\", function() { return getRelevantEvents; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getScrollGridClassNames\", function() { return getScrollGridClassNames; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getScrollbarWidths\", function() { return getScrollbarWidths; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getSectionClassNames\", function() { return getSectionClassNames; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getSectionHasLiquidHeight\", function() { return getSectionHasLiquidHeight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getSegMeta\", function() { return getSegMeta; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getSlotClassNames\", function() { return getSlotClassNames; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getStickyFooterScrollbar\", function() { return getStickyFooterScrollbar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getStickyHeaderDates\", function() { return getStickyHeaderDates; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getUnequalProps\", function() { return getUnequalProps; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"globalLocales\", function() { return globalLocales; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"globalPlugins\", function() { return globalPlugins; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"greatestDurationDenominator\", function() { return greatestDurationDenominator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"guid\", function() { return guid; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hasBgRendering\", function() { return hasBgRendering; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hasShrinkWidth\", function() { return hasShrinkWidth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"htmlToElement\", function() { return htmlToElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identity\", function() { return identity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"interactionSettingsStore\", function() { return interactionSettingsStore; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"interactionSettingsToStore\", function() { return interactionSettingsToStore; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"intersectRanges\", function() { return intersectRanges; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"intersectRects\", function() { return intersectRects; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isArraysEqual\", function() { return isArraysEqual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isColPropsEqual\", function() { return isColPropsEqual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isDateSpansEqual\", function() { return isDateSpansEqual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isElVisible\", function() { return isElVisible; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isInt\", function() { return isInt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isInteractionValid\", function() { return isInteractionValid; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isMultiDayRange\", function() { return isMultiDayRange; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isPropsEqual\", function() { return isPropsEqual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isPropsValid\", function() { return isPropsValid; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isSingleDay\", function() { return isSingleDay; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isValidDate\", function() { return isValidDate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"listenBySelector\", function() { return listenBySelector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapHash\", function() { return mapHash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"memoize\", function() { return memoize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"memoizeArraylike\", function() { return memoizeArraylike; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"memoizeHashlike\", function() { return memoizeHashlike; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"memoizeObjArg\", function() { return memoizeObjArg; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mergeEventStores\", function() { return mergeEventStores; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyDuration\", function() { return multiplyDuration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"padStart\", function() { return padStart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseBusinessHours\", function() { return parseBusinessHours; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseClassNames\", function() { return parseClassNames; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseDragMeta\", function() { return parseDragMeta; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseEventDef\", function() { return parseEventDef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseFieldSpecs\", function() { return parseFieldSpecs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseMarker\", function() { return parse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pointInsideRect\", function() { return pointInsideRect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"preventContextMenu\", function() { return preventContextMenu; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"preventDefault\", function() { return preventDefault; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"preventSelection\", function() { return preventSelection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rangeContainsMarker\", function() { return rangeContainsMarker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rangeContainsRange\", function() { return rangeContainsRange; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rangesEqual\", function() { return rangesEqual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rangesIntersect\", function() { return rangesIntersect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"refineEventDef\", function() { return refineEventDef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"refineProps\", function() { return refineProps; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeElement\", function() { return removeElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeExact\", function() { return removeExact; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"renderChunkContent\", function() { return renderChunkContent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"renderFill\", function() { return renderFill; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"renderMicroColGroup\", function() { return renderMicroColGroup; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"renderScrollShim\", function() { return renderScrollShim; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"requestJson\", function() { return requestJson; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sanitizeShrinkWidth\", function() { return sanitizeShrinkWidth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setElSeg\", function() { return setElSeg; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setRef\", function() { return setRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sliceEventStore\", function() { return sliceEventStore; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sliceEvents\", function() { return sliceEvents; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sortEventSegs\", function() { return sortEventSegs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"startOfDay\", function() { return startOfDay; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"translateRect\", function() { return translateRect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"triggerDateSelect\", function() { return triggerDateSelect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unpromisify\", function() { return unpromisify; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"version\", function() { return version; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"whenTransitionDone\", function() { return whenTransitionDone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"wholeDivideDurations\", function() { return wholeDivideDurations; });\n/* harmony import */ var _main_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main.css */ \"./node_modules/@fullcalendar/common/main.css\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _vdom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vdom */ \"./node_modules/@fullcalendar/common/vdom.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return _vdom__WEBPACK_IMPORTED_MODULE_2__[\"Component\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createElement\", function() { return _vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return _vdom__WEBPACK_IMPORTED_MODULE_2__[\"render\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createRef\", function() { return _vdom__WEBPACK_IMPORTED_MODULE_2__[\"createRef\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Fragment\", function() { return _vdom__WEBPACK_IMPORTED_MODULE_2__[\"Fragment\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createContext\", function() { return _vdom__WEBPACK_IMPORTED_MODULE_2__[\"createContext\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"flushToDom\", function() { return _vdom__WEBPACK_IMPORTED_MODULE_2__[\"flushToDom\"]; });\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\nFullCalendar v5.0.0\nDocs & License: https://fullcalendar.io/\n(c) 2020 Adam Shaw\n*/\n\n\n\n // no public types yet. when there are, export from:\n// import {} from './api-type-deps'\n\nvar EventSourceApi =\n/** @class */\nfunction () {\n  function EventSourceApi(context, internalEventSource // rename?\n  ) {\n    this.context = context;\n    this.internalEventSource = internalEventSource;\n  }\n\n  EventSourceApi.prototype.remove = function () {\n    this.context.dispatch({\n      type: 'REMOVE_EVENT_SOURCE',\n      sourceId: this.internalEventSource.sourceId\n    });\n  };\n\n  EventSourceApi.prototype.refetch = function () {\n    this.context.dispatch({\n      type: 'FETCH_EVENT_SOURCES',\n      sourceIds: [this.internalEventSource.sourceId]\n    });\n  };\n\n  Object.defineProperty(EventSourceApi.prototype, \"id\", {\n    get: function get() {\n      return this.internalEventSource.publicId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventSourceApi.prototype, \"url\", {\n    // only relevant to json-feed event sources\n    get: function get() {\n      return this.internalEventSource.meta.url;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return EventSourceApi;\n}(); // TODO: new util arrayify?\n\n\nfunction removeExact(array, exactVal) {\n  var removeCnt = 0;\n  var i = 0;\n\n  while (i < array.length) {\n    if (array[i] === exactVal) {\n      array.splice(i, 1);\n      removeCnt++;\n    } else {\n      i++;\n    }\n  }\n\n  return removeCnt;\n}\n\nfunction isArraysEqual(a0, a1, equalityFunc) {\n  if (a0 === a1) {\n    return true;\n  }\n\n  var len = a0.length;\n  var i;\n\n  if (len !== a1.length) {\n    // not array? or not same length?\n    return false;\n  }\n\n  for (i = 0; i < len; i++) {\n    if (!(equalityFunc ? equalityFunc(a0[i], a1[i]) : a0[i] === a1[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction htmlToElement(html) {\n  html = html.trim();\n  var container = document.createElement('div');\n  container.innerHTML = html;\n  return container.firstChild;\n}\n\nfunction removeElement(el) {\n  if (el.parentNode) {\n    el.parentNode.removeChild(el);\n  }\n}\n\nfunction injectHtml(el, html) {\n  el.innerHTML = html;\n}\n\nfunction injectDomNodes(el, domNodes) {\n  var oldNodes = Array.prototype.slice.call(el.childNodes); // TODO: use array util\n\n  var newNodes = Array.prototype.slice.call(domNodes); // TODO: use array util\n\n  if (!isArraysEqual(oldNodes, newNodes)) {\n    for (var _i = 0, newNodes_1 = newNodes; _i < newNodes_1.length; _i++) {\n      var newNode = newNodes_1[_i];\n      el.appendChild(newNode);\n    }\n\n    oldNodes.forEach(removeElement);\n  }\n}\n\nfunction isElVisible(el) {\n  return Boolean(el.offsetWidth && el.offsetHeight);\n} // Querying\n// ----------------------------------------------------------------------------------------------------------------\n// from https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\n\n\nvar matchesMethod = Element.prototype.matches || Element.prototype.matchesSelector || Element.prototype.msMatchesSelector;\n\nvar closestMethod = Element.prototype.closest || function (selector) {\n  // polyfill\n  var el = this;\n\n  if (!document.documentElement.contains(el)) {\n    return null;\n  }\n\n  do {\n    if (elementMatches(el, selector)) {\n      return el;\n    }\n\n    el = el.parentElement || el.parentNode;\n  } while (el !== null && el.nodeType === 1);\n\n  return null;\n};\n\nfunction elementClosest(el, selector) {\n  return closestMethod.call(el, selector);\n}\n\nfunction elementMatches(el, selector) {\n  return matchesMethod.call(el, selector);\n} // accepts multiple subject els\n// returns a real array. good for methods like forEach\n// TODO: accept the document\n\n\nfunction findElements(container, selector) {\n  var containers = container instanceof HTMLElement ? [container] : container;\n  var allMatches = [];\n\n  for (var i = 0; i < containers.length; i++) {\n    var matches = containers[i].querySelectorAll(selector);\n\n    for (var j = 0; j < matches.length; j++) {\n      allMatches.push(matches[j]);\n    }\n  }\n\n  return allMatches;\n} // accepts multiple subject els\n// only queries direct child elements // TODO: rename to findDirectChildren!\n\n\nfunction findDirectChildren(parent, selector) {\n  var parents = parent instanceof HTMLElement ? [parent] : parent;\n  var allMatches = [];\n\n  for (var i = 0; i < parents.length; i++) {\n    var childNodes = parents[i].children; // only ever elements\n\n    for (var j = 0; j < childNodes.length; j++) {\n      var childNode = childNodes[j];\n\n      if (!selector || elementMatches(childNode, selector)) {\n        allMatches.push(childNode);\n      }\n    }\n  }\n\n  return allMatches;\n} // Style\n// ----------------------------------------------------------------------------------------------------------------\n\n\nvar PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;\n\nfunction applyStyle(el, props) {\n  for (var propName in props) {\n    applyStyleProp(el, propName, props[propName]);\n  }\n}\n\nfunction applyStyleProp(el, name, val) {\n  if (val == null) {\n    el.style[name] = '';\n  } else if (typeof val === 'number' && PIXEL_PROP_RE.test(name)) {\n    el.style[name] = val + 'px';\n  } else {\n    el.style[name] = val;\n  }\n} // Stops a mouse/touch event from doing it's native browser action\n\n\nfunction preventDefault(ev) {\n  ev.preventDefault();\n} // Event Delegation\n// ----------------------------------------------------------------------------------------------------------------\n\n\nfunction buildDelegationHandler(selector, handler) {\n  return function (ev) {\n    var matchedChild = elementClosest(ev.target, selector);\n\n    if (matchedChild) {\n      handler.call(matchedChild, ev, matchedChild);\n    }\n  };\n}\n\nfunction listenBySelector(container, eventType, selector, handler) {\n  var attachedHandler = buildDelegationHandler(selector, handler);\n  container.addEventListener(eventType, attachedHandler);\n  return function () {\n    container.removeEventListener(eventType, attachedHandler);\n  };\n}\n\nfunction listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {\n  var currentMatchedChild;\n  return listenBySelector(container, 'mouseover', selector, function (ev, matchedChild) {\n    if (matchedChild !== currentMatchedChild) {\n      currentMatchedChild = matchedChild;\n      onMouseEnter(ev, matchedChild);\n\n      var realOnMouseLeave_1 = function realOnMouseLeave_1(ev) {\n        currentMatchedChild = null;\n        onMouseLeave(ev, matchedChild);\n        matchedChild.removeEventListener('mouseleave', realOnMouseLeave_1);\n      }; // listen to the next mouseleave, and then unattach\n\n\n      matchedChild.addEventListener('mouseleave', realOnMouseLeave_1);\n    }\n  });\n} // Animation\n// ----------------------------------------------------------------------------------------------------------------\n\n\nvar transitionEventNames = ['webkitTransitionEnd', 'otransitionend', 'oTransitionEnd', 'msTransitionEnd', 'transitionend']; // triggered only when the next single subsequent transition finishes\n\nfunction whenTransitionDone(el, callback) {\n  var realCallback = function realCallback(ev) {\n    callback(ev);\n    transitionEventNames.forEach(function (eventName) {\n      el.removeEventListener(eventName, realCallback);\n    });\n  };\n\n  transitionEventNames.forEach(function (eventName) {\n    el.addEventListener(eventName, realCallback); // cross-browser way to determine when the transition finishes\n  });\n}\n\nvar guidNumber = 0;\n\nfunction guid() {\n  return String(guidNumber++);\n}\n/* FullCalendar-specific DOM Utilities\n----------------------------------------------------------------------------------------------------------------------*/\n// Make the mouse cursor express that an event is not allowed in the current area\n\n\nfunction disableCursor() {\n  document.body.classList.add('fc-not-allowed');\n} // Returns the mouse cursor to its original look\n\n\nfunction enableCursor() {\n  document.body.classList.remove('fc-not-allowed');\n}\n/* Selection\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nfunction preventSelection(el) {\n  el.classList.add('fc-unselectable');\n  el.addEventListener('selectstart', preventDefault);\n}\n\nfunction allowSelection(el) {\n  el.classList.remove('fc-unselectable');\n  el.removeEventListener('selectstart', preventDefault);\n}\n/* Context Menu\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nfunction preventContextMenu(el) {\n  el.addEventListener('contextmenu', preventDefault);\n}\n\nfunction allowContextMenu(el) {\n  el.removeEventListener('contextmenu', preventDefault);\n}\n\nfunction parseFieldSpecs(input) {\n  var specs = [];\n  var tokens = [];\n  var i;\n  var token;\n\n  if (typeof input === 'string') {\n    tokens = input.split(/\\s*,\\s*/);\n  } else if (typeof input === 'function') {\n    tokens = [input];\n  } else if (Array.isArray(input)) {\n    tokens = input;\n  }\n\n  for (i = 0; i < tokens.length; i++) {\n    token = tokens[i];\n\n    if (typeof token === 'string') {\n      specs.push(token.charAt(0) === '-' ? {\n        field: token.substring(1),\n        order: -1\n      } : {\n        field: token,\n        order: 1\n      });\n    } else if (typeof token === 'function') {\n      specs.push({\n        func: token\n      });\n    }\n  }\n\n  return specs;\n}\n\nfunction compareByFieldSpecs(obj0, obj1, fieldSpecs) {\n  var i;\n  var cmp;\n\n  for (i = 0; i < fieldSpecs.length; i++) {\n    cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i]);\n\n    if (cmp) {\n      return cmp;\n    }\n  }\n\n  return 0;\n}\n\nfunction compareByFieldSpec(obj0, obj1, fieldSpec) {\n  if (fieldSpec.func) {\n    return fieldSpec.func(obj0, obj1);\n  }\n\n  return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field]) * (fieldSpec.order || 1);\n}\n\nfunction flexibleCompare(a, b) {\n  if (!a && !b) {\n    return 0;\n  }\n\n  if (b == null) {\n    return -1;\n  }\n\n  if (a == null) {\n    return 1;\n  }\n\n  if (typeof a === 'string' || typeof b === 'string') {\n    return String(a).localeCompare(String(b));\n  }\n\n  return a - b;\n}\n/* String Utilities\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nfunction padStart(val, len) {\n  var s = String(val);\n  return '000'.substr(0, len - s.length) + s;\n}\n/* Number Utilities\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nfunction compareNumbers(a, b) {\n  return a - b;\n}\n\nfunction isInt(n) {\n  return n % 1 === 0;\n}\n/* FC-specific DOM dimension stuff\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nfunction computeSmallestCellWidth(cellEl) {\n  var allWidthEl = cellEl.querySelector('.fc-scrollgrid-shrink-frame');\n  var contentWidthEl = cellEl.querySelector('.fc-scrollgrid-shrink-cushion');\n\n  if (!allWidthEl) {\n    throw new Error('needs fc-scrollgrid-shrink-frame className'); // TODO: use const\n  }\n\n  if (!contentWidthEl) {\n    throw new Error('needs fc-scrollgrid-shrink-cushion className');\n  }\n\n  return cellEl.getBoundingClientRect().width - allWidthEl.getBoundingClientRect().width + // the cell padding+border\n  contentWidthEl.getBoundingClientRect().width;\n}\n\nvar DAY_IDS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat']; // Adding\n\nfunction addWeeks(m, n) {\n  var a = dateToUtcArray(m);\n  a[2] += n * 7;\n  return arrayToUtcDate(a);\n}\n\nfunction addDays(m, n) {\n  var a = dateToUtcArray(m);\n  a[2] += n;\n  return arrayToUtcDate(a);\n}\n\nfunction addMs(m, n) {\n  var a = dateToUtcArray(m);\n  a[6] += n;\n  return arrayToUtcDate(a);\n} // Diffing (all return floats)\n// TODO: why not use ranges?\n\n\nfunction diffWeeks(m0, m1) {\n  return diffDays(m0, m1) / 7;\n}\n\nfunction diffDays(m0, m1) {\n  return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60 * 24);\n}\n\nfunction diffHours(m0, m1) {\n  return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60);\n}\n\nfunction diffMinutes(m0, m1) {\n  return (m1.valueOf() - m0.valueOf()) / (1000 * 60);\n}\n\nfunction diffSeconds(m0, m1) {\n  return (m1.valueOf() - m0.valueOf()) / 1000;\n}\n\nfunction diffDayAndTime(m0, m1) {\n  var m0day = startOfDay(m0);\n  var m1day = startOfDay(m1);\n  return {\n    years: 0,\n    months: 0,\n    days: Math.round(diffDays(m0day, m1day)),\n    milliseconds: m1.valueOf() - m1day.valueOf() - (m0.valueOf() - m0day.valueOf())\n  };\n} // Diffing Whole Units\n\n\nfunction diffWholeWeeks(m0, m1) {\n  var d = diffWholeDays(m0, m1);\n\n  if (d !== null && d % 7 === 0) {\n    return d / 7;\n  }\n\n  return null;\n}\n\nfunction diffWholeDays(m0, m1) {\n  if (timeAsMs(m0) === timeAsMs(m1)) {\n    return Math.round(diffDays(m0, m1));\n  }\n\n  return null;\n} // Start-Of\n\n\nfunction startOfDay(m) {\n  return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate()]);\n}\n\nfunction startOfHour(m) {\n  return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate(), m.getUTCHours()]);\n}\n\nfunction startOfMinute(m) {\n  return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate(), m.getUTCHours(), m.getUTCMinutes()]);\n}\n\nfunction startOfSecond(m) {\n  return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate(), m.getUTCHours(), m.getUTCMinutes(), m.getUTCSeconds()]);\n} // Week Computation\n\n\nfunction weekOfYear(marker, dow, doy) {\n  var y = marker.getUTCFullYear();\n  var w = weekOfGivenYear(marker, y, dow, doy);\n\n  if (w < 1) {\n    return weekOfGivenYear(marker, y - 1, dow, doy);\n  }\n\n  var nextW = weekOfGivenYear(marker, y + 1, dow, doy);\n\n  if (nextW >= 1) {\n    return Math.min(w, nextW);\n  }\n\n  return w;\n}\n\nfunction weekOfGivenYear(marker, year, dow, doy) {\n  var firstWeekStart = arrayToUtcDate([year, 0, 1 + firstWeekOffset(year, dow, doy)]);\n  var dayStart = startOfDay(marker);\n  var days = Math.round(diffDays(firstWeekStart, dayStart));\n  return Math.floor(days / 7) + 1; // zero-indexed\n} // start-of-first-week - start-of-year\n\n\nfunction firstWeekOffset(year, dow, doy) {\n  // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n  var fwd = 7 + dow - doy; // first-week day local weekday -- which local weekday is fwd\n\n  var fwdlw = (7 + arrayToUtcDate([year, 0, fwd]).getUTCDay() - dow) % 7;\n  return -fwdlw + fwd - 1;\n} // Array Conversion\n\n\nfunction dateToLocalArray(date) {\n  return [date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()];\n}\n\nfunction arrayToLocalDate(a) {\n  return new Date(a[0], a[1] || 0, a[2] == null ? 1 : a[2], // day of month\n  a[3] || 0, a[4] || 0, a[5] || 0);\n}\n\nfunction dateToUtcArray(date) {\n  return [date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds()];\n}\n\nfunction arrayToUtcDate(a) {\n  // according to web standards (and Safari), a month index is required.\n  // massage if only given a year.\n  if (a.length === 1) {\n    a = a.concat([0]);\n  }\n\n  return new Date(Date.UTC.apply(Date, a));\n} // Other Utils\n\n\nfunction isValidDate(m) {\n  return !isNaN(m.valueOf());\n}\n\nfunction timeAsMs(m) {\n  return m.getUTCHours() * 1000 * 60 * 60 + m.getUTCMinutes() * 1000 * 60 + m.getUTCSeconds() * 1000 + m.getUTCMilliseconds();\n}\n\nfunction createEventInstance(defId, range, forcedStartTzo, forcedEndTzo) {\n  return {\n    instanceId: guid(),\n    defId: defId,\n    range: range,\n    forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,\n    forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo\n  };\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty; // Merges an array of objects into a single object.\n// The second argument allows for an array of property names who's object values will be merged together.\n\nfunction mergeProps(propObjs, complexPropsMap) {\n  var dest = {};\n\n  if (complexPropsMap) {\n    for (var name_1 in complexPropsMap) {\n      var complexObjs = []; // collect the trailing object values, stopping when a non-object is discovered\n\n      for (var i = propObjs.length - 1; i >= 0; i--) {\n        var val = propObjs[i][name_1];\n\n        if (_typeof(val) === 'object' && val) {\n          // non-null object\n          complexObjs.unshift(val);\n        } else if (val !== undefined) {\n          dest[name_1] = val; // if there were no objects, this value will be used\n\n          break;\n        }\n      } // if the trailing values were objects, use the merged value\n\n\n      if (complexObjs.length) {\n        dest[name_1] = mergeProps(complexObjs);\n      }\n    }\n  } // copy values into the destination, going from last to first\n\n\n  for (var i = propObjs.length - 1; i >= 0; i--) {\n    var props = propObjs[i];\n\n    for (var name_2 in props) {\n      if (!(name_2 in dest)) {\n        // if already assigned by previous props or complex props, don't reassign\n        dest[name_2] = props[name_2];\n      }\n    }\n  }\n\n  return dest;\n}\n\nfunction filterHash(hash, func) {\n  var filtered = {};\n\n  for (var key in hash) {\n    if (func(hash[key], key)) {\n      filtered[key] = hash[key];\n    }\n  }\n\n  return filtered;\n}\n\nfunction mapHash(hash, func) {\n  var newHash = {};\n\n  for (var key in hash) {\n    newHash[key] = func(hash[key], key);\n  }\n\n  return newHash;\n}\n\nfunction arrayToHash(a) {\n  var hash = {};\n\n  for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {\n    var item = a_1[_i];\n    hash[item] = true;\n  }\n\n  return hash;\n}\n\nfunction buildHashFromArray(a, func) {\n  var hash = {};\n\n  for (var i = 0; i < a.length; i++) {\n    var tuple = func(a[i], i);\n    hash[tuple[0]] = tuple[1];\n  }\n\n  return hash;\n}\n\nfunction hashValuesToArray(obj) {\n  var a = [];\n\n  for (var key in obj) {\n    a.push(obj[key]);\n  }\n\n  return a;\n}\n\nfunction isPropsEqual(obj0, obj1) {\n  if (obj0 === obj1) {\n    return true;\n  }\n\n  for (var key in obj0) {\n    if (hasOwnProperty.call(obj0, key)) {\n      if (!(key in obj1)) {\n        return false;\n      }\n    }\n  }\n\n  for (var key in obj1) {\n    if (hasOwnProperty.call(obj1, key)) {\n      if (obj0[key] !== obj1[key]) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction getUnequalProps(obj0, obj1) {\n  var keys = [];\n\n  for (var key in obj0) {\n    if (hasOwnProperty.call(obj0, key)) {\n      if (!(key in obj1)) {\n        keys.push(key);\n      }\n    }\n  }\n\n  for (var key in obj1) {\n    if (hasOwnProperty.call(obj1, key)) {\n      if (obj0[key] !== obj1[key]) {\n        keys.push(key);\n      }\n    }\n  }\n\n  return keys;\n}\n\nfunction compareObjs(oldProps, newProps, equalityFuncs) {\n  if (equalityFuncs === void 0) {\n    equalityFuncs = {};\n  }\n\n  if (oldProps === newProps) {\n    return true;\n  }\n\n  for (var key in newProps) {\n    if (key in oldProps && isObjValsEqual(oldProps[key], newProps[key], equalityFuncs[key])) ;else {\n      return false;\n    }\n  } // check for props that were omitted in the new\n\n\n  for (var key in oldProps) {\n    if (!(key in newProps)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/*\nassumed \"true\" equality for handler names like \"onReceiveSomething\"\n*/\n\n\nfunction isObjValsEqual(val0, val1, comparator) {\n  if (val0 === val1 || comparator === true) {\n    return true;\n  }\n\n  if (comparator) {\n    return comparator(val0, val1);\n  }\n\n  return false;\n}\n\nfunction collectFromHash(hash, startIndex, endIndex, step) {\n  if (startIndex === void 0) {\n    startIndex = 0;\n  }\n\n  if (step === void 0) {\n    step = 1;\n  }\n\n  var res = [];\n\n  if (endIndex == null) {\n    endIndex = Object.keys(hash).length;\n  }\n\n  for (var i = startIndex; i < endIndex; i += step) {\n    var val = hash[i];\n\n    if (val !== undefined) {\n      // will disregard undefined for sparse arrays\n      res.push(val);\n    }\n  }\n\n  return res;\n}\n\nfunction parseRecurring(refined, defaultAllDay, dateEnv, recurringTypes) {\n  for (var i = 0; i < recurringTypes.length; i++) {\n    var parsed = recurringTypes[i].parse(refined, dateEnv);\n\n    if (parsed) {\n      var allDay = refined.allDay;\n\n      if (allDay == null) {\n        allDay = defaultAllDay;\n\n        if (allDay == null) {\n          allDay = parsed.allDayGuess;\n\n          if (allDay == null) {\n            allDay = false;\n          }\n        }\n      }\n\n      return {\n        allDay: allDay,\n        duration: parsed.duration,\n        typeData: parsed.typeData,\n        typeId: i\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction expandRecurring(eventStore, framingRange, context) {\n  var dateEnv = context.dateEnv,\n      pluginHooks = context.pluginHooks,\n      options = context.options;\n  var defs = eventStore.defs,\n      instances = eventStore.instances; // remove existing recurring instances\n  // TODO: bad. always expand events as a second step\n\n  instances = filterHash(instances, function (instance) {\n    return !defs[instance.defId].recurringDef;\n  });\n\n  for (var defId in defs) {\n    var def = defs[defId];\n\n    if (def.recurringDef) {\n      var duration = def.recurringDef.duration;\n\n      if (!duration) {\n        duration = def.allDay ? options.defaultAllDayEventDuration : options.defaultTimedEventDuration;\n      }\n\n      var starts = expandRecurringRanges(def, duration, framingRange, dateEnv, pluginHooks.recurringTypes);\n\n      for (var _i = 0, starts_1 = starts; _i < starts_1.length; _i++) {\n        var start = starts_1[_i];\n        var instance = createEventInstance(defId, {\n          start: start,\n          end: dateEnv.add(start, duration)\n        });\n        instances[instance.instanceId] = instance;\n      }\n    }\n  }\n\n  return {\n    defs: defs,\n    instances: instances\n  };\n}\n/*\nEvent MUST have a recurringDef\n*/\n\n\nfunction expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {\n  var typeDef = recurringTypes[eventDef.recurringDef.typeId];\n  var markers = typeDef.expand(eventDef.recurringDef.typeData, {\n    start: dateEnv.subtract(framingRange.start, duration),\n    end: framingRange.end\n  }, dateEnv); // the recurrence plugins don't guarantee that all-day events are start-of-day, so we have to\n\n  if (eventDef.allDay) {\n    markers = markers.map(startOfDay);\n  }\n\n  return markers;\n}\n\nvar INTERNAL_UNITS = ['years', 'months', 'days', 'milliseconds'];\nvar PARSE_RE = /^(-?)(?:(\\d+)\\.)?(\\d+):(\\d\\d)(?::(\\d\\d)(?:\\.(\\d\\d\\d))?)?/; // Parsing and Creation\n\nfunction createDuration(input, unit) {\n  var _a;\n\n  if (typeof input === 'string') {\n    return parseString(input);\n  } else if (_typeof(input) === 'object' && input) {\n    // non-null object\n    return parseObject(input);\n  } else if (typeof input === 'number') {\n    return parseObject((_a = {}, _a[unit || 'milliseconds'] = input, _a));\n  } else {\n    return null;\n  }\n}\n\nfunction parseString(s) {\n  var m = PARSE_RE.exec(s);\n\n  if (m) {\n    var sign = m[1] ? -1 : 1;\n    return {\n      years: 0,\n      months: 0,\n      days: sign * (m[2] ? parseInt(m[2], 10) : 0),\n      milliseconds: sign * ((m[3] ? parseInt(m[3], 10) : 0) * 60 * 60 * 1000 + // hours\n      (m[4] ? parseInt(m[4], 10) : 0) * 60 * 1000 + // minutes\n      (m[5] ? parseInt(m[5], 10) : 0) * 1000 + ( // seconds\n      m[6] ? parseInt(m[6], 10) : 0) // ms\n      )\n    };\n  }\n\n  return null;\n}\n\nfunction parseObject(obj) {\n  var duration = {\n    years: obj.years || obj.year || 0,\n    months: obj.months || obj.month || 0,\n    days: obj.days || obj.day || 0,\n    milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1000 + // hours\n    (obj.minutes || obj.minute || 0) * 60 * 1000 + // minutes\n    (obj.seconds || obj.second || 0) * 1000 + ( // seconds\n    obj.milliseconds || obj.millisecond || obj.ms || 0) // ms\n\n  };\n  var weeks = obj.weeks || obj.week;\n\n  if (weeks) {\n    duration.days += weeks * 7;\n    duration.specifiedWeeks = true;\n  }\n\n  return duration;\n} // Equality\n\n\nfunction durationsEqual(d0, d1) {\n  return d0.years === d1.years && d0.months === d1.months && d0.days === d1.days && d0.milliseconds === d1.milliseconds;\n}\n\nfunction isSingleDay(dur) {\n  return dur.years === 0 && dur.months === 0 && dur.days === 1 && dur.milliseconds === 0;\n} // Simple Math\n\n\nfunction addDurations(d0, d1) {\n  return {\n    years: d0.years + d1.years,\n    months: d0.months + d1.months,\n    days: d0.days + d1.days,\n    milliseconds: d0.milliseconds + d1.milliseconds\n  };\n}\n\nfunction subtractDurations(d1, d0) {\n  return {\n    years: d1.years - d0.years,\n    months: d1.months - d0.months,\n    days: d1.days - d0.days,\n    milliseconds: d1.milliseconds - d0.milliseconds\n  };\n}\n\nfunction multiplyDuration(d, n) {\n  return {\n    years: d.years * n,\n    months: d.months * n,\n    days: d.days * n,\n    milliseconds: d.milliseconds * n\n  };\n} // Conversions\n// \"Rough\" because they are based on average-case Gregorian months/years\n\n\nfunction asRoughYears(dur) {\n  return asRoughDays(dur) / 365;\n}\n\nfunction asRoughMonths(dur) {\n  return asRoughDays(dur) / 30;\n}\n\nfunction asRoughDays(dur) {\n  return asRoughMs(dur) / 864e5;\n}\n\nfunction asRoughMinutes(dur) {\n  return asRoughMs(dur) / (1000 * 60);\n}\n\nfunction asRoughSeconds(dur) {\n  return asRoughMs(dur) / 1000;\n}\n\nfunction asRoughMs(dur) {\n  return dur.years * (365 * 864e5) + dur.months * (30 * 864e5) + dur.days * 864e5 + dur.milliseconds;\n} // Advanced Math\n\n\nfunction wholeDivideDurations(numerator, denominator) {\n  var res = null;\n\n  for (var i = 0; i < INTERNAL_UNITS.length; i++) {\n    var unit = INTERNAL_UNITS[i];\n\n    if (denominator[unit]) {\n      var localRes = numerator[unit] / denominator[unit];\n\n      if (!isInt(localRes) || res !== null && res !== localRes) {\n        return null;\n      }\n\n      res = localRes;\n    } else if (numerator[unit]) {\n      // needs to divide by something but can't!\n      return null;\n    }\n  }\n\n  return res;\n}\n\nfunction greatestDurationDenominator(dur) {\n  var ms = dur.milliseconds;\n\n  if (ms) {\n    if (ms % 1000 !== 0) {\n      return {\n        unit: 'millisecond',\n        value: ms\n      };\n    }\n\n    if (ms % (1000 * 60) !== 0) {\n      return {\n        unit: 'second',\n        value: ms / 1000\n      };\n    }\n\n    if (ms % (1000 * 60 * 60) !== 0) {\n      return {\n        unit: 'minute',\n        value: ms / (1000 * 60)\n      };\n    }\n\n    if (ms) {\n      return {\n        unit: 'hour',\n        value: ms / (1000 * 60 * 60)\n      };\n    }\n  }\n\n  if (dur.days) {\n    if (dur.specifiedWeeks && dur.days % 7 === 0) {\n      return {\n        unit: 'week',\n        value: dur.days / 7\n      };\n    }\n\n    return {\n      unit: 'day',\n      value: dur.days\n    };\n  }\n\n  if (dur.months) {\n    return {\n      unit: 'month',\n      value: dur.months\n    };\n  }\n\n  if (dur.years) {\n    return {\n      unit: 'year',\n      value: dur.years\n    };\n  }\n\n  return {\n    unit: 'millisecond',\n    value: 0\n  };\n} // timeZoneOffset is in minutes\n\n\nfunction buildIsoString(marker, timeZoneOffset, stripZeroTime) {\n  if (stripZeroTime === void 0) {\n    stripZeroTime = false;\n  }\n\n  var s = marker.toISOString();\n  s = s.replace('.000', '');\n\n  if (stripZeroTime) {\n    s = s.replace('T00:00:00Z', '');\n  }\n\n  if (s.length > 10) {\n    // time part wasn't stripped, can add timezone info\n    if (timeZoneOffset == null) {\n      s = s.replace('Z', '');\n    } else if (timeZoneOffset !== 0) {\n      s = s.replace('Z', formatTimeZoneOffset(timeZoneOffset, true));\n    } // otherwise, its UTC-0 and we want to keep the Z\n\n  }\n\n  return s;\n} // formats the date, but with no time part\n// TODO: somehow merge with buildIsoString and stripZeroTime\n// TODO: rename. omit \"string\"\n\n\nfunction formatDayString(marker) {\n  return marker.toISOString().replace(/T.*$/, '');\n} // TODO: use Date::toISOString and use everything after the T?\n\n\nfunction formatIsoTimeString(marker) {\n  return padStart(marker.getUTCHours(), 2) + ':' + padStart(marker.getUTCMinutes(), 2) + ':' + padStart(marker.getUTCSeconds(), 2);\n}\n\nfunction formatTimeZoneOffset(minutes, doIso) {\n  if (doIso === void 0) {\n    doIso = false;\n  }\n\n  var sign = minutes < 0 ? '-' : '+';\n  var abs = Math.abs(minutes);\n  var hours = Math.floor(abs / 60);\n  var mins = Math.round(abs % 60);\n\n  if (doIso) {\n    return sign + padStart(hours, 2) + ':' + padStart(mins, 2);\n  } else {\n    return 'GMT' + sign + hours + (mins ? ':' + padStart(mins, 2) : '');\n  }\n}\n\nfunction memoize(workerFunc, resEquality, teardownFunc) {\n  var currentArgs;\n  var currentRes;\n  return function () {\n    var newArgs = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      newArgs[_i] = arguments[_i];\n    }\n\n    if (!currentArgs) {\n      currentRes = workerFunc.apply(this, newArgs);\n    } else if (!isArraysEqual(currentArgs, newArgs)) {\n      if (teardownFunc) {\n        teardownFunc(currentRes);\n      }\n\n      var res = workerFunc.apply(this, newArgs);\n\n      if (!resEquality || !resEquality(res, currentRes)) {\n        currentRes = res;\n      }\n    }\n\n    currentArgs = newArgs;\n    return currentRes;\n  };\n}\n\nfunction memoizeObjArg(workerFunc, resEquality, teardownFunc) {\n  var currentArg;\n  var currentRes;\n  return function (newArg) {\n    if (!currentArg) {\n      currentRes = workerFunc.call(this, newArg);\n    } else if (!isPropsEqual(currentArg, newArg)) {\n      if (teardownFunc) {\n        teardownFunc(currentRes);\n      }\n\n      var res = workerFunc.call(this, newArg);\n\n      if (!resEquality || !resEquality(res, currentRes)) {\n        currentRes = res;\n      }\n    }\n\n    currentArg = newArg;\n    return currentRes;\n  };\n}\n\nfunction memoizeArraylike( // used at all?\nworkerFunc, resEquality, teardownFunc) {\n  var currentArgSets = [];\n  var currentResults = [];\n  return function (newArgSets) {\n    var currentLen = currentArgSets.length;\n    var newLen = newArgSets.length;\n    var i = 0;\n\n    for (; i < currentLen; i++) {\n      if (!newArgSets[i]) {\n        // one of the old sets no longer exists\n        if (teardownFunc) {\n          teardownFunc(currentResults[i]);\n        }\n      } else if (!isArraysEqual(currentArgSets[i], newArgSets[i])) {\n        if (teardownFunc) {\n          teardownFunc(currentResults[i]);\n        }\n\n        var res = workerFunc.apply(this, newArgSets[i]);\n\n        if (!resEquality || !resEquality(res, currentResults[i])) {\n          currentResults[i] = res;\n        }\n      }\n    }\n\n    for (; i < newLen; i++) {\n      currentResults[i] = workerFunc.apply(this, newArgSets[i]);\n    }\n\n    currentArgSets = newArgSets;\n    currentResults.splice(newLen); // remove excess\n\n    return currentResults;\n  };\n}\n\nfunction memoizeHashlike( // used?\nworkerFunc, resEquality, teardownFunc // TODO: change arg order\n) {\n  var currentArgHash = {};\n  var currentResHash = {};\n  return function (newArgHash) {\n    var newResHash = {};\n\n    for (var key in newArgHash) {\n      if (!currentResHash[key]) {\n        newResHash[key] = workerFunc.apply(this, newArgHash[key]);\n      } else if (!isArraysEqual(currentArgHash[key], newArgHash[key])) {\n        if (teardownFunc) {\n          teardownFunc(currentResHash[key]);\n        }\n\n        var res = workerFunc.apply(this, newArgHash[key]);\n        newResHash[key] = resEquality && resEquality(res, currentResHash[key]) ? currentResHash[key] : res;\n      } else {\n        newResHash[key] = currentResHash[key];\n      }\n    }\n\n    currentArgHash = newArgHash;\n    currentResHash = newResHash;\n    return newResHash;\n  };\n}\n\nvar EXTENDED_SETTINGS_AND_SEVERITIES = {\n  week: 3,\n  separator: 0,\n  omitZeroMinute: 0,\n  meridiem: 0,\n  omitCommas: 0\n};\nvar STANDARD_DATE_PROP_SEVERITIES = {\n  timeZoneName: 7,\n  era: 6,\n  year: 5,\n  month: 4,\n  day: 2,\n  weekday: 2,\n  hour: 1,\n  minute: 1,\n  second: 1\n};\nvar MERIDIEM_RE = /\\s*([ap])\\.?m\\.?/i; // eats up leading spaces too\n\nvar COMMA_RE = /,/g; // we need re for globalness\n\nvar MULTI_SPACE_RE = /\\s+/g;\nvar LTR_RE = /\\u200e/g; // control character\n\nvar UTC_RE = /UTC|GMT/;\n\nvar NativeFormatter =\n/** @class */\nfunction () {\n  function NativeFormatter(formatSettings) {\n    var standardDateProps = {};\n    var extendedSettings = {};\n    var severity = 0;\n\n    for (var name_1 in formatSettings) {\n      if (name_1 in EXTENDED_SETTINGS_AND_SEVERITIES) {\n        extendedSettings[name_1] = formatSettings[name_1];\n        severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name_1], severity);\n      } else {\n        standardDateProps[name_1] = formatSettings[name_1];\n\n        if (name_1 in STANDARD_DATE_PROP_SEVERITIES) {\n          // TODO: what about hour12? no severity\n          severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name_1], severity);\n        }\n      }\n    }\n\n    this.standardDateProps = standardDateProps;\n    this.extendedSettings = extendedSettings;\n    this.severity = severity;\n    this.buildFormattingFunc = memoize(buildFormattingFunc);\n  }\n\n  NativeFormatter.prototype.format = function (date, context) {\n    return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);\n  };\n\n  NativeFormatter.prototype.formatRange = function (start, end, context) {\n    var _a = this,\n        standardDateProps = _a.standardDateProps,\n        extendedSettings = _a.extendedSettings;\n\n    var diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context.calendarSystem);\n\n    if (!diffSeverity) {\n      return this.format(start, context);\n    }\n\n    var biggestUnitForPartial = diffSeverity;\n\n    if (biggestUnitForPartial > 1 && ( // the two dates are different in a way that's larger scale than time\n    standardDateProps.year === 'numeric' || standardDateProps.year === '2-digit') && (standardDateProps.month === 'numeric' || standardDateProps.month === '2-digit') && (standardDateProps.day === 'numeric' || standardDateProps.day === '2-digit')) {\n      biggestUnitForPartial = 1; // make it look like the dates are only different in terms of time\n    }\n\n    var full0 = this.format(start, context);\n    var full1 = this.format(end, context);\n\n    if (full0 === full1) {\n      return full0;\n    }\n\n    var partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);\n    var partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);\n    var partial0 = partialFormattingFunc(start);\n    var partial1 = partialFormattingFunc(end);\n    var insertion = findCommonInsertion(full0, partial0, full1, partial1);\n    var separator = extendedSettings.separator || context.defaultSeparator || '';\n\n    if (insertion) {\n      return insertion.before + partial0 + separator + partial1 + insertion.after;\n    }\n\n    return full0 + separator + full1;\n  };\n\n  NativeFormatter.prototype.getLargestUnit = function () {\n    switch (this.severity) {\n      case 7:\n      case 6:\n      case 5:\n        return 'year';\n\n      case 4:\n        return 'month';\n\n      case 3:\n        return 'week';\n\n      case 2:\n        return 'day';\n\n      default:\n        return 'time';\n      // really?\n    }\n  };\n\n  return NativeFormatter;\n}();\n\nfunction buildFormattingFunc(standardDateProps, extendedSettings, context) {\n  var standardDatePropCnt = Object.keys(standardDateProps).length;\n\n  if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === 'short') {\n    return function (date) {\n      return formatTimeZoneOffset(date.timeZoneOffset);\n    };\n  }\n\n  if (standardDatePropCnt === 0 && extendedSettings.week) {\n    return function (date) {\n      return formatWeekNumber(context.computeWeekNumber(date.marker), context.weekText, context.locale, extendedSettings.week);\n    };\n  }\n\n  return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);\n}\n\nfunction buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {\n  standardDateProps = Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, standardDateProps); // copy\n\n  extendedSettings = Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, extendedSettings); // copy\n\n  sanitizeSettings(standardDateProps, extendedSettings);\n  standardDateProps.timeZone = 'UTC'; // we leverage the only guaranteed timeZone for our UTC markers\n\n  var normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);\n  var zeroFormat; // needed?\n\n  if (extendedSettings.omitZeroMinute) {\n    var zeroProps = Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, standardDateProps);\n\n    delete zeroProps.minute; // seconds and ms were already considered in sanitizeSettings\n\n    zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);\n  }\n\n  return function (date) {\n    var marker = date.marker;\n    var format;\n\n    if (zeroFormat && !marker.getUTCMinutes()) {\n      format = zeroFormat;\n    } else {\n      format = normalFormat;\n    }\n\n    var s = format.format(marker);\n    return postProcess(s, date, standardDateProps, extendedSettings, context);\n  };\n}\n\nfunction sanitizeSettings(standardDateProps, extendedSettings) {\n  // deal with a browser inconsistency where formatting the timezone\n  // requires that the hour/minute be present.\n  if (standardDateProps.timeZoneName) {\n    if (!standardDateProps.hour) {\n      standardDateProps.hour = '2-digit';\n    }\n\n    if (!standardDateProps.minute) {\n      standardDateProps.minute = '2-digit';\n    }\n  } // only support short timezone names\n\n\n  if (standardDateProps.timeZoneName === 'long') {\n    standardDateProps.timeZoneName = 'short';\n  } // if requesting to display seconds, MUST display minutes\n\n\n  if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {\n    delete extendedSettings.omitZeroMinute;\n  }\n}\n\nfunction postProcess(s, date, standardDateProps, extendedSettings, context) {\n  s = s.replace(LTR_RE, ''); // remove left-to-right control chars. do first. good for other regexes\n\n  if (standardDateProps.timeZoneName === 'short') {\n    s = injectTzoStr(s, context.timeZone === 'UTC' || date.timeZoneOffset == null ? 'UTC' : // important to normalize for IE, which does \"GMT\"\n    formatTimeZoneOffset(date.timeZoneOffset));\n  }\n\n  if (extendedSettings.omitCommas) {\n    s = s.replace(COMMA_RE, '').trim();\n  }\n\n  if (extendedSettings.omitZeroMinute) {\n    s = s.replace(':00', ''); // zeroFormat doesn't always achieve this\n  } // ^ do anything that might create adjacent spaces before this point,\n  // because MERIDIEM_RE likes to eat up loading spaces\n\n\n  if (extendedSettings.meridiem === false) {\n    s = s.replace(MERIDIEM_RE, '').trim();\n  } else if (extendedSettings.meridiem === 'narrow') {\n    // a/p\n    s = s.replace(MERIDIEM_RE, function (m0, m1) {\n      return m1.toLocaleLowerCase();\n    });\n  } else if (extendedSettings.meridiem === 'short') {\n    // am/pm\n    s = s.replace(MERIDIEM_RE, function (m0, m1) {\n      return m1.toLocaleLowerCase() + 'm';\n    });\n  } else if (extendedSettings.meridiem === 'lowercase') {\n    // other meridiem transformers already converted to lowercase\n    s = s.replace(MERIDIEM_RE, function (m0) {\n      return m0.toLocaleLowerCase();\n    });\n  }\n\n  s = s.replace(MULTI_SPACE_RE, ' ');\n  s = s.trim();\n  return s;\n}\n\nfunction injectTzoStr(s, tzoStr) {\n  var replaced = false;\n  s = s.replace(UTC_RE, function () {\n    replaced = true;\n    return tzoStr;\n  }); // IE11 doesn't include UTC/GMT in the original string, so append to end\n\n  if (!replaced) {\n    s += ' ' + tzoStr;\n  }\n\n  return s;\n}\n\nfunction formatWeekNumber(num, weekText, locale, display) {\n  var parts = [];\n\n  if (display === 'narrow') {\n    parts.push(weekText);\n  } else if (display === 'short') {\n    parts.push(weekText, ' ');\n  } // otherwise, considered 'numeric'\n\n\n  parts.push(locale.simpleNumberFormat.format(num));\n\n  if (locale.options.direction === 'rtl') {\n    // TODO: use control characters instead?\n    parts.reverse();\n  }\n\n  return parts.join('');\n} // Range Formatting Utils\n// 0 = exactly the same\n// 1 = different by time\n// and bigger\n\n\nfunction computeMarkerDiffSeverity(d0, d1, ca) {\n  if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {\n    return 5;\n  }\n\n  if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {\n    return 4;\n  }\n\n  if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {\n    return 2;\n  }\n\n  if (timeAsMs(d0) !== timeAsMs(d1)) {\n    return 1;\n  }\n\n  return 0;\n}\n\nfunction computePartialFormattingOptions(options, biggestUnit) {\n  var partialOptions = {};\n\n  for (var name_2 in options) {\n    if (!(name_2 in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)\n    STANDARD_DATE_PROP_SEVERITIES[name_2] <= biggestUnit) {\n      partialOptions[name_2] = options[name_2];\n    }\n  }\n\n  return partialOptions;\n}\n\nfunction findCommonInsertion(full0, partial0, full1, partial1) {\n  var i0 = 0;\n\n  while (i0 < full0.length) {\n    var found0 = full0.indexOf(partial0, i0);\n\n    if (found0 === -1) {\n      break;\n    }\n\n    var before0 = full0.substr(0, found0);\n    i0 = found0 + partial0.length;\n    var after0 = full0.substr(i0);\n    var i1 = 0;\n\n    while (i1 < full1.length) {\n      var found1 = full1.indexOf(partial1, i1);\n\n      if (found1 === -1) {\n        break;\n      }\n\n      var before1 = full1.substr(0, found1);\n      i1 = found1 + partial1.length;\n      var after1 = full1.substr(i1);\n\n      if (before0 === before1 && after0 === after1) {\n        return {\n          before: before0,\n          after: after0\n        };\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction expandZonedMarker(dateInfo, calendarSystem) {\n  var a = calendarSystem.markerToArray(dateInfo.marker);\n  return {\n    marker: dateInfo.marker,\n    timeZoneOffset: dateInfo.timeZoneOffset,\n    array: a,\n    year: a[0],\n    month: a[1],\n    day: a[2],\n    hour: a[3],\n    minute: a[4],\n    second: a[5],\n    millisecond: a[6]\n  };\n}\n\nfunction createVerboseFormattingArg(start, end, context, separator) {\n  var startInfo = expandZonedMarker(start, context.calendarSystem);\n  var endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;\n  return {\n    date: startInfo,\n    start: startInfo,\n    end: endInfo,\n    timeZone: context.timeZone,\n    localeCodes: context.locale.codes,\n    separator: separator\n  };\n}\n/*\nTODO: fix the terminology of \"formatter\" vs \"formatting func\"\n*/\n\n/*\nAt the time of instantiation, this object does not know which cmd-formatting system it will use.\nIt receives this at the time of formatting, as a setting.\n*/\n\n\nvar CmdFormatter =\n/** @class */\nfunction () {\n  function CmdFormatter(cmdStr, separator) {\n    this.cmdStr = cmdStr;\n    this.separator = separator;\n  }\n\n  CmdFormatter.prototype.format = function (date, context) {\n    return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, this.separator));\n  };\n\n  CmdFormatter.prototype.formatRange = function (start, end, context) {\n    return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context, this.separator));\n  };\n\n  return CmdFormatter;\n}();\n\nvar FuncFormatter =\n/** @class */\nfunction () {\n  function FuncFormatter(func) {\n    this.func = func;\n  }\n\n  FuncFormatter.prototype.format = function (date, context) {\n    return this.func(createVerboseFormattingArg(date, null, context));\n  };\n\n  FuncFormatter.prototype.formatRange = function (start, end, context) {\n    return this.func(createVerboseFormattingArg(start, end, context));\n  };\n\n  return FuncFormatter;\n}();\n\nfunction createFormatter(input, defaultSeparator) {\n  if (_typeof(input) === 'object' && input) {\n    // non-null object\n    if (typeof defaultSeparator === 'string') {\n      input = Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({\n        separator: defaultSeparator\n      }, input);\n    }\n\n    return new NativeFormatter(input);\n  } else if (typeof input === 'string') {\n    return new CmdFormatter(input, defaultSeparator);\n  } else if (typeof input === 'function') {\n    return new FuncFormatter(input);\n  }\n} // base options\n// ------------\n\n\nvar BASE_OPTION_REFINERS = {\n  navLinkDayClick: identity,\n  navLinkWeekClick: identity,\n  duration: createDuration,\n  bootstrapFontAwesome: identity,\n  buttonIcons: identity,\n  customButtons: identity,\n  defaultAllDayEventDuration: createDuration,\n  defaultTimedEventDuration: createDuration,\n  nextDayThreshold: createDuration,\n  scrollTime: createDuration,\n  slotMinTime: createDuration,\n  slotMaxTime: createDuration,\n  dayPopoverFormat: createFormatter,\n  slotDuration: createDuration,\n  snapDuration: createDuration,\n  headerToolbar: identity,\n  footerToolbar: identity,\n  defaultRangeSeparator: String,\n  titleRangeSeparator: String,\n  forceEventDuration: Boolean,\n  dayHeaders: Boolean,\n  dayHeaderFormat: createFormatter,\n  dayHeaderClassNames: identity,\n  dayHeaderContent: identity,\n  dayHeaderDidMount: identity,\n  dayHeaderWillUnmount: identity,\n  dayCellClassNames: identity,\n  dayCellContent: identity,\n  dayCellDidMount: identity,\n  dayCellWillUnmount: identity,\n  initialView: String,\n  aspectRatio: Number,\n  weekends: Boolean,\n  weekNumberCalculation: identity,\n  weekNumbers: Boolean,\n  weekNumberClassNames: identity,\n  weekNumberContent: identity,\n  weekNumberDidMount: identity,\n  weekNumberWillUnmount: identity,\n  editable: Boolean,\n  viewClassNames: identity,\n  viewDidMount: identity,\n  viewWillUnmount: identity,\n  nowIndicator: Boolean,\n  nowIndicatorClassNames: identity,\n  nowIndicatorContent: identity,\n  nowIndicatorDidMount: identity,\n  nowIndicatorWillUnmount: identity,\n  showNonCurrentDates: Boolean,\n  lazyFetching: Boolean,\n  startParam: String,\n  endParam: String,\n  timeZoneParam: String,\n  timeZone: String,\n  locales: identity,\n  locale: identity,\n  themeSystem: String,\n  dragRevertDuration: Number,\n  dragScroll: Boolean,\n  allDayMaintainDuration: Boolean,\n  unselectAuto: Boolean,\n  dropAccept: identity,\n  eventOrder: parseFieldSpecs,\n  handleWindowResize: Boolean,\n  windowResizeDelay: Number,\n  longPressDelay: Number,\n  eventDragMinDistance: Number,\n  expandRows: Boolean,\n  height: identity,\n  contentHeight: identity,\n  direction: String,\n  weekNumberFormat: createFormatter,\n  eventResizableFromStart: Boolean,\n  displayEventTime: Boolean,\n  displayEventEnd: Boolean,\n  weekText: String,\n  progressiveEventRendering: Boolean,\n  businessHours: identity,\n  initialDate: identity,\n  now: identity,\n  eventDataTransform: identity,\n  stickyHeaderDates: identity,\n  stickyFooterScrollbar: identity,\n  viewHeight: identity,\n  defaultAllDay: Boolean,\n  eventSourceFailure: identity,\n  eventSourceSuccess: identity,\n  eventDisplay: String,\n  eventStartEditable: Boolean,\n  eventDurationEditable: Boolean,\n  eventOverlap: identity,\n  eventConstraint: identity,\n  eventAllow: identity,\n  eventBackgroundColor: String,\n  eventBorderColor: String,\n  eventTextColor: String,\n  eventColor: String,\n  eventClassNames: identity,\n  eventContent: identity,\n  eventDidMount: identity,\n  eventWillUnmount: identity,\n  selectConstraint: identity,\n  selectOverlap: identity,\n  selectAllow: identity,\n  droppable: Boolean,\n  unselectCancel: String,\n  slotLabelFormat: identity,\n  slotLaneClassNames: identity,\n  slotLaneContent: identity,\n  slotLaneDidMount: identity,\n  slotLaneWillUnmount: identity,\n  slotLabelClassNames: identity,\n  slotLabelContent: identity,\n  slotLabelDidMount: identity,\n  slotLabelWillUnmount: identity,\n  dayMaxEvents: identity,\n  dayMaxEventRows: identity,\n  dayMinWidth: Number,\n  slotLabelInterval: createDuration,\n  allDayText: String,\n  allDayClassNames: identity,\n  allDayContent: identity,\n  allDayDidMount: identity,\n  allDayWillUnmount: identity,\n  slotMinWidth: Number,\n  navLinks: Boolean,\n  eventTimeFormat: createFormatter,\n  rerenderDelay: Number,\n  moreLinkText: identity,\n  selectMinDistance: Number,\n  selectable: Boolean,\n  selectLongPressDelay: Number,\n  eventLongPressDelay: Number,\n  selectMirror: Boolean,\n  eventMinHeight: Number,\n  slotEventOverlap: Boolean,\n  plugins: identity,\n  firstDay: Number,\n  dayCount: Number,\n  dateAlignment: String,\n  dateIncrement: createDuration,\n  hiddenDays: identity,\n  monthMode: Boolean,\n  fixedWeekCount: Boolean,\n  validRange: identity,\n  visibleRange: identity,\n  titleFormat: identity,\n  // only used by list-view, but languages define the value, so we need it in base options\n  noEventsText: String\n}; // do NOT give a type here. need `typeof BASE_OPTION_DEFAULTS` to give real results.\n// raw values.\n\nvar BASE_OPTION_DEFAULTS = {\n  eventDisplay: 'auto',\n  defaultRangeSeparator: ' - ',\n  titleRangeSeparator: \" \\u2013 \",\n  defaultTimedEventDuration: '01:00:00',\n  defaultAllDayEventDuration: {\n    day: 1\n  },\n  forceEventDuration: false,\n  nextDayThreshold: '00:00:00',\n  dayHeaders: true,\n  initialView: '',\n  aspectRatio: 1.35,\n  headerToolbar: {\n    start: 'title',\n    center: '',\n    end: 'today prev,next'\n  },\n  weekends: true,\n  weekNumbers: false,\n  weekNumberCalculation: 'local',\n  editable: false,\n  nowIndicator: false,\n  scrollTime: '06:00:00',\n  slotMinTime: '00:00:00',\n  slotMaxTime: '24:00:00',\n  showNonCurrentDates: true,\n  lazyFetching: true,\n  startParam: 'start',\n  endParam: 'end',\n  timeZoneParam: 'timeZone',\n  timeZone: 'local',\n  locales: [],\n  locale: '',\n  themeSystem: 'standard',\n  dragRevertDuration: 500,\n  dragScroll: true,\n  allDayMaintainDuration: false,\n  unselectAuto: true,\n  dropAccept: '*',\n  eventOrder: 'start,-duration,allDay,title',\n  dayPopoverFormat: {\n    month: 'long',\n    day: 'numeric',\n    year: 'numeric'\n  },\n  handleWindowResize: true,\n  windowResizeDelay: 100,\n  longPressDelay: 1000,\n  eventDragMinDistance: 5,\n  expandRows: false,\n  navLinks: false,\n  selectable: false\n}; // calendar listeners\n// ------------------\n\nvar CALENDAR_LISTENER_REFINERS = {\n  datesSet: identity,\n  eventsSet: identity,\n  eventAdd: identity,\n  eventChange: identity,\n  eventRemove: identity,\n  windowResize: identity,\n  eventClick: identity,\n  eventMouseEnter: identity,\n  eventMouseLeave: identity,\n  select: identity,\n  unselect: identity,\n  loading: identity,\n  // internal\n  _unmount: identity,\n  _beforeprint: identity,\n  _afterprint: identity,\n  _noEventDrop: identity,\n  _noEventResize: identity,\n  _resize: identity,\n  _scrollRequest: identity\n}; // calendar-specific options\n// -------------------------\n\nvar CALENDAR_OPTION_REFINERS = {\n  buttonText: identity,\n  views: identity,\n  plugins: identity,\n  initialEvents: identity,\n  events: identity,\n  eventSources: identity\n};\nvar COMPLEX_OPTION_COMPARATORS = {\n  headerToolbar: isBoolComplexEqual,\n  footerToolbar: isBoolComplexEqual,\n  buttonText: isBoolComplexEqual,\n  buttonIcons: isBoolComplexEqual\n};\n\nfunction isBoolComplexEqual(a, b) {\n  if (_typeof(a) === 'object' && _typeof(b) === 'object' && a && b) {\n    // both non-null objects\n    return isPropsEqual(a, b);\n  } else {\n    return a === b;\n  }\n} // view-specific options\n// ---------------------\n\n\nvar VIEW_OPTION_REFINERS = {\n  type: String,\n  component: identity,\n  buttonText: String,\n  buttonTextKey: String,\n  dateProfileGeneratorClass: identity,\n  usesMinMaxTime: Boolean,\n  classNames: identity,\n  content: identity,\n  didMount: identity,\n  willUnmount: identity\n}; // util funcs\n// ----------------------------------------------------------------------------------------------------\n\nfunction mergeRawOptions(optionSets) {\n  return mergeProps(optionSets, COMPLEX_OPTION_COMPARATORS);\n}\n\nfunction refineProps(input, refiners) {\n  var refined = {};\n  var extra = {};\n\n  for (var propName in refiners) {\n    if (propName in input) {\n      refined[propName] = refiners[propName](input[propName]);\n    }\n  }\n\n  for (var propName in input) {\n    if (!(propName in refiners)) {\n      extra[propName] = input[propName];\n    }\n  }\n\n  return {\n    refined: refined,\n    extra: extra\n  };\n}\n\nfunction identity(raw) {\n  return raw;\n}\n\nfunction parseEvents(rawEvents, eventSource, context, allowOpenRange) {\n  var eventStore = createEmptyEventStore();\n  var eventRefiners = buildEventRefiners(context);\n\n  for (var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++) {\n    var rawEvent = rawEvents_1[_i];\n    var tuple = parseEvent(rawEvent, eventSource, context, allowOpenRange, eventRefiners);\n\n    if (tuple) {\n      eventTupleToStore(tuple, eventStore);\n    }\n  }\n\n  return eventStore;\n}\n\nfunction eventTupleToStore(tuple, eventStore) {\n  if (eventStore === void 0) {\n    eventStore = createEmptyEventStore();\n  }\n\n  eventStore.defs[tuple.def.defId] = tuple.def;\n\n  if (tuple.instance) {\n    eventStore.instances[tuple.instance.instanceId] = tuple.instance;\n  }\n\n  return eventStore;\n} // retrieves events that have the same groupId as the instance specified by `instanceId`\n// or they are the same as the instance.\n// why might instanceId not be in the store? an event from another calendar?\n\n\nfunction getRelevantEvents(eventStore, instanceId) {\n  var instance = eventStore.instances[instanceId];\n\n  if (instance) {\n    var def_1 = eventStore.defs[instance.defId]; // get events/instances with same group\n\n    var newStore = filterEventStoreDefs(eventStore, function (lookDef) {\n      return isEventDefsGrouped(def_1, lookDef);\n    }); // add the original\n    // TODO: wish we could use eventTupleToStore or something like it\n\n    newStore.defs[def_1.defId] = def_1;\n    newStore.instances[instance.instanceId] = instance;\n    return newStore;\n  }\n\n  return createEmptyEventStore();\n}\n\nfunction isEventDefsGrouped(def0, def1) {\n  return Boolean(def0.groupId && def0.groupId === def1.groupId);\n}\n\nfunction createEmptyEventStore() {\n  return {\n    defs: {},\n    instances: {}\n  };\n}\n\nfunction mergeEventStores(store0, store1) {\n  return {\n    defs: Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, store0.defs), store1.defs),\n    instances: Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, store0.instances), store1.instances)\n  };\n}\n\nfunction filterEventStoreDefs(eventStore, filterFunc) {\n  var defs = filterHash(eventStore.defs, filterFunc);\n  var instances = filterHash(eventStore.instances, function (instance) {\n    return defs[instance.defId]; // still exists?\n  });\n  return {\n    defs: defs,\n    instances: instances\n  };\n}\n\nfunction excludeSubEventStore(master, sub) {\n  var defs = master.defs,\n      instances = master.instances;\n  var filteredDefs = {};\n  var filteredInstances = {};\n\n  for (var defId in defs) {\n    if (!sub.defs[defId]) {\n      // not explicitly excluded\n      filteredDefs[defId] = defs[defId];\n    }\n  }\n\n  for (var instanceId in instances) {\n    if (!sub.instances[instanceId] && // not explicitly excluded\n    filteredDefs[instances[instanceId].defId] // def wasn't filtered away\n    ) {\n        filteredInstances[instanceId] = instances[instanceId];\n      }\n  }\n\n  return {\n    defs: filteredDefs,\n    instances: filteredInstances\n  };\n}\n\nfunction normalizeConstraint(input, context) {\n  if (Array.isArray(input)) {\n    return parseEvents(input, null, context, true); // allowOpenRange=true\n  } else if (_typeof(input) === 'object' && input) {\n    // non-null object\n    return parseEvents([input], null, context, true); // allowOpenRange=true\n  } else if (input != null) {\n    return String(input);\n  } else {\n    return null;\n  }\n}\n\nfunction parseClassNames(raw) {\n  if (Array.isArray(raw)) {\n    return raw;\n  } else if (typeof raw === 'string') {\n    return raw.split(/\\s+/);\n  } else {\n    return [];\n  }\n} // TODO: better called \"EventSettings\" or \"EventConfig\"\n// TODO: move this file into structs\n// TODO: separate constraint/overlap/allow, because selection uses only that, not other props\n\n\nvar EVENT_UI_REFINERS = {\n  display: String,\n  editable: Boolean,\n  startEditable: Boolean,\n  durationEditable: Boolean,\n  constraint: identity,\n  overlap: identity,\n  allow: identity,\n  className: parseClassNames,\n  classNames: parseClassNames,\n  color: String,\n  backgroundColor: String,\n  borderColor: String,\n  textColor: String\n};\n\nfunction createEventUi(refined, context) {\n  var constraint = normalizeConstraint(refined.constraint, context);\n  return {\n    display: refined.display || null,\n    startEditable: refined.startEditable != null ? refined.startEditable : refined.editable,\n    durationEditable: refined.durationEditable != null ? refined.durationEditable : refined.editable,\n    constraints: constraint != null ? [constraint] : [],\n    overlap: refined.overlap != null ? refined.overlap : null,\n    allows: refined.allow != null ? [refined.allow] : [],\n    backgroundColor: refined.backgroundColor || refined.color || '',\n    borderColor: refined.borderColor || refined.color || '',\n    textColor: refined.textColor || '',\n    classNames: (refined.className || []).concat(refined.classNames || []) // join singular and plural\n\n  };\n} // TODO: prevent against problems with <2 args!\n\n\nfunction combineEventUis(uis) {\n  return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);\n}\n\nfunction combineTwoEventUis(item0, item1) {\n  return {\n    display: item1.display != null ? item1.display : item0.display,\n    startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,\n    durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,\n    constraints: item0.constraints.concat(item1.constraints),\n    overlap: typeof item1.overlap === 'boolean' ? item1.overlap : item0.overlap,\n    allows: item0.allows.concat(item1.allows),\n    backgroundColor: item1.backgroundColor || item0.backgroundColor,\n    borderColor: item1.borderColor || item0.borderColor,\n    textColor: item1.textColor || item0.textColor,\n    classNames: item0.classNames.concat(item1.classNames)\n  };\n}\n\nvar EMPTY_EVENT_UI = {\n  display: null,\n  startEditable: null,\n  durationEditable: null,\n  constraints: [],\n  overlap: null,\n  allows: [],\n  backgroundColor: '',\n  borderColor: '',\n  textColor: '',\n  classNames: []\n};\nvar EVENT_NON_DATE_REFINERS = {\n  id: String,\n  groupId: String,\n  title: String,\n  url: String\n};\nvar EVENT_DATE_REFINERS = {\n  start: identity,\n  end: identity,\n  date: identity,\n  allDay: Boolean\n};\n\nvar EVENT_REFINERS = Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, EVENT_NON_DATE_REFINERS), EVENT_DATE_REFINERS), {\n  extendedProps: identity\n});\n\nfunction parseEvent(raw, eventSource, context, allowOpenRange, refiners) {\n  if (refiners === void 0) {\n    refiners = buildEventRefiners(context);\n  }\n\n  var _a = refineEventDef(raw, context, refiners),\n      refined = _a.refined,\n      extra = _a.extra;\n\n  var defaultAllDay = computeIsDefaultAllDay(eventSource, context);\n  var recurringRes = parseRecurring(refined, defaultAllDay, context.dateEnv, context.pluginHooks.recurringTypes);\n\n  if (recurringRes) {\n    var def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : '', recurringRes.allDay, Boolean(recurringRes.duration), context);\n    def.recurringDef = {\n      typeId: recurringRes.typeId,\n      typeData: recurringRes.typeData,\n      duration: recurringRes.duration\n    };\n    return {\n      def: def,\n      instance: null\n    };\n  } else {\n    var singleRes = parseSingle(refined, defaultAllDay, context, allowOpenRange);\n\n    if (singleRes) {\n      var def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : '', singleRes.allDay, singleRes.hasEnd, context);\n      var instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);\n      return {\n        def: def,\n        instance: instance\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction refineEventDef(raw, context, refiners) {\n  if (refiners === void 0) {\n    refiners = buildEventRefiners(context);\n  }\n\n  return refineProps(raw, refiners);\n}\n\nfunction buildEventRefiners(context) {\n  return Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, EVENT_UI_REFINERS), EVENT_REFINERS), context.pluginHooks.eventRefiners);\n}\n/*\nWill NOT populate extendedProps with the leftover properties.\nWill NOT populate date-related props.\n*/\n\n\nfunction parseEventDef(refined, extra, sourceId, allDay, hasEnd, context) {\n  var def = {\n    title: refined.title || '',\n    groupId: refined.groupId || '',\n    publicId: refined.id || '',\n    url: refined.url || '',\n    recurringDef: null,\n    defId: guid(),\n    sourceId: sourceId,\n    allDay: allDay,\n    hasEnd: hasEnd,\n    ui: createEventUi(refined, context),\n    extendedProps: Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, refined.extendedProps || {}), extra)\n  };\n\n  for (var _i = 0, _a = context.pluginHooks.eventDefMemberAdders; _i < _a.length; _i++) {\n    var memberAdder = _a[_i];\n\n    Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(def, memberAdder(refined));\n  } // help out EventApi from having user modify props\n\n\n  Object.freeze(def.ui.classNames);\n  Object.freeze(def.extendedProps);\n  return def;\n}\n\nfunction parseSingle(refined, defaultAllDay, context, allowOpenRange) {\n  var allDay = refined.allDay;\n  var startMeta;\n  var startMarker = null;\n  var hasEnd = false;\n  var endMeta;\n  var endMarker = null;\n  var startInput = refined.start != null ? refined.start : refined.date;\n  startMeta = context.dateEnv.createMarkerMeta(startInput);\n\n  if (startMeta) {\n    startMarker = startMeta.marker;\n  } else if (!allowOpenRange) {\n    return null;\n  }\n\n  if (refined.end != null) {\n    endMeta = context.dateEnv.createMarkerMeta(refined.end);\n  }\n\n  if (allDay == null) {\n    if (defaultAllDay != null) {\n      allDay = defaultAllDay;\n    } else {\n      // fall back to the date props LAST\n      allDay = (!startMeta || startMeta.isTimeUnspecified) && (!endMeta || endMeta.isTimeUnspecified);\n    }\n  }\n\n  if (allDay && startMarker) {\n    startMarker = startOfDay(startMarker);\n  }\n\n  if (endMeta) {\n    endMarker = endMeta.marker;\n\n    if (allDay) {\n      endMarker = startOfDay(endMarker);\n    }\n\n    if (startMarker && endMarker <= startMarker) {\n      endMarker = null;\n    }\n  }\n\n  if (endMarker) {\n    hasEnd = true;\n  } else if (!allowOpenRange) {\n    hasEnd = context.options.forceEventDuration || false;\n    endMarker = context.dateEnv.add(startMarker, allDay ? context.options.defaultAllDayEventDuration : context.options.defaultTimedEventDuration);\n  }\n\n  return {\n    allDay: allDay,\n    hasEnd: hasEnd,\n    range: {\n      start: startMarker,\n      end: endMarker\n    },\n    forcedStartTzo: startMeta ? startMeta.forcedTzo : null,\n    forcedEndTzo: endMeta ? endMeta.forcedTzo : null\n  };\n}\n\nfunction computeIsDefaultAllDay(eventSource, context) {\n  var res = null;\n\n  if (eventSource) {\n    res = eventSource.defaultAllDay;\n  }\n\n  if (res == null) {\n    res = context.options.defaultAllDay;\n  }\n\n  return res;\n}\n/* Date stuff that doesn't belong in datelib core\n----------------------------------------------------------------------------------------------------------------------*/\n// given a timed range, computes an all-day range that has the same exact duration,\n// but whose start time is aligned with the start of the day.\n\n\nfunction computeAlignedDayRange(timedRange) {\n  var dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;\n  var start = startOfDay(timedRange.start);\n  var end = addDays(start, dayCnt);\n  return {\n    start: start,\n    end: end\n  };\n} // given a timed range, computes an all-day range based on how for the end date bleeds into the next day\n// TODO: give nextDayThreshold a default arg\n\n\nfunction computeVisibleDayRange(timedRange, nextDayThreshold) {\n  if (nextDayThreshold === void 0) {\n    nextDayThreshold = createDuration(0);\n  }\n\n  var startDay = null;\n  var endDay = null;\n\n  if (timedRange.end) {\n    endDay = startOfDay(timedRange.end);\n    var endTimeMS = timedRange.end.valueOf() - endDay.valueOf(); // # of milliseconds into `endDay`\n    // If the end time is actually inclusively part of the next day and is equal to or\n    // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.\n    // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.\n\n    if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {\n      endDay = addDays(endDay, 1);\n    }\n  }\n\n  if (timedRange.start) {\n    startDay = startOfDay(timedRange.start); // the beginning of the day the range starts\n    // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.\n\n    if (endDay && endDay <= startDay) {\n      endDay = addDays(startDay, 1);\n    }\n  }\n\n  return {\n    start: startDay,\n    end: endDay\n  };\n} // spans from one day into another?\n\n\nfunction isMultiDayRange(range) {\n  var visibleRange = computeVisibleDayRange(range);\n  return diffDays(visibleRange.start, visibleRange.end) > 1;\n}\n\nfunction diffDates(date0, date1, dateEnv, largeUnit) {\n  if (largeUnit === 'year') {\n    return createDuration(dateEnv.diffWholeYears(date0, date1), 'year');\n  } else if (largeUnit === 'month') {\n    return createDuration(dateEnv.diffWholeMonths(date0, date1), 'month');\n  } else {\n    return diffDayAndTime(date0, date1); // returns a duration\n  }\n}\n\nfunction parseRange(input, dateEnv) {\n  var start = null;\n  var end = null;\n\n  if (input.start) {\n    start = dateEnv.createMarker(input.start);\n  }\n\n  if (input.end) {\n    end = dateEnv.createMarker(input.end);\n  }\n\n  if (!start && !end) {\n    return null;\n  }\n\n  if (start && end && end < start) {\n    return null;\n  }\n\n  return {\n    start: start,\n    end: end\n  };\n} // SIDE-EFFECT: will mutate ranges.\n// Will return a new array result.\n\n\nfunction invertRanges(ranges, constraintRange) {\n  var invertedRanges = [];\n  var start = constraintRange.start; // the end of the previous range. the start of the new range\n\n  var i;\n  var dateRange; // ranges need to be in order. required for our date-walking algorithm\n\n  ranges.sort(compareRanges);\n\n  for (i = 0; i < ranges.length; i++) {\n    dateRange = ranges[i]; // add the span of time before the event (if there is any)\n\n    if (dateRange.start > start) {\n      // compare millisecond time (skip any ambig logic)\n      invertedRanges.push({\n        start: start,\n        end: dateRange.start\n      });\n    }\n\n    if (dateRange.end > start) {\n      start = dateRange.end;\n    }\n  } // add the span of time after the last event (if there is any)\n\n\n  if (start < constraintRange.end) {\n    // compare millisecond time (skip any ambig logic)\n    invertedRanges.push({\n      start: start,\n      end: constraintRange.end\n    });\n  }\n\n  return invertedRanges;\n}\n\nfunction compareRanges(range0, range1) {\n  return range0.start.valueOf() - range1.start.valueOf(); // earlier ranges go first\n}\n\nfunction intersectRanges(range0, range1) {\n  var start = range0.start;\n  var end = range0.end;\n  var newRange = null;\n\n  if (range1.start !== null) {\n    if (start === null) {\n      start = range1.start;\n    } else {\n      start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));\n    }\n  }\n\n  if (range1.end != null) {\n    if (end === null) {\n      end = range1.end;\n    } else {\n      end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));\n    }\n  }\n\n  if (start === null || end === null || start < end) {\n    newRange = {\n      start: start,\n      end: end\n    };\n  }\n\n  return newRange;\n}\n\nfunction rangesEqual(range0, range1) {\n  return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) && (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());\n}\n\nfunction rangesIntersect(range0, range1) {\n  return (range0.end === null || range1.start === null || range0.end > range1.start) && (range0.start === null || range1.end === null || range0.start < range1.end);\n}\n\nfunction rangeContainsRange(outerRange, innerRange) {\n  return (outerRange.start === null || innerRange.start !== null && innerRange.start >= outerRange.start) && (outerRange.end === null || innerRange.end !== null && innerRange.end <= outerRange.end);\n}\n\nfunction rangeContainsMarker(range, date) {\n  return (range.start === null || date >= range.start) && (range.end === null || date < range.end);\n} // If the given date is not within the given range, move it inside.\n// (If it's past the end, make it one millisecond before the end).\n\n\nfunction constrainMarkerToRange(date, range) {\n  if (range.start != null && date < range.start) {\n    return range.start;\n  }\n\n  if (range.end != null && date >= range.end) {\n    return new Date(range.end.valueOf() - 1);\n  }\n\n  return date;\n}\n/*\nSpecifying nextDayThreshold signals that all-day ranges should be sliced.\n*/\n\n\nfunction sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {\n  var inverseBgByGroupId = {};\n  var inverseBgByDefId = {};\n  var defByGroupId = {};\n  var bgRanges = [];\n  var fgRanges = [];\n  var eventUis = compileEventUis(eventStore.defs, eventUiBases);\n\n  for (var defId in eventStore.defs) {\n    var def = eventStore.defs[defId];\n    var ui = eventUis[def.defId];\n\n    if (ui.display === 'inverse-background') {\n      if (def.groupId) {\n        inverseBgByGroupId[def.groupId] = [];\n\n        if (!defByGroupId[def.groupId]) {\n          defByGroupId[def.groupId] = def;\n        }\n      } else {\n        inverseBgByDefId[defId] = [];\n      }\n    }\n  }\n\n  for (var instanceId in eventStore.instances) {\n    var instance = eventStore.instances[instanceId];\n    var def = eventStore.defs[instance.defId];\n    var ui = eventUis[def.defId];\n    var origRange = instance.range;\n    var normalRange = !def.allDay && nextDayThreshold ? computeVisibleDayRange(origRange, nextDayThreshold) : origRange;\n    var slicedRange = intersectRanges(normalRange, framingRange);\n\n    if (slicedRange) {\n      if (ui.display === 'inverse-background') {\n        if (def.groupId) {\n          inverseBgByGroupId[def.groupId].push(slicedRange);\n        } else {\n          inverseBgByDefId[instance.defId].push(slicedRange);\n        }\n      } else if (ui.display !== 'none') {\n        (ui.display === 'background' ? bgRanges : fgRanges).push({\n          def: def,\n          ui: ui,\n          instance: instance,\n          range: slicedRange,\n          isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),\n          isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf()\n        });\n      }\n    }\n  }\n\n  for (var groupId in inverseBgByGroupId) {\n    // BY GROUP\n    var ranges = inverseBgByGroupId[groupId];\n    var invertedRanges = invertRanges(ranges, framingRange);\n\n    for (var _i = 0, invertedRanges_1 = invertedRanges; _i < invertedRanges_1.length; _i++) {\n      var invertedRange = invertedRanges_1[_i];\n      var def = defByGroupId[groupId];\n      var ui = eventUis[def.defId];\n      bgRanges.push({\n        def: def,\n        ui: ui,\n        instance: null,\n        range: invertedRange,\n        isStart: false,\n        isEnd: false\n      });\n    }\n  }\n\n  for (var defId in inverseBgByDefId) {\n    var ranges = inverseBgByDefId[defId];\n    var invertedRanges = invertRanges(ranges, framingRange);\n\n    for (var _a = 0, invertedRanges_2 = invertedRanges; _a < invertedRanges_2.length; _a++) {\n      var invertedRange = invertedRanges_2[_a];\n      bgRanges.push({\n        def: eventStore.defs[defId],\n        ui: eventUis[defId],\n        instance: null,\n        range: invertedRange,\n        isStart: false,\n        isEnd: false\n      });\n    }\n  }\n\n  return {\n    bg: bgRanges,\n    fg: fgRanges\n  };\n}\n\nfunction hasBgRendering(def) {\n  return def.ui.display === 'background' || def.ui.display === 'inverse-background';\n}\n\nfunction setElSeg(el, seg) {\n  el.fcSeg = seg;\n}\n\nfunction getElSeg(el) {\n  return el.fcSeg || el.parentNode.fcSeg || // for the harness\n  null;\n} // event ui computation\n\n\nfunction compileEventUis(eventDefs, eventUiBases) {\n  return mapHash(eventDefs, function (eventDef) {\n    return compileEventUi(eventDef, eventUiBases);\n  });\n}\n\nfunction compileEventUi(eventDef, eventUiBases) {\n  var uis = [];\n\n  if (eventUiBases['']) {\n    uis.push(eventUiBases['']);\n  }\n\n  if (eventUiBases[eventDef.defId]) {\n    uis.push(eventUiBases[eventDef.defId]);\n  }\n\n  uis.push(eventDef.ui);\n  return combineEventUis(uis);\n}\n\nfunction sortEventSegs(segs, eventOrderSpecs) {\n  var objs = segs.map(buildSegCompareObj);\n  objs.sort(function (obj0, obj1) {\n    return compareByFieldSpecs(obj0, obj1, eventOrderSpecs);\n  });\n  return objs.map(function (c) {\n    return c._seg;\n  });\n} // returns a object with all primitive props that can be compared\n\n\nfunction buildSegCompareObj(seg) {\n  var eventRange = seg.eventRange;\n  var eventDef = eventRange.def;\n  var range = eventRange.instance ? eventRange.instance.range : eventRange.range;\n  var start = range.start ? range.start.valueOf() : 0; // TODO: better support for open-range events\n\n  var end = range.end ? range.end.valueOf() : 0; // \"\n\n  return Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, eventDef.extendedProps), eventDef), {\n    id: eventDef.publicId,\n    start: start,\n    end: end,\n    duration: end - start,\n    allDay: Number(eventDef.allDay),\n    _seg: seg // for later retrieval\n\n  });\n}\n\nfunction computeSegDraggable(seg, context) {\n  var pluginHooks = context.pluginHooks;\n  var transformers = pluginHooks.isDraggableTransformers;\n  var _a = seg.eventRange,\n      def = _a.def,\n      ui = _a.ui;\n  var val = ui.startEditable;\n\n  for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {\n    var transformer = transformers_1[_i];\n    val = transformer(val, def, ui, context);\n  }\n\n  return val;\n}\n\nfunction computeSegStartResizable(seg, context) {\n  return seg.isStart && seg.eventRange.ui.durationEditable && context.options.eventResizableFromStart;\n}\n\nfunction computeSegEndResizable(seg, context) {\n  return seg.isEnd && seg.eventRange.ui.durationEditable;\n}\n\nfunction buildSegTimeText(seg, timeFormat, context, defaultDisplayEventTime, // defaults to true\ndefaultDisplayEventEnd, // defaults to true\nstartOverride, endOverride) {\n  var dateEnv = context.dateEnv,\n      options = context.options;\n  var displayEventTime = options.displayEventTime,\n      displayEventEnd = options.displayEventEnd;\n  var eventDef = seg.eventRange.def;\n  var eventInstance = seg.eventRange.instance;\n\n  if (displayEventTime == null) {\n    displayEventTime = defaultDisplayEventTime !== false;\n  }\n\n  if (displayEventEnd == null) {\n    displayEventEnd = defaultDisplayEventEnd !== false;\n  }\n\n  if (displayEventTime && !eventDef.allDay && (seg.isStart || seg.isEnd)) {\n    var segStart = startOverride || (seg.isStart ? eventInstance.range.start : seg.start || seg.eventRange.range.start);\n    var segEnd = endOverride || (seg.isEnd ? eventInstance.range.end : seg.end || seg.eventRange.range.end);\n\n    if (displayEventEnd && eventDef.hasEnd) {\n      return dateEnv.formatRange(segStart, segEnd, timeFormat, {\n        forcedStartTzo: startOverride ? null : eventInstance.forcedStartTzo,\n        forcedEndTzo: endOverride ? null : eventInstance.forcedEndTzo\n      });\n    } else {\n      return dateEnv.format(segStart, timeFormat, {\n        forcedTzo: startOverride ? null : eventInstance.forcedStartTzo // nooooo, same\n\n      });\n    }\n  }\n\n  return '';\n}\n\nfunction getSegMeta(seg, todayRange, nowDate) {\n  var segRange = seg.eventRange.range;\n  return {\n    isPast: segRange.end < (nowDate || todayRange.start),\n    isFuture: segRange.start >= (nowDate || todayRange.end),\n    isToday: todayRange && rangeContainsMarker(todayRange, segRange.start)\n  };\n}\n\nfunction getEventClassNames(props) {\n  var classNames = ['fc-event'];\n\n  if (props.isMirror) {\n    classNames.push('fc-event-mirror');\n  }\n\n  if (props.isDraggable) {\n    classNames.push('fc-event-draggable');\n  }\n\n  if (props.isStartResizable || props.isEndResizable) {\n    classNames.push('fc-event-resizable');\n  }\n\n  if (props.isDragging) {\n    classNames.push('fc-event-dragging');\n  }\n\n  if (props.isResizing) {\n    classNames.push('fc-event-resizing');\n  }\n\n  if (props.isSelected) {\n    classNames.push('fc-event-selected');\n  }\n\n  if (props.isStart) {\n    classNames.push('fc-event-start');\n  }\n\n  if (props.isEnd) {\n    classNames.push('fc-event-end');\n  }\n\n  if (props.isPast) {\n    classNames.push('fc-event-past');\n  }\n\n  if (props.isToday) {\n    classNames.push('fc-event-today');\n  }\n\n  if (props.isFuture) {\n    classNames.push('fc-event-future');\n  }\n\n  return classNames;\n}\n\nfunction buildEventRangeKey(eventRange) {\n  return eventRange.instance ? eventRange.instance.instanceId : eventRange.def.defId + ':' + eventRange.range.start.toISOString(); // inverse-background events don't have specific instances. TODO: better solution\n}\n\nvar STANDARD_PROPS = {\n  start: identity,\n  end: identity,\n  allDay: Boolean\n};\n\nfunction parseDateSpan(raw, dateEnv, defaultDuration) {\n  var span = parseOpenDateSpan(raw, dateEnv);\n  var range = span.range;\n\n  if (!range.start) {\n    return null;\n  }\n\n  if (!range.end) {\n    if (defaultDuration == null) {\n      return null;\n    } else {\n      range.end = dateEnv.add(range.start, defaultDuration);\n    }\n  }\n\n  return span;\n}\n/*\nTODO: somehow combine with parseRange?\nWill return null if the start/end props were present but parsed invalidly.\n*/\n\n\nfunction parseOpenDateSpan(raw, dateEnv) {\n  var _a = refineProps(raw, STANDARD_PROPS),\n      standardProps = _a.refined,\n      extra = _a.extra;\n\n  var startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;\n  var endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;\n  var allDay = standardProps.allDay;\n\n  if (allDay == null) {\n    allDay = startMeta && startMeta.isTimeUnspecified && (!endMeta || endMeta.isTimeUnspecified);\n  }\n\n  return Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({\n    range: {\n      start: startMeta ? startMeta.marker : null,\n      end: endMeta ? endMeta.marker : null\n    },\n    allDay: allDay\n  }, extra);\n}\n\nfunction isDateSpansEqual(span0, span1) {\n  return rangesEqual(span0.range, span1.range) && span0.allDay === span1.allDay && isSpanPropsEqual(span0, span1);\n} // the NON-DATE-RELATED props\n\n\nfunction isSpanPropsEqual(span0, span1) {\n  for (var propName in span1) {\n    if (propName !== 'range' && propName !== 'allDay') {\n      if (span0[propName] !== span1[propName]) {\n        return false;\n      }\n    }\n  } // are there any props that span0 has that span1 DOESN'T have?\n  // both have range/allDay, so no need to special-case.\n\n\n  for (var propName in span0) {\n    if (!(propName in span1)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction buildDateSpanApi(span, dateEnv) {\n  return Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, buildRangeApi(span.range, dateEnv, span.allDay)), {\n    allDay: span.allDay\n  });\n}\n\nfunction buildRangeApiWithTimeZone(range, dateEnv, omitTime) {\n  return Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, buildRangeApi(range, dateEnv, omitTime)), {\n    timeZone: dateEnv.timeZone\n  });\n}\n\nfunction buildRangeApi(range, dateEnv, omitTime) {\n  return {\n    start: dateEnv.toDate(range.start),\n    end: dateEnv.toDate(range.end),\n    startStr: dateEnv.formatIso(range.start, {\n      omitTime: omitTime\n    }),\n    endStr: dateEnv.formatIso(range.end, {\n      omitTime: omitTime\n    })\n  };\n}\n\nfunction fabricateEventRange(dateSpan, eventUiBases, context) {\n  var res = refineEventDef({\n    editable: false\n  }, context);\n  var def = parseEventDef(res.refined, res.extra, '', // sourceId\n  dateSpan.allDay, true, // hasEnd\n  context);\n  return {\n    def: def,\n    ui: compileEventUi(def, eventUiBases),\n    instance: createEventInstance(def.defId, dateSpan.range),\n    range: dateSpan.range,\n    isStart: true,\n    isEnd: true\n  };\n}\n\nfunction triggerDateSelect(selection, pev, context) {\n  context.emitter.trigger('select', Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, buildDateSpanApiWithContext(selection, context)), {\n    jsEvent: pev ? pev.origEvent : null,\n    view: context.viewApi || context.calendarApi.view\n  }));\n}\n\nfunction triggerDateUnselect(pev, context) {\n  context.emitter.trigger('unselect', {\n    jsEvent: pev ? pev.origEvent : null,\n    view: context.viewApi || context.calendarApi.view\n  });\n}\n\nfunction buildDateSpanApiWithContext(dateSpan, context) {\n  var props = {};\n\n  for (var _i = 0, _a = context.pluginHooks.dateSpanTransforms; _i < _a.length; _i++) {\n    var transform = _a[_i];\n\n    Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(props, transform(dateSpan, context));\n  }\n\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(props, buildDateSpanApi(dateSpan, context.dateEnv));\n\n  return props;\n} // Given an event's allDay status and start date, return what its fallback end date should be.\n// TODO: rename to computeDefaultEventEnd\n\n\nfunction getDefaultEventEnd(allDay, marker, context) {\n  var dateEnv = context.dateEnv,\n      options = context.options;\n  var end = marker;\n\n  if (allDay) {\n    end = startOfDay(end);\n    end = dateEnv.add(end, options.defaultAllDayEventDuration);\n  } else {\n    end = dateEnv.add(end, options.defaultTimedEventDuration);\n  }\n\n  return end;\n} // applies the mutation to ALL defs/instances within the event store\n\n\nfunction applyMutationToEventStore(eventStore, eventConfigBase, mutation, context) {\n  var eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);\n  var dest = createEmptyEventStore();\n\n  for (var defId in eventStore.defs) {\n    var def = eventStore.defs[defId];\n    dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, context);\n  }\n\n  for (var instanceId in eventStore.instances) {\n    var instance = eventStore.instances[instanceId];\n    var def = dest.defs[instance.defId]; // important to grab the newly modified def\n\n    dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, context);\n  }\n\n  return dest;\n}\n\nfunction applyMutationToEventDef(eventDef, eventConfig, mutation, context) {\n  var standardProps = mutation.standardProps || {}; // if hasEnd has not been specified, guess a good value based on deltas.\n  // if duration will change, there's no way the default duration will persist,\n  // and thus, we need to mark the event as having a real end\n\n  if (standardProps.hasEnd == null && eventConfig.durationEditable && (mutation.startDelta || mutation.endDelta)) {\n    standardProps.hasEnd = true; // TODO: is this mutation okay?\n  }\n\n  var copy = Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, eventDef), standardProps), {\n    ui: Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, eventDef.ui), standardProps.ui)\n  });\n\n  if (mutation.extendedProps) {\n    copy.extendedProps = Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, copy.extendedProps), mutation.extendedProps);\n  }\n\n  for (var _i = 0, _a = context.pluginHooks.eventDefMutationAppliers; _i < _a.length; _i++) {\n    var applier = _a[_i];\n    applier(copy, mutation, context);\n  }\n\n  if (!copy.hasEnd && context.options.forceEventDuration) {\n    copy.hasEnd = true;\n  }\n\n  return copy;\n}\n\nfunction applyMutationToEventInstance(eventInstance, eventDef, // must first be modified by applyMutationToEventDef\neventConfig, mutation, context) {\n  var dateEnv = context.dateEnv;\n  var forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;\n  var clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;\n\n  var copy = Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, eventInstance);\n\n  if (forceAllDay) {\n    copy.range = computeAlignedDayRange(copy.range);\n  }\n\n  if (mutation.datesDelta && eventConfig.startEditable) {\n    copy.range = {\n      start: dateEnv.add(copy.range.start, mutation.datesDelta),\n      end: dateEnv.add(copy.range.end, mutation.datesDelta)\n    };\n  }\n\n  if (mutation.startDelta && eventConfig.durationEditable) {\n    copy.range = {\n      start: dateEnv.add(copy.range.start, mutation.startDelta),\n      end: copy.range.end\n    };\n  }\n\n  if (mutation.endDelta && eventConfig.durationEditable) {\n    copy.range = {\n      start: copy.range.start,\n      end: dateEnv.add(copy.range.end, mutation.endDelta)\n    };\n  }\n\n  if (clearEnd) {\n    copy.range = {\n      start: copy.range.start,\n      end: getDefaultEventEnd(eventDef.allDay, copy.range.start, context)\n    };\n  } // in case event was all-day but the supplied deltas were not\n  // better util for this?\n\n\n  if (eventDef.allDay) {\n    copy.range = {\n      start: startOfDay(copy.range.start),\n      end: startOfDay(copy.range.end)\n    };\n  } // handle invalid durations\n\n\n  if (copy.range.end < copy.range.start) {\n    copy.range.end = getDefaultEventEnd(eventDef.allDay, copy.range.start, context);\n  }\n\n  return copy;\n} // no public types yet. when there are, export from:\n// import {} from './api-type-deps'\n\n\nvar ViewApi =\n/** @class */\nfunction () {\n  function ViewApi(type, getCurrentData, dateEnv) {\n    this.type = type;\n    this.getCurrentData = getCurrentData;\n    this.dateEnv = dateEnv;\n  }\n\n  Object.defineProperty(ViewApi.prototype, \"calendar\", {\n    get: function get() {\n      return this.getCurrentData().calendarApi;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewApi.prototype, \"title\", {\n    get: function get() {\n      return this.getCurrentData().viewTitle;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewApi.prototype, \"activeStart\", {\n    get: function get() {\n      return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewApi.prototype, \"activeEnd\", {\n    get: function get() {\n      return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewApi.prototype, \"currentStart\", {\n    get: function get() {\n      return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewApi.prototype, \"currentEnd\", {\n    get: function get() {\n      return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end);\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ViewApi.prototype.getOption = function (name) {\n    return this.getCurrentData().options[name]; // are the view-specific options\n  };\n\n  return ViewApi;\n}();\n\nvar EVENT_SOURCE_REFINERS = {\n  id: String,\n  defaultAllDay: Boolean,\n  url: String,\n  events: identity,\n  eventDataTransform: identity,\n  // for any network-related sources\n  success: identity,\n  failure: identity\n};\n\nfunction parseEventSource(raw, context, refiners) {\n  if (refiners === void 0) {\n    refiners = buildEventSourceRefiners(context);\n  }\n\n  var rawObj;\n\n  if (typeof raw === 'string') {\n    rawObj = {\n      url: raw\n    };\n  } else if (typeof raw === 'function' || Array.isArray(raw)) {\n    rawObj = {\n      events: raw\n    };\n  } else if (_typeof(raw) === 'object' && raw) {\n    // not null\n    rawObj = raw;\n  }\n\n  if (rawObj) {\n    var _a = refineProps(rawObj, refiners),\n        refined = _a.refined,\n        extra = _a.extra;\n\n    var metaRes = buildEventSourceMeta(refined, context);\n\n    if (metaRes) {\n      return {\n        _raw: raw,\n        isFetching: false,\n        latestFetchId: '',\n        fetchRange: null,\n        defaultAllDay: refined.defaultAllDay,\n        eventDataTransform: refined.eventDataTransform,\n        success: refined.success,\n        failure: refined.failure,\n        publicId: refined.id || '',\n        sourceId: guid(),\n        sourceDefId: metaRes.sourceDefId,\n        meta: metaRes.meta,\n        ui: createEventUi(refined, context),\n        extendedProps: extra\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction buildEventSourceRefiners(context) {\n  return Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, EVENT_UI_REFINERS), EVENT_SOURCE_REFINERS), context.pluginHooks.eventSourceRefiners);\n}\n\nfunction buildEventSourceMeta(raw, context) {\n  var defs = context.pluginHooks.eventSourceDefs;\n\n  for (var i = defs.length - 1; i >= 0; i--) {\n    // later-added plugins take precedence\n    var def = defs[i];\n    var meta = def.parseMeta(raw);\n\n    if (meta) {\n      return {\n        sourceDefId: i,\n        meta: meta\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction reduceCurrentDate(currentDate, action) {\n  switch (action.type) {\n    case 'CHANGE_DATE':\n      return action.dateMarker;\n\n    default:\n      return currentDate;\n  }\n}\n\nfunction getInitialDate(options, dateEnv) {\n  var initialDateInput = options.initialDate; // compute the initial ambig-timezone date\n\n  if (initialDateInput != null) {\n    return dateEnv.createMarker(initialDateInput);\n  } else {\n    return getNow(options.now, dateEnv); // getNow already returns unzoned\n  }\n}\n\nfunction getNow(nowInput, dateEnv) {\n  if (typeof nowInput === 'function') {\n    nowInput = nowInput();\n  }\n\n  if (nowInput == null) {\n    return dateEnv.createNowMarker();\n  }\n\n  return dateEnv.createMarker(nowInput);\n}\n\nvar CalendarApi =\n/** @class */\nfunction () {\n  function CalendarApi() {}\n\n  CalendarApi.prototype.getCurrentData = function () {\n    return this.currentDataManager.getCurrentData();\n  };\n\n  CalendarApi.prototype.dispatch = function (action) {\n    return this.currentDataManager.dispatch(action);\n  };\n\n  Object.defineProperty(CalendarApi.prototype, \"view\", {\n    get: function get() {\n      return this.getCurrentData().viewApi;\n    } // for public API\n    ,\n    enumerable: false,\n    configurable: true\n  });\n\n  CalendarApi.prototype.batchRendering = function (callback) {\n    callback();\n  };\n\n  CalendarApi.prototype.updateSize = function () {\n    this.trigger('_resize', true);\n  }; // Options\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.setOption = function (name, val) {\n    this.dispatch({\n      type: 'SET_OPTION',\n      optionName: name,\n      rawOptionValue: val\n    });\n  };\n\n  CalendarApi.prototype.getOption = function (name) {\n    return this.currentDataManager.currentCalendarOptionsInput[name];\n  };\n\n  CalendarApi.prototype.getAvailableLocaleCodes = function () {\n    return Object.keys(this.getCurrentData().availableRawLocales);\n  }; // Trigger\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.on = function (handlerName, handler) {\n    var currentDataManager = this.currentDataManager;\n\n    if (currentDataManager.currentCalendarOptionsRefiners[handlerName]) {\n      currentDataManager.emitter.on(handlerName, handler);\n    } else {\n      console.warn(\"Unknown listener name '\" + handlerName + \"'\");\n    }\n  };\n\n  CalendarApi.prototype.off = function (handlerName, handler) {\n    this.currentDataManager.emitter.off(handlerName, handler);\n  };\n\n  CalendarApi.prototype.trigger = function (handlerName) {\n    var _a;\n\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    (_a = this.currentDataManager.emitter).trigger.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__spreadArrays\"])([handlerName], args));\n  }; // View\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.changeView = function (viewType, dateOrRange) {\n    var _this = this;\n\n    this.batchRendering(function () {\n      _this.unselect();\n\n      if (dateOrRange) {\n        if (dateOrRange.start && dateOrRange.end) {\n          // a range\n          _this.dispatch({\n            type: 'CHANGE_VIEW_TYPE',\n            viewType: viewType\n          });\n\n          _this.dispatch({\n            type: 'SET_OPTION',\n            optionName: 'visibleRange',\n            rawOptionValue: dateOrRange\n          });\n        } else {\n          var dateEnv = _this.getCurrentData().dateEnv;\n\n          _this.dispatch({\n            type: 'CHANGE_VIEW_TYPE',\n            viewType: viewType,\n            dateMarker: dateEnv.createMarker(dateOrRange)\n          });\n        }\n      } else {\n        _this.dispatch({\n          type: 'CHANGE_VIEW_TYPE',\n          viewType: viewType\n        });\n      }\n    });\n  }; // Forces navigation to a view for the given date.\n  // `viewType` can be a specific view name or a generic one like \"week\" or \"day\".\n  // needs to change\n\n\n  CalendarApi.prototype.zoomTo = function (dateMarker, viewType) {\n    var state = this.getCurrentData();\n    var spec;\n    viewType = viewType || 'day'; // day is default zoom\n\n    spec = state.viewSpecs[viewType] || this.getUnitViewSpec(viewType);\n    this.unselect();\n\n    if (spec) {\n      this.dispatch({\n        type: 'CHANGE_VIEW_TYPE',\n        viewType: spec.type,\n        dateMarker: dateMarker\n      });\n    } else {\n      this.dispatch({\n        type: 'CHANGE_DATE',\n        dateMarker: dateMarker\n      });\n    }\n  }; // Given a duration singular unit, like \"week\" or \"day\", finds a matching view spec.\n  // Preference is given to views that have corresponding buttons.\n\n\n  CalendarApi.prototype.getUnitViewSpec = function (unit) {\n    var _a = this.getCurrentData(),\n        viewSpecs = _a.viewSpecs,\n        toolbarConfig = _a.toolbarConfig;\n\n    var viewTypes = [].concat(toolbarConfig.viewsWithButtons);\n    var i;\n    var spec;\n\n    for (var viewType in viewSpecs) {\n      viewTypes.push(viewType);\n    }\n\n    for (i = 0; i < viewTypes.length; i++) {\n      spec = viewSpecs[viewTypes[i]];\n\n      if (spec) {\n        if (spec.singleUnit === unit) {\n          return spec;\n        }\n      }\n    }\n  }; // Current Date\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.prev = function () {\n    this.unselect();\n    this.dispatch({\n      type: 'PREV'\n    });\n  };\n\n  CalendarApi.prototype.next = function () {\n    this.unselect();\n    this.dispatch({\n      type: 'NEXT'\n    });\n  };\n\n  CalendarApi.prototype.prevYear = function () {\n    var state = this.getCurrentData();\n    this.unselect();\n    this.dispatch({\n      type: 'CHANGE_DATE',\n      dateMarker: state.dateEnv.addYears(state.currentDate, -1)\n    });\n  };\n\n  CalendarApi.prototype.nextYear = function () {\n    var state = this.getCurrentData();\n    this.unselect();\n    this.dispatch({\n      type: 'CHANGE_DATE',\n      dateMarker: state.dateEnv.addYears(state.currentDate, 1)\n    });\n  };\n\n  CalendarApi.prototype.today = function () {\n    var state = this.getCurrentData();\n    this.unselect();\n    this.dispatch({\n      type: 'CHANGE_DATE',\n      dateMarker: getNow(state.calendarOptions.now, state.dateEnv)\n    });\n  };\n\n  CalendarApi.prototype.gotoDate = function (zonedDateInput) {\n    var state = this.getCurrentData();\n    this.unselect();\n    this.dispatch({\n      type: 'CHANGE_DATE',\n      dateMarker: state.dateEnv.createMarker(zonedDateInput)\n    });\n  };\n\n  CalendarApi.prototype.incrementDate = function (deltaInput) {\n    var state = this.getCurrentData();\n    var delta = createDuration(deltaInput);\n\n    if (delta) {\n      // else, warn about invalid input?\n      this.unselect();\n      this.dispatch({\n        type: 'CHANGE_DATE',\n        dateMarker: state.dateEnv.add(state.currentDate, delta)\n      });\n    }\n  }; // for external API\n\n\n  CalendarApi.prototype.getDate = function () {\n    var state = this.getCurrentData();\n    return state.dateEnv.toDate(state.currentDate);\n  }; // Date Formatting Utils\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.formatDate = function (d, formatter) {\n    var dateEnv = this.getCurrentData().dateEnv;\n    return dateEnv.format(dateEnv.createMarker(d), createFormatter(formatter));\n  }; // `settings` is for formatter AND isEndExclusive\n\n\n  CalendarApi.prototype.formatRange = function (d0, d1, settings) {\n    var _a = this.getCurrentData(),\n        dateEnv = _a.dateEnv,\n        options = _a.options;\n\n    return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings, options.defaultRangeSeparator), settings);\n  };\n\n  CalendarApi.prototype.formatIso = function (d, omitTime) {\n    var dateEnv = this.getCurrentData().dateEnv;\n    return dateEnv.formatIso(dateEnv.createMarker(d), {\n      omitTime: omitTime\n    });\n  }; // Date Selection / Event Selection / DayClick\n  // -----------------------------------------------------------------------------------------------------------------\n  // this public method receives start/end dates in any format, with any timezone\n  // NOTE: args were changed from v3\n\n\n  CalendarApi.prototype.select = function (dateOrObj, endDate) {\n    var selectionInput;\n\n    if (endDate == null) {\n      if (dateOrObj.start != null) {\n        selectionInput = dateOrObj;\n      } else {\n        selectionInput = {\n          start: dateOrObj,\n          end: null\n        };\n      }\n    } else {\n      selectionInput = {\n        start: dateOrObj,\n        end: endDate\n      };\n    }\n\n    var state = this.getCurrentData();\n    var selection = parseDateSpan(selectionInput, state.dateEnv, createDuration({\n      days: 1\n    }) // TODO: cache this?\n    );\n\n    if (selection) {\n      // throw parse error otherwise?\n      this.dispatch({\n        type: 'SELECT_DATES',\n        selection: selection\n      });\n      triggerDateSelect(selection, null, state);\n    }\n  }; // public method\n\n\n  CalendarApi.prototype.unselect = function (pev) {\n    var state = this.getCurrentData();\n\n    if (state.dateSelection) {\n      this.dispatch({\n        type: 'UNSELECT_DATES'\n      });\n      triggerDateUnselect(pev, state);\n    }\n  }; // Public Events API\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.addEvent = function (eventInput, sourceInput) {\n    if (eventInput instanceof EventApi) {\n      var def = eventInput._def;\n      var instance = eventInput._instance;\n      var currentData = this.getCurrentData(); // not already present? don't want to add an old snapshot\n\n      if (!currentData.eventStore.defs[def.defId]) {\n        this.dispatch({\n          type: 'ADD_EVENTS',\n          eventStore: eventTupleToStore({\n            def: def,\n            instance: instance\n          }) // TODO: better util for two args?\n\n        });\n        this.triggerEventAdd(eventInput);\n      }\n\n      return eventInput;\n    }\n\n    var state = this.getCurrentData();\n    var eventSource;\n\n    if (sourceInput instanceof EventSourceApi) {\n      eventSource = sourceInput.internalEventSource;\n    } else if (typeof sourceInput === 'boolean') {\n      if (sourceInput) {\n        // true. part of the first event source\n        eventSource = hashValuesToArray(state.eventSources)[0];\n      }\n    } else if (sourceInput != null) {\n      // an ID. accepts a number too\n      var sourceApi = this.getEventSourceById(sourceInput); // TODO: use an internal function\n\n      if (!sourceApi) {\n        console.warn('Could not find an event source with ID \"' + sourceInput + '\"'); // TODO: test\n\n        return null;\n      } else {\n        eventSource = sourceApi.internalEventSource;\n      }\n    }\n\n    var tuple = parseEvent(eventInput, eventSource, state, false);\n\n    if (tuple) {\n      var newEventApi = new EventApi(state, tuple.def, tuple.def.recurringDef ? null : tuple.instance);\n      this.dispatch({\n        type: 'ADD_EVENTS',\n        eventStore: eventTupleToStore(tuple)\n      });\n      this.triggerEventAdd(newEventApi);\n      return newEventApi;\n    }\n\n    return null;\n  };\n\n  CalendarApi.prototype.triggerEventAdd = function (eventApi) {\n    var _this = this;\n\n    var emitter = this.getCurrentData().emitter;\n    emitter.trigger('eventAdd', {\n      event: eventApi,\n      relatedEvents: [],\n      revert: function revert() {\n        _this.dispatch({\n          type: 'REMOVE_EVENTS',\n          eventStore: eventApiToStore(eventApi)\n        });\n      }\n    });\n  }; // TODO: optimize\n\n\n  CalendarApi.prototype.getEventById = function (id) {\n    var state = this.getCurrentData();\n    var _a = state.eventStore,\n        defs = _a.defs,\n        instances = _a.instances;\n    id = String(id);\n\n    for (var defId in defs) {\n      var def = defs[defId];\n\n      if (def.publicId === id) {\n        if (def.recurringDef) {\n          return new EventApi(state, def, null);\n        } else {\n          for (var instanceId in instances) {\n            var instance = instances[instanceId];\n\n            if (instance.defId === def.defId) {\n              return new EventApi(state, def, instance);\n            }\n          }\n        }\n      }\n    }\n\n    return null;\n  };\n\n  CalendarApi.prototype.getEvents = function () {\n    var currentData = this.getCurrentData();\n    return buildEventApis(currentData.eventStore, currentData);\n  };\n\n  CalendarApi.prototype.removeAllEvents = function () {\n    this.dispatch({\n      type: 'REMOVE_ALL_EVENTS'\n    });\n  }; // Public Event Sources API\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.getEventSources = function () {\n    var state = this.getCurrentData();\n    var sourceHash = state.eventSources;\n    var sourceApis = [];\n\n    for (var internalId in sourceHash) {\n      sourceApis.push(new EventSourceApi(state, sourceHash[internalId]));\n    }\n\n    return sourceApis;\n  };\n\n  CalendarApi.prototype.getEventSourceById = function (id) {\n    var state = this.getCurrentData();\n    var sourceHash = state.eventSources;\n    id = String(id);\n\n    for (var sourceId in sourceHash) {\n      if (sourceHash[sourceId].publicId === id) {\n        return new EventSourceApi(state, sourceHash[sourceId]);\n      }\n    }\n\n    return null;\n  };\n\n  CalendarApi.prototype.addEventSource = function (sourceInput) {\n    var state = this.getCurrentData();\n\n    if (sourceInput instanceof EventSourceApi) {\n      // not already present? don't want to add an old snapshot\n      if (!state.eventSources[sourceInput.internalEventSource.sourceId]) {\n        this.dispatch({\n          type: 'ADD_EVENT_SOURCES',\n          sources: [sourceInput.internalEventSource]\n        });\n      }\n\n      return sourceInput;\n    }\n\n    var eventSource = parseEventSource(sourceInput, state);\n\n    if (eventSource) {\n      // TODO: error otherwise?\n      this.dispatch({\n        type: 'ADD_EVENT_SOURCES',\n        sources: [eventSource]\n      });\n      return new EventSourceApi(state, eventSource);\n    }\n\n    return null;\n  };\n\n  CalendarApi.prototype.removeAllEventSources = function () {\n    this.dispatch({\n      type: 'REMOVE_ALL_EVENT_SOURCES'\n    });\n  };\n\n  CalendarApi.prototype.refetchEvents = function () {\n    this.dispatch({\n      type: 'FETCH_EVENT_SOURCES'\n    });\n  }; // Scroll\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.scrollToTime = function (timeInput) {\n    var time = createDuration(timeInput);\n\n    if (time) {\n      this.trigger('_scrollRequest', {\n        time: time\n      });\n    }\n  };\n\n  return CalendarApi;\n}();\n\nvar EventApi =\n/** @class */\nfunction () {\n  // instance will be null if expressing a recurring event that has no current instances,\n  // OR if trying to validate an incoming external event that has no dates assigned\n  function EventApi(context, def, instance) {\n    this._context = context;\n    this._def = def;\n    this._instance = instance || null;\n  }\n  /*\n  TODO: make event struct more responsible for this\n  */\n\n\n  EventApi.prototype.setProp = function (name, val) {\n    var _a, _b;\n\n    if (name in EVENT_DATE_REFINERS) {\n      console.warn(\"Could not set date-related prop 'name'. Use one of the date-related methods instead.\");\n    } else if (name in EVENT_NON_DATE_REFINERS) {\n      val = EVENT_NON_DATE_REFINERS[name](val);\n      this.mutate({\n        standardProps: (_a = {}, _a[name] = val, _a)\n      });\n    } else if (name in EVENT_UI_REFINERS) {\n      var ui = EVENT_UI_REFINERS[name](val);\n\n      if (name === 'color') {\n        ui = {\n          backgroundColor: val,\n          borderColor: val\n        };\n      } else if (name === 'editable') {\n        ui = {\n          startEditable: val,\n          durationEditable: val\n        };\n      } else {\n        ui = (_b = {}, _b[name] = val, _b);\n      }\n\n      this.mutate({\n        standardProps: {\n          ui: ui\n        }\n      });\n    } else {\n      console.warn(\"Could not set prop '\" + name + \"'. Use setExtendedProp instead.\");\n    }\n  };\n\n  EventApi.prototype.setExtendedProp = function (name, val) {\n    var _a;\n\n    this.mutate({\n      extendedProps: (_a = {}, _a[name] = val, _a)\n    });\n  };\n\n  EventApi.prototype.setStart = function (startInput, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var dateEnv = this._context.dateEnv;\n    var start = dateEnv.createMarker(startInput);\n\n    if (start && this._instance) {\n      // TODO: warning if parsed bad\n      var instanceRange = this._instance.range;\n      var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity); // what if parsed bad!?\n\n      if (options.maintainDuration) {\n        this.mutate({\n          datesDelta: startDelta\n        });\n      } else {\n        this.mutate({\n          startDelta: startDelta\n        });\n      }\n    }\n  };\n\n  EventApi.prototype.setEnd = function (endInput, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var dateEnv = this._context.dateEnv;\n    var end;\n\n    if (endInput != null) {\n      end = dateEnv.createMarker(endInput);\n\n      if (!end) {\n        return; // TODO: warning if parsed bad\n      }\n    }\n\n    if (this._instance) {\n      if (end) {\n        var endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);\n        this.mutate({\n          endDelta: endDelta\n        });\n      } else {\n        this.mutate({\n          standardProps: {\n            hasEnd: false\n          }\n        });\n      }\n    }\n  };\n\n  EventApi.prototype.setDates = function (startInput, endInput, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var dateEnv = this._context.dateEnv;\n    var standardProps = {\n      allDay: options.allDay\n    };\n    var start = dateEnv.createMarker(startInput);\n    var end;\n\n    if (!start) {\n      return; // TODO: warning if parsed bad\n    }\n\n    if (endInput != null) {\n      end = dateEnv.createMarker(endInput);\n\n      if (!end) {\n        // TODO: warning if parsed bad\n        return;\n      }\n    }\n\n    if (this._instance) {\n      var instanceRange = this._instance.range; // when computing the diff for an event being converted to all-day,\n      // compute diff off of the all-day values the way event-mutation does.\n\n      if (options.allDay === true) {\n        instanceRange = computeAlignedDayRange(instanceRange);\n      }\n\n      var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);\n\n      if (end) {\n        var endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);\n\n        if (durationsEqual(startDelta, endDelta)) {\n          this.mutate({\n            datesDelta: startDelta,\n            standardProps: standardProps\n          });\n        } else {\n          this.mutate({\n            startDelta: startDelta,\n            endDelta: endDelta,\n            standardProps: standardProps\n          });\n        }\n      } else {\n        // means \"clear the end\"\n        standardProps.hasEnd = false;\n        this.mutate({\n          datesDelta: startDelta,\n          standardProps: standardProps\n        });\n      }\n    }\n  };\n\n  EventApi.prototype.moveStart = function (deltaInput) {\n    var delta = createDuration(deltaInput);\n\n    if (delta) {\n      // TODO: warning if parsed bad\n      this.mutate({\n        startDelta: delta\n      });\n    }\n  };\n\n  EventApi.prototype.moveEnd = function (deltaInput) {\n    var delta = createDuration(deltaInput);\n\n    if (delta) {\n      // TODO: warning if parsed bad\n      this.mutate({\n        endDelta: delta\n      });\n    }\n  };\n\n  EventApi.prototype.moveDates = function (deltaInput) {\n    var delta = createDuration(deltaInput);\n\n    if (delta) {\n      // TODO: warning if parsed bad\n      this.mutate({\n        datesDelta: delta\n      });\n    }\n  };\n\n  EventApi.prototype.setAllDay = function (allDay, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var standardProps = {\n      allDay: allDay\n    };\n    var maintainDuration = options.maintainDuration;\n\n    if (maintainDuration == null) {\n      maintainDuration = this._context.options.allDayMaintainDuration;\n    }\n\n    if (this._def.allDay !== allDay) {\n      standardProps.hasEnd = maintainDuration;\n    }\n\n    this.mutate({\n      standardProps: standardProps\n    });\n  };\n\n  EventApi.prototype.formatRange = function (formatInput) {\n    var dateEnv = this._context.dateEnv;\n    var instance = this._instance;\n    var formatter = createFormatter(formatInput, this._context.options.defaultRangeSeparator);\n\n    if (this._def.hasEnd) {\n      return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {\n        forcedStartTzo: instance.forcedStartTzo,\n        forcedEndTzo: instance.forcedEndTzo\n      });\n    } else {\n      return dateEnv.format(instance.range.start, formatter, {\n        forcedTzo: instance.forcedStartTzo\n      });\n    }\n  };\n\n  EventApi.prototype.mutate = function (mutation) {\n    var instance = this._instance;\n\n    if (instance) {\n      var def = this._def;\n      var context_1 = this._context;\n      var eventStore = context_1.getCurrentData().eventStore;\n      var relevantEvents_1 = getRelevantEvents(eventStore, instance.instanceId);\n      var eventConfigBase = {\n        '': {\n          display: '',\n          startEditable: true,\n          durationEditable: true,\n          constraints: [],\n          overlap: null,\n          allows: [],\n          backgroundColor: '',\n          borderColor: '',\n          textColor: '',\n          classNames: []\n        }\n      };\n      relevantEvents_1 = applyMutationToEventStore(relevantEvents_1, eventConfigBase, mutation, context_1);\n      var oldEvent = new EventApi(context_1, def, instance); // snapshot\n\n      this._def = relevantEvents_1.defs[def.defId];\n      this._instance = relevantEvents_1.instances[instance.instanceId];\n      context_1.dispatch({\n        type: 'MERGE_EVENTS',\n        eventStore: relevantEvents_1\n      });\n      context_1.emitter.trigger('eventChange', {\n        oldEvent: oldEvent,\n        event: this,\n        relatedEvents: buildEventApis(relevantEvents_1, context_1, instance),\n        revert: function revert() {\n          context_1.dispatch({\n            type: 'REMOVE_EVENTS',\n            eventStore: relevantEvents_1\n          });\n        }\n      });\n    }\n  };\n\n  EventApi.prototype.remove = function () {\n    var context = this._context;\n    var asStore = eventApiToStore(this);\n    context.dispatch({\n      type: 'REMOVE_EVENTS',\n      eventStore: asStore\n    });\n    context.emitter.trigger('eventRemove', {\n      event: this,\n      relatedEvents: [],\n      revert: function revert() {\n        context.dispatch({\n          type: 'MERGE_EVENTS',\n          eventStore: asStore\n        });\n      }\n    });\n  };\n\n  Object.defineProperty(EventApi.prototype, \"source\", {\n    get: function get() {\n      var sourceId = this._def.sourceId;\n\n      if (sourceId) {\n        return new EventSourceApi(this._context, this._context.getCurrentData().eventSources[sourceId]);\n      }\n\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"start\", {\n    get: function get() {\n      return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"end\", {\n    get: function get() {\n      return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"startStr\", {\n    get: function get() {\n      var instance = this._instance;\n\n      if (instance) {\n        return this._context.dateEnv.formatIso(instance.range.start, {\n          omitTime: this._def.allDay,\n          forcedTzo: instance.forcedStartTzo\n        });\n      }\n\n      return '';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"endStr\", {\n    get: function get() {\n      var instance = this._instance;\n\n      if (instance && this._def.hasEnd) {\n        return this._context.dateEnv.formatIso(instance.range.end, {\n          omitTime: this._def.allDay,\n          forcedTzo: instance.forcedEndTzo\n        });\n      }\n\n      return '';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"id\", {\n    // computable props that all access the def\n    // TODO: find a TypeScript-compatible way to do this at scale\n    get: function get() {\n      return this._def.publicId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"groupId\", {\n    get: function get() {\n      return this._def.groupId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"allDay\", {\n    get: function get() {\n      return this._def.allDay;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"title\", {\n    get: function get() {\n      return this._def.title;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"url\", {\n    get: function get() {\n      return this._def.url;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"display\", {\n    get: function get() {\n      return this._def.ui.display || 'auto';\n    } // bad. just normalize the type earlier\n    ,\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"startEditable\", {\n    get: function get() {\n      return this._def.ui.startEditable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"durationEditable\", {\n    get: function get() {\n      return this._def.ui.durationEditable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"constraint\", {\n    get: function get() {\n      return this._def.ui.constraints[0] || null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"overlap\", {\n    get: function get() {\n      return this._def.ui.overlap;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"allow\", {\n    get: function get() {\n      return this._def.ui.allows[0] || null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"backgroundColor\", {\n    get: function get() {\n      return this._def.ui.backgroundColor;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"borderColor\", {\n    get: function get() {\n      return this._def.ui.borderColor;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"textColor\", {\n    get: function get() {\n      return this._def.ui.textColor;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"classNames\", {\n    // NOTE: user can't modify these because Object.freeze was called in event-def parsing\n    get: function get() {\n      return this._def.ui.classNames;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"extendedProps\", {\n    get: function get() {\n      return this._def.extendedProps;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  EventApi.prototype.toPlainObject = function (settings) {\n    if (settings === void 0) {\n      settings = {};\n    }\n\n    var def = this._def;\n    var ui = def.ui;\n\n    var _a = this,\n        startStr = _a.startStr,\n        endStr = _a.endStr;\n\n    var res = {};\n\n    if (def.title) {\n      res.title = def.title;\n    }\n\n    if (startStr) {\n      res.start = startStr;\n    }\n\n    if (endStr) {\n      res.end = endStr;\n    }\n\n    if (def.publicId) {\n      res.id = def.publicId;\n    }\n\n    if (def.groupId) {\n      res.groupId = def.groupId;\n    }\n\n    if (def.url) {\n      res.url = def.url;\n    }\n\n    if (ui.display && ui.display !== 'auto') {\n      res.display = ui.display;\n    } // TODO: what about recurring-event properties???\n    // TODO: include startEditable/durationEditable/constraint/overlap/allow\n\n\n    if (settings.collapseColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {\n      res.color = ui.backgroundColor;\n    } else {\n      if (ui.backgroundColor) {\n        res.backgroundColor = ui.backgroundColor;\n      }\n\n      if (ui.borderColor) {\n        res.borderColor = ui.borderColor;\n      }\n    }\n\n    if (ui.textColor) {\n      res.textColor = ui.textColor;\n    }\n\n    if (ui.classNames.length) {\n      res.classNames = ui.classNames;\n    }\n\n    if (Object.keys(def.extendedProps).length) {\n      if (settings.collapseExtendedProps) {\n        Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(res, def.extendedProps);\n      } else {\n        res.extendedProps = def.extendedProps;\n      }\n    }\n\n    return res;\n  };\n\n  EventApi.prototype.toJSON = function () {\n    return this.toPlainObject();\n  };\n\n  return EventApi;\n}();\n\nfunction eventApiToStore(eventApi) {\n  var _a, _b;\n\n  var def = eventApi._def;\n  var instance = eventApi._instance;\n  return {\n    defs: (_a = {}, _a[def.defId] = def, _a),\n    instances: instance ? (_b = {}, _b[instance.instanceId] = instance, _b) : {}\n  };\n}\n\nfunction buildEventApis(eventStore, context, excludeInstance) {\n  var defs = eventStore.defs,\n      instances = eventStore.instances;\n  var eventApis = [];\n  var excludeInstanceId = excludeInstance ? excludeInstance.instanceId : '';\n\n  for (var id in instances) {\n    var instance = instances[id];\n    var def = defs[instance.defId];\n\n    if (instance.instanceId !== excludeInstanceId) {\n      eventApis.push(new EventApi(context, def, instance));\n    }\n  }\n\n  return eventApis;\n}\n\nvar calendarSystemClassMap = {};\n\nfunction registerCalendarSystem(name, theClass) {\n  calendarSystemClassMap[name] = theClass;\n}\n\nfunction createCalendarSystem(name) {\n  return new calendarSystemClassMap[name]();\n}\n\nvar GregorianCalendarSystem =\n/** @class */\nfunction () {\n  function GregorianCalendarSystem() {}\n\n  GregorianCalendarSystem.prototype.getMarkerYear = function (d) {\n    return d.getUTCFullYear();\n  };\n\n  GregorianCalendarSystem.prototype.getMarkerMonth = function (d) {\n    return d.getUTCMonth();\n  };\n\n  GregorianCalendarSystem.prototype.getMarkerDay = function (d) {\n    return d.getUTCDate();\n  };\n\n  GregorianCalendarSystem.prototype.arrayToMarker = function (arr) {\n    return arrayToUtcDate(arr);\n  };\n\n  GregorianCalendarSystem.prototype.markerToArray = function (marker) {\n    return dateToUtcArray(marker);\n  };\n\n  return GregorianCalendarSystem;\n}();\n\nregisterCalendarSystem('gregory', GregorianCalendarSystem);\nvar ISO_RE = /^\\s*(\\d{4})(-(\\d{2})(-(\\d{2})([T ](\\d{2}):(\\d{2})(:(\\d{2})(\\.(\\d+))?)?(Z|(([-+])(\\d{2})(:?(\\d{2}))?))?)?)?)?$/;\n\nfunction parse(str) {\n  var m = ISO_RE.exec(str);\n\n  if (m) {\n    var marker = new Date(Date.UTC(Number(m[1]), m[3] ? Number(m[3]) - 1 : 0, Number(m[5] || 1), Number(m[7] || 0), Number(m[8] || 0), Number(m[10] || 0), m[12] ? Number('0.' + m[12]) * 1000 : 0));\n\n    if (isValidDate(marker)) {\n      var timeZoneOffset = null;\n\n      if (m[13]) {\n        timeZoneOffset = (m[15] === '-' ? -1 : 1) * (Number(m[16] || 0) * 60 + Number(m[18] || 0));\n      }\n\n      return {\n        marker: marker,\n        isTimeUnspecified: !m[6],\n        timeZoneOffset: timeZoneOffset\n      };\n    }\n  }\n\n  return null;\n}\n\nvar DateEnv =\n/** @class */\nfunction () {\n  function DateEnv(settings) {\n    var timeZone = this.timeZone = settings.timeZone;\n    var isNamedTimeZone = timeZone !== 'local' && timeZone !== 'UTC';\n\n    if (settings.namedTimeZoneImpl && isNamedTimeZone) {\n      this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);\n    }\n\n    this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);\n    this.calendarSystem = createCalendarSystem(settings.calendarSystem);\n    this.locale = settings.locale;\n    this.weekDow = settings.locale.week.dow;\n    this.weekDoy = settings.locale.week.doy;\n\n    if (settings.weekNumberCalculation === 'ISO') {\n      this.weekDow = 1;\n      this.weekDoy = 4;\n    }\n\n    if (typeof settings.firstDay === 'number') {\n      this.weekDow = settings.firstDay;\n    }\n\n    if (typeof settings.weekNumberCalculation === 'function') {\n      this.weekNumberFunc = settings.weekNumberCalculation;\n    }\n\n    this.weekText = settings.weekText != null ? settings.weekText : settings.locale.options.weekText;\n    this.cmdFormatter = settings.cmdFormatter;\n    this.defaultSeparator = settings.defaultSeparator;\n  } // Creating / Parsing\n\n\n  DateEnv.prototype.createMarker = function (input) {\n    var meta = this.createMarkerMeta(input);\n\n    if (meta === null) {\n      return null;\n    }\n\n    return meta.marker;\n  };\n\n  DateEnv.prototype.createNowMarker = function () {\n    if (this.canComputeOffset) {\n      return this.timestampToMarker(new Date().valueOf());\n    } else {\n      // if we can't compute the current date val for a timezone,\n      // better to give the current local date vals than UTC\n      return arrayToUtcDate(dateToLocalArray(new Date()));\n    }\n  };\n\n  DateEnv.prototype.createMarkerMeta = function (input) {\n    if (typeof input === 'string') {\n      return this.parse(input);\n    }\n\n    var marker = null;\n\n    if (typeof input === 'number') {\n      marker = this.timestampToMarker(input);\n    } else if (input instanceof Date) {\n      input = input.valueOf();\n\n      if (!isNaN(input)) {\n        marker = this.timestampToMarker(input);\n      }\n    } else if (Array.isArray(input)) {\n      marker = arrayToUtcDate(input);\n    }\n\n    if (marker === null || !isValidDate(marker)) {\n      return null;\n    }\n\n    return {\n      marker: marker,\n      isTimeUnspecified: false,\n      forcedTzo: null\n    };\n  };\n\n  DateEnv.prototype.parse = function (s) {\n    var parts = parse(s);\n\n    if (parts === null) {\n      return null;\n    }\n\n    var marker = parts.marker;\n    var forcedTzo = null;\n\n    if (parts.timeZoneOffset !== null) {\n      if (this.canComputeOffset) {\n        marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1000);\n      } else {\n        forcedTzo = parts.timeZoneOffset;\n      }\n    }\n\n    return {\n      marker: marker,\n      isTimeUnspecified: parts.isTimeUnspecified,\n      forcedTzo: forcedTzo\n    };\n  }; // Accessors\n\n\n  DateEnv.prototype.getYear = function (marker) {\n    return this.calendarSystem.getMarkerYear(marker);\n  };\n\n  DateEnv.prototype.getMonth = function (marker) {\n    return this.calendarSystem.getMarkerMonth(marker);\n  }; // Adding / Subtracting\n\n\n  DateEnv.prototype.add = function (marker, dur) {\n    var a = this.calendarSystem.markerToArray(marker);\n    a[0] += dur.years;\n    a[1] += dur.months;\n    a[2] += dur.days;\n    a[6] += dur.milliseconds;\n    return this.calendarSystem.arrayToMarker(a);\n  };\n\n  DateEnv.prototype.subtract = function (marker, dur) {\n    var a = this.calendarSystem.markerToArray(marker);\n    a[0] -= dur.years;\n    a[1] -= dur.months;\n    a[2] -= dur.days;\n    a[6] -= dur.milliseconds;\n    return this.calendarSystem.arrayToMarker(a);\n  };\n\n  DateEnv.prototype.addYears = function (marker, n) {\n    var a = this.calendarSystem.markerToArray(marker);\n    a[0] += n;\n    return this.calendarSystem.arrayToMarker(a);\n  };\n\n  DateEnv.prototype.addMonths = function (marker, n) {\n    var a = this.calendarSystem.markerToArray(marker);\n    a[1] += n;\n    return this.calendarSystem.arrayToMarker(a);\n  }; // Diffing Whole Units\n\n\n  DateEnv.prototype.diffWholeYears = function (m0, m1) {\n    var calendarSystem = this.calendarSystem;\n\n    if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) && calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {\n      return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);\n    }\n\n    return null;\n  };\n\n  DateEnv.prototype.diffWholeMonths = function (m0, m1) {\n    var calendarSystem = this.calendarSystem;\n\n    if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {\n      return calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0) + (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;\n    }\n\n    return null;\n  }; // Range / Duration\n\n\n  DateEnv.prototype.greatestWholeUnit = function (m0, m1) {\n    var n = this.diffWholeYears(m0, m1);\n\n    if (n !== null) {\n      return {\n        unit: 'year',\n        value: n\n      };\n    }\n\n    n = this.diffWholeMonths(m0, m1);\n\n    if (n !== null) {\n      return {\n        unit: 'month',\n        value: n\n      };\n    }\n\n    n = diffWholeWeeks(m0, m1);\n\n    if (n !== null) {\n      return {\n        unit: 'week',\n        value: n\n      };\n    }\n\n    n = diffWholeDays(m0, m1);\n\n    if (n !== null) {\n      return {\n        unit: 'day',\n        value: n\n      };\n    }\n\n    n = diffHours(m0, m1);\n\n    if (isInt(n)) {\n      return {\n        unit: 'hour',\n        value: n\n      };\n    }\n\n    n = diffMinutes(m0, m1);\n\n    if (isInt(n)) {\n      return {\n        unit: 'minute',\n        value: n\n      };\n    }\n\n    n = diffSeconds(m0, m1);\n\n    if (isInt(n)) {\n      return {\n        unit: 'second',\n        value: n\n      };\n    }\n\n    return {\n      unit: 'millisecond',\n      value: m1.valueOf() - m0.valueOf()\n    };\n  };\n\n  DateEnv.prototype.countDurationsBetween = function (m0, m1, d) {\n    // TODO: can use greatestWholeUnit\n    var diff;\n\n    if (d.years) {\n      diff = this.diffWholeYears(m0, m1);\n\n      if (diff !== null) {\n        return diff / asRoughYears(d);\n      }\n    }\n\n    if (d.months) {\n      diff = this.diffWholeMonths(m0, m1);\n\n      if (diff !== null) {\n        return diff / asRoughMonths(d);\n      }\n    }\n\n    if (d.days) {\n      diff = diffWholeDays(m0, m1);\n\n      if (diff !== null) {\n        return diff / asRoughDays(d);\n      }\n    }\n\n    return (m1.valueOf() - m0.valueOf()) / asRoughMs(d);\n  }; // Start-Of\n  // these DON'T return zoned-dates. only UTC start-of dates\n\n\n  DateEnv.prototype.startOf = function (m, unit) {\n    if (unit === 'year') {\n      return this.startOfYear(m);\n    } else if (unit === 'month') {\n      return this.startOfMonth(m);\n    } else if (unit === 'week') {\n      return this.startOfWeek(m);\n    } else if (unit === 'day') {\n      return startOfDay(m);\n    } else if (unit === 'hour') {\n      return startOfHour(m);\n    } else if (unit === 'minute') {\n      return startOfMinute(m);\n    } else if (unit === 'second') {\n      return startOfSecond(m);\n    }\n  };\n\n  DateEnv.prototype.startOfYear = function (m) {\n    return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(m)]);\n  };\n\n  DateEnv.prototype.startOfMonth = function (m) {\n    return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(m), this.calendarSystem.getMarkerMonth(m)]);\n  };\n\n  DateEnv.prototype.startOfWeek = function (m) {\n    return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(m), this.calendarSystem.getMarkerMonth(m), m.getUTCDate() - (m.getUTCDay() - this.weekDow + 7) % 7]);\n  }; // Week Number\n\n\n  DateEnv.prototype.computeWeekNumber = function (marker) {\n    if (this.weekNumberFunc) {\n      return this.weekNumberFunc(this.toDate(marker));\n    } else {\n      return weekOfYear(marker, this.weekDow, this.weekDoy);\n    }\n  }; // TODO: choke on timeZoneName: long\n\n\n  DateEnv.prototype.format = function (marker, formatter, dateOptions) {\n    if (dateOptions === void 0) {\n      dateOptions = {};\n    }\n\n    return formatter.format({\n      marker: marker,\n      timeZoneOffset: dateOptions.forcedTzo != null ? dateOptions.forcedTzo : this.offsetForMarker(marker)\n    }, this);\n  };\n\n  DateEnv.prototype.formatRange = function (start, end, formatter, dateOptions) {\n    if (dateOptions === void 0) {\n      dateOptions = {};\n    }\n\n    if (dateOptions.isEndExclusive) {\n      end = addMs(end, -1);\n    }\n\n    return formatter.formatRange({\n      marker: start,\n      timeZoneOffset: dateOptions.forcedStartTzo != null ? dateOptions.forcedStartTzo : this.offsetForMarker(start)\n    }, {\n      marker: end,\n      timeZoneOffset: dateOptions.forcedEndTzo != null ? dateOptions.forcedEndTzo : this.offsetForMarker(end)\n    }, this);\n  };\n  /*\n  DUMB: the omitTime arg is dumb. if we omit the time, we want to omit the timezone offset. and if we do that,\n  might as well use buildIsoString or some other util directly\n  */\n\n\n  DateEnv.prototype.formatIso = function (marker, extraOptions) {\n    if (extraOptions === void 0) {\n      extraOptions = {};\n    }\n\n    var timeZoneOffset = null;\n\n    if (!extraOptions.omitTimeZoneOffset) {\n      if (extraOptions.forcedTzo != null) {\n        timeZoneOffset = extraOptions.forcedTzo;\n      } else {\n        timeZoneOffset = this.offsetForMarker(marker);\n      }\n    }\n\n    return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);\n  }; // TimeZone\n\n\n  DateEnv.prototype.timestampToMarker = function (ms) {\n    if (this.timeZone === 'local') {\n      return arrayToUtcDate(dateToLocalArray(new Date(ms)));\n    } else if (this.timeZone === 'UTC' || !this.namedTimeZoneImpl) {\n      return new Date(ms);\n    } else {\n      return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));\n    }\n  };\n\n  DateEnv.prototype.offsetForMarker = function (m) {\n    if (this.timeZone === 'local') {\n      return -arrayToLocalDate(dateToUtcArray(m)).getTimezoneOffset(); // convert \"inverse\" offset to \"normal\" offset\n    } else if (this.timeZone === 'UTC') {\n      return 0;\n    } else if (this.namedTimeZoneImpl) {\n      return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m));\n    }\n\n    return null;\n  }; // Conversion\n\n\n  DateEnv.prototype.toDate = function (m, forcedTzo) {\n    if (this.timeZone === 'local') {\n      return arrayToLocalDate(dateToUtcArray(m));\n    } else if (this.timeZone === 'UTC') {\n      return new Date(m.valueOf()); // make sure it's a copy\n    } else if (!this.namedTimeZoneImpl) {\n      return new Date(m.valueOf() - (forcedTzo || 0));\n    } else {\n      return new Date(m.valueOf() - this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m)) * 1000 * 60 // convert minutes -> ms\n      );\n    }\n  };\n\n  return DateEnv;\n}();\n\nvar globalLocales = [];\nvar RAW_EN_LOCALE = {\n  code: 'en',\n  week: {\n    dow: 0,\n    doy: 4 // 4 days need to be within the year to be considered the first week\n\n  },\n  direction: 'ltr',\n  buttonText: {\n    prev: 'prev',\n    next: 'next',\n    prevYear: 'prev year',\n    nextYear: 'next year',\n    year: 'year',\n    today: 'today',\n    month: 'month',\n    week: 'week',\n    day: 'day',\n    list: 'list'\n  },\n  weekText: 'W',\n  allDayText: 'all-day',\n  moreLinkText: 'more',\n  noEventsText: 'No events to display'\n};\n\nfunction organizeRawLocales(explicitRawLocales) {\n  var defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : 'en';\n  var allRawLocales = globalLocales.concat(explicitRawLocales);\n  var rawLocaleMap = {\n    en: RAW_EN_LOCALE // necessary?\n\n  };\n\n  for (var _i = 0, allRawLocales_1 = allRawLocales; _i < allRawLocales_1.length; _i++) {\n    var rawLocale = allRawLocales_1[_i];\n    rawLocaleMap[rawLocale.code] = rawLocale;\n  }\n\n  return {\n    map: rawLocaleMap,\n    defaultCode: defaultCode\n  };\n}\n\nfunction buildLocale(inputSingular, available) {\n  if (_typeof(inputSingular) === 'object' && !Array.isArray(inputSingular)) {\n    return parseLocale(inputSingular.code, [inputSingular.code], inputSingular);\n  } else {\n    return queryLocale(inputSingular, available);\n  }\n}\n\nfunction queryLocale(codeArg, available) {\n  var codes = [].concat(codeArg || []); // will convert to array\n\n  var raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;\n  return parseLocale(codeArg, codes, raw);\n}\n\nfunction queryRawLocale(codes, available) {\n  for (var i = 0; i < codes.length; i++) {\n    var parts = codes[i].toLocaleLowerCase().split('-');\n\n    for (var j = parts.length; j > 0; j--) {\n      var simpleId = parts.slice(0, j).join('-');\n\n      if (available[simpleId]) {\n        return available[simpleId];\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction parseLocale(codeArg, codes, raw) {\n  var merged = mergeProps([RAW_EN_LOCALE, raw], ['buttonText']);\n  delete merged.code; // don't want this part of the options\n\n  var week = merged.week;\n  delete merged.week;\n  return {\n    codeArg: codeArg,\n    codes: codes,\n    week: week,\n    simpleNumberFormat: new Intl.NumberFormat(codeArg),\n    options: merged\n  };\n}\n\nfunction formatDate(dateInput, settings) {\n  if (settings === void 0) {\n    settings = {};\n  }\n\n  var dateEnv = buildDateEnv(settings);\n  var formatter = createFormatter(settings);\n  var dateMeta = dateEnv.createMarkerMeta(dateInput);\n\n  if (!dateMeta) {\n    // TODO: warning?\n    return '';\n  }\n\n  return dateEnv.format(dateMeta.marker, formatter, {\n    forcedTzo: dateMeta.forcedTzo\n  });\n}\n\nfunction formatRange(startInput, endInput, settings // mixture of env and formatter settings\n) {\n  var dateEnv = buildDateEnv(_typeof(settings) === 'object' && settings ? settings : {}); // pass in if non-null object\n\n  var formatter = createFormatter(settings, BASE_OPTION_DEFAULTS.defaultRangeSeparator);\n  var startMeta = dateEnv.createMarkerMeta(startInput);\n  var endMeta = dateEnv.createMarkerMeta(endInput);\n\n  if (!startMeta || !endMeta) {\n    // TODO: warning?\n    return '';\n  }\n\n  return dateEnv.formatRange(startMeta.marker, endMeta.marker, formatter, {\n    forcedStartTzo: startMeta.forcedTzo,\n    forcedEndTzo: endMeta.forcedTzo,\n    isEndExclusive: settings.isEndExclusive\n  });\n} // TODO: more DRY and optimized\n\n\nfunction buildDateEnv(settings) {\n  var locale = buildLocale(settings.locale || 'en', organizeRawLocales([]).map); // TODO: don't hardcode 'en' everywhere\n  // ensure required settings\n\n  settings = Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({\n    timeZone: BASE_OPTION_DEFAULTS.timeZone,\n    calendarSystem: 'gregory'\n  }, settings), {\n    locale: locale\n  });\n  return new DateEnv(settings);\n}\n\nvar DEF_DEFAULTS = {\n  startTime: '09:00',\n  endTime: '17:00',\n  daysOfWeek: [1, 2, 3, 4, 5],\n  display: 'inverse-background',\n  classNames: 'fc-non-business',\n  groupId: '_businessHours' // so multiple defs get grouped\n\n};\n/*\nTODO: pass around as EventDefHash!!!\n*/\n\nfunction parseBusinessHours(input, context) {\n  return parseEvents(refineInputs(input), null, context);\n}\n\nfunction refineInputs(input) {\n  var rawDefs;\n\n  if (input === true) {\n    rawDefs = [{}]; // will get DEF_DEFAULTS verbatim\n  } else if (Array.isArray(input)) {\n    // if specifying an array, every sub-definition NEEDS a day-of-week\n    rawDefs = input.filter(function (rawDef) {\n      return rawDef.daysOfWeek;\n    });\n  } else if (_typeof(input) === 'object' && input) {\n    // non-null object\n    rawDefs = [input];\n  } else {\n    // is probably false\n    rawDefs = [];\n  }\n\n  rawDefs = rawDefs.map(function (rawDef) {\n    return Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, DEF_DEFAULTS), rawDef);\n  });\n  return rawDefs;\n}\n\nfunction pointInsideRect(point, rect) {\n  return point.left >= rect.left && point.left < rect.right && point.top >= rect.top && point.top < rect.bottom;\n} // Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false\n\n\nfunction intersectRects(rect1, rect2) {\n  var res = {\n    left: Math.max(rect1.left, rect2.left),\n    right: Math.min(rect1.right, rect2.right),\n    top: Math.max(rect1.top, rect2.top),\n    bottom: Math.min(rect1.bottom, rect2.bottom)\n  };\n\n  if (res.left < res.right && res.top < res.bottom) {\n    return res;\n  }\n\n  return false;\n}\n\nfunction translateRect(rect, deltaX, deltaY) {\n  return {\n    left: rect.left + deltaX,\n    right: rect.right + deltaX,\n    top: rect.top + deltaY,\n    bottom: rect.bottom + deltaY\n  };\n} // Returns a new point that will have been moved to reside within the given rectangle\n\n\nfunction constrainPoint(point, rect) {\n  return {\n    left: Math.min(Math.max(point.left, rect.left), rect.right),\n    top: Math.min(Math.max(point.top, rect.top), rect.bottom)\n  };\n} // Returns a point that is the center of the given rectangle\n\n\nfunction getRectCenter(rect) {\n  return {\n    left: (rect.left + rect.right) / 2,\n    top: (rect.top + rect.bottom) / 2\n  };\n} // Subtracts point2's coordinates from point1's coordinates, returning a delta\n\n\nfunction diffPoints(point1, point2) {\n  return {\n    left: point1.left - point2.left,\n    top: point1.top - point2.top\n  };\n}\n\nvar EMPTY_EVENT_STORE = createEmptyEventStore(); // for purecomponents. TODO: keep elsewhere\n\nvar Splitter =\n/** @class */\nfunction () {\n  function Splitter() {\n    this.getKeysForEventDefs = memoize(this._getKeysForEventDefs);\n    this.splitDateSelection = memoize(this._splitDateSpan);\n    this.splitEventStore = memoize(this._splitEventStore);\n    this.splitIndividualUi = memoize(this._splitIndividualUi);\n    this.splitEventDrag = memoize(this._splitInteraction);\n    this.splitEventResize = memoize(this._splitInteraction);\n    this.eventUiBuilders = {}; // TODO: typescript protection\n  }\n\n  Splitter.prototype.splitProps = function (props) {\n    var _this = this;\n\n    var keyInfos = this.getKeyInfo(props);\n    var defKeys = this.getKeysForEventDefs(props.eventStore);\n    var dateSelections = this.splitDateSelection(props.dateSelection);\n    var individualUi = this.splitIndividualUi(props.eventUiBases, defKeys); // the individual *bases*\n\n    var eventStores = this.splitEventStore(props.eventStore, defKeys);\n    var eventDrags = this.splitEventDrag(props.eventDrag);\n    var eventResizes = this.splitEventResize(props.eventResize);\n    var splitProps = {};\n    this.eventUiBuilders = mapHash(keyInfos, function (info, key) {\n      return _this.eventUiBuilders[key] || memoize(buildEventUiForKey);\n    });\n\n    for (var key in keyInfos) {\n      var keyInfo = keyInfos[key];\n      var eventStore = eventStores[key] || EMPTY_EVENT_STORE;\n      var buildEventUi = this.eventUiBuilders[key];\n      splitProps[key] = {\n        businessHours: keyInfo.businessHours || props.businessHours,\n        dateSelection: dateSelections[key] || null,\n        eventStore: eventStore,\n        eventUiBases: buildEventUi(props.eventUiBases[''], keyInfo.ui, individualUi[key]),\n        eventSelection: eventStore.instances[props.eventSelection] ? props.eventSelection : '',\n        eventDrag: eventDrags[key] || null,\n        eventResize: eventResizes[key] || null\n      };\n    }\n\n    return splitProps;\n  };\n\n  Splitter.prototype._splitDateSpan = function (dateSpan) {\n    var dateSpans = {};\n\n    if (dateSpan) {\n      var keys = this.getKeysForDateSpan(dateSpan);\n\n      for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n        var key = keys_1[_i];\n        dateSpans[key] = dateSpan;\n      }\n    }\n\n    return dateSpans;\n  };\n\n  Splitter.prototype._getKeysForEventDefs = function (eventStore) {\n    var _this = this;\n\n    return mapHash(eventStore.defs, function (eventDef) {\n      return _this.getKeysForEventDef(eventDef);\n    });\n  };\n\n  Splitter.prototype._splitEventStore = function (eventStore, defKeys) {\n    var defs = eventStore.defs,\n        instances = eventStore.instances;\n    var splitStores = {};\n\n    for (var defId in defs) {\n      for (var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++) {\n        var key = _a[_i];\n\n        if (!splitStores[key]) {\n          splitStores[key] = createEmptyEventStore();\n        }\n\n        splitStores[key].defs[defId] = defs[defId];\n      }\n    }\n\n    for (var instanceId in instances) {\n      var instance = instances[instanceId];\n\n      for (var _b = 0, _c = defKeys[instance.defId]; _b < _c.length; _b++) {\n        var key = _c[_b];\n\n        if (splitStores[key]) {\n          // must have already been created\n          splitStores[key].instances[instanceId] = instance;\n        }\n      }\n    }\n\n    return splitStores;\n  };\n\n  Splitter.prototype._splitIndividualUi = function (eventUiBases, defKeys) {\n    var splitHashes = {};\n\n    for (var defId in eventUiBases) {\n      if (defId) {\n        // not the '' key\n        for (var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++) {\n          var key = _a[_i];\n\n          if (!splitHashes[key]) {\n            splitHashes[key] = {};\n          }\n\n          splitHashes[key][defId] = eventUiBases[defId];\n        }\n      }\n    }\n\n    return splitHashes;\n  };\n\n  Splitter.prototype._splitInteraction = function (interaction) {\n    var splitStates = {};\n\n    if (interaction) {\n      var affectedStores_1 = this._splitEventStore(interaction.affectedEvents, this._getKeysForEventDefs(interaction.affectedEvents) // can't use cached. might be events from other calendar\n      ); // can't rely on defKeys because event data is mutated\n\n\n      var mutatedKeysByDefId = this._getKeysForEventDefs(interaction.mutatedEvents);\n\n      var mutatedStores_1 = this._splitEventStore(interaction.mutatedEvents, mutatedKeysByDefId);\n\n      var populate = function populate(key) {\n        if (!splitStates[key]) {\n          splitStates[key] = {\n            affectedEvents: affectedStores_1[key] || EMPTY_EVENT_STORE,\n            mutatedEvents: mutatedStores_1[key] || EMPTY_EVENT_STORE,\n            isEvent: interaction.isEvent\n          };\n        }\n      };\n\n      for (var key in affectedStores_1) {\n        populate(key);\n      }\n\n      for (var key in mutatedStores_1) {\n        populate(key);\n      }\n    }\n\n    return splitStates;\n  };\n\n  return Splitter;\n}();\n\nfunction buildEventUiForKey(allUi, eventUiForKey, individualUi) {\n  var baseParts = [];\n\n  if (allUi) {\n    baseParts.push(allUi);\n  }\n\n  if (eventUiForKey) {\n    baseParts.push(eventUiForKey);\n  }\n\n  var stuff = {\n    '': combineEventUis(baseParts)\n  };\n\n  if (individualUi) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(stuff, individualUi);\n  }\n\n  return stuff;\n}\n\nfunction getDateMeta(date, todayRange, nowDate, dateProfile) {\n  return {\n    dow: date.getUTCDay(),\n    isDisabled: Boolean(dateProfile && !rangeContainsMarker(dateProfile.activeRange, date)),\n    isOther: Boolean(dateProfile && !rangeContainsMarker(dateProfile.currentRange, date)),\n    isToday: Boolean(todayRange && rangeContainsMarker(todayRange, date)),\n    isPast: Boolean(nowDate ? date < nowDate : todayRange ? date < todayRange.start : false),\n    isFuture: Boolean(nowDate ? date > nowDate : todayRange ? date >= todayRange.end : false)\n  };\n}\n\nfunction getDayClassNames(meta, theme) {\n  var classNames = ['fc-day', 'fc-day-' + DAY_IDS[meta.dow]];\n\n  if (meta.isDisabled) {\n    classNames.push('fc-day-disabled');\n  } else {\n    if (meta.isToday) {\n      classNames.push('fc-day-today');\n      classNames.push(theme.getClass('today'));\n    }\n\n    if (meta.isPast) {\n      classNames.push('fc-day-past');\n    }\n\n    if (meta.isFuture) {\n      classNames.push('fc-day-future');\n    }\n\n    if (meta.isOther) {\n      classNames.push('fc-day-other');\n    }\n  }\n\n  return classNames;\n}\n\nfunction getSlotClassNames(meta, theme) {\n  var classNames = ['fc-slot', 'fc-slot-' + DAY_IDS[meta.dow]];\n\n  if (meta.isDisabled) {\n    classNames.push('fc-slot-disabled');\n  } else {\n    if (meta.isToday) {\n      classNames.push('fc-slot-today');\n      classNames.push(theme.getClass('today'));\n    }\n\n    if (meta.isPast) {\n      classNames.push('fc-slot-past');\n    }\n\n    if (meta.isFuture) {\n      classNames.push('fc-slot-future');\n    }\n  }\n\n  return classNames;\n}\n\nfunction buildNavLinkData(date, type) {\n  if (type === void 0) {\n    type = 'day';\n  }\n\n  return JSON.stringify({\n    date: formatDayString(date),\n    type: type\n  });\n}\n\nvar _isRtlScrollbarOnLeft = null;\n\nfunction getIsRtlScrollbarOnLeft() {\n  if (_isRtlScrollbarOnLeft === null) {\n    _isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();\n  }\n\n  return _isRtlScrollbarOnLeft;\n}\n\nfunction computeIsRtlScrollbarOnLeft() {\n  // TODO: use htmlToElement\n  var outerEl = document.createElement('div');\n  applyStyle(outerEl, {\n    position: 'absolute',\n    top: -1000,\n    left: 0,\n    border: 0,\n    padding: 0,\n    overflow: 'scroll',\n    direction: 'rtl'\n  });\n  outerEl.innerHTML = '<div></div>';\n  document.body.appendChild(outerEl);\n  var innerEl = outerEl.firstChild;\n  var res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;\n  removeElement(outerEl);\n  return res;\n}\n\nvar _scrollbarWidths;\n\nfunction getScrollbarWidths() {\n  if (!_scrollbarWidths) {\n    _scrollbarWidths = computeScrollbarWidths();\n  }\n\n  return _scrollbarWidths;\n}\n\nfunction computeScrollbarWidths() {\n  var el = document.createElement('div');\n  el.style.overflow = 'scroll';\n  document.body.appendChild(el);\n  var res = computeScrollbarWidthsForEl(el);\n  document.body.removeChild(el);\n  return res;\n} // WARNING: will include border\n\n\nfunction computeScrollbarWidthsForEl(el) {\n  return {\n    x: el.offsetHeight - el.clientHeight,\n    y: el.offsetWidth - el.clientWidth\n  };\n}\n\nfunction computeEdges(el, getPadding) {\n  if (getPadding === void 0) {\n    getPadding = false;\n  }\n\n  var computedStyle = window.getComputedStyle(el);\n  var borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;\n  var borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;\n  var borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;\n  var borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;\n  var badScrollbarWidths = computeScrollbarWidthsForEl(el); // includes border!\n\n  var scrollbarLeftRight = badScrollbarWidths.y - borderLeft - borderRight;\n  var scrollbarBottom = badScrollbarWidths.x - borderTop - borderBottom;\n  var res = {\n    borderLeft: borderLeft,\n    borderRight: borderRight,\n    borderTop: borderTop,\n    borderBottom: borderBottom,\n    scrollbarBottom: scrollbarBottom,\n    scrollbarLeft: 0,\n    scrollbarRight: 0\n  };\n\n  if (getIsRtlScrollbarOnLeft() && computedStyle.direction === 'rtl') {\n    // is the scrollbar on the left side?\n    res.scrollbarLeft = scrollbarLeftRight;\n  } else {\n    res.scrollbarRight = scrollbarLeftRight;\n  }\n\n  if (getPadding) {\n    res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;\n    res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;\n    res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;\n    res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;\n  }\n\n  return res;\n}\n\nfunction computeInnerRect(el, goWithinPadding, doFromWindowViewport) {\n  if (goWithinPadding === void 0) {\n    goWithinPadding = false;\n  }\n\n  var outerRect = doFromWindowViewport ? el.getBoundingClientRect() : computeRect(el);\n  var edges = computeEdges(el, goWithinPadding);\n  var res = {\n    left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,\n    right: outerRect.right - edges.borderRight - edges.scrollbarRight,\n    top: outerRect.top + edges.borderTop,\n    bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom\n  };\n\n  if (goWithinPadding) {\n    res.left += edges.paddingLeft;\n    res.right -= edges.paddingRight;\n    res.top += edges.paddingTop;\n    res.bottom -= edges.paddingBottom;\n  }\n\n  return res;\n}\n\nfunction computeRect(el) {\n  var rect = el.getBoundingClientRect();\n  return {\n    left: rect.left + window.pageXOffset,\n    top: rect.top + window.pageYOffset,\n    right: rect.right + window.pageXOffset,\n    bottom: rect.bottom + window.pageYOffset\n  };\n}\n\nfunction computeHeightAndMargins(el) {\n  return el.getBoundingClientRect().height + computeVMargins(el);\n}\n\nfunction computeVMargins(el) {\n  var computed = window.getComputedStyle(el);\n  return parseInt(computed.marginTop, 10) + parseInt(computed.marginBottom, 10);\n} // does not return window\n\n\nfunction getClippingParents(el) {\n  var parents = [];\n\n  while (el instanceof HTMLElement) {\n    // will stop when gets to document or null\n    var computedStyle = window.getComputedStyle(el);\n\n    if (computedStyle.position === 'fixed') {\n      break;\n    }\n\n    if (/(auto|scroll)/.test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {\n      parents.push(el);\n    }\n\n    el = el.parentNode;\n  }\n\n  return parents;\n} // given a function that resolves a result asynchronously.\n// the function can either call passed-in success and failure callbacks,\n// or it can return a promise.\n// if you need to pass additional params to func, bind them first.\n\n\nfunction unpromisify(func, success, failure) {\n  // guard against success/failure callbacks being called more than once\n  // and guard against a promise AND callback being used together.\n  var isResolved = false;\n\n  var wrappedSuccess = function wrappedSuccess() {\n    if (!isResolved) {\n      isResolved = true;\n      success.apply(this, arguments);\n    }\n  };\n\n  var wrappedFailure = function wrappedFailure() {\n    if (!isResolved) {\n      isResolved = true;\n\n      if (failure) {\n        failure.apply(this, arguments);\n      }\n    }\n  };\n\n  var res = func(wrappedSuccess, wrappedFailure);\n\n  if (res && typeof res.then === 'function') {\n    res.then(wrappedSuccess, wrappedFailure);\n  }\n}\n\nvar Emitter =\n/** @class */\nfunction () {\n  function Emitter() {\n    this.handlers = {};\n    this.thisContext = null;\n  }\n\n  Emitter.prototype.setThisContext = function (thisContext) {\n    this.thisContext = thisContext;\n  };\n\n  Emitter.prototype.setOptions = function (options) {\n    this.options = options;\n  };\n\n  Emitter.prototype.on = function (type, handler) {\n    addToHash(this.handlers, type, handler);\n  };\n\n  Emitter.prototype.off = function (type, handler) {\n    removeFromHash(this.handlers, type, handler);\n  };\n\n  Emitter.prototype.trigger = function (type) {\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    var attachedHandlers = this.handlers[type] || [];\n    var optionHandler = this.options && this.options[type];\n    var handlers = [].concat(optionHandler || [], attachedHandlers);\n\n    for (var _a = 0, handlers_1 = handlers; _a < handlers_1.length; _a++) {\n      var handler = handlers_1[_a];\n      handler.apply(this.thisContext, args);\n    }\n  };\n\n  Emitter.prototype.hasHandlers = function (type) {\n    return this.handlers[type] && this.handlers[type].length || this.options && this.options[type];\n  };\n\n  return Emitter;\n}();\n\nfunction addToHash(hash, type, handler) {\n  (hash[type] || (hash[type] = [])).push(handler);\n}\n\nfunction removeFromHash(hash, type, handler) {\n  if (handler) {\n    if (hash[type]) {\n      hash[type] = hash[type].filter(function (func) {\n        return func !== handler;\n      });\n    }\n  } else {\n    delete hash[type]; // remove all handler funcs for this type\n  }\n}\n/*\nRecords offset information for a set of elements, relative to an origin element.\nCan record the left/right OR the top/bottom OR both.\nProvides methods for querying the cache by position.\n*/\n\n\nvar PositionCache =\n/** @class */\nfunction () {\n  function PositionCache(originEl, els, isHorizontal, isVertical) {\n    this.els = els;\n    var originClientRect = this.originClientRect = originEl.getBoundingClientRect(); // relative to viewport top-left\n\n    if (isHorizontal) {\n      this.buildElHorizontals(originClientRect.left);\n    }\n\n    if (isVertical) {\n      this.buildElVerticals(originClientRect.top);\n    }\n  } // Populates the left/right internal coordinate arrays\n\n\n  PositionCache.prototype.buildElHorizontals = function (originClientLeft) {\n    var lefts = [];\n    var rights = [];\n\n    for (var _i = 0, _a = this.els; _i < _a.length; _i++) {\n      var el = _a[_i];\n      var rect = el.getBoundingClientRect();\n      lefts.push(rect.left - originClientLeft);\n      rights.push(rect.right - originClientLeft);\n    }\n\n    this.lefts = lefts;\n    this.rights = rights;\n  }; // Populates the top/bottom internal coordinate arrays\n\n\n  PositionCache.prototype.buildElVerticals = function (originClientTop) {\n    var tops = [];\n    var bottoms = [];\n\n    for (var _i = 0, _a = this.els; _i < _a.length; _i++) {\n      var el = _a[_i];\n      var rect = el.getBoundingClientRect();\n      tops.push(rect.top - originClientTop);\n      bottoms.push(rect.bottom - originClientTop);\n    }\n\n    this.tops = tops;\n    this.bottoms = bottoms;\n  }; // Given a left offset (from document left), returns the index of the el that it horizontally intersects.\n  // If no intersection is made, returns undefined.\n\n\n  PositionCache.prototype.leftToIndex = function (leftPosition) {\n    var lefts = this.lefts;\n    var rights = this.rights;\n    var len = lefts.length;\n    var i;\n\n    for (i = 0; i < len; i++) {\n      if (leftPosition >= lefts[i] && leftPosition < rights[i]) {\n        return i;\n      }\n    }\n  }; // Given a top offset (from document top), returns the index of the el that it vertically intersects.\n  // If no intersection is made, returns undefined.\n\n\n  PositionCache.prototype.topToIndex = function (topPosition) {\n    var tops = this.tops;\n    var bottoms = this.bottoms;\n    var len = tops.length;\n    var i;\n\n    for (i = 0; i < len; i++) {\n      if (topPosition >= tops[i] && topPosition < bottoms[i]) {\n        return i;\n      }\n    }\n  }; // Gets the width of the element at the given index\n\n\n  PositionCache.prototype.getWidth = function (leftIndex) {\n    return this.rights[leftIndex] - this.lefts[leftIndex];\n  }; // Gets the height of the element at the given index\n\n\n  PositionCache.prototype.getHeight = function (topIndex) {\n    return this.bottoms[topIndex] - this.tops[topIndex];\n  };\n\n  return PositionCache;\n}();\n/*\nAn object for getting/setting scroll-related information for an element.\nInternally, this is done very differently for window versus DOM element,\nso this object serves as a common interface.\n*/\n\n\nvar ScrollController =\n/** @class */\nfunction () {\n  function ScrollController() {}\n\n  ScrollController.prototype.getMaxScrollTop = function () {\n    return this.getScrollHeight() - this.getClientHeight();\n  };\n\n  ScrollController.prototype.getMaxScrollLeft = function () {\n    return this.getScrollWidth() - this.getClientWidth();\n  };\n\n  ScrollController.prototype.canScrollVertically = function () {\n    return this.getMaxScrollTop() > 0;\n  };\n\n  ScrollController.prototype.canScrollHorizontally = function () {\n    return this.getMaxScrollLeft() > 0;\n  };\n\n  ScrollController.prototype.canScrollUp = function () {\n    return this.getScrollTop() > 0;\n  };\n\n  ScrollController.prototype.canScrollDown = function () {\n    return this.getScrollTop() < this.getMaxScrollTop();\n  };\n\n  ScrollController.prototype.canScrollLeft = function () {\n    return this.getScrollLeft() > 0;\n  };\n\n  ScrollController.prototype.canScrollRight = function () {\n    return this.getScrollLeft() < this.getMaxScrollLeft();\n  };\n\n  return ScrollController;\n}();\n\nvar ElementScrollController =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(ElementScrollController, _super);\n\n  function ElementScrollController(el) {\n    var _this = _super.call(this) || this;\n\n    _this.el = el;\n    return _this;\n  }\n\n  ElementScrollController.prototype.getScrollTop = function () {\n    return this.el.scrollTop;\n  };\n\n  ElementScrollController.prototype.getScrollLeft = function () {\n    return this.el.scrollLeft;\n  };\n\n  ElementScrollController.prototype.setScrollTop = function (top) {\n    this.el.scrollTop = top;\n  };\n\n  ElementScrollController.prototype.setScrollLeft = function (left) {\n    this.el.scrollLeft = left;\n  };\n\n  ElementScrollController.prototype.getScrollWidth = function () {\n    return this.el.scrollWidth;\n  };\n\n  ElementScrollController.prototype.getScrollHeight = function () {\n    return this.el.scrollHeight;\n  };\n\n  ElementScrollController.prototype.getClientHeight = function () {\n    return this.el.clientHeight;\n  };\n\n  ElementScrollController.prototype.getClientWidth = function () {\n    return this.el.clientWidth;\n  };\n\n  return ElementScrollController;\n}(ScrollController);\n\nvar WindowScrollController =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(WindowScrollController, _super);\n\n  function WindowScrollController() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  WindowScrollController.prototype.getScrollTop = function () {\n    return window.pageYOffset;\n  };\n\n  WindowScrollController.prototype.getScrollLeft = function () {\n    return window.pageXOffset;\n  };\n\n  WindowScrollController.prototype.setScrollTop = function (n) {\n    window.scroll(window.pageXOffset, n);\n  };\n\n  WindowScrollController.prototype.setScrollLeft = function (n) {\n    window.scroll(n, window.pageYOffset);\n  };\n\n  WindowScrollController.prototype.getScrollWidth = function () {\n    return document.documentElement.scrollWidth;\n  };\n\n  WindowScrollController.prototype.getScrollHeight = function () {\n    return document.documentElement.scrollHeight;\n  };\n\n  WindowScrollController.prototype.getClientHeight = function () {\n    return document.documentElement.clientHeight;\n  };\n\n  WindowScrollController.prototype.getClientWidth = function () {\n    return document.documentElement.clientWidth;\n  };\n\n  return WindowScrollController;\n}(ScrollController);\n\nvar Theme =\n/** @class */\nfunction () {\n  function Theme(calendarOptions) {\n    if (this.iconOverrideOption) {\n      this.setIconOverride(calendarOptions[this.iconOverrideOption]);\n    }\n  }\n\n  Theme.prototype.setIconOverride = function (iconOverrideHash) {\n    var iconClassesCopy;\n    var buttonName;\n\n    if (_typeof(iconOverrideHash) === 'object' && iconOverrideHash) {\n      // non-null object\n      iconClassesCopy = Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, this.iconClasses);\n\n      for (buttonName in iconOverrideHash) {\n        iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);\n      }\n\n      this.iconClasses = iconClassesCopy;\n    } else if (iconOverrideHash === false) {\n      this.iconClasses = {};\n    }\n  };\n\n  Theme.prototype.applyIconOverridePrefix = function (className) {\n    var prefix = this.iconOverridePrefix;\n\n    if (prefix && className.indexOf(prefix) !== 0) {\n      // if not already present\n      className = prefix + className;\n    }\n\n    return className;\n  };\n\n  Theme.prototype.getClass = function (key) {\n    return this.classes[key] || '';\n  };\n\n  Theme.prototype.getIconClass = function (buttonName, isRtl) {\n    var className;\n\n    if (isRtl && this.rtlIconClasses) {\n      className = this.rtlIconClasses[buttonName] || this.iconClasses[buttonName];\n    } else {\n      className = this.iconClasses[buttonName];\n    }\n\n    if (className) {\n      return this.baseIconClass + ' ' + className;\n    }\n\n    return '';\n  };\n\n  Theme.prototype.getCustomButtonIconClass = function (customButtonProps) {\n    var className;\n\n    if (this.iconOverrideCustomButtonOption) {\n      className = customButtonProps[this.iconOverrideCustomButtonOption];\n\n      if (className) {\n        return this.baseIconClass + ' ' + this.applyIconOverridePrefix(className);\n      }\n    }\n\n    return '';\n  };\n\n  return Theme;\n}();\n\nTheme.prototype.classes = {};\nTheme.prototype.iconClasses = {};\nTheme.prototype.baseIconClass = '';\nTheme.prototype.iconOverridePrefix = '';\n\nvar ScrollResponder =\n/** @class */\nfunction () {\n  function ScrollResponder(execFunc, emitter, scrollTime) {\n    var _this = this;\n\n    this.execFunc = execFunc;\n    this.emitter = emitter;\n    this.scrollTime = scrollTime;\n\n    this.handleScrollRequest = function (request) {\n      _this.queuedRequest = Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, _this.queuedRequest || {}, request);\n\n      _this.drain();\n    };\n\n    emitter.on('_scrollRequest', this.handleScrollRequest);\n    this.fireInitialScroll();\n  }\n\n  ScrollResponder.prototype.detach = function () {\n    this.emitter.off('_scrollRequest', this.handleScrollRequest);\n  };\n\n  ScrollResponder.prototype.update = function (isDatesNew) {\n    if (isDatesNew) {\n      this.fireInitialScroll(); // will drain\n    } else {\n      this.drain();\n    }\n  };\n\n  ScrollResponder.prototype.fireInitialScroll = function () {\n    this.handleScrollRequest({\n      time: this.scrollTime\n    });\n  };\n\n  ScrollResponder.prototype.drain = function () {\n    if (this.queuedRequest && this.execFunc(this.queuedRequest)) {\n      this.queuedRequest = null;\n    }\n  };\n\n  return ScrollResponder;\n}();\n\nvar ViewContextType = Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createContext\"])({}); // for Components\n\nfunction buildViewContext(viewSpec, viewApi, viewOptions, dateProfileGenerator, dateEnv, theme, pluginHooks, dispatch, getCurrentData, emitter, calendarApi, registerInteractiveComponent, unregisterInteractiveComponent) {\n  return {\n    dateEnv: dateEnv,\n    options: viewOptions,\n    pluginHooks: pluginHooks,\n    emitter: emitter,\n    dispatch: dispatch,\n    getCurrentData: getCurrentData,\n    calendarApi: calendarApi,\n    viewSpec: viewSpec,\n    viewApi: viewApi,\n    dateProfileGenerator: dateProfileGenerator,\n    theme: theme,\n    isRtl: viewOptions.direction === 'rtl',\n    addResizeHandler: function addResizeHandler(handler) {\n      emitter.on('_resize', handler);\n    },\n    removeResizeHandler: function removeResizeHandler(handler) {\n      emitter.off('_resize', handler);\n    },\n    createScrollResponder: function createScrollResponder(execFunc) {\n      return new ScrollResponder(execFunc, emitter, createDuration(viewOptions.scrollTime));\n    },\n    registerInteractiveComponent: registerInteractiveComponent,\n    unregisterInteractiveComponent: unregisterInteractiveComponent\n  };\n}\n\nvar PureComponent =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(PureComponent, _super);\n\n  function PureComponent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  PureComponent.prototype.shouldComponentUpdate = function (nextProps, nextState) {\n    if (this.debug) {\n      console.log(getUnequalProps(nextProps, this.props), getUnequalProps(nextState, this.state));\n    }\n\n    return !compareObjs(this.props, nextProps, this.propEquality) || !compareObjs(this.state, nextState, this.stateEquality);\n  };\n\n  PureComponent.addPropsEquality = addPropsEquality;\n  PureComponent.addStateEquality = addStateEquality;\n  PureComponent.contextType = ViewContextType;\n  return PureComponent;\n}(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"Component\"]);\n\nPureComponent.prototype.propEquality = {};\nPureComponent.prototype.stateEquality = {};\n\nvar BaseComponent =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(BaseComponent, _super);\n\n  function BaseComponent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  BaseComponent.contextType = ViewContextType;\n  return BaseComponent;\n}(PureComponent);\n\nfunction addPropsEquality(propEquality) {\n  var hash = Object.create(this.prototype.propEquality);\n\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(hash, propEquality);\n\n  this.prototype.propEquality = hash;\n}\n\nfunction addStateEquality(stateEquality) {\n  var hash = Object.create(this.prototype.stateEquality);\n\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(hash, stateEquality);\n\n  this.prototype.stateEquality = hash;\n} // use other one\n\n\nfunction setRef(ref, current) {\n  if (typeof ref === 'function') {\n    ref(current);\n  } else if (ref) {\n    // see https://github.com/facebook/react/issues/13029\n    ref.current = current;\n  }\n}\n\nfunction reduceEventStore(eventStore, action, eventSources, dateProfile, context) {\n  switch (action.type) {\n    case 'RECEIVE_EVENTS':\n      // raw\n      return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, context);\n\n    case 'ADD_EVENTS':\n      // already parsed, but not expanded\n      return addEvent(eventStore, action.eventStore, // new ones\n      dateProfile ? dateProfile.activeRange : null, context);\n\n    case 'MERGE_EVENTS':\n      // already parsed and expanded\n      return mergeEventStores(eventStore, action.eventStore);\n\n    case 'PREV': // TODO: how do we track all actions that affect dateProfile :(\n\n    case 'NEXT':\n    case 'CHANGE_DATE':\n    case 'CHANGE_VIEW_TYPE':\n      if (dateProfile) {\n        return expandRecurring(eventStore, dateProfile.activeRange, context);\n      } else {\n        return eventStore;\n      }\n\n    case 'REMOVE_EVENTS':\n      return excludeSubEventStore(eventStore, action.eventStore);\n\n    case 'REMOVE_EVENT_SOURCE':\n      return excludeEventsBySourceId(eventStore, action.sourceId);\n\n    case 'REMOVE_ALL_EVENT_SOURCES':\n      return filterEventStoreDefs(eventStore, function (eventDef) {\n        return !eventDef.sourceId; // only keep events with no source id\n      });\n\n    case 'REMOVE_ALL_EVENTS':\n      return createEmptyEventStore();\n\n    default:\n      return eventStore;\n  }\n}\n\nfunction receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, context) {\n  if (eventSource && // not already removed\n  fetchId === eventSource.latestFetchId // TODO: wish this logic was always in event-sources\n  ) {\n      var subset = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context);\n\n      if (fetchRange) {\n        subset = expandRecurring(subset, fetchRange, context);\n      }\n\n      return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);\n    }\n\n  return eventStore;\n}\n\nfunction transformRawEvents(rawEvents, eventSource, context) {\n  var calEachTransform = context.options.eventDataTransform;\n  var sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;\n\n  if (sourceEachTransform) {\n    rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);\n  }\n\n  if (calEachTransform) {\n    rawEvents = transformEachRawEvent(rawEvents, calEachTransform);\n  }\n\n  return rawEvents;\n}\n\nfunction transformEachRawEvent(rawEvents, func) {\n  var refinedEvents;\n\n  if (!func) {\n    refinedEvents = rawEvents;\n  } else {\n    refinedEvents = [];\n\n    for (var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++) {\n      var rawEvent = rawEvents_1[_i];\n      var refinedEvent = func(rawEvent);\n\n      if (refinedEvent) {\n        refinedEvents.push(refinedEvent);\n      } else if (refinedEvent == null) {\n        refinedEvents.push(rawEvent);\n      } // if a different falsy value, do nothing\n\n    }\n  }\n\n  return refinedEvents;\n}\n\nfunction addEvent(eventStore, subset, expandRange, context) {\n  if (expandRange) {\n    subset = expandRecurring(subset, expandRange, context);\n  }\n\n  return mergeEventStores(eventStore, subset);\n}\n\nfunction rezoneEventStoreDates(eventStore, oldDateEnv, newDateEnv) {\n  var defs = eventStore.defs;\n  var instances = mapHash(eventStore.instances, function (instance) {\n    var def = defs[instance.defId];\n\n    if (def.allDay || def.recurringDef) {\n      return instance; // isn't dependent on timezone\n    } else {\n      return Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, instance), {\n        range: {\n          start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),\n          end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo))\n        },\n        forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo,\n        forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo\n      });\n    }\n  });\n  return {\n    defs: defs,\n    instances: instances\n  };\n}\n\nfunction excludeEventsBySourceId(eventStore, sourceId) {\n  return filterEventStoreDefs(eventStore, function (eventDef) {\n    return eventDef.sourceId !== sourceId;\n  });\n} // QUESTION: why not just return instances? do a general object-property-exclusion util\n\n\nfunction excludeInstances(eventStore, removals) {\n  return {\n    defs: eventStore.defs,\n    instances: filterHash(eventStore.instances, function (instance) {\n      return !removals[instance.instanceId];\n    })\n  };\n} // high-level segmenting-aware tester functions\n// ------------------------------------------------------------------------------------------------------------------------\n\n\nfunction isInteractionValid(interaction, context) {\n  return isNewPropsValid({\n    eventDrag: interaction\n  }, context); // HACK: the eventDrag props is used for ALL interactions\n}\n\nfunction isDateSelectionValid(dateSelection, context) {\n  return isNewPropsValid({\n    dateSelection: dateSelection\n  }, context);\n}\n\nfunction isNewPropsValid(newProps, context) {\n  var calendarState = context.getCurrentData();\n\n  var props = Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({\n    businessHours: calendarState.businessHours,\n    dateSelection: '',\n    eventStore: calendarState.eventStore,\n    eventUiBases: calendarState.eventUiBases,\n    eventSelection: '',\n    eventDrag: null,\n    eventResize: null\n  }, newProps);\n\n  return (context.pluginHooks.isPropsValid || isPropsValid)(props, context);\n}\n\nfunction isPropsValid(state, context, dateSpanMeta, filterConfig) {\n  if (dateSpanMeta === void 0) {\n    dateSpanMeta = {};\n  }\n\n  if (state.eventDrag && !isInteractionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n    return false;\n  }\n\n  if (state.dateSelection && !isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n    return false;\n  }\n\n  return true;\n} // Moving Event Validation\n// ------------------------------------------------------------------------------------------------------------------------\n\n\nfunction isInteractionPropsValid(state, context, dateSpanMeta, filterConfig) {\n  var currentState = context.getCurrentData();\n  var interaction = state.eventDrag; // HACK: the eventDrag props is used for ALL interactions\n\n  var subjectEventStore = interaction.mutatedEvents;\n  var subjectDefs = subjectEventStore.defs;\n  var subjectInstances = subjectEventStore.instances;\n  var subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ? state.eventUiBases : {\n    '': currentState.selectionConfig\n  } // if not a real event, validate as a selection\n  );\n\n  if (filterConfig) {\n    subjectConfigs = mapHash(subjectConfigs, filterConfig);\n  }\n\n  var otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances); // exclude the subject events. TODO: exclude defs too?\n\n  var otherDefs = otherEventStore.defs;\n  var otherInstances = otherEventStore.instances;\n  var otherConfigs = compileEventUis(otherDefs, state.eventUiBases);\n\n  for (var subjectInstanceId in subjectInstances) {\n    var subjectInstance = subjectInstances[subjectInstanceId];\n    var subjectRange = subjectInstance.range;\n    var subjectConfig = subjectConfigs[subjectInstance.defId];\n    var subjectDef = subjectDefs[subjectInstance.defId]; // constraint\n\n    if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, context)) {\n      return false;\n    } // overlap\n\n\n    var eventOverlap = context.options.eventOverlap;\n    var eventOverlapFunc = typeof eventOverlap === 'function' ? eventOverlap : null;\n\n    for (var otherInstanceId in otherInstances) {\n      var otherInstance = otherInstances[otherInstanceId]; // intersect! evaluate\n\n      if (rangesIntersect(subjectRange, otherInstance.range)) {\n        var otherOverlap = otherConfigs[otherInstance.defId].overlap; // consider the other event's overlap. only do this if the subject event is a \"real\" event\n\n        if (otherOverlap === false && interaction.isEvent) {\n          return false;\n        }\n\n        if (subjectConfig.overlap === false) {\n          return false;\n        }\n\n        if (eventOverlapFunc && !eventOverlapFunc(new EventApi(context, otherDefs[otherInstance.defId], otherInstance), // still event\n        new EventApi(context, subjectDef, subjectInstance) // moving event\n        )) {\n          return false;\n        }\n      }\n    } // allow (a function)\n\n\n    var calendarEventStore = currentState.eventStore; // need global-to-calendar, not local to component (splittable)state\n\n    for (var _i = 0, _a = subjectConfig.allows; _i < _a.length; _i++) {\n      var subjectAllow = _a[_i];\n\n      var subjectDateSpan = Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, dateSpanMeta), {\n        range: subjectInstance.range,\n        allDay: subjectDef.allDay\n      });\n\n      var origDef = calendarEventStore.defs[subjectDef.defId];\n      var origInstance = calendarEventStore.instances[subjectInstanceId];\n      var eventApi = void 0;\n\n      if (origDef) {\n        // was previously in the calendar\n        eventApi = new EventApi(context, origDef, origInstance);\n      } else {\n        // was an external event\n        eventApi = new EventApi(context, subjectDef); // no instance, because had no dates\n      }\n\n      if (!subjectAllow(buildDateSpanApiWithContext(subjectDateSpan, context), eventApi)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n} // Date Selection Validation\n// ------------------------------------------------------------------------------------------------------------------------\n\n\nfunction isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig) {\n  var relevantEventStore = state.eventStore;\n  var relevantDefs = relevantEventStore.defs;\n  var relevantInstances = relevantEventStore.instances;\n  var selection = state.dateSelection;\n  var selectionRange = selection.range;\n  var selectionConfig = context.getCurrentData().selectionConfig;\n\n  if (filterConfig) {\n    selectionConfig = filterConfig(selectionConfig);\n  } // constraint\n\n\n  if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, context)) {\n    return false;\n  } // overlap\n\n\n  var selectOverlap = context.options.selectOverlap;\n  var selectOverlapFunc = typeof selectOverlap === 'function' ? selectOverlap : null;\n\n  for (var relevantInstanceId in relevantInstances) {\n    var relevantInstance = relevantInstances[relevantInstanceId]; // intersect! evaluate\n\n    if (rangesIntersect(selectionRange, relevantInstance.range)) {\n      if (selectionConfig.overlap === false) {\n        return false;\n      }\n\n      if (selectOverlapFunc && !selectOverlapFunc(new EventApi(context, relevantDefs[relevantInstance.defId], relevantInstance), null)) {\n        return false;\n      }\n    }\n  } // allow (a function)\n\n\n  for (var _i = 0, _a = selectionConfig.allows; _i < _a.length; _i++) {\n    var selectionAllow = _a[_i];\n\n    var fullDateSpan = Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, dateSpanMeta), selection);\n\n    if (!selectionAllow(buildDateSpanApiWithContext(fullDateSpan, context), null)) {\n      return false;\n    }\n  }\n\n  return true;\n} // Constraint Utils\n// ------------------------------------------------------------------------------------------------------------------------\n\n\nfunction allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, context) {\n  for (var _i = 0, constraints_1 = constraints; _i < constraints_1.length; _i++) {\n    var constraint = constraints_1[_i];\n\n    if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context), subjectRange)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction constraintToRanges(constraint, subjectRange, // for expanding a recurring constraint, or expanding business hours\notherEventStore, // for if constraint is an even group ID\nbusinessHoursUnexpanded, // for if constraint is 'businessHours'\ncontext // for expanding businesshours\n) {\n  if (constraint === 'businessHours') {\n    return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, context));\n  } else if (typeof constraint === 'string') {\n    // an group ID\n    return eventStoreToRanges(filterEventStoreDefs(otherEventStore, function (eventDef) {\n      return eventDef.groupId === constraint;\n    }));\n  } else if (_typeof(constraint) === 'object' && constraint) {\n    // non-null object\n    return eventStoreToRanges(expandRecurring(constraint, subjectRange, context));\n  }\n\n  return []; // if it's false\n} // TODO: move to event-store file?\n\n\nfunction eventStoreToRanges(eventStore) {\n  var instances = eventStore.instances;\n  var ranges = [];\n\n  for (var instanceId in instances) {\n    ranges.push(instances[instanceId].range);\n  }\n\n  return ranges;\n} // TODO: move to geom file?\n\n\nfunction anyRangesContainRange(outerRanges, innerRange) {\n  for (var _i = 0, outerRanges_1 = outerRanges; _i < outerRanges_1.length; _i++) {\n    var outerRange = outerRanges_1[_i];\n\n    if (rangeContainsRange(outerRange, innerRange)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/*\nan INTERACTABLE date component\n\nPURPOSES:\n- hook up to fg, fill, and mirror renderers\n- interface for dragging and hits\n*/\n\n\nvar DateComponent =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(DateComponent, _super);\n\n  function DateComponent() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.uid = guid();\n    return _this;\n  } // Hit System\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  DateComponent.prototype.prepareHits = function () {};\n\n  DateComponent.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {\n    return null; // this should be abstract\n  }; // Validation\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  DateComponent.prototype.isInteractionValid = function (interaction) {\n    var dateProfile = this.props.dateProfile; // HACK\n\n    var instances = interaction.mutatedEvents.instances;\n\n    if (dateProfile) {\n      // HACK for MorePopover\n      for (var instanceId in instances) {\n        if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {\n          return false;\n        }\n      }\n    }\n\n    return isInteractionValid(interaction, this.context);\n  };\n\n  DateComponent.prototype.isDateSelectionValid = function (selection) {\n    var dateProfile = this.props.dateProfile; // HACK\n\n    if (dateProfile && // HACK for MorePopover\n    !rangeContainsRange(dateProfile.validRange, selection.range)) {\n      return false;\n    }\n\n    return isDateSelectionValid(selection, this.context);\n  }; // Pointer Interaction Utils\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  DateComponent.prototype.isValidSegDownEl = function (el) {\n    return !this.props.eventDrag && // HACK\n    !this.props.eventResize && // HACK\n    !elementClosest(el, '.fc-event-mirror') && (this.isPopover() || !this.isInPopover(el)); // ^above line ensures we don't detect a seg interaction within a nested component.\n    // it's a HACK because it only supports a popover as the nested component.\n  };\n\n  DateComponent.prototype.isValidDateDownEl = function (el) {\n    return !elementClosest(el, '.fc-event:not(.fc-bg-event)') && !elementClosest(el, '.fc-daygrid-more-link') && // a \"more..\" link\n    !elementClosest(el, 'a[data-navlink]') && // a clickable nav link\n    !this.isInPopover(el);\n  };\n\n  DateComponent.prototype.isPopover = function () {\n    return false;\n  };\n\n  DateComponent.prototype.isInPopover = function (el) {\n    return Boolean(elementClosest(el, '.fc-popover'));\n  };\n\n  return DateComponent;\n}(BaseComponent); // TODO: easier way to add new hooks? need to update a million things\n\n\nfunction createPlugin(input) {\n  return {\n    id: guid(),\n    deps: input.deps || [],\n    reducers: input.reducers || [],\n    contextInit: [].concat(input.contextInit || []),\n    eventRefiners: input.eventRefiners || {},\n    eventDefMemberAdders: input.eventDefMemberAdders || [],\n    eventSourceRefiners: input.eventSourceRefiners || {},\n    isDraggableTransformers: input.isDraggableTransformers || [],\n    eventDragMutationMassagers: input.eventDragMutationMassagers || [],\n    eventDefMutationAppliers: input.eventDefMutationAppliers || [],\n    dateSelectionTransformers: input.dateSelectionTransformers || [],\n    datePointTransforms: input.datePointTransforms || [],\n    dateSpanTransforms: input.dateSpanTransforms || [],\n    views: input.views || {},\n    viewPropsTransformers: input.viewPropsTransformers || [],\n    isPropsValid: input.isPropsValid || null,\n    externalDefTransforms: input.externalDefTransforms || [],\n    eventResizeJoinTransforms: input.eventResizeJoinTransforms || [],\n    viewContainerAppends: input.viewContainerAppends || [],\n    eventDropTransformers: input.eventDropTransformers || [],\n    componentInteractions: input.componentInteractions || [],\n    calendarInteractions: input.calendarInteractions || [],\n    themeClasses: input.themeClasses || {},\n    eventSourceDefs: input.eventSourceDefs || [],\n    cmdFormatter: input.cmdFormatter,\n    recurringTypes: input.recurringTypes || [],\n    namedTimeZonedImpl: input.namedTimeZonedImpl,\n    initialView: input.initialView || '',\n    elementDraggingImpl: input.elementDraggingImpl,\n    optionChangeHandlers: input.optionChangeHandlers || {},\n    scrollGridImpl: input.scrollGridImpl || null,\n    contentTypeHandlers: input.contentTypeHandlers || {},\n    listenerRefiners: input.listenerRefiners || {},\n    optionRefiners: input.optionRefiners || {},\n    propSetHandlers: input.propSetHandlers || {}\n  };\n}\n\nfunction buildPluginHooks(pluginDefs, globalDefs) {\n  var isAdded = {};\n  var hooks = {\n    reducers: [],\n    contextInit: [],\n    eventRefiners: {},\n    eventDefMemberAdders: [],\n    eventSourceRefiners: {},\n    isDraggableTransformers: [],\n    eventDragMutationMassagers: [],\n    eventDefMutationAppliers: [],\n    dateSelectionTransformers: [],\n    datePointTransforms: [],\n    dateSpanTransforms: [],\n    views: {},\n    viewPropsTransformers: [],\n    isPropsValid: null,\n    externalDefTransforms: [],\n    eventResizeJoinTransforms: [],\n    viewContainerAppends: [],\n    eventDropTransformers: [],\n    componentInteractions: [],\n    calendarInteractions: [],\n    themeClasses: {},\n    eventSourceDefs: [],\n    cmdFormatter: null,\n    recurringTypes: [],\n    namedTimeZonedImpl: null,\n    initialView: '',\n    elementDraggingImpl: null,\n    optionChangeHandlers: {},\n    scrollGridImpl: null,\n    contentTypeHandlers: {},\n    listenerRefiners: {},\n    optionRefiners: {},\n    propSetHandlers: {}\n  };\n\n  function addDefs(defs) {\n    for (var _i = 0, defs_1 = defs; _i < defs_1.length; _i++) {\n      var def = defs_1[_i];\n\n      if (!isAdded[def.id]) {\n        isAdded[def.id] = true;\n        addDefs(def.deps);\n        hooks = combineHooks(hooks, def);\n      }\n    }\n  }\n\n  if (pluginDefs) {\n    addDefs(pluginDefs);\n  }\n\n  addDefs(globalDefs);\n  return hooks;\n}\n\nfunction buildBuildPluginHooks() {\n  var currentOverrideDefs = [];\n  var currentGlobalDefs = [];\n  var currentHooks;\n  return function (overrideDefs, globalDefs) {\n    if (!currentHooks || !isArraysEqual(overrideDefs, currentOverrideDefs) || !isArraysEqual(globalDefs, currentGlobalDefs)) {\n      currentHooks = buildPluginHooks(overrideDefs, globalDefs);\n    }\n\n    currentOverrideDefs = overrideDefs;\n    currentGlobalDefs = globalDefs;\n    return currentHooks;\n  };\n}\n\nfunction combineHooks(hooks0, hooks1) {\n  return {\n    reducers: hooks0.reducers.concat(hooks1.reducers),\n    contextInit: hooks0.contextInit.concat(hooks1.contextInit),\n    eventRefiners: Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, hooks0.eventRefiners), hooks1.eventRefiners),\n    eventDefMemberAdders: hooks0.eventDefMemberAdders.concat(hooks1.eventDefMemberAdders),\n    eventSourceRefiners: Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, hooks0.eventSourceRefiners), hooks1.eventSourceRefiners),\n    isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),\n    eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),\n    eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),\n    dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),\n    datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),\n    dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),\n    views: Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, hooks0.views), hooks1.views),\n    viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),\n    isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,\n    externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),\n    eventResizeJoinTransforms: hooks0.eventResizeJoinTransforms.concat(hooks1.eventResizeJoinTransforms),\n    viewContainerAppends: hooks0.viewContainerAppends.concat(hooks1.viewContainerAppends),\n    eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),\n    calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),\n    componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),\n    themeClasses: Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, hooks0.themeClasses), hooks1.themeClasses),\n    eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),\n    cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,\n    recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),\n    namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,\n    initialView: hooks0.initialView || hooks1.initialView,\n    elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,\n    optionChangeHandlers: Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, hooks0.optionChangeHandlers), hooks1.optionChangeHandlers),\n    scrollGridImpl: hooks1.scrollGridImpl || hooks0.scrollGridImpl,\n    contentTypeHandlers: Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, hooks0.contentTypeHandlers), hooks1.contentTypeHandlers),\n    listenerRefiners: Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, hooks0.listenerRefiners), hooks1.listenerRefiners),\n    optionRefiners: Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, hooks0.optionRefiners), hooks1.optionRefiners),\n    propSetHandlers: Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, hooks0.propSetHandlers), hooks1.propSetHandlers)\n  };\n}\n\nvar StandardTheme =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(StandardTheme, _super);\n\n  function StandardTheme() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return StandardTheme;\n}(Theme);\n\nStandardTheme.prototype.classes = {\n  root: 'fc-theme-standard',\n  tableCellShaded: 'fc-cell-shaded',\n  buttonGroup: 'fc-button-group',\n  button: 'fc-button fc-button-primary',\n  buttonActive: 'fc-button-active'\n};\nStandardTheme.prototype.baseIconClass = 'fc-icon';\nStandardTheme.prototype.iconClasses = {\n  close: 'fc-icon-x',\n  prev: 'fc-icon-chevron-left',\n  next: 'fc-icon-chevron-right',\n  prevYear: 'fc-icon-chevrons-left',\n  nextYear: 'fc-icon-chevrons-right'\n};\nStandardTheme.prototype.rtlIconClasses = {\n  prev: 'fc-icon-chevron-right',\n  next: 'fc-icon-chevron-left',\n  prevYear: 'fc-icon-chevrons-right',\n  nextYear: 'fc-icon-chevrons-left'\n};\nStandardTheme.prototype.iconOverrideOption = 'buttonIcons'; // TODO: make TS-friendly\n\nStandardTheme.prototype.iconOverrideCustomButtonOption = 'icon';\nStandardTheme.prototype.iconOverridePrefix = 'fc-icon-';\n\nfunction compileViewDefs(defaultConfigs, overrideConfigs) {\n  var hash = {};\n  var viewType;\n\n  for (viewType in defaultConfigs) {\n    ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n  }\n\n  for (viewType in overrideConfigs) {\n    ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n  }\n\n  return hash;\n}\n\nfunction ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n  if (hash[viewType]) {\n    return hash[viewType];\n  }\n\n  var viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n\n  if (viewDef) {\n    hash[viewType] = viewDef;\n  }\n\n  return viewDef;\n}\n\nfunction buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n  var defaultConfig = defaultConfigs[viewType];\n  var overrideConfig = overrideConfigs[viewType];\n\n  var queryProp = function queryProp(name) {\n    return defaultConfig && defaultConfig[name] !== null ? defaultConfig[name] : overrideConfig && overrideConfig[name] !== null ? overrideConfig[name] : null;\n  };\n\n  var theComponent = queryProp('component');\n  var superType = queryProp('superType');\n  var superDef = null;\n\n  if (superType) {\n    if (superType === viewType) {\n      throw new Error('Can\\'t have a custom view type that references itself');\n    }\n\n    superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);\n  }\n\n  if (!theComponent && superDef) {\n    theComponent = superDef.component;\n  }\n\n  if (!theComponent) {\n    return null; // don't throw a warning, might be settings for a single-unit view\n  }\n\n  return {\n    type: viewType,\n    component: theComponent,\n    defaults: Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, superDef ? superDef.defaults : {}), defaultConfig ? defaultConfig.rawOptions : {}),\n    overrides: Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, superDef ? superDef.overrides : {}), overrideConfig ? overrideConfig.rawOptions : {})\n  };\n} // NOTE: in JSX, you should always use this class with <HookProps> arg. otherwise, will default to any???\n\n\nvar RenderHook =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(RenderHook, _super);\n\n  function RenderHook() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.rootElRef = Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createRef\"])();\n\n    _this.handleRootEl = function (el) {\n      setRef(_this.rootElRef, el);\n\n      if (_this.props.elRef) {\n        setRef(_this.props.elRef, el);\n      }\n    };\n\n    return _this;\n  }\n\n  RenderHook.prototype.render = function () {\n    var _this = this;\n\n    var props = this.props;\n    var hookProps = props.hookProps;\n    return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(MountHook, {\n      hookProps: hookProps,\n      didMount: props.didMount,\n      willUnmount: props.willUnmount,\n      elRef: this.handleRootEl\n    }, function (rootElRef) {\n      return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(ContentHook, {\n        hookProps: hookProps,\n        content: props.content,\n        defaultContent: props.defaultContent,\n        backupElRef: _this.rootElRef\n      }, function (innerElRef, innerContent) {\n        return props.children(rootElRef, normalizeClassNames(props.classNames, hookProps), innerElRef, innerContent);\n      });\n    });\n  };\n\n  return RenderHook;\n}(BaseComponent); // for forcing rerender of components that use the ContentHook\n\n\nvar CustomContentRenderContext = Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createContext\"])(0);\n\nvar ContentHook =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(ContentHook, _super);\n\n  function ContentHook() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.innerElRef = Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createRef\"])();\n    return _this;\n  }\n\n  ContentHook.prototype.render = function () {\n    var _this = this;\n\n    return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(CustomContentRenderContext.Consumer, null, function () {\n      return _this.props.children(_this.innerElRef, _this.renderInnerContent());\n    });\n  };\n\n  ContentHook.prototype.componentDidMount = function () {\n    this.updateCustomContent();\n  };\n\n  ContentHook.prototype.componentDidUpdate = function () {\n    this.updateCustomContent();\n  };\n\n  ContentHook.prototype.renderInnerContent = function () {\n    var contentTypeHandlers = this.context.pluginHooks.contentTypeHandlers;\n\n    var _a = this,\n        props = _a.props,\n        customContentInfo = _a.customContentInfo;\n\n    var rawVal = props.content;\n    var innerContent = normalizeContent(rawVal, props.hookProps);\n    var innerContentVDom = null;\n\n    if (innerContent === undefined) {\n      // use the default\n      innerContent = normalizeContent(props.defaultContent, props.hookProps);\n    }\n\n    if (innerContent !== undefined) {\n      // we allow custom content handlers to return nothing\n      if (customContentInfo) {\n        customContentInfo.contentVal = innerContent[customContentInfo.contentKey];\n      } else if (_typeof(innerContent) === 'object') {\n        // look for a prop that would indicate a custom content handler is needed\n        for (var contentKey in contentTypeHandlers) {\n          if (innerContent[contentKey] !== undefined) {\n            customContentInfo = this.customContentInfo = {\n              contentKey: contentKey,\n              contentVal: innerContent[contentKey],\n              handler: contentTypeHandlers[contentKey]()\n            };\n            break;\n          }\n        }\n      }\n\n      if (customContentInfo) {\n        innerContentVDom = []; // signal that something was specified\n      } else {\n        innerContentVDom = innerContent; // assume a [p]react vdom node. use it\n      }\n    }\n\n    return innerContentVDom;\n  };\n\n  ContentHook.prototype.updateCustomContent = function () {\n    if (this.customContentInfo) {\n      this.customContentInfo.handler(this.innerElRef.current || this.props.backupElRef.current, // the element to render into\n      this.customContentInfo.contentVal);\n    }\n  };\n\n  return ContentHook;\n}(BaseComponent);\n\nvar MountHook =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(MountHook, _super);\n\n  function MountHook() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.handleRootEl = function (rootEl) {\n      _this.rootEl = rootEl;\n\n      if (_this.props.elRef) {\n        setRef(_this.props.elRef, rootEl);\n      }\n    };\n\n    return _this;\n  }\n\n  MountHook.prototype.render = function () {\n    return this.props.children(this.handleRootEl);\n  };\n\n  MountHook.prototype.componentDidMount = function () {\n    var callback = this.props.didMount;\n    callback && callback(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, this.props.hookProps), {\n      el: this.rootEl\n    }));\n  };\n\n  MountHook.prototype.componentWillUnmount = function () {\n    var callback = this.props.willUnmount;\n    callback && callback(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, this.props.hookProps), {\n      el: this.rootEl\n    }));\n  };\n\n  return MountHook;\n}(BaseComponent);\n\nfunction buildClassNameNormalizer() {\n  var currentGenerator;\n  var currentHookProps;\n  var currentClassNames = [];\n  return function (generator, hookProps) {\n    if (!currentHookProps || !isPropsEqual(currentHookProps, hookProps) || generator !== currentGenerator) {\n      currentGenerator = generator;\n      currentHookProps = hookProps;\n      currentClassNames = normalizeClassNames(generator, hookProps);\n    }\n\n    return currentClassNames;\n  };\n}\n\nfunction normalizeClassNames(classNames, hookProps) {\n  if (typeof classNames === 'function') {\n    classNames = classNames(hookProps);\n  }\n\n  return parseClassNames(classNames);\n}\n\nfunction normalizeContent(input, hookProps) {\n  if (typeof input === 'function') {\n    return input(hookProps, _vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"]); // give the function the vdom-creation func\n  } else {\n    return input;\n  }\n}\n\nvar ViewRoot =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(ViewRoot, _super);\n\n  function ViewRoot() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.normalizeClassNames = buildClassNameNormalizer();\n    return _this;\n  }\n\n  ViewRoot.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var options = context.options;\n    var hookProps = {\n      view: context.viewApi\n    };\n    var customClassNames = this.normalizeClassNames(options.viewClassNames, hookProps);\n    return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(MountHook, {\n      hookProps: hookProps,\n      didMount: options.viewDidMount,\n      willUnmount: options.viewWillUnmount,\n      elRef: props.elRef\n    }, function (rootElRef) {\n      return props.children(rootElRef, [\"fc-\" + props.viewSpec.type + \"-view\", 'fc-view'].concat(customClassNames));\n    });\n  };\n\n  return ViewRoot;\n}(BaseComponent);\n\nfunction parseViewConfigs(inputs) {\n  return mapHash(inputs, parseViewConfig);\n}\n\nfunction parseViewConfig(input) {\n  var rawOptions = typeof input === 'function' ? {\n    component: input\n  } : input;\n  var component = rawOptions.component;\n\n  if (rawOptions.content) {\n    component = createViewHookComponent(rawOptions); // TODO: remove content/classNames/didMount/etc from options?\n  }\n\n  return {\n    superType: rawOptions.type,\n    component: component,\n    rawOptions: rawOptions // includes type and component too :(\n\n  };\n}\n\nfunction createViewHookComponent(options) {\n  return function (viewProps) {\n    return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(ViewContextType.Consumer, null, function (context) {\n      return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(ViewRoot, {\n        viewSpec: context.viewSpec\n      }, function (rootElRef, viewClassNames) {\n        var hookProps = Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, viewProps), {\n          nextDayThreshold: context.options.nextDayThreshold\n        });\n\n        return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(RenderHook, {\n          hookProps: hookProps,\n          classNames: options.classNames,\n          content: options.content,\n          didMount: options.didMount,\n          willUnmount: options.willUnmount,\n          elRef: rootElRef\n        }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n          return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"div\", {\n            className: viewClassNames.concat(customClassNames).join(' '),\n            ref: rootElRef\n          }, innerContent);\n        });\n      });\n    });\n  };\n}\n\nfunction buildViewSpecs(defaultInputs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n  var defaultConfigs = parseViewConfigs(defaultInputs);\n  var overrideConfigs = parseViewConfigs(optionOverrides.views);\n  var viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);\n  return mapHash(viewDefs, function (viewDef) {\n    return buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults);\n  });\n}\n\nfunction buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n  var durationInput = viewDef.overrides.duration || viewDef.defaults.duration || dynamicOptionOverrides.duration || optionOverrides.duration;\n  var duration = null;\n  var durationUnit = '';\n  var singleUnit = '';\n  var singleUnitOverrides = {};\n\n  if (durationInput) {\n    duration = createDurationCached(durationInput);\n\n    if (duration) {\n      // valid?\n      var denom = greatestDurationDenominator(duration);\n      durationUnit = denom.unit;\n\n      if (denom.value === 1) {\n        singleUnit = durationUnit;\n        singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].rawOptions : {};\n      }\n    }\n  }\n\n  var queryButtonText = function queryButtonText(optionsSubset) {\n    var buttonTextMap = optionsSubset.buttonText || {};\n    var buttonTextKey = viewDef.defaults.buttonTextKey;\n\n    if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {\n      return buttonTextMap[buttonTextKey];\n    }\n\n    if (buttonTextMap[viewDef.type] != null) {\n      return buttonTextMap[viewDef.type];\n    }\n\n    if (buttonTextMap[singleUnit] != null) {\n      return buttonTextMap[singleUnit];\n    }\n  };\n\n  return {\n    type: viewDef.type,\n    component: viewDef.component,\n    duration: duration,\n    durationUnit: durationUnit,\n    singleUnit: singleUnit,\n    optionDefaults: viewDef.defaults,\n    optionOverrides: Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, singleUnitOverrides), viewDef.overrides),\n    buttonTextOverride: queryButtonText(dynamicOptionOverrides) || queryButtonText(optionOverrides) || // constructor-specified buttonText lookup hash takes precedence\n    viewDef.overrides.buttonText,\n    buttonTextDefault: queryButtonText(localeDefaults) || viewDef.defaults.buttonText || queryButtonText(BASE_OPTION_DEFAULTS) || viewDef.type // fall back to given view name\n\n  };\n} // hack to get memoization working\n\n\nvar durationInputMap = {};\n\nfunction createDurationCached(durationInput) {\n  var json = JSON.stringify(durationInput);\n  var res = durationInputMap[json];\n\n  if (res === undefined) {\n    res = createDuration(durationInput);\n    durationInputMap[json] = res;\n  }\n\n  return res;\n}\n\nvar DateProfileGenerator =\n/** @class */\nfunction () {\n  function DateProfileGenerator(props) {\n    this.props = props;\n    this.nowDate = getNow(props.nowInput, props.dateEnv);\n    this.initHiddenDays();\n  }\n  /* Date Range Computation\n  ------------------------------------------------------------------------------------------------------------------*/\n  // Builds a structure with info about what the dates/ranges will be for the \"prev\" view.\n\n\n  DateProfileGenerator.prototype.buildPrev = function (currentDateProfile, currentDate, forceToValid) {\n    var dateEnv = this.props.dateEnv;\n    var prevDate = dateEnv.subtract(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month\n    currentDateProfile.dateIncrement);\n    return this.build(prevDate, -1, forceToValid);\n  }; // Builds a structure with info about what the dates/ranges will be for the \"next\" view.\n\n\n  DateProfileGenerator.prototype.buildNext = function (currentDateProfile, currentDate, forceToValid) {\n    var dateEnv = this.props.dateEnv;\n    var nextDate = dateEnv.add(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month\n    currentDateProfile.dateIncrement);\n    return this.build(nextDate, 1, forceToValid);\n  }; // Builds a structure holding dates/ranges for rendering around the given date.\n  // Optional direction param indicates whether the date is being incremented/decremented\n  // from its previous value. decremented = -1, incremented = 1 (default).\n\n\n  DateProfileGenerator.prototype.build = function (currentDate, direction, forceToValid) {\n    if (forceToValid === void 0) {\n      forceToValid = true;\n    }\n\n    var props = this.props;\n    var validRange;\n    var currentInfo;\n    var isRangeAllDay;\n    var renderRange;\n    var activeRange;\n    var isValid;\n    validRange = this.buildValidRange();\n    validRange = this.trimHiddenDays(validRange);\n\n    if (forceToValid) {\n      currentDate = constrainMarkerToRange(currentDate, validRange);\n    }\n\n    currentInfo = this.buildCurrentRangeInfo(currentDate, direction);\n    isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);\n    renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);\n    renderRange = this.trimHiddenDays(renderRange);\n    activeRange = renderRange;\n\n    if (!props.showNonCurrentDates) {\n      activeRange = intersectRanges(activeRange, currentInfo.range);\n    }\n\n    activeRange = this.adjustActiveRange(activeRange);\n    activeRange = intersectRanges(activeRange, validRange); // might return null\n    // it's invalid if the originally requested date is not contained,\n    // or if the range is completely outside of the valid range.\n\n    isValid = rangesIntersect(currentInfo.range, validRange);\n    return {\n      // constraint for where prev/next operations can go and where events can be dragged/resized to.\n      // an object with optional start and end properties.\n      validRange: validRange,\n      // range the view is formally responsible for.\n      // for example, a month view might have 1st-31st, excluding padded dates\n      currentRange: currentInfo.range,\n      // name of largest unit being displayed, like \"month\" or \"week\"\n      currentRangeUnit: currentInfo.unit,\n      isRangeAllDay: isRangeAllDay,\n      // dates that display events and accept drag-n-drop\n      // will be `null` if no dates accept events\n      activeRange: activeRange,\n      // date range with a rendered skeleton\n      // includes not-active days that need some sort of DOM\n      renderRange: renderRange,\n      // Duration object that denotes the first visible time of any given day\n      slotMinTime: props.slotMinTime,\n      // Duration object that denotes the exclusive visible end time of any given day\n      slotMaxTime: props.slotMaxTime,\n      isValid: isValid,\n      // how far the current date will move for a prev/next operation\n      dateIncrement: this.buildDateIncrement(currentInfo.duration) // pass a fallback (might be null) ^\n\n    };\n  }; // Builds an object with optional start/end properties.\n  // Indicates the minimum/maximum dates to display.\n  // not responsible for trimming hidden days.\n\n\n  DateProfileGenerator.prototype.buildValidRange = function () {\n    var input = this.props.validRangeInput;\n    var simpleInput = typeof input === 'function' ? input.call(this.props.calendarApi, this.nowDate) : input;\n    return this.refineRange(simpleInput) || {\n      start: null,\n      end: null\n    }; // completely open-ended\n  }; // Builds a structure with info about the \"current\" range, the range that is\n  // highlighted as being the current month for example.\n  // See build() for a description of `direction`.\n  // Guaranteed to have `range` and `unit` properties. `duration` is optional.\n\n\n  DateProfileGenerator.prototype.buildCurrentRangeInfo = function (date, direction) {\n    var props = this.props;\n    var duration = null;\n    var unit = null;\n    var range = null;\n    var dayCount;\n\n    if (props.duration) {\n      duration = props.duration;\n      unit = props.durationUnit;\n      range = this.buildRangeFromDuration(date, direction, duration, unit);\n    } else if (dayCount = this.props.dayCount) {\n      unit = 'day';\n      range = this.buildRangeFromDayCount(date, direction, dayCount);\n    } else if (range = this.buildCustomVisibleRange(date)) {\n      unit = props.dateEnv.greatestWholeUnit(range.start, range.end).unit;\n    } else {\n      duration = this.getFallbackDuration();\n      unit = greatestDurationDenominator(duration).unit;\n      range = this.buildRangeFromDuration(date, direction, duration, unit);\n    }\n\n    return {\n      duration: duration,\n      unit: unit,\n      range: range\n    };\n  };\n\n  DateProfileGenerator.prototype.getFallbackDuration = function () {\n    return createDuration({\n      day: 1\n    });\n  }; // Returns a new activeRange to have time values (un-ambiguate)\n  // slotMinTime or slotMaxTime causes the range to expand.\n\n\n  DateProfileGenerator.prototype.adjustActiveRange = function (range) {\n    var _a = this.props,\n        dateEnv = _a.dateEnv,\n        usesMinMaxTime = _a.usesMinMaxTime,\n        slotMinTime = _a.slotMinTime,\n        slotMaxTime = _a.slotMaxTime;\n    var start = range.start;\n    var end = range.end;\n\n    if (usesMinMaxTime) {\n      // expand active range if slotMinTime is negative (why not when positive?)\n      if (asRoughDays(slotMinTime) < 0) {\n        start = startOfDay(start); // necessary?\n\n        start = dateEnv.add(start, slotMinTime);\n      } // expand active range if slotMaxTime is beyond one day (why not when negative?)\n\n\n      if (asRoughDays(slotMaxTime) > 1) {\n        end = startOfDay(end); // necessary?\n\n        end = addDays(end, -1);\n        end = dateEnv.add(end, slotMaxTime);\n      }\n    }\n\n    return {\n      start: start,\n      end: end\n    };\n  }; // Builds the \"current\" range when it is specified as an explicit duration.\n  // `unit` is the already-computed greatestDurationDenominator unit of duration.\n\n\n  DateProfileGenerator.prototype.buildRangeFromDuration = function (date, direction, duration, unit) {\n    var _a = this.props,\n        dateEnv = _a.dateEnv,\n        dateAlignment = _a.dateAlignment;\n    var start;\n    var end;\n    var res; // compute what the alignment should be\n\n    if (!dateAlignment) {\n      var dateIncrement = this.props.dateIncrement;\n\n      if (dateIncrement) {\n        // use the smaller of the two units\n        if (asRoughMs(dateIncrement) < asRoughMs(duration)) {\n          dateAlignment = greatestDurationDenominator(dateIncrement).unit;\n        } else {\n          dateAlignment = unit;\n        }\n      } else {\n        dateAlignment = unit;\n      }\n    } // if the view displays a single day or smaller\n\n\n    if (asRoughDays(duration) <= 1) {\n      if (this.isHiddenDay(start)) {\n        start = this.skipHiddenDays(start, direction);\n        start = startOfDay(start);\n      }\n    }\n\n    function computeRes() {\n      start = dateEnv.startOf(date, dateAlignment);\n      end = dateEnv.add(start, duration);\n      res = {\n        start: start,\n        end: end\n      };\n    }\n\n    computeRes(); // if range is completely enveloped by hidden days, go past the hidden days\n\n    if (!this.trimHiddenDays(res)) {\n      date = this.skipHiddenDays(date, direction);\n      computeRes();\n    }\n\n    return res;\n  }; // Builds the \"current\" range when a dayCount is specified.\n\n\n  DateProfileGenerator.prototype.buildRangeFromDayCount = function (date, direction, dayCount) {\n    var _a = this.props,\n        dateEnv = _a.dateEnv,\n        dateAlignment = _a.dateAlignment;\n    var runningCount = 0;\n    var start = date;\n    var end;\n\n    if (dateAlignment) {\n      start = dateEnv.startOf(start, dateAlignment);\n    }\n\n    start = startOfDay(start);\n    start = this.skipHiddenDays(start, direction);\n    end = start;\n\n    do {\n      end = addDays(end, 1);\n\n      if (!this.isHiddenDay(end)) {\n        runningCount++;\n      }\n    } while (runningCount < dayCount);\n\n    return {\n      start: start,\n      end: end\n    };\n  }; // Builds a normalized range object for the \"visible\" range,\n  // which is a way to define the currentRange and activeRange at the same time.\n\n\n  DateProfileGenerator.prototype.buildCustomVisibleRange = function (date) {\n    var props = this.props;\n    var input = props.visibleRangeInput;\n    var simpleInput = typeof input === 'function' ? input.call(props.calendarApi, props.dateEnv.toDate(date)) : input;\n    var range = this.refineRange(simpleInput);\n\n    if (range && (range.start == null || range.end == null)) {\n      return null;\n    }\n\n    return range;\n  }; // Computes the range that will represent the element/cells for *rendering*,\n  // but which may have voided days/times.\n  // not responsible for trimming hidden days.\n\n\n  DateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {\n    return currentRange;\n  }; // Compute the duration value that should be added/substracted to the current date\n  // when a prev/next operation happens.\n\n\n  DateProfileGenerator.prototype.buildDateIncrement = function (fallback) {\n    var dateIncrement = this.props.dateIncrement;\n    var customAlignment;\n\n    if (dateIncrement) {\n      return dateIncrement;\n    } else if (customAlignment = this.props.dateAlignment) {\n      return createDuration(1, customAlignment);\n    } else if (fallback) {\n      return fallback;\n    } else {\n      return createDuration({\n        days: 1\n      });\n    }\n  };\n\n  DateProfileGenerator.prototype.refineRange = function (rangeInput) {\n    if (rangeInput) {\n      var range = parseRange(rangeInput, this.props.dateEnv);\n\n      if (range) {\n        range = computeVisibleDayRange(range);\n      }\n\n      return range;\n    }\n\n    return null;\n  };\n  /* Hidden Days\n  ------------------------------------------------------------------------------------------------------------------*/\n  // Initializes internal variables related to calculating hidden days-of-week\n\n\n  DateProfileGenerator.prototype.initHiddenDays = function () {\n    var hiddenDays = this.props.hiddenDays || []; // array of day-of-week indices that are hidden\n\n    var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)\n\n    var dayCnt = 0;\n    var i;\n\n    if (this.props.weekends === false) {\n      hiddenDays.push(0, 6); // 0=sunday, 6=saturday\n    }\n\n    for (i = 0; i < 7; i++) {\n      if (!(isHiddenDayHash[i] = hiddenDays.indexOf(i) !== -1)) {\n        dayCnt++;\n      }\n    }\n\n    if (!dayCnt) {\n      throw new Error('invalid hiddenDays'); // all days were hidden? bad.\n    }\n\n    this.isHiddenDayHash = isHiddenDayHash;\n  }; // Remove days from the beginning and end of the range that are computed as hidden.\n  // If the whole range is trimmed off, returns null\n\n\n  DateProfileGenerator.prototype.trimHiddenDays = function (range) {\n    var start = range.start;\n    var end = range.end;\n\n    if (start) {\n      start = this.skipHiddenDays(start);\n    }\n\n    if (end) {\n      end = this.skipHiddenDays(end, -1, true);\n    }\n\n    if (start == null || end == null || start < end) {\n      return {\n        start: start,\n        end: end\n      };\n    }\n\n    return null;\n  }; // Is the current day hidden?\n  // `day` is a day-of-week index (0-6), or a Date (used for UTC)\n\n\n  DateProfileGenerator.prototype.isHiddenDay = function (day) {\n    if (day instanceof Date) {\n      day = day.getUTCDay();\n    }\n\n    return this.isHiddenDayHash[day];\n  }; // Incrementing the current day until it is no longer a hidden day, returning a copy.\n  // DOES NOT CONSIDER validRange!\n  // If the initial value of `date` is not a hidden day, don't do anything.\n  // Pass `isExclusive` as `true` if you are dealing with an end date.\n  // `inc` defaults to `1` (increment one day forward each time)\n\n\n  DateProfileGenerator.prototype.skipHiddenDays = function (date, inc, isExclusive) {\n    if (inc === void 0) {\n      inc = 1;\n    }\n\n    if (isExclusive === void 0) {\n      isExclusive = false;\n    }\n\n    while (this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]) {\n      date = addDays(date, inc);\n    }\n\n    return date;\n  };\n\n  return DateProfileGenerator;\n}();\n\nfunction reduceViewType(viewType, action) {\n  switch (action.type) {\n    case 'CHANGE_VIEW_TYPE':\n      return viewType = action.viewType;\n  }\n\n  return viewType;\n}\n\nfunction reduceDynamicOptionOverrides(dynamicOptionOverrides, action) {\n  var _a;\n\n  switch (action.type) {\n    case 'SET_OPTION':\n      return Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, dynamicOptionOverrides), (_a = {}, _a[action.optionName] = action.rawOptionValue, _a));\n\n    default:\n      return dynamicOptionOverrides;\n  }\n}\n\nfunction reduceDateProfile(currentDateProfile, action, currentDate, dateProfileGenerator) {\n  var dp;\n\n  switch (action.type) {\n    case 'CHANGE_VIEW_TYPE':\n      return dateProfileGenerator.build(action.dateMarker || currentDate);\n\n    case 'CHANGE_DATE':\n      if (!currentDateProfile.activeRange || !rangeContainsMarker(currentDateProfile.currentRange, action.dateMarker) // don't move if date already in view\n      ) {\n          return dateProfileGenerator.build(action.dateMarker);\n        }\n\n      break;\n\n    case 'PREV':\n      dp = dateProfileGenerator.buildPrev(currentDateProfile, currentDate);\n\n      if (dp.isValid) {\n        return dp;\n      }\n\n      break;\n\n    case 'NEXT':\n      dp = dateProfileGenerator.buildNext(currentDateProfile, currentDate);\n\n      if (dp.isValid) {\n        return dp;\n      }\n\n      break;\n  }\n\n  return currentDateProfile;\n}\n\nfunction initEventSources(calendarOptions, dateProfile, context) {\n  var activeRange = dateProfile ? dateProfile.activeRange : null;\n  return addSources({}, parseInitialSources(calendarOptions, context), activeRange, context);\n}\n\nfunction reduceEventSources(eventSources, action, dateProfile, context) {\n  var activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n\n  switch (action.type) {\n    case 'ADD_EVENT_SOURCES':\n      // already parsed\n      return addSources(eventSources, action.sources, activeRange, context);\n\n    case 'REMOVE_EVENT_SOURCE':\n      return removeSource(eventSources, action.sourceId);\n\n    case 'PREV': // TODO: how do we track all actions that affect dateProfile :(\n\n    case 'NEXT':\n    case 'CHANGE_DATE':\n    case 'CHANGE_VIEW_TYPE':\n      if (dateProfile) {\n        return fetchDirtySources(eventSources, activeRange, context);\n      } else {\n        return eventSources;\n      }\n\n    case 'FETCH_EVENT_SOURCES':\n      return fetchSourcesByIds(eventSources, action.sourceIds ? // why no type?\n      arrayToHash(action.sourceIds) : excludeStaticSources(eventSources, context), activeRange, context);\n\n    case 'RECEIVE_EVENTS':\n    case 'RECEIVE_EVENT_ERROR':\n      return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);\n\n    case 'REMOVE_ALL_EVENT_SOURCES':\n      return {};\n\n    default:\n      return eventSources;\n  }\n}\n\nfunction reduceEventSourcesNewTimeZone(eventSources, dateProfile, context) {\n  var activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n\n  return fetchSourcesByIds(eventSources, excludeStaticSources(eventSources, context), activeRange, context);\n}\n\nfunction computeEventSourceLoadingLevel(eventSources) {\n  var cnt = 0;\n\n  for (var sourceId in eventSources) {\n    if (eventSources[sourceId].isFetching) {\n      cnt++;\n    }\n  }\n\n  return cnt;\n}\n\nfunction addSources(eventSourceHash, sources, fetchRange, context) {\n  var hash = {};\n\n  for (var _i = 0, sources_1 = sources; _i < sources_1.length; _i++) {\n    var source = sources_1[_i];\n    hash[source.sourceId] = source;\n  }\n\n  if (fetchRange) {\n    hash = fetchDirtySources(hash, fetchRange, context);\n  }\n\n  return Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, eventSourceHash), hash);\n}\n\nfunction removeSource(eventSourceHash, sourceId) {\n  return filterHash(eventSourceHash, function (eventSource) {\n    return eventSource.sourceId !== sourceId;\n  });\n}\n\nfunction fetchDirtySources(sourceHash, fetchRange, context) {\n  return fetchSourcesByIds(sourceHash, filterHash(sourceHash, function (eventSource) {\n    return isSourceDirty(eventSource, fetchRange, context);\n  }), fetchRange, context);\n}\n\nfunction isSourceDirty(eventSource, fetchRange, context) {\n  if (!doesSourceNeedRange(eventSource, context)) {\n    return !eventSource.latestFetchId;\n  } else {\n    return !context.options.lazyFetching || !eventSource.fetchRange || eventSource.isFetching || // always cancel outdated in-progress fetches\n    fetchRange.start < eventSource.fetchRange.start || fetchRange.end > eventSource.fetchRange.end;\n  }\n}\n\nfunction fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, context) {\n  var nextSources = {};\n\n  for (var sourceId in prevSources) {\n    var source = prevSources[sourceId];\n\n    if (sourceIdHash[sourceId]) {\n      nextSources[sourceId] = fetchSource(source, fetchRange, context);\n    } else {\n      nextSources[sourceId] = source;\n    }\n  }\n\n  return nextSources;\n}\n\nfunction fetchSource(eventSource, fetchRange, context) {\n  var options = context.options,\n      calendarApi = context.calendarApi;\n  var sourceDef = context.pluginHooks.eventSourceDefs[eventSource.sourceDefId];\n  var fetchId = guid();\n  sourceDef.fetch({\n    eventSource: eventSource,\n    range: fetchRange,\n    context: context\n  }, function (res) {\n    var rawEvents = res.rawEvents;\n\n    if (options.eventSourceSuccess) {\n      rawEvents = options.eventSourceSuccess.call(calendarApi, rawEvents, res.xhr) || rawEvents;\n    }\n\n    if (eventSource.success) {\n      rawEvents = eventSource.success.call(calendarApi, rawEvents, res.xhr) || rawEvents;\n    }\n\n    context.dispatch({\n      type: 'RECEIVE_EVENTS',\n      sourceId: eventSource.sourceId,\n      fetchId: fetchId,\n      fetchRange: fetchRange,\n      rawEvents: rawEvents\n    });\n  }, function (error) {\n    console.warn(error.message, error);\n\n    if (options.eventSourceFailure) {\n      options.eventSourceFailure.call(calendarApi, error);\n    }\n\n    if (eventSource.failure) {\n      eventSource.failure(error);\n    }\n\n    context.dispatch({\n      type: 'RECEIVE_EVENT_ERROR',\n      sourceId: eventSource.sourceId,\n      fetchId: fetchId,\n      fetchRange: fetchRange,\n      error: error\n    });\n  });\n  return Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, eventSource), {\n    isFetching: true,\n    latestFetchId: fetchId\n  });\n}\n\nfunction receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {\n  var _a;\n\n  var eventSource = sourceHash[sourceId];\n\n  if (eventSource && // not already removed\n  fetchId === eventSource.latestFetchId) {\n    return Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, sourceHash), (_a = {}, _a[sourceId] = Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, eventSource), {\n      isFetching: false,\n      fetchRange: fetchRange // also serves as a marker that at least one fetch has completed\n\n    }), _a));\n  }\n\n  return sourceHash;\n}\n\nfunction excludeStaticSources(eventSources, context) {\n  return filterHash(eventSources, function (eventSource) {\n    return doesSourceNeedRange(eventSource, context);\n  });\n}\n\nfunction parseInitialSources(rawOptions, context) {\n  var refiners = buildEventSourceRefiners(context);\n  var rawSources = [].concat(rawOptions.eventSources || []);\n  var sources = []; // parsed\n\n  if (rawOptions.initialEvents) {\n    rawSources.unshift(rawOptions.initialEvents);\n  }\n\n  if (rawOptions.events) {\n    rawSources.unshift(rawOptions.events);\n  }\n\n  for (var _i = 0, rawSources_1 = rawSources; _i < rawSources_1.length; _i++) {\n    var rawSource = rawSources_1[_i];\n    var source = parseEventSource(rawSource, context, refiners);\n\n    if (source) {\n      sources.push(source);\n    }\n  }\n\n  return sources;\n}\n\nfunction doesSourceNeedRange(eventSource, context) {\n  var defs = context.pluginHooks.eventSourceDefs;\n  return !defs[eventSource.sourceDefId].ignoreRange;\n}\n\nfunction reduceDateSelection(currentSelection, action) {\n  switch (action.type) {\n    case 'UNSELECT_DATES':\n      return null;\n\n    case 'SELECT_DATES':\n      return action.selection;\n\n    default:\n      return currentSelection;\n  }\n}\n\nfunction reduceSelectedEvent(currentInstanceId, action) {\n  switch (action.type) {\n    case 'UNSELECT_EVENT':\n      return '';\n\n    case 'SELECT_EVENT':\n      return action.eventInstanceId;\n\n    default:\n      return currentInstanceId;\n  }\n}\n\nfunction reduceEventDrag(currentDrag, action) {\n  var newDrag;\n\n  switch (action.type) {\n    case 'UNSET_EVENT_DRAG':\n      return null;\n\n    case 'SET_EVENT_DRAG':\n      newDrag = action.state;\n      return {\n        affectedEvents: newDrag.affectedEvents,\n        mutatedEvents: newDrag.mutatedEvents,\n        isEvent: newDrag.isEvent\n      };\n\n    default:\n      return currentDrag;\n  }\n}\n\nfunction reduceEventResize(currentResize, action) {\n  var newResize;\n\n  switch (action.type) {\n    case 'UNSET_EVENT_RESIZE':\n      return null;\n\n    case 'SET_EVENT_RESIZE':\n      newResize = action.state;\n      return {\n        affectedEvents: newResize.affectedEvents,\n        mutatedEvents: newResize.mutatedEvents,\n        isEvent: newResize.isEvent\n      };\n\n    default:\n      return currentResize;\n  }\n}\n\nfunction parseToolbars(calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n  var viewsWithButtons = [];\n  var headerToolbar = calendarOptions.headerToolbar ? parseToolbar(calendarOptions.headerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi, viewsWithButtons) : null;\n  var footerToolbar = calendarOptions.footerToolbar ? parseToolbar(calendarOptions.footerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi, viewsWithButtons) : null;\n  return {\n    headerToolbar: headerToolbar,\n    footerToolbar: footerToolbar,\n    viewsWithButtons: viewsWithButtons\n  };\n}\n\nfunction parseToolbar(sectionStrHash, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi, viewsWithButtons // dump side effects\n) {\n  return mapHash(sectionStrHash, function (sectionStr) {\n    return parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi, viewsWithButtons);\n  });\n}\n/*\nBAD: querying icons and text here. should be done at render time\n*/\n\n\nfunction parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi, viewsWithButtons // dump side effects\n) {\n  var isRtl = calendarOptions.direction === 'rtl';\n  var calendarCustomButtons = calendarOptions.customButtons || {};\n  var calendarButtonTextOverrides = calendarOptionOverrides.buttonText || {};\n  var calendarButtonText = calendarOptions.buttonText || {};\n  var sectionSubstrs = sectionStr ? sectionStr.split(' ') : [];\n  return sectionSubstrs.map(function (buttonGroupStr) {\n    return buttonGroupStr.split(',').map(function (buttonName) {\n      if (buttonName === 'title') {\n        return {\n          buttonName: buttonName\n        };\n      } else {\n        var customButtonProps_1;\n        var viewSpec = void 0;\n        var buttonClick = void 0;\n        var buttonIcon = void 0; // only one of these will be set\n\n        var buttonText = void 0; // \"\n\n        if (customButtonProps_1 = calendarCustomButtons[buttonName]) {\n          buttonClick = function buttonClick(ev) {\n            if (customButtonProps_1.click) {\n              customButtonProps_1.click.call(ev.target, ev); // TODO: correct to use `target`?\n            }\n          };\n\n          (buttonIcon = theme.getCustomButtonIconClass(customButtonProps_1)) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = customButtonProps_1.text);\n        } else if (viewSpec = viewSpecs[buttonName]) {\n          viewsWithButtons.push(buttonName);\n\n          buttonClick = function buttonClick() {\n            calendarApi.changeView(buttonName);\n          };\n\n          (buttonText = viewSpec.buttonTextOverride) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = viewSpec.buttonTextDefault);\n        } else if (calendarApi[buttonName]) {\n          // a calendarApi method\n          buttonClick = function buttonClick() {\n            calendarApi[buttonName]();\n          };\n\n          (buttonText = calendarButtonTextOverrides[buttonName]) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = calendarButtonText[buttonName]); //            ^ everything else is considered default\n        }\n\n        return {\n          buttonName: buttonName,\n          buttonClick: buttonClick,\n          buttonIcon: buttonIcon,\n          buttonText: buttonText\n        };\n      }\n    });\n  });\n}\n\nvar eventSourceDef = {\n  ignoreRange: true,\n  parseMeta: function parseMeta(refined) {\n    if (Array.isArray(refined.events)) {\n      return refined.events;\n    }\n\n    return null;\n  },\n  fetch: function fetch(arg, success) {\n    success({\n      rawEvents: arg.eventSource.meta\n    });\n  }\n};\nvar arrayEventSourcePlugin = createPlugin({\n  eventSourceDefs: [eventSourceDef]\n});\nvar eventSourceDef$1 = {\n  parseMeta: function parseMeta(refined) {\n    if (typeof refined.events === 'function') {\n      return refined.events;\n    }\n\n    return null;\n  },\n  fetch: function fetch(arg, success, failure) {\n    var dateEnv = arg.context.dateEnv;\n    var func = arg.eventSource.meta;\n    unpromisify(func.bind(null, buildRangeApiWithTimeZone(arg.range, dateEnv)), function (rawEvents) {\n      success({\n        rawEvents: rawEvents\n      }); // needs an object response\n    }, failure // send errorObj directly to failure callback\n    );\n  }\n};\nvar funcEventSourcePlugin = createPlugin({\n  eventSourceDefs: [eventSourceDef$1]\n});\n\nfunction requestJson(method, url, params, successCallback, failureCallback) {\n  method = method.toUpperCase();\n  var body = null;\n\n  if (method === 'GET') {\n    url = injectQueryStringParams(url, params);\n  } else {\n    body = encodeParams(params);\n  }\n\n  var xhr = new XMLHttpRequest();\n  xhr.open(method, url, true);\n\n  if (method !== 'GET') {\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n  }\n\n  xhr.onload = function () {\n    if (xhr.status >= 200 && xhr.status < 400) {\n      var parsed = false;\n      var res = void 0;\n\n      try {\n        res = JSON.parse(xhr.responseText);\n        parsed = true;\n      } catch (err) {// will handle parsed=false\n      }\n\n      if (parsed) {\n        successCallback(res, xhr);\n      } else {\n        failureCallback('Failure parsing JSON', xhr);\n      }\n    } else {\n      failureCallback('Request failed', xhr);\n    }\n  };\n\n  xhr.onerror = function () {\n    failureCallback('Request failed', xhr);\n  };\n\n  xhr.send(body);\n}\n\nfunction injectQueryStringParams(url, params) {\n  return url + (url.indexOf('?') === -1 ? '?' : '&') + encodeParams(params);\n}\n\nfunction encodeParams(params) {\n  var parts = [];\n\n  for (var key in params) {\n    parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(params[key]));\n  }\n\n  return parts.join('&');\n}\n\nvar JSON_FEED_EVENT_SOURCE_REFINERS = {\n  method: String,\n  extraParams: identity,\n  startParam: String,\n  endParam: String,\n  timeZoneParam: String\n};\nvar eventSourceDef$2 = {\n  parseMeta: function parseMeta(refined) {\n    if (refined.url) {\n      return {\n        url: refined.url,\n        method: (refined.method || 'GET').toUpperCase(),\n        extraParams: refined.extraParams,\n        startParam: refined.startParam,\n        endParam: refined.endParam,\n        timeZoneParam: refined.timeZoneParam\n      };\n    }\n\n    return null;\n  },\n  fetch: function fetch(arg, success, failure) {\n    var meta = arg.eventSource.meta;\n    var requestParams = buildRequestParams(meta, arg.range, arg.context);\n    requestJson(meta.method, meta.url, requestParams, function (rawEvents, xhr) {\n      success({\n        rawEvents: rawEvents,\n        xhr: xhr\n      });\n    }, function (errorMessage, xhr) {\n      failure({\n        message: errorMessage,\n        xhr: xhr\n      });\n    });\n  }\n};\nvar jsonFeedEventSourcePlugin = createPlugin({\n  eventSourceRefiners: JSON_FEED_EVENT_SOURCE_REFINERS,\n  eventSourceDefs: [eventSourceDef$2]\n});\n\nfunction buildRequestParams(meta, range, context) {\n  var dateEnv = context.dateEnv,\n      options = context.options;\n  var startParam;\n  var endParam;\n  var timeZoneParam;\n  var customRequestParams;\n  var params = {};\n  startParam = meta.startParam;\n\n  if (startParam == null) {\n    startParam = options.startParam;\n  }\n\n  endParam = meta.endParam;\n\n  if (endParam == null) {\n    endParam = options.endParam;\n  }\n\n  timeZoneParam = meta.timeZoneParam;\n\n  if (timeZoneParam == null) {\n    timeZoneParam = options.timeZoneParam;\n  } // retrieve any outbound GET/POST data from the options\n\n\n  if (typeof meta.extraParams === 'function') {\n    // supplied as a function that returns a key/value object\n    customRequestParams = meta.extraParams();\n  } else {\n    // probably supplied as a straight key/value object\n    customRequestParams = meta.extraParams || {};\n  }\n\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(params, customRequestParams);\n\n  params[startParam] = dateEnv.formatIso(range.start);\n  params[endParam] = dateEnv.formatIso(range.end);\n\n  if (dateEnv.timeZone !== 'local') {\n    params[timeZoneParam] = dateEnv.timeZone;\n  }\n\n  return params;\n}\n\nvar SIMPLE_RECURRING_REFINERS = {\n  daysOfWeek: identity,\n  startTime: createDuration,\n  endTime: createDuration,\n  duration: createDuration,\n  startRecur: identity,\n  endRecur: identity\n};\nvar recurring = {\n  parse: function parse(refined, dateEnv) {\n    if (refined.daysOfWeek || refined.startTime || refined.endTime || refined.startRecur || refined.endRecur) {\n      var recurringData = {\n        daysOfWeek: refined.daysOfWeek || null,\n        startTime: refined.startTime || null,\n        endTime: refined.endTime || null,\n        startRecur: refined.startRecur ? dateEnv.createMarker(refined.startRecur) : null,\n        endRecur: refined.endRecur ? dateEnv.createMarker(refined.endRecur) : null\n      };\n      var duration = void 0;\n\n      if (refined.duration) {\n        duration = refined.duration;\n      }\n\n      if (!duration && refined.startTime && refined.endTime) {\n        duration = subtractDurations(refined.endTime, refined.startTime);\n      }\n\n      return {\n        allDayGuess: Boolean(!refined.startTime && !refined.endTime),\n        duration: duration,\n        typeData: recurringData // doesn't need endTime anymore but oh well\n\n      };\n    }\n\n    return null;\n  },\n  expand: function expand(typeData, framingRange, dateEnv) {\n    var clippedFramingRange = intersectRanges(framingRange, {\n      start: typeData.startRecur,\n      end: typeData.endRecur\n    });\n\n    if (clippedFramingRange) {\n      return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);\n    } else {\n      return [];\n    }\n  }\n};\nvar simpleRecurringEventsPlugin = createPlugin({\n  recurringTypes: [recurring],\n  eventRefiners: SIMPLE_RECURRING_REFINERS\n});\n\nfunction expandRanges(daysOfWeek, startTime, framingRange, dateEnv) {\n  var dowHash = daysOfWeek ? arrayToHash(daysOfWeek) : null;\n  var dayMarker = startOfDay(framingRange.start);\n  var endMarker = framingRange.end;\n  var instanceStarts = [];\n\n  while (dayMarker < endMarker) {\n    var instanceStart // if everyday, or this particular day-of-week\n    = void 0; // if everyday, or this particular day-of-week\n\n    if (!dowHash || dowHash[dayMarker.getUTCDay()]) {\n      if (startTime) {\n        instanceStart = dateEnv.add(dayMarker, startTime);\n      } else {\n        instanceStart = dayMarker;\n      }\n\n      instanceStarts.push(instanceStart);\n    }\n\n    dayMarker = addDays(dayMarker, 1);\n  }\n\n  return instanceStarts;\n}\n\nvar changeHandlerPlugin = createPlugin({\n  optionChangeHandlers: {\n    events: function events(_events, context) {\n      handleEventSources([_events], context);\n    },\n    eventSources: handleEventSources\n  }\n});\n/*\nBUG: if `event` was supplied, all previously-given `eventSources` will be wiped out\n*/\n\nfunction handleEventSources(inputs, context) {\n  var unfoundSources = hashValuesToArray(context.getCurrentData().eventSources);\n  var newInputs = [];\n\n  for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\n    var input = inputs_1[_i];\n    var inputFound = false;\n\n    for (var i = 0; i < unfoundSources.length; i++) {\n      if (unfoundSources[i]._raw === input) {\n        unfoundSources.splice(i, 1); // delete\n\n        inputFound = true;\n        break;\n      }\n    }\n\n    if (!inputFound) {\n      newInputs.push(input);\n    }\n  }\n\n  for (var _a = 0, unfoundSources_1 = unfoundSources; _a < unfoundSources_1.length; _a++) {\n    var unfoundSource = unfoundSources_1[_a];\n    context.dispatch({\n      type: 'REMOVE_EVENT_SOURCE',\n      sourceId: unfoundSource.sourceId\n    });\n  }\n\n  for (var _b = 0, newInputs_1 = newInputs; _b < newInputs_1.length; _b++) {\n    var newInput = newInputs_1[_b];\n    context.calendarApi.addEventSource(newInput);\n  }\n}\n\nfunction handleDateProfile(dateProfile, context) {\n  context.emitter.trigger('datesSet', Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, buildRangeApiWithTimeZone(dateProfile.activeRange, context.dateEnv)), {\n    view: context.viewApi\n  }));\n}\n\nfunction handleEventStore(eventStore, context) {\n  var emitter = context.emitter;\n\n  if (emitter.hasHandlers('eventsSet')) {\n    emitter.trigger('eventsSet', buildEventApis(eventStore, context));\n  }\n}\n/*\nthis array is exposed on the root namespace so that UMD plugins can add to it.\nsee the rollup-bundles script.\n*/\n\n\nvar globalPlugins = [arrayEventSourcePlugin, funcEventSourcePlugin, jsonFeedEventSourcePlugin, simpleRecurringEventsPlugin, changeHandlerPlugin, createPlugin({\n  contentTypeHandlers: {\n    html: function html() {\n      return injectHtml;\n    },\n    domNodes: function domNodes() {\n      return injectDomNodes;\n    }\n  },\n  propSetHandlers: {\n    dateProfile: handleDateProfile,\n    eventStore: handleEventStore\n  }\n})];\n\nvar DelayedRunner =\n/** @class */\nfunction () {\n  function DelayedRunner(drainedOption) {\n    this.drainedOption = drainedOption;\n    this.isRunning = false;\n    this.isDirty = false;\n    this.pauseDepths = {};\n    this.timeoutId = 0;\n  }\n\n  DelayedRunner.prototype.request = function (delay) {\n    this.isDirty = true;\n\n    if (!this.isPaused()) {\n      this.clearTimeout();\n\n      if (delay == null) {\n        this.tryDrain();\n      } else {\n        this.timeoutId = setTimeout( // NOT OPTIMAL! TODO: look at debounce\n        this.tryDrain.bind(this), delay);\n      }\n    }\n  };\n\n  DelayedRunner.prototype.pause = function (scope) {\n    if (scope === void 0) {\n      scope = '';\n    }\n\n    var pauseDepths = this.pauseDepths;\n    pauseDepths[scope] = (pauseDepths[scope] || 0) + 1;\n    this.clearTimeout();\n  };\n\n  DelayedRunner.prototype.resume = function (scope, force) {\n    if (scope === void 0) {\n      scope = '';\n    }\n\n    var pauseDepths = this.pauseDepths;\n\n    if (scope in pauseDepths) {\n      if (force) {\n        delete pauseDepths[scope];\n      } else {\n        var depth = --pauseDepths[scope];\n\n        if (depth <= 0) {\n          delete pauseDepths[scope];\n        }\n      }\n\n      this.tryDrain();\n    }\n  };\n\n  DelayedRunner.prototype.isPaused = function () {\n    return Object.keys(this.pauseDepths).length;\n  };\n\n  DelayedRunner.prototype.tryDrain = function () {\n    if (!this.isRunning && !this.isPaused()) {\n      this.isRunning = true;\n\n      while (this.isDirty) {\n        this.isDirty = false;\n        this.drained(); // might set isDirty to true again\n      }\n\n      this.isRunning = false;\n    }\n  };\n\n  DelayedRunner.prototype.clear = function () {\n    this.clearTimeout();\n    this.isDirty = false;\n    this.pauseDepths = {};\n  };\n\n  DelayedRunner.prototype.clearTimeout = function () {\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId);\n      this.timeoutId = 0;\n    }\n  };\n\n  DelayedRunner.prototype.drained = function () {\n    if (this.drainedOption) {\n      this.drainedOption();\n    }\n  };\n\n  return DelayedRunner;\n}();\n\nvar TaskRunner =\n/** @class */\nfunction () {\n  function TaskRunner(runTaskOption, drainedOption) {\n    this.runTaskOption = runTaskOption;\n    this.drainedOption = drainedOption;\n    this.queue = [];\n    this.delayedRunner = new DelayedRunner(this.drain.bind(this));\n  }\n\n  TaskRunner.prototype.request = function (task, delay) {\n    this.queue.push(task);\n    this.delayedRunner.request(delay);\n  };\n\n  TaskRunner.prototype.pause = function (scope) {\n    this.delayedRunner.pause(scope);\n  };\n\n  TaskRunner.prototype.resume = function (scope, force) {\n    this.delayedRunner.resume(scope, force);\n  };\n\n  TaskRunner.prototype.drain = function () {\n    var queue = this.queue;\n\n    while (queue.length) {\n      var completedTasks = [];\n      var task = void 0;\n\n      while (task = queue.shift()) {\n        this.runTask(task);\n        completedTasks.push(task);\n      }\n\n      this.drained(completedTasks);\n    } // keep going, in case new tasks were added in the drained handler\n\n  };\n\n  TaskRunner.prototype.runTask = function (task) {\n    if (this.runTaskOption) {\n      this.runTaskOption(task);\n    }\n  };\n\n  TaskRunner.prototype.drained = function (completedTasks) {\n    if (this.drainedOption) {\n      this.drainedOption(completedTasks);\n    }\n  };\n\n  return TaskRunner;\n}(); // Computes what the title at the top of the calendarApi should be for this view\n\n\nfunction buildTitle(dateProfile, viewOptions, dateEnv) {\n  var range; // for views that span a large unit of time, show the proper interval, ignoring stray days before and after\n\n  if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {\n    range = dateProfile.currentRange;\n  } else {\n    // for day units or smaller, use the actual day range\n    range = dateProfile.activeRange;\n  }\n\n  return dateEnv.formatRange(range.start, range.end, createFormatter(viewOptions.titleFormat || buildTitleFormat(dateProfile), viewOptions.titleRangeSeparator), {\n    isEndExclusive: dateProfile.isRangeAllDay\n  });\n} // Generates the format string that should be used to generate the title for the current date range.\n// Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.\n\n\nfunction buildTitleFormat(dateProfile) {\n  var currentRangeUnit = dateProfile.currentRangeUnit;\n\n  if (currentRangeUnit === 'year') {\n    return {\n      year: 'numeric'\n    };\n  } else if (currentRangeUnit === 'month') {\n    return {\n      year: 'numeric',\n      month: 'long'\n    }; // like \"September 2014\"\n  } else {\n    var days = diffWholeDays(dateProfile.currentRange.start, dateProfile.currentRange.end);\n\n    if (days !== null && days > 1) {\n      // multi-day range. shorter, like \"Sep 9 - 10 2014\"\n      return {\n        year: 'numeric',\n        month: 'short',\n        day: 'numeric'\n      };\n    } else {\n      // one day. longer, like \"September 9 2014\"\n      return {\n        year: 'numeric',\n        month: 'long',\n        day: 'numeric'\n      };\n    }\n  }\n} // in future refactor, do the redux-style function(state=initial) for initial-state\n// also, whatever is happening in constructor, have it happen in action queue too\n\n\nvar CalendarDataManager =\n/** @class */\nfunction () {\n  function CalendarDataManager(props) {\n    var _this = this;\n\n    this.computeOptionsData = memoize(this._computeOptionsData);\n    this.computeCurrentViewData = memoize(this._computeCurrentViewData);\n    this.organizeRawLocales = memoize(organizeRawLocales);\n    this.buildLocale = memoize(buildLocale);\n    this.buildPluginHooks = buildBuildPluginHooks();\n    this.buildDateEnv = memoize(buildDateEnv$1);\n    this.buildTheme = memoize(buildTheme);\n    this.parseToolbars = memoize(parseToolbars);\n    this.buildViewSpecs = memoize(buildViewSpecs);\n    this.buildDateProfileGenerator = memoizeObjArg(buildDateProfileGenerator);\n    this.buildViewApi = memoize(buildViewApi);\n    this.buildViewUiProps = memoizeObjArg(buildViewUiProps);\n    this.buildEventUiBySource = memoize(buildEventUiBySource, isPropsEqual);\n    this.buildEventUiBases = memoize(buildEventUiBases);\n    this.parseContextBusinessHours = memoizeObjArg(parseContextBusinessHours);\n    this.buildTitle = memoize(buildTitle);\n    this.emitter = new Emitter();\n    this.actionRunner = new TaskRunner(this._handleAction.bind(this), this.updateData.bind(this));\n    this.currentCalendarOptionsInput = {};\n    this.currentCalendarOptionsRefined = {};\n    this.currentViewOptionsInput = {};\n    this.currentViewOptionsRefined = {};\n    this.currentCalendarOptionsRefiners = {};\n\n    this.getCurrentData = function () {\n      return _this.data;\n    };\n\n    this.dispatch = function (action) {\n      _this.actionRunner.request(action); // protects against recursive calls to _handleAction\n\n    };\n\n    this.props = props;\n    this.actionRunner.pause();\n    var dynamicOptionOverrides = {};\n    var optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n    var currentViewType = optionsData.calendarOptions.initialView || optionsData.pluginHooks.initialView;\n    var currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides); // wire things up\n    // TODO: not DRY\n\n    props.calendarApi.currentDataManager = this;\n    this.emitter.setThisContext(props.calendarApi);\n    this.emitter.setOptions(currentViewData.options);\n    var currentDate = getInitialDate(optionsData.calendarOptions, optionsData.dateEnv);\n    var dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n\n    if (!rangeContainsMarker(dateProfile.activeRange, currentDate)) {\n      currentDate = dateProfile.currentRange.start;\n    }\n\n    var calendarContext = {\n      dateEnv: optionsData.dateEnv,\n      options: optionsData.calendarOptions,\n      pluginHooks: optionsData.pluginHooks,\n      calendarApi: props.calendarApi,\n      dispatch: this.dispatch,\n      emitter: this.emitter,\n      getCurrentData: this.getCurrentData\n    }; // needs to be after setThisContext\n\n    for (var _i = 0, _a = optionsData.pluginHooks.contextInit; _i < _a.length; _i++) {\n      var callback = _a[_i];\n      callback(calendarContext);\n    } // NOT DRY\n\n\n    var eventSources = initEventSources(optionsData.calendarOptions, dateProfile, calendarContext);\n    var initialState = {\n      dynamicOptionOverrides: dynamicOptionOverrides,\n      currentViewType: currentViewType,\n      currentDate: currentDate,\n      dateProfile: dateProfile,\n      businessHours: this.parseContextBusinessHours(calendarContext),\n      eventSources: eventSources,\n      eventUiBases: {},\n      loadingLevel: computeEventSourceLoadingLevel(eventSources),\n      eventStore: createEmptyEventStore(),\n      renderableEventStore: createEmptyEventStore(),\n      dateSelection: null,\n      eventSelection: '',\n      eventDrag: null,\n      eventResize: null,\n      selectionConfig: this.buildViewUiProps(calendarContext).selectionConfig\n    };\n\n    var contextAndState = Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, calendarContext), initialState);\n\n    for (var _b = 0, _c = optionsData.pluginHooks.reducers; _b < _c.length; _b++) {\n      var reducer = _c[_b];\n\n      Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(initialState, reducer(null, null, contextAndState));\n    }\n\n    if (initialState.loadingLevel) {\n      this.emitter.trigger('loading', true); // NOT DRY\n    }\n\n    this.state = initialState;\n    this.updateData();\n    this.actionRunner.resume();\n  }\n\n  CalendarDataManager.prototype.resetOptions = function (optionOverrides, append) {\n    var props = this.props;\n    props.optionOverrides = append ? Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, props.optionOverrides), optionOverrides) : optionOverrides;\n    this.actionRunner.request({\n      type: 'NOTHING'\n    });\n  };\n\n  CalendarDataManager.prototype._handleAction = function (action) {\n    var _a = this,\n        props = _a.props,\n        state = _a.state,\n        emitter = _a.emitter;\n\n    var dynamicOptionOverrides = reduceDynamicOptionOverrides(state.dynamicOptionOverrides, action);\n    var optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n    var currentViewType = reduceViewType(state.currentViewType, action);\n    var currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides); // wire things up\n    // TODO: not DRY\n\n    props.calendarApi.currentDataManager = this;\n    emitter.setThisContext(props.calendarApi);\n    emitter.setOptions(currentViewData.options);\n    var calendarContext = {\n      dateEnv: optionsData.dateEnv,\n      options: optionsData.calendarOptions,\n      pluginHooks: optionsData.pluginHooks,\n      calendarApi: props.calendarApi,\n      dispatch: this.dispatch,\n      emitter: emitter,\n      getCurrentData: this.getCurrentData\n    };\n    var currentDate = state.currentDate;\n    var dateProfile = state.dateProfile;\n\n    if (this.data && this.data.dateProfileGenerator !== currentViewData.dateProfileGenerator) {\n      // hack\n      dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n    }\n\n    currentDate = reduceCurrentDate(currentDate, action);\n    dateProfile = reduceDateProfile(dateProfile, action, currentDate, currentViewData.dateProfileGenerator);\n\n    if (!rangeContainsMarker(dateProfile.currentRange, currentDate)) {\n      currentDate = dateProfile.currentRange.start;\n    }\n\n    var eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendarContext);\n    var eventSourceLoadingLevel = computeEventSourceLoadingLevel(eventSources);\n    var eventStore = reduceEventStore(state.eventStore, action, eventSources, dateProfile, calendarContext);\n    var renderableEventStore = eventSourceLoadingLevel && !currentViewData.options.progressiveEventRendering ? state.renderableEventStore || eventStore : // try from previous state\n    eventStore;\n\n    var _b = this.buildViewUiProps(calendarContext),\n        eventUiSingleBase = _b.eventUiSingleBase,\n        selectionConfig = _b.selectionConfig; // will memoize obj\n\n\n    var eventUiBySource = this.buildEventUiBySource(eventSources);\n    var eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);\n    var prevLoadingLevel = state.loadingLevel || 0;\n    var loadingLevel = eventSourceLoadingLevel;\n    var newState = {\n      dynamicOptionOverrides: dynamicOptionOverrides,\n      currentViewType: currentViewType,\n      currentDate: currentDate,\n      dateProfile: dateProfile,\n      eventSources: eventSources,\n      eventStore: eventStore,\n      renderableEventStore: renderableEventStore,\n      selectionConfig: selectionConfig,\n      eventUiBases: eventUiBases,\n      loadingLevel: loadingLevel,\n      businessHours: this.parseContextBusinessHours(calendarContext),\n      dateSelection: reduceDateSelection(state.dateSelection, action),\n      eventSelection: reduceSelectedEvent(state.eventSelection, action),\n      eventDrag: reduceEventDrag(state.eventDrag, action),\n      eventResize: reduceEventResize(state.eventResize, action)\n    };\n\n    var contextAndState = Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, calendarContext), newState);\n\n    for (var _i = 0, _c = optionsData.pluginHooks.reducers; _i < _c.length; _i++) {\n      var reducer = _c[_i];\n\n      Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(newState, reducer(state, action, contextAndState)); // give the OLD state, for old value\n\n    } // TODO: use propSetHandlers in plugin system\n\n\n    if (!prevLoadingLevel && loadingLevel) {\n      emitter.trigger('loading', true);\n    } else if (prevLoadingLevel && !loadingLevel) {\n      emitter.trigger('loading', false);\n    }\n\n    this.state = newState;\n\n    if (props.onAction) {\n      props.onAction(action);\n    }\n  };\n\n  CalendarDataManager.prototype.updateData = function () {\n    var _a = this,\n        props = _a.props,\n        state = _a.state;\n\n    var oldData = this.data;\n    var optionsData = this.computeOptionsData(props.optionOverrides, state.dynamicOptionOverrides, props.calendarApi);\n    var currentViewData = this.computeCurrentViewData(state.currentViewType, optionsData, props.optionOverrides, state.dynamicOptionOverrides);\n\n    var data = this.data = Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({\n      viewTitle: this.buildTitle(state.dateProfile, currentViewData.options, optionsData.dateEnv),\n      calendarApi: props.calendarApi,\n      dispatch: this.dispatch,\n      emitter: this.emitter,\n      getCurrentData: this.getCurrentData\n    }, optionsData), currentViewData), state);\n\n    var changeHandlers = optionsData.pluginHooks.optionChangeHandlers;\n    var oldCalendarOptions = oldData && oldData.calendarOptions;\n    var newCalendarOptions = optionsData.calendarOptions;\n\n    if (oldCalendarOptions && oldCalendarOptions !== newCalendarOptions) {\n      if (oldCalendarOptions.timeZone !== newCalendarOptions.timeZone) {\n        // hack\n        state.eventSources = data.eventSources = reduceEventSourcesNewTimeZone(data.eventSources, state.dateProfile, data);\n        state.eventStore = data.eventStore = rezoneEventStoreDates(data.eventStore, oldData.dateEnv, data.dateEnv);\n      }\n\n      for (var optionName in changeHandlers) {\n        if (oldCalendarOptions[optionName] !== newCalendarOptions[optionName]) {\n          changeHandlers[optionName](newCalendarOptions[optionName], data);\n        }\n      }\n    }\n\n    if (props.onData) {\n      props.onData(data);\n    }\n  };\n\n  CalendarDataManager.prototype._computeOptionsData = function (optionOverrides, dynamicOptionOverrides, calendarApi) {\n    // TODO: blacklist options that are handled by optionChangeHandlers\n    var _a = this.processRawCalendarOptions(optionOverrides, dynamicOptionOverrides),\n        refinedOptions = _a.refinedOptions,\n        pluginHooks = _a.pluginHooks,\n        localeDefaults = _a.localeDefaults,\n        availableLocaleData = _a.availableLocaleData,\n        extra = _a.extra;\n\n    warnUnknownOptions(extra);\n    var dateEnv = this.buildDateEnv(refinedOptions.timeZone, refinedOptions.locale, refinedOptions.weekNumberCalculation, refinedOptions.firstDay, refinedOptions.weekText, pluginHooks, availableLocaleData, refinedOptions.defaultRangeSeparator);\n    var viewSpecs = this.buildViewSpecs(pluginHooks.views, optionOverrides, dynamicOptionOverrides, localeDefaults);\n    var theme = this.buildTheme(refinedOptions, pluginHooks);\n    var toolbarConfig = this.parseToolbars(refinedOptions, optionOverrides, theme, viewSpecs, calendarApi);\n    return {\n      calendarOptions: refinedOptions,\n      pluginHooks: pluginHooks,\n      dateEnv: dateEnv,\n      viewSpecs: viewSpecs,\n      theme: theme,\n      toolbarConfig: toolbarConfig,\n      localeDefaults: localeDefaults,\n      availableRawLocales: availableLocaleData.map\n    };\n  }; // always called from behind a memoizer\n\n\n  CalendarDataManager.prototype.processRawCalendarOptions = function (optionOverrides, dynamicOptionOverrides) {\n    var _a = mergeRawOptions([BASE_OPTION_DEFAULTS, optionOverrides, dynamicOptionOverrides]),\n        locales = _a.locales,\n        locale = _a.locale;\n\n    var availableLocaleData = this.organizeRawLocales(locales);\n    var availableRawLocales = availableLocaleData.map;\n    var localeDefaults = this.buildLocale(locale || availableLocaleData.defaultCode, availableRawLocales).options;\n    var pluginHooks = this.buildPluginHooks(optionOverrides.plugins || [], globalPlugins);\n\n    var refiners = this.currentCalendarOptionsRefiners = Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n\n    var extra = {};\n    var raw = mergeRawOptions([BASE_OPTION_DEFAULTS, localeDefaults, optionOverrides, dynamicOptionOverrides]);\n    var refined = {};\n    var currentRaw = this.currentCalendarOptionsInput;\n    var currentRefined = this.currentCalendarOptionsRefined;\n    var anyChanges = false;\n\n    for (var optionName in raw) {\n      if (optionName !== 'plugins') {\n        // because plugins is special-cased\n        if (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && optionName in currentRaw && COMPLEX_OPTION_COMPARATORS[optionName](currentRaw[optionName], raw[optionName])) {\n          refined[optionName] = currentRefined[optionName];\n        } else if (refiners[optionName]) {\n          refined[optionName] = refiners[optionName](raw[optionName]);\n          anyChanges = true;\n        } else {\n          extra[optionName] = currentRaw[optionName];\n        }\n      }\n    }\n\n    if (anyChanges) {\n      this.currentCalendarOptionsInput = raw;\n      this.currentCalendarOptionsRefined = refined;\n    }\n\n    return {\n      rawOptions: this.currentCalendarOptionsInput,\n      refinedOptions: this.currentCalendarOptionsRefined,\n      pluginHooks: pluginHooks,\n      availableLocaleData: availableLocaleData,\n      localeDefaults: localeDefaults,\n      extra: extra\n    };\n  };\n\n  CalendarDataManager.prototype._computeCurrentViewData = function (viewType, optionsData, optionOverrides, dynamicOptionOverrides) {\n    var viewSpec = optionsData.viewSpecs[viewType];\n\n    if (!viewSpec) {\n      throw new Error(\"viewType \\\"\" + viewType + \"\\\" is not available. Please make sure you've loaded all neccessary plugins\");\n    }\n\n    var _a = this.processRawViewOptions(viewSpec, optionsData.pluginHooks, optionsData.localeDefaults, optionOverrides, dynamicOptionOverrides),\n        refinedOptions = _a.refinedOptions,\n        extra = _a.extra;\n\n    warnUnknownOptions(extra);\n    var dateProfileGenerator = this.buildDateProfileGenerator({\n      dateProfileGeneratorClass: viewSpec.optionDefaults.dateProfileGeneratorClass,\n      duration: viewSpec.duration,\n      durationUnit: viewSpec.durationUnit,\n      usesMinMaxTime: viewSpec.optionDefaults.usesMinMaxTime,\n      dateEnv: optionsData.dateEnv,\n      calendarApi: this.props.calendarApi,\n      slotMinTime: refinedOptions.slotMinTime,\n      slotMaxTime: refinedOptions.slotMaxTime,\n      showNonCurrentDates: refinedOptions.showNonCurrentDates,\n      dayCount: refinedOptions.dayCount,\n      dateAlignment: refinedOptions.dateAlignment,\n      dateIncrement: refinedOptions.dateIncrement,\n      hiddenDays: refinedOptions.hiddenDays,\n      weekends: refinedOptions.weekends,\n      nowInput: refinedOptions.now,\n      validRangeInput: refinedOptions.validRange,\n      visibleRangeInput: refinedOptions.visibleRange,\n      monthMode: refinedOptions.monthMode,\n      fixedWeekCount: refinedOptions.fixedWeekCount\n    });\n    var viewApi = this.buildViewApi(viewType, this.getCurrentData, optionsData.dateEnv);\n    return {\n      viewSpec: viewSpec,\n      options: refinedOptions,\n      dateProfileGenerator: dateProfileGenerator,\n      viewApi: viewApi\n    };\n  };\n\n  CalendarDataManager.prototype.processRawViewOptions = function (viewSpec, pluginHooks, localeDefaults, optionOverrides, dynamicOptionOverrides) {\n    var raw = mergeRawOptions([BASE_OPTION_DEFAULTS, viewSpec.optionDefaults, localeDefaults, optionOverrides, viewSpec.optionOverrides, dynamicOptionOverrides]);\n\n    var refiners = Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), VIEW_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n\n    var refined = {};\n    var currentRaw = this.currentViewOptionsInput;\n    var currentRefined = this.currentViewOptionsRefined;\n    var anyChanges = false;\n    var extra = {};\n\n    for (var optionName in raw) {\n      if (raw[optionName] === currentRaw[optionName]) {\n        refined[optionName] = currentRefined[optionName];\n      } else {\n        if (raw[optionName] === this.currentCalendarOptionsInput[optionName]) {\n          if (optionName in this.currentCalendarOptionsRefined) {\n            // might be an \"extra\" prop\n            refined[optionName] = this.currentCalendarOptionsRefined[optionName];\n          }\n        } else if (refiners[optionName]) {\n          refined[optionName] = refiners[optionName](raw[optionName]);\n        } else {\n          extra[optionName] = raw[optionName];\n        }\n\n        anyChanges = true;\n      }\n    }\n\n    if (anyChanges) {\n      this.currentViewOptionsInput = raw;\n      this.currentViewOptionsRefined = refined;\n    }\n\n    return {\n      rawOptions: this.currentViewOptionsInput,\n      refinedOptions: this.currentViewOptionsRefined,\n      extra: extra\n    };\n  };\n\n  return CalendarDataManager;\n}();\n\nfunction buildDateEnv$1(timeZone, explicitLocale, weekNumberCalculation, firstDay, weekText, pluginHooks, availableLocaleData, defaultSeparator) {\n  var locale = buildLocale(explicitLocale || availableLocaleData.defaultCode, availableLocaleData.map);\n  return new DateEnv({\n    calendarSystem: 'gregory',\n    timeZone: timeZone,\n    namedTimeZoneImpl: pluginHooks.namedTimeZonedImpl,\n    locale: locale,\n    weekNumberCalculation: weekNumberCalculation,\n    firstDay: firstDay,\n    weekText: weekText,\n    cmdFormatter: pluginHooks.cmdFormatter,\n    defaultSeparator: defaultSeparator\n  });\n}\n\nfunction buildTheme(options, pluginHooks) {\n  var ThemeClass = pluginHooks.themeClasses[options.themeSystem] || StandardTheme;\n  return new ThemeClass(options);\n}\n\nfunction buildDateProfileGenerator(props) {\n  var DateProfileGeneratorClass = props.dateProfileGeneratorClass || DateProfileGenerator;\n  return new DateProfileGeneratorClass(props);\n}\n\nfunction buildViewApi(type, getCurrentData, dateEnv) {\n  return new ViewApi(type, getCurrentData, dateEnv);\n}\n\nfunction buildEventUiBySource(eventSources) {\n  return mapHash(eventSources, function (eventSource) {\n    return eventSource.ui;\n  });\n}\n\nfunction buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {\n  var eventUiBases = {\n    '': eventUiSingleBase\n  };\n\n  for (var defId in eventDefs) {\n    var def = eventDefs[defId];\n\n    if (def.sourceId && eventUiBySource[def.sourceId]) {\n      eventUiBases[defId] = eventUiBySource[def.sourceId];\n    }\n  }\n\n  return eventUiBases;\n}\n\nfunction buildViewUiProps(calendarContext) {\n  var options = calendarContext.options;\n  return {\n    eventUiSingleBase: createEventUi({\n      display: options.eventDisplay,\n      editable: options.editable,\n      startEditable: options.eventStartEditable,\n      durationEditable: options.eventDurationEditable,\n      constraint: options.eventConstraint,\n      overlap: typeof options.eventOverlap === 'boolean' ? options.eventOverlap : undefined,\n      allow: options.eventAllow,\n      backgroundColor: options.eventBackgroundColor,\n      borderColor: options.eventBorderColor,\n      textColor: options.eventTextColor,\n      color: options.eventColor // classNames: options.eventClassNames // render hook will handle this\n\n    }, calendarContext),\n    selectionConfig: createEventUi({\n      constraint: options.selectConstraint,\n      overlap: typeof options.selectOverlap === 'boolean' ? options.selectOverlap : undefined,\n      allow: options.selectAllow\n    }, calendarContext)\n  };\n}\n\nfunction parseContextBusinessHours(calendarContext) {\n  return parseBusinessHours(calendarContext.options.businessHours, calendarContext);\n}\n\nfunction warnUnknownOptions(options, viewName) {\n  for (var optionName in options) {\n    console.warn(\"Unknown option '\" + optionName + \"'\" + (viewName ? \" for view '\" + viewName + \"'\" : ''));\n  }\n} // TODO: move this to react plugin?\n\n\nvar CalendarDataProvider =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(CalendarDataProvider, _super);\n\n  function CalendarDataProvider(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.handleData = function (data) {\n      if (!_this.dataManager) {\n        // still within initial run, before assignment in constructor\n        // eslint-disable-next-line react/no-direct-mutation-state\n        _this.state = data; // can't use setState yet\n      } else {\n        _this.setState(data);\n      }\n    };\n\n    _this.dataManager = new CalendarDataManager({\n      optionOverrides: props.optionOverrides,\n      calendarApi: props.calendarApi,\n      onData: _this.handleData\n    });\n    return _this;\n  }\n\n  CalendarDataProvider.prototype.render = function () {\n    return this.props.children(this.state);\n  };\n\n  CalendarDataProvider.prototype.componentDidUpdate = function (prevProps) {\n    var newOptionOverrides = this.props.optionOverrides;\n\n    if (newOptionOverrides !== prevProps.optionOverrides) {\n      // prevent recursive handleData\n      this.dataManager.resetOptions(newOptionOverrides);\n    }\n  };\n\n  return CalendarDataProvider;\n}(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"Component\"]); // HELPERS\n\n/*\nif nextDayThreshold is specified, slicing is done in an all-day fashion.\nyou can get nextDayThreshold from context.nextDayThreshold\n*/\n\n\nfunction sliceEvents(props, allDay) {\n  return sliceEventStore(props.eventStore, props.eventUiBases, props.dateProfile.activeRange, allDay ? props.nextDayThreshold : null).fg;\n}\n\nvar NamedTimeZoneImpl =\n/** @class */\nfunction () {\n  function NamedTimeZoneImpl(timeZoneName) {\n    this.timeZoneName = timeZoneName;\n  }\n\n  return NamedTimeZoneImpl;\n}();\n\nvar Interaction =\n/** @class */\nfunction () {\n  function Interaction(settings) {\n    this.component = settings.component;\n  }\n\n  Interaction.prototype.destroy = function () {};\n\n  return Interaction;\n}();\n\nfunction parseInteractionSettings(component, input) {\n  return {\n    component: component,\n    el: input.el,\n    useEventCenter: input.useEventCenter != null ? input.useEventCenter : true\n  };\n}\n\nfunction interactionSettingsToStore(settings) {\n  var _a;\n\n  return _a = {}, _a[settings.component.uid] = settings, _a;\n} // global state\n\n\nvar interactionSettingsStore = {};\n/*\nAn abstraction for a dragging interaction originating on an event.\nDoes higher-level things than PointerDragger, such as possibly:\n- a \"mirror\" that moves with the pointer\n- a minimum number of pixels or other criteria for a true drag to begin\n\nsubclasses must emit:\n- pointerdown\n- dragstart\n- dragmove\n- pointerup\n- dragend\n*/\n\nvar ElementDragging =\n/** @class */\nfunction () {\n  function ElementDragging(el, selector) {\n    this.emitter = new Emitter();\n  }\n\n  ElementDragging.prototype.destroy = function () {};\n\n  ElementDragging.prototype.setMirrorIsVisible = function (bool) {// optional if subclass doesn't want to support a mirror\n  };\n\n  ElementDragging.prototype.setMirrorNeedsRevert = function (bool) {// optional if subclass doesn't want to support a mirror\n  };\n\n  ElementDragging.prototype.setAutoScrollEnabled = function (bool) {// optional\n  };\n\n  return ElementDragging;\n}(); // TODO: get rid of this in favor of options system,\n// tho it's really easy to access this globally rather than pass thru options.\n\n\nvar config = {};\n/*\nInformation about what will happen when an external element is dragged-and-dropped\nonto a calendar. Contains information for creating an event.\n*/\n\nvar DRAG_META_REFINERS = {\n  startTime: createDuration,\n  duration: createDuration,\n  create: Boolean,\n  sourceId: String\n};\n\nfunction parseDragMeta(raw) {\n  var _a = refineProps(raw, DRAG_META_REFINERS),\n      refined = _a.refined,\n      extra = _a.extra;\n\n  return {\n    startTime: refined.startTime || null,\n    duration: refined.duration || null,\n    create: refined.create != null ? refined.create : true,\n    sourceId: refined.sourceId,\n    leftoverProps: extra\n  };\n}\n\nvar Toolbar =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(Toolbar, _super);\n\n  function Toolbar() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Toolbar.prototype.render = function () {\n    var _a = this.props,\n        model = _a.model,\n        extraClassName = _a.extraClassName;\n    var forceLtr = false;\n    var startContent, endContent;\n    var centerContent = model.center;\n\n    if (model.left) {\n      forceLtr = true;\n      startContent = model.left;\n    } else {\n      startContent = model.start;\n    }\n\n    if (model.right) {\n      forceLtr = true;\n      endContent = model.right;\n    } else {\n      endContent = model.end;\n    }\n\n    var classNames = [extraClassName || '', 'fc-toolbar', forceLtr ? 'fc-toolbar-ltr' : ''];\n    return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"div\", {\n      className: classNames.join(' ')\n    }, this.renderSection('start', startContent || []), this.renderSection('center', centerContent || []), this.renderSection('end', endContent || []));\n  };\n\n  Toolbar.prototype.renderSection = function (key, widgetGroups) {\n    var props = this.props;\n    return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(ToolbarSection, {\n      key: key,\n      widgetGroups: widgetGroups,\n      title: props.title,\n      activeButton: props.activeButton,\n      isTodayEnabled: props.isTodayEnabled,\n      isPrevEnabled: props.isPrevEnabled,\n      isNextEnabled: props.isNextEnabled\n    });\n  };\n\n  return Toolbar;\n}(BaseComponent);\n\nvar ToolbarSection =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(ToolbarSection, _super);\n\n  function ToolbarSection() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ToolbarSection.prototype.render = function () {\n    var _this = this;\n\n    var children = this.props.widgetGroups.map(function (widgetGroup) {\n      return _this.renderWidgetGroup(widgetGroup);\n    });\n    return _vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"].apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__spreadArrays\"])(['div', {\n      className: 'fc-toolbar-chunk'\n    }], children));\n  };\n\n  ToolbarSection.prototype.renderWidgetGroup = function (widgetGroup) {\n    var props = this.props;\n    var theme = this.context.theme;\n    var children = [];\n    var isOnlyButtons = true;\n\n    for (var _i = 0, widgetGroup_1 = widgetGroup; _i < widgetGroup_1.length; _i++) {\n      var widget = widgetGroup_1[_i];\n      var buttonName = widget.buttonName,\n          buttonClick = widget.buttonClick,\n          buttonText = widget.buttonText,\n          buttonIcon = widget.buttonIcon;\n\n      if (buttonName === 'title') {\n        isOnlyButtons = false;\n        children.push(Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"h2\", {\n          className: 'fc-toolbar-title'\n        }, props.title));\n      } else {\n        var ariaAttrs = buttonIcon ? {\n          'aria-label': buttonName\n        } : {};\n        var buttonClasses = ['fc-' + buttonName + '-button', theme.getClass('button')];\n\n        if (buttonName === props.activeButton) {\n          buttonClasses.push(theme.getClass('buttonActive'));\n        }\n\n        var isDisabled = !props.isTodayEnabled && buttonName === 'today' || !props.isPrevEnabled && buttonName === 'prev' || !props.isNextEnabled && buttonName === 'next';\n        children.push(Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"button\", Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({\n          disabled: isDisabled,\n          className: buttonClasses.join(' '),\n          onClick: buttonClick\n        }, ariaAttrs), buttonText || (buttonIcon ? Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"span\", {\n          className: buttonIcon\n        }) : '')));\n      }\n    }\n\n    if (children.length > 1) {\n      var groupClassName = isOnlyButtons && theme.getClass('buttonGroup') || '';\n      return _vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"].apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__spreadArrays\"])(['div', {\n        className: groupClassName\n      }], children));\n    } else {\n      return children[0];\n    }\n  };\n\n  return ToolbarSection;\n}(BaseComponent); // TODO: do function component?\n\n\nvar ViewContainer =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(ViewContainer, _super);\n\n  function ViewContainer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ViewContainer.prototype.render = function () {\n    var props = this.props;\n    var aspectRatio = props.aspectRatio;\n    var classNames = ['fc-view-harness', aspectRatio || props.liquid || props.height ? 'fc-view-harness-active' // harness controls the height\n    : 'fc-view-harness-passive' // let the view do the height\n    ];\n    var height = '';\n    var paddingBottom = '';\n\n    if (aspectRatio) {\n      paddingBottom = 1 / aspectRatio * 100 + '%';\n    } else {\n      height = props.height || '';\n    }\n\n    return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"div\", {\n      ref: props.elRef,\n      onClick: props.onClick,\n      className: classNames.join(' '),\n      style: {\n        height: height,\n        paddingBottom: paddingBottom\n      }\n    }, props.children);\n  };\n\n  return ViewContainer;\n}(BaseComponent);\n/*\nDetects when the user clicks on an event within a DateComponent\n*/\n\n\nvar EventClicking =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(EventClicking, _super);\n\n  function EventClicking(settings) {\n    var _this = _super.call(this, settings) || this;\n\n    _this.handleSegClick = function (ev, segEl) {\n      var component = _this.component;\n      var context = component.context;\n      var seg = getElSeg(segEl);\n\n      if (seg && // might be the <div> surrounding the more link\n      component.isValidSegDownEl(ev.target)) {\n        // our way to simulate a link click for elements that can't be <a> tags\n        // grab before trigger fired in case trigger trashes DOM thru rerendering\n        var hasUrlContainer = elementClosest(ev.target, '.fc-event-forced-url');\n        var url = hasUrlContainer ? hasUrlContainer.querySelector('a[href]').href : '';\n        context.emitter.trigger('eventClick', {\n          el: segEl,\n          event: new EventApi(component.context, seg.eventRange.def, seg.eventRange.instance),\n          jsEvent: ev,\n          view: context.viewApi\n        });\n\n        if (url && !ev.defaultPrevented) {\n          window.location.href = url;\n        }\n      }\n    };\n\n    _this.destroy = listenBySelector(settings.el, 'click', '.fc-event', // on both fg and bg events\n    _this.handleSegClick);\n    return _this;\n  }\n\n  return EventClicking;\n}(Interaction);\n/*\nTriggers events and adds/removes core classNames when the user's pointer\nenters/leaves event-elements of a component.\n*/\n\n\nvar EventHovering =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(EventHovering, _super);\n\n  function EventHovering(settings) {\n    var _this = _super.call(this, settings) || this; // for simulating an eventMouseLeave when the event el is destroyed while mouse is over it\n\n\n    _this.handleEventElRemove = function (el) {\n      if (el === _this.currentSegEl) {\n        _this.handleSegLeave(null, _this.currentSegEl);\n      }\n    };\n\n    _this.handleSegEnter = function (ev, segEl) {\n      if (getElSeg(segEl)) {\n        // TODO: better way to make sure not hovering over more+ link or its wrapper\n        _this.currentSegEl = segEl;\n\n        _this.triggerEvent('eventMouseEnter', ev, segEl);\n      }\n    };\n\n    _this.handleSegLeave = function (ev, segEl) {\n      if (_this.currentSegEl) {\n        _this.currentSegEl = null;\n\n        _this.triggerEvent('eventMouseLeave', ev, segEl);\n      }\n    };\n\n    _this.removeHoverListeners = listenToHoverBySelector(settings.el, '.fc-event', // on both fg and bg events\n    _this.handleSegEnter, _this.handleSegLeave);\n    return _this;\n  }\n\n  EventHovering.prototype.destroy = function () {\n    this.removeHoverListeners();\n  };\n\n  EventHovering.prototype.triggerEvent = function (publicEvName, ev, segEl) {\n    var component = this.component;\n    var context = component.context;\n    var seg = getElSeg(segEl);\n\n    if (!ev || component.isValidSegDownEl(ev.target)) {\n      context.emitter.trigger(publicEvName, {\n        el: segEl,\n        event: new EventApi(context, seg.eventRange.def, seg.eventRange.instance),\n        jsEvent: ev,\n        view: context.viewApi\n      });\n    }\n  };\n\n  return EventHovering;\n}(Interaction);\n\nvar CalendarContent =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(CalendarContent, _super);\n\n  function CalendarContent() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.buildViewContext = memoize(buildViewContext);\n    _this.buildViewPropTransformers = memoize(buildViewPropTransformers);\n    _this.buildToolbarProps = memoize(buildToolbarProps);\n    _this.handleNavLinkClick = buildDelegationHandler('a[data-navlink]', _this._handleNavLinkClick.bind(_this));\n    _this.headerRef = Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createRef\"])();\n    _this.footerRef = Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createRef\"])();\n    _this.interactionsStore = {}; // Component Registration\n    // -----------------------------------------------------------------------------------------------------------------\n\n    _this.registerInteractiveComponent = function (component, settingsInput) {\n      var settings = parseInteractionSettings(component, settingsInput);\n      var DEFAULT_INTERACTIONS = [EventClicking, EventHovering];\n      var interactionClasses = DEFAULT_INTERACTIONS.concat(_this.props.pluginHooks.componentInteractions);\n      var interactions = interactionClasses.map(function (interactionClass) {\n        return new interactionClass(settings);\n      });\n      _this.interactionsStore[component.uid] = interactions;\n      interactionSettingsStore[component.uid] = settings;\n    };\n\n    _this.unregisterInteractiveComponent = function (component) {\n      for (var _i = 0, _a = _this.interactionsStore[component.uid]; _i < _a.length; _i++) {\n        var listener = _a[_i];\n        listener.destroy();\n      }\n\n      delete _this.interactionsStore[component.uid];\n      delete interactionSettingsStore[component.uid];\n    }; // Resizing\n    // -----------------------------------------------------------------------------------------------------------------\n\n\n    _this.resizeRunner = new DelayedRunner(function () {\n      _this.props.emitter.trigger('_resize', true); // should window resizes be considered \"forced\" ?\n\n\n      _this.props.emitter.trigger('windowResize', {\n        view: _this.props.viewApi\n      });\n    });\n\n    _this.handleWindowResize = function (ev) {\n      var options = _this.props.options;\n\n      if (options.handleWindowResize && ev.target === window // avoid jqui events\n      ) {\n          _this.resizeRunner.request(options.windowResizeDelay);\n        }\n    };\n\n    return _this;\n  }\n  /*\n  renders INSIDE of an outer div\n  */\n\n\n  CalendarContent.prototype.render = function () {\n    var props = this.props;\n    var toolbarConfig = props.toolbarConfig,\n        options = props.options;\n    var toolbarProps = this.buildToolbarProps(props.viewSpec, props.dateProfile, props.dateProfileGenerator, props.currentDate, getNow(props.options.now, props.dateEnv), // TODO: use NowTimer????\n    props.viewTitle);\n    var viewVGrow = false;\n    var viewHeight = '';\n    var viewAspectRatio;\n\n    if (props.isHeightAuto || props.forPrint) {\n      viewHeight = '';\n    } else if (options.height != null) {\n      viewVGrow = true;\n    } else if (options.contentHeight != null) {\n      viewHeight = options.contentHeight;\n    } else {\n      viewAspectRatio = Math.max(options.aspectRatio, 0.5); // prevent from getting too tall\n    }\n\n    var viewContext = this.buildViewContext(props.viewSpec, props.viewApi, props.options, props.dateProfileGenerator, props.dateEnv, props.theme, props.pluginHooks, props.dispatch, props.getCurrentData, props.emitter, props.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent);\n    return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(ViewContextType.Provider, {\n      value: viewContext\n    }, toolbarConfig.headerToolbar && Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(Toolbar, Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({\n      ref: this.headerRef,\n      extraClassName: 'fc-header-toolbar',\n      model: toolbarConfig.headerToolbar\n    }, toolbarProps)), Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(ViewContainer, {\n      liquid: viewVGrow,\n      height: viewHeight,\n      aspectRatio: viewAspectRatio,\n      onClick: this.handleNavLinkClick\n    }, this.renderView(props), this.buildAppendContent()), toolbarConfig.footerToolbar && Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(Toolbar, Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({\n      ref: this.footerRef,\n      extraClassName: 'fc-footer-toolbar',\n      model: toolbarConfig.footerToolbar\n    }, toolbarProps)));\n  };\n\n  CalendarContent.prototype.componentDidMount = function () {\n    var props = this.props;\n    this.calendarInteractions = props.pluginHooks.calendarInteractions.map(function (calendarInteractionClass) {\n      return new calendarInteractionClass(props);\n    });\n    window.addEventListener('resize', this.handleWindowResize);\n    var propSetHandlers = props.pluginHooks.propSetHandlers;\n\n    for (var propName in propSetHandlers) {\n      propSetHandlers[propName](props[propName], props);\n    }\n  };\n\n  CalendarContent.prototype.componentDidUpdate = function (prevProps) {\n    var props = this.props;\n    var propSetHandlers = props.pluginHooks.propSetHandlers;\n\n    for (var propName in propSetHandlers) {\n      if (props[propName] !== prevProps[propName]) {\n        propSetHandlers[propName](props[propName], props);\n      }\n    }\n  };\n\n  CalendarContent.prototype.componentWillUnmount = function () {\n    window.removeEventListener('resize', this.handleWindowResize);\n    this.resizeRunner.clear();\n\n    for (var _i = 0, _a = this.calendarInteractions; _i < _a.length; _i++) {\n      var interaction = _a[_i];\n      interaction.destroy();\n    }\n\n    this.props.emitter.trigger('_unmount');\n  };\n\n  CalendarContent.prototype._handleNavLinkClick = function (ev, anchorEl) {\n    var _a = this.props,\n        dateEnv = _a.dateEnv,\n        options = _a.options,\n        calendarApi = _a.calendarApi;\n    var navLinkOptions = anchorEl.getAttribute('data-navlink');\n    navLinkOptions = navLinkOptions ? JSON.parse(navLinkOptions) : {};\n    var dateMarker = dateEnv.createMarker(navLinkOptions.date);\n    var viewType = navLinkOptions.type;\n    var customAction = viewType === 'day' ? options.navLinkDayClick : viewType === 'week' ? options.navLinkWeekClick : null;\n\n    if (typeof customAction === 'function') {\n      customAction.call(calendarApi, dateEnv.toDate(dateMarker), ev);\n    } else {\n      if (typeof customAction === 'string') {\n        viewType = customAction;\n      }\n\n      calendarApi.zoomTo(dateMarker, viewType);\n    }\n  };\n\n  CalendarContent.prototype.buildAppendContent = function () {\n    var props = this.props;\n    var children = props.pluginHooks.viewContainerAppends.map(function (buildAppendContent) {\n      return buildAppendContent(props);\n    });\n    return _vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"].apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__spreadArrays\"])([_vdom__WEBPACK_IMPORTED_MODULE_2__[\"Fragment\"], {}], children));\n  };\n\n  CalendarContent.prototype.renderView = function (props) {\n    var pluginHooks = props.pluginHooks;\n    var viewSpec = props.viewSpec;\n    var viewProps = {\n      dateProfile: props.dateProfile,\n      businessHours: props.businessHours,\n      eventStore: props.renderableEventStore,\n      eventUiBases: props.eventUiBases,\n      dateSelection: props.dateSelection,\n      eventSelection: props.eventSelection,\n      eventDrag: props.eventDrag,\n      eventResize: props.eventResize,\n      isHeightAuto: props.isHeightAuto,\n      forPrint: props.forPrint\n    };\n    var transformers = this.buildViewPropTransformers(pluginHooks.viewPropsTransformers);\n\n    for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {\n      var transformer = transformers_1[_i];\n\n      Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(viewProps, transformer.transform(viewProps, props));\n    }\n\n    var ViewComponent = viewSpec.component;\n    return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(ViewComponent, Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({}, viewProps));\n  };\n\n  return CalendarContent;\n}(PureComponent);\n\nfunction buildToolbarProps(viewSpec, dateProfile, dateProfileGenerator, currentDate, now, title) {\n  // don't force any date-profiles to valid date profiles (the `false`) so that we can tell if it's invalid\n  var todayInfo = dateProfileGenerator.build(now, undefined, false); // TODO: need `undefined` or else INFINITE LOOP for some reason\n\n  var prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate, false);\n  var nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate, false);\n  return {\n    title: title,\n    activeButton: viewSpec.type,\n    isTodayEnabled: todayInfo.isValid && !rangeContainsMarker(dateProfile.currentRange, now),\n    isPrevEnabled: prevInfo.isValid,\n    isNextEnabled: nextInfo.isValid\n  };\n} // Plugin\n// -----------------------------------------------------------------------------------------------------------------\n\n\nfunction buildViewPropTransformers(theClasses) {\n  return theClasses.map(function (theClass) {\n    return new theClass();\n  });\n}\n\nvar canVGrowWithinCell;\n\nfunction getCanVGrowWithinCell() {\n  if (canVGrowWithinCell == null) {\n    canVGrowWithinCell = computeCanVGrowWithinCell();\n  }\n\n  return canVGrowWithinCell;\n}\n\nfunction computeCanVGrowWithinCell() {\n  // TODO: abstraction for creating these temporary detection-based els\n  var el = document.createElement('div');\n  el.style.position = 'absolute'; // for not interfering with current layout\n\n  el.style.top = '0';\n  el.style.left = '0';\n  el.innerHTML = '<table style=\"height:100px\"><tr><td><div style=\"height:100%\"></div></td></tr></table>';\n  document.body.appendChild(el);\n  var div = el.querySelector('div');\n  var possible = div.offsetHeight > 0;\n  document.body.removeChild(el);\n  return possible;\n}\n\nvar CalendarRoot =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(CalendarRoot, _super);\n\n  function CalendarRoot() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      forPrint: false\n    };\n\n    _this.handleBeforePrint = function () {\n      _this.setState({\n        forPrint: true\n      });\n    };\n\n    _this.handleAfterPrint = function () {\n      _this.setState({\n        forPrint: false\n      });\n    };\n\n    return _this;\n  }\n\n  CalendarRoot.prototype.render = function () {\n    var props = this.props;\n    var options = props.options;\n    var forPrint = this.state.forPrint;\n    var isHeightAuto = forPrint || options.height === 'auto' || options.contentHeight === 'auto';\n    var height = !isHeightAuto && options.height != null ? options.height : '';\n    var classNames = ['fc', forPrint ? 'fc-media-print' : 'fc-media-screen', 'fc-direction-' + options.direction, props.theme.getClass('root')];\n\n    if (!getCanVGrowWithinCell()) {\n      classNames.push('fc-liquid-hack');\n    }\n\n    return props.children(classNames, height, isHeightAuto, forPrint);\n  };\n\n  CalendarRoot.prototype.componentDidMount = function () {\n    var emitter = this.props.emitter;\n    emitter.on('_beforeprint', this.handleBeforePrint);\n    emitter.on('_afterprint', this.handleAfterPrint);\n  };\n\n  CalendarRoot.prototype.componentWillUnmount = function () {\n    var emitter = this.props.emitter;\n    emitter.off('_beforeprint', this.handleBeforePrint);\n    emitter.off('_afterprint', this.handleAfterPrint);\n  };\n\n  return CalendarRoot;\n}(BaseComponent); // Computes a default column header formatting string if `colFormat` is not explicitly defined\n\n\nfunction computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {\n  // if more than one week row, or if there are a lot of columns with not much space,\n  // put just the day numbers will be in each cell\n  if (!datesRepDistinctDays || dayCnt > 10) {\n    return createFormatter({\n      weekday: 'short'\n    }); // \"Sat\"\n  } else if (dayCnt > 1) {\n    return createFormatter({\n      weekday: 'short',\n      month: 'numeric',\n      day: 'numeric',\n      omitCommas: true\n    }); // \"Sat 11/12\"\n  } else {\n    return createFormatter({\n      weekday: 'long'\n    }); // \"Saturday\"\n  }\n}\n\nvar CLASS_NAME = 'fc-col-header-cell'; // do the cushion too? no\n\nvar TableDateCell =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(TableDateCell, _super);\n\n  function TableDateCell() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableDateCell.prototype.render = function () {\n    var _a = this.context,\n        dateEnv = _a.dateEnv,\n        options = _a.options,\n        theme = _a.theme,\n        viewApi = _a.viewApi;\n    var props = this.props;\n    var date = props.date,\n        dateProfile = props.dateProfile;\n    var dayMeta = getDateMeta(date, props.todayRange, null, dateProfile);\n    var classNames = [CLASS_NAME].concat(getDayClassNames(dayMeta, theme));\n    var text = dateEnv.format(date, props.dayHeaderFormat); // if colCnt is 1, we are already in a day-view and don't need a navlink\n\n    var navLinkAttrs = options.navLinks && !dayMeta.isDisabled && props.colCnt > 1 ? {\n      'data-navlink': buildNavLinkData(date),\n      tabIndex: 0\n    } : {};\n\n    var hookProps = Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({\n      date: dateEnv.toDate(date),\n      view: viewApi\n    }, props.extraHookProps), {\n      text: text\n    }), dayMeta);\n\n    return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.dayHeaderClassNames,\n      content: options.dayHeaderContent,\n      defaultContent: renderInner,\n      didMount: options.dayHeaderDidMount,\n      willUnmount: options.dayHeaderWillUnmount\n    }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n      return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"th\", Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({\n        ref: rootElRef,\n        className: classNames.concat(customClassNames).join(' '),\n        \"data-date\": !dayMeta.isDisabled ? formatDayString(date) : undefined,\n        colSpan: props.colSpan\n      }, props.extraDataAttrs), Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"div\", {\n        className: 'fc-scrollgrid-sync-inner'\n      }, !dayMeta.isDisabled && Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"a\", Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({\n        ref: innerElRef,\n        className: ['fc-col-header-cell-cushion', props.isSticky ? 'fc-sticky' : ''].join(' ')\n      }, navLinkAttrs), innerContent)));\n    });\n  };\n\n  return TableDateCell;\n}(BaseComponent);\n\nvar TableDowCell =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(TableDowCell, _super);\n\n  function TableDowCell() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableDowCell.prototype.render = function () {\n    var props = this.props;\n    var _a = this.context,\n        dateEnv = _a.dateEnv,\n        theme = _a.theme,\n        viewApi = _a.viewApi,\n        options = _a.options;\n    var date = addDays(new Date(259200000), props.dow); // start with Sun, 04 Jan 1970 00:00:00 GMT\n\n    var dateMeta = {\n      dow: props.dow,\n      isDisabled: false,\n      isFuture: false,\n      isPast: false,\n      isToday: false,\n      isOther: false\n    };\n    var classNames = [CLASS_NAME].concat(getDayClassNames(dateMeta, theme), props.extraClassNames || []);\n    var text = dateEnv.format(date, props.dayHeaderFormat);\n\n    var hookProps = Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({\n      // TODO: make this public?\n      date: date\n    }, dateMeta), {\n      view: viewApi\n    }), props.extraHookProps), {\n      text: text\n    });\n\n    return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.dayHeaderClassNames,\n      content: options.dayHeaderContent,\n      defaultContent: renderInner,\n      didMount: options.dayHeaderDidMount,\n      willUnmount: options.dayHeaderWillUnmount\n    }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n      return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"th\", Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({\n        ref: rootElRef,\n        className: classNames.concat(customClassNames).join(' '),\n        colSpan: props.colSpan\n      }, props.extraDataAttrs), Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"div\", {\n        className: 'fc-scrollgrid-sync-inner'\n      }, Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"a\", {\n        className: ['fc-col-header-cell-cushion', props.isSticky ? 'fc-sticky' : ''].join(' '),\n        ref: innerElRef\n      }, innerContent)));\n    });\n  };\n\n  return TableDowCell;\n}(BaseComponent);\n\nfunction renderInner(hookProps) {\n  return hookProps.text;\n}\n\nvar NowTimer =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(NowTimer, _super);\n\n  function NowTimer(props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    _this.initialNowDate = getNow(context.options.now, context.dateEnv);\n    _this.initialNowQueriedMs = new Date().valueOf();\n    _this.state = _this.computeTiming().currentState;\n    return _this;\n  }\n\n  NowTimer.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        state = _a.state;\n\n    return props.children(state.nowDate, state.todayRange);\n  };\n\n  NowTimer.prototype.componentDidMount = function () {\n    this.setTimeout();\n  };\n\n  NowTimer.prototype.componentDidUpdate = function (prevProps) {\n    if (prevProps.unit !== this.props.unit) {\n      this.clearTimeout();\n      this.setTimeout();\n    }\n  };\n\n  NowTimer.prototype.componentWillUnmount = function () {\n    this.clearTimeout();\n  };\n\n  NowTimer.prototype.computeTiming = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var unroundedNow = addMs(this.initialNowDate, new Date().valueOf() - this.initialNowQueriedMs);\n    var currentUnitStart = context.dateEnv.startOf(unroundedNow, props.unit);\n    var nextUnitStart = context.dateEnv.add(currentUnitStart, createDuration(1, props.unit));\n    var waitMs = nextUnitStart.valueOf() - unroundedNow.valueOf();\n    return {\n      currentState: {\n        nowDate: currentUnitStart,\n        todayRange: buildDayRange(currentUnitStart)\n      },\n      nextState: {\n        nowDate: nextUnitStart,\n        todayRange: buildDayRange(nextUnitStart)\n      },\n      waitMs: waitMs\n    };\n  };\n\n  NowTimer.prototype.setTimeout = function () {\n    var _this = this;\n\n    var _a = this.computeTiming(),\n        nextState = _a.nextState,\n        waitMs = _a.waitMs;\n\n    this.timeoutId = setTimeout(function () {\n      _this.setState(nextState, function () {\n        _this.setTimeout();\n      });\n    }, waitMs);\n  };\n\n  NowTimer.prototype.clearTimeout = function () {\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId);\n    }\n  };\n\n  NowTimer.contextType = ViewContextType;\n  return NowTimer;\n}(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"Component\"]);\n\nfunction buildDayRange(date) {\n  var start = startOfDay(date);\n  var end = addDays(start, 1);\n  return {\n    start: start,\n    end: end\n  };\n}\n\nvar DayHeader =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(DayHeader, _super);\n\n  function DayHeader() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.createDayHeaderFormatter = memoize(createDayHeaderFormatter);\n    return _this;\n  }\n\n  DayHeader.prototype.render = function () {\n    var context = this.context;\n    var _a = this.props,\n        dates = _a.dates,\n        dateProfile = _a.dateProfile,\n        datesRepDistinctDays = _a.datesRepDistinctDays,\n        renderIntro = _a.renderIntro;\n    var dayHeaderFormat = this.createDayHeaderFormatter(context.options.dayHeaderFormat, datesRepDistinctDays, dates.length);\n    return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(NowTimer, {\n      unit: 'day'\n    }, function (nowDate, todayRange) {\n      return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"tr\", null, renderIntro && renderIntro(), dates.map(function (date) {\n        return datesRepDistinctDays ? Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(TableDateCell, {\n          key: date.toISOString(),\n          date: date,\n          dateProfile: dateProfile,\n          todayRange: todayRange,\n          colCnt: dates.length,\n          dayHeaderFormat: dayHeaderFormat\n        }) : Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(TableDowCell, {\n          key: date.getUTCDay(),\n          dow: date.getUTCDay(),\n          dayHeaderFormat: dayHeaderFormat\n        });\n      }));\n    });\n  };\n\n  return DayHeader;\n}(BaseComponent);\n\nfunction createDayHeaderFormatter(explicitFormat, datesRepDistinctDays, dateCnt) {\n  return explicitFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dateCnt);\n}\n\nvar DaySeriesModel =\n/** @class */\nfunction () {\n  function DaySeriesModel(range, dateProfileGenerator) {\n    var date = range.start;\n    var end = range.end;\n    var indices = [];\n    var dates = [];\n    var dayIndex = -1;\n\n    while (date < end) {\n      // loop each day from start to end\n      if (dateProfileGenerator.isHiddenDay(date)) {\n        indices.push(dayIndex + 0.5); // mark that it's between indices\n      } else {\n        dayIndex++;\n        indices.push(dayIndex);\n        dates.push(date);\n      }\n\n      date = addDays(date, 1);\n    }\n\n    this.dates = dates;\n    this.indices = indices;\n    this.cnt = dates.length;\n  }\n\n  DaySeriesModel.prototype.sliceRange = function (range) {\n    var firstIndex = this.getDateDayIndex(range.start); // inclusive first index\n\n    var lastIndex = this.getDateDayIndex(addDays(range.end, -1)); // inclusive last index\n\n    var clippedFirstIndex = Math.max(0, firstIndex);\n    var clippedLastIndex = Math.min(this.cnt - 1, lastIndex); // deal with in-between indices\n\n    clippedFirstIndex = Math.ceil(clippedFirstIndex); // in-between starts round to next cell\n\n    clippedLastIndex = Math.floor(clippedLastIndex); // in-between ends round to prev cell\n\n    if (clippedFirstIndex <= clippedLastIndex) {\n      return {\n        firstIndex: clippedFirstIndex,\n        lastIndex: clippedLastIndex,\n        isStart: firstIndex === clippedFirstIndex,\n        isEnd: lastIndex === clippedLastIndex\n      };\n    } else {\n      return null;\n    }\n  }; // Given a date, returns its chronolocial cell-index from the first cell of the grid.\n  // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.\n  // If before the first offset, returns a negative number.\n  // If after the last offset, returns an offset past the last cell offset.\n  // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.\n\n\n  DaySeriesModel.prototype.getDateDayIndex = function (date) {\n    var indices = this.indices;\n    var dayOffset = Math.floor(diffDays(this.dates[0], date));\n\n    if (dayOffset < 0) {\n      return indices[0] - 1;\n    } else if (dayOffset >= indices.length) {\n      return indices[indices.length - 1] + 1;\n    } else {\n      return indices[dayOffset];\n    }\n  };\n\n  return DaySeriesModel;\n}();\n\nvar DayTableModel =\n/** @class */\nfunction () {\n  function DayTableModel(daySeries, breakOnWeeks) {\n    var dates = daySeries.dates;\n    var daysPerRow;\n    var firstDay;\n    var rowCnt;\n\n    if (breakOnWeeks) {\n      // count columns until the day-of-week repeats\n      firstDay = dates[0].getUTCDay();\n\n      for (daysPerRow = 1; daysPerRow < dates.length; daysPerRow++) {\n        if (dates[daysPerRow].getUTCDay() === firstDay) {\n          break;\n        }\n      }\n\n      rowCnt = Math.ceil(dates.length / daysPerRow);\n    } else {\n      rowCnt = 1;\n      daysPerRow = dates.length;\n    }\n\n    this.rowCnt = rowCnt;\n    this.colCnt = daysPerRow;\n    this.daySeries = daySeries;\n    this.cells = this.buildCells();\n    this.headerDates = this.buildHeaderDates();\n  }\n\n  DayTableModel.prototype.buildCells = function () {\n    var rows = [];\n\n    for (var row = 0; row < this.rowCnt; row++) {\n      var cells = [];\n\n      for (var col = 0; col < this.colCnt; col++) {\n        cells.push(this.buildCell(row, col));\n      }\n\n      rows.push(cells);\n    }\n\n    return rows;\n  };\n\n  DayTableModel.prototype.buildCell = function (row, col) {\n    var date = this.daySeries.dates[row * this.colCnt + col];\n    return {\n      key: date.toISOString(),\n      date: date\n    };\n  };\n\n  DayTableModel.prototype.buildHeaderDates = function () {\n    var dates = [];\n\n    for (var col = 0; col < this.colCnt; col++) {\n      dates.push(this.cells[0][col].date);\n    }\n\n    return dates;\n  };\n\n  DayTableModel.prototype.sliceRange = function (range) {\n    var colCnt = this.colCnt;\n    var seriesSeg = this.daySeries.sliceRange(range);\n    var segs = [];\n\n    if (seriesSeg) {\n      var firstIndex = seriesSeg.firstIndex,\n          lastIndex = seriesSeg.lastIndex;\n      var index = firstIndex;\n\n      while (index <= lastIndex) {\n        var row = Math.floor(index / colCnt);\n        var nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);\n        segs.push({\n          row: row,\n          firstCol: index % colCnt,\n          lastCol: (nextIndex - 1) % colCnt,\n          isStart: seriesSeg.isStart && index === firstIndex,\n          isEnd: seriesSeg.isEnd && nextIndex - 1 === lastIndex\n        });\n        index = nextIndex;\n      }\n    }\n\n    return segs;\n  };\n\n  return DayTableModel;\n}();\n\nvar Slicer =\n/** @class */\nfunction () {\n  function Slicer() {\n    this.sliceBusinessHours = memoize(this._sliceBusinessHours);\n    this.sliceDateSelection = memoize(this._sliceDateSpan);\n    this.sliceEventStore = memoize(this._sliceEventStore);\n    this.sliceEventDrag = memoize(this._sliceInteraction);\n    this.sliceEventResize = memoize(this._sliceInteraction);\n    this.forceDayIfListItem = false; // hack\n  }\n\n  Slicer.prototype.sliceProps = function (props, dateProfile, nextDayThreshold, context) {\n    var extraArgs = [];\n\n    for (var _i = 4; _i < arguments.length; _i++) {\n      extraArgs[_i - 4] = arguments[_i];\n    }\n\n    var eventUiBases = props.eventUiBases;\n    var eventSegs = this.sliceEventStore.apply(this, Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__spreadArrays\"])([props.eventStore, eventUiBases, dateProfile, nextDayThreshold], extraArgs));\n    return {\n      dateSelectionSegs: this.sliceDateSelection.apply(this, Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__spreadArrays\"])([props.dateSelection, eventUiBases, context], extraArgs)),\n      businessHourSegs: this.sliceBusinessHours.apply(this, Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__spreadArrays\"])([props.businessHours, dateProfile, nextDayThreshold, context], extraArgs)),\n      fgEventSegs: eventSegs.fg,\n      bgEventSegs: eventSegs.bg,\n      eventDrag: this.sliceEventDrag.apply(this, Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__spreadArrays\"])([props.eventDrag, eventUiBases, dateProfile, nextDayThreshold], extraArgs)),\n      eventResize: this.sliceEventResize.apply(this, Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__spreadArrays\"])([props.eventResize, eventUiBases, dateProfile, nextDayThreshold], extraArgs)),\n      eventSelection: props.eventSelection\n    }; // TODO: give interactionSegs?\n  };\n\n  Slicer.prototype.sliceNowDate = function ( // does not memoize\n  date, context) {\n    var extraArgs = [];\n\n    for (var _i = 2; _i < arguments.length; _i++) {\n      extraArgs[_i - 2] = arguments[_i];\n    }\n\n    return this._sliceDateSpan.apply(this, Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__spreadArrays\"])([{\n      range: {\n        start: date,\n        end: addMs(date, 1)\n      },\n      allDay: false\n    }, {}, context], extraArgs));\n  };\n\n  Slicer.prototype._sliceBusinessHours = function (businessHours, dateProfile, nextDayThreshold, context) {\n    var extraArgs = [];\n\n    for (var _i = 4; _i < arguments.length; _i++) {\n      extraArgs[_i - 4] = arguments[_i];\n    }\n\n    if (!businessHours) {\n      return [];\n    }\n\n    return this._sliceEventStore.apply(this, Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__spreadArrays\"])([expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), context), {}, dateProfile, nextDayThreshold], extraArgs)).bg;\n  };\n\n  Slicer.prototype._sliceEventStore = function (eventStore, eventUiBases, dateProfile, nextDayThreshold) {\n    var extraArgs = [];\n\n    for (var _i = 4; _i < arguments.length; _i++) {\n      extraArgs[_i - 4] = arguments[_i];\n    }\n\n    if (eventStore) {\n      var rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n      return {\n        bg: this.sliceEventRanges(rangeRes.bg, extraArgs),\n        fg: this.sliceEventRanges(rangeRes.fg, extraArgs)\n      };\n    } else {\n      return {\n        bg: [],\n        fg: []\n      };\n    }\n  };\n\n  Slicer.prototype._sliceInteraction = function (interaction, eventUiBases, dateProfile, nextDayThreshold) {\n    var extraArgs = [];\n\n    for (var _i = 4; _i < arguments.length; _i++) {\n      extraArgs[_i - 4] = arguments[_i];\n    }\n\n    if (!interaction) {\n      return null;\n    }\n\n    var rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n    return {\n      segs: this.sliceEventRanges(rangeRes.fg, extraArgs),\n      affectedInstances: interaction.affectedEvents.instances,\n      isEvent: interaction.isEvent\n    };\n  };\n\n  Slicer.prototype._sliceDateSpan = function (dateSpan, eventUiBases, context) {\n    var extraArgs = [];\n\n    for (var _i = 3; _i < arguments.length; _i++) {\n      extraArgs[_i - 3] = arguments[_i];\n    }\n\n    if (!dateSpan) {\n      return [];\n    }\n\n    var eventRange = fabricateEventRange(dateSpan, eventUiBases, context);\n    var segs = this.sliceRange.apply(this, Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__spreadArrays\"])([dateSpan.range], extraArgs));\n\n    for (var _a = 0, segs_1 = segs; _a < segs_1.length; _a++) {\n      var seg = segs_1[_a];\n      seg.eventRange = eventRange;\n    }\n\n    return segs;\n  };\n  /*\n  \"complete\" seg means it has component and eventRange\n  */\n\n\n  Slicer.prototype.sliceEventRanges = function (eventRanges, extraArgs) {\n    var segs = [];\n\n    for (var _i = 0, eventRanges_1 = eventRanges; _i < eventRanges_1.length; _i++) {\n      var eventRange = eventRanges_1[_i];\n      segs.push.apply(segs, this.sliceEventRange(eventRange, extraArgs));\n    }\n\n    return segs;\n  };\n  /*\n  \"complete\" seg means it has component and eventRange\n  */\n\n\n  Slicer.prototype.sliceEventRange = function (eventRange, extraArgs) {\n    var dateRange = eventRange.range; // hack to make multi-day events that are being force-displayed as list-items to take up only one day\n\n    if (this.forceDayIfListItem && eventRange.ui.display === 'list-item') {\n      dateRange = {\n        start: dateRange.start,\n        end: addDays(dateRange.start, 1)\n      };\n    }\n\n    var segs = this.sliceRange.apply(this, Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__spreadArrays\"])([dateRange], extraArgs));\n\n    for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n      var seg = segs_2[_i];\n      seg.eventRange = eventRange;\n      seg.isStart = eventRange.isStart && seg.isStart;\n      seg.isEnd = eventRange.isEnd && seg.isEnd;\n    }\n\n    return segs;\n  };\n\n  return Slicer;\n}();\n/*\nfor incorporating slotMinTime/slotMaxTime if appropriate\nTODO: should be part of DateProfile!\nTimelineDateProfile already does this btw\n*/\n\n\nfunction computeActiveRange(dateProfile, isComponentAllDay) {\n  var range = dateProfile.activeRange;\n\n  if (isComponentAllDay) {\n    return range;\n  }\n\n  return {\n    start: addMs(range.start, dateProfile.slotMinTime.milliseconds),\n    end: addMs(range.end, dateProfile.slotMaxTime.milliseconds - 864e5) // 864e5 = ms in a day\n\n  };\n}\n\nvar VISIBLE_HIDDEN_RE = /^(visible|hidden)$/;\n\nvar Scroller =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(Scroller, _super);\n\n  function Scroller() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.handleEl = function (el) {\n      _this.el = el;\n      setRef(_this.props.elRef, el);\n    };\n\n    return _this;\n  }\n\n  Scroller.prototype.render = function () {\n    var props = this.props;\n    var liquid = props.liquid,\n        liquidIsAbsolute = props.liquidIsAbsolute;\n    var isAbsolute = liquid && liquidIsAbsolute;\n    var className = ['fc-scroller'];\n\n    if (liquid) {\n      if (liquidIsAbsolute) {\n        className.push('fc-scroller-liquid-absolute');\n      } else {\n        className.push('fc-scroller-liquid');\n      }\n    }\n\n    return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"div\", {\n      ref: this.handleEl,\n      className: className.join(' '),\n      style: {\n        overflowX: props.overflowX,\n        overflowY: props.overflowY,\n        left: isAbsolute && -(props.overcomeLeft || 0) || '',\n        right: isAbsolute && -(props.overcomeRight || 0) || '',\n        bottom: isAbsolute && -(props.overcomeBottom || 0) || '',\n        marginLeft: !isAbsolute && -(props.overcomeLeft || 0) || '',\n        marginRight: !isAbsolute && -(props.overcomeRight || 0) || '',\n        marginBottom: !isAbsolute && -(props.overcomeBottom || 0) || '',\n        maxHeight: props.maxHeight || ''\n      }\n    }, props.children);\n  };\n\n  Scroller.prototype.needsXScrolling = function () {\n    if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n      return false;\n    } // testing scrollWidth>clientWidth is unreliable cross-browser when pixel heights aren't integers.\n    // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n    // inner-child margins and absolute positioning\n\n\n    var el = this.el;\n    var realClientWidth = this.el.getBoundingClientRect().width - this.getYScrollbarWidth();\n    var children = el.children;\n\n    for (var i = 0; i < children.length; i++) {\n      var childEl = children[i];\n\n      if (childEl.getBoundingClientRect().width > realClientWidth) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  Scroller.prototype.needsYScrolling = function () {\n    if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n      return false;\n    } // testing scrollHeight>clientHeight is unreliable cross-browser when pixel heights aren't integers.\n    // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n    // inner-child margins and absolute positioning\n\n\n    var el = this.el;\n    var realClientHeight = this.el.getBoundingClientRect().height - this.getXScrollbarWidth();\n    var children = el.children;\n\n    for (var i = 0; i < children.length; i++) {\n      var childEl = children[i];\n\n      if (childEl.getBoundingClientRect().height > realClientHeight) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  Scroller.prototype.getXScrollbarWidth = function () {\n    if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n      return 0;\n    } else {\n      return this.el.offsetHeight - this.el.clientHeight; // only works because we guarantee no borders. TODO: add to CSS with important?\n    }\n  };\n\n  Scroller.prototype.getYScrollbarWidth = function () {\n    if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n      return 0;\n    } else {\n      return this.el.offsetWidth - this.el.clientWidth; // only works because we guarantee no borders. TODO: add to CSS with important?\n    }\n  };\n\n  return Scroller;\n}(BaseComponent);\n/*\nTODO: somehow infer OtherArgs from masterCallback?\nTODO: infer RefType from masterCallback if provided\n*/\n\n\nvar RefMap =\n/** @class */\nfunction () {\n  function RefMap(masterCallback) {\n    var _this = this;\n\n    this.masterCallback = masterCallback;\n    this.currentMap = {};\n    this.depths = {};\n    this.callbackMap = {};\n\n    this.handleValue = function (val, key) {\n      var _a = _this,\n          depths = _a.depths,\n          currentMap = _a.currentMap;\n      var removed = false;\n      var added = false;\n\n      if (val !== null) {\n        removed = key in currentMap; // for bug... ACTUALLY: can probably do away with this now that callers don't share numeric indices anymore\n\n        currentMap[key] = val;\n        depths[key] = (depths[key] || 0) + 1;\n        added = true;\n      } else if (--depths[key] === 0) {\n        delete currentMap[key];\n        delete _this.callbackMap[key];\n        removed = true;\n      }\n\n      if (_this.masterCallback) {\n        if (removed) {\n          _this.masterCallback(null, String(key));\n        }\n\n        if (added) {\n          _this.masterCallback(val, String(key));\n        }\n      }\n    };\n  }\n\n  RefMap.prototype.createRef = function (key) {\n    var _this = this;\n\n    var refCallback = this.callbackMap[key];\n\n    if (!refCallback) {\n      refCallback = this.callbackMap[key] = function (val) {\n        _this.handleValue(val, String(key));\n      };\n    }\n\n    return refCallback;\n  }; // TODO: check callers that don't care about order. should use getAll instead\n  // NOTE: this method has become less valuable now that we are encouraged to map order by some other index\n  // TODO: provide ONE array-export function, buildArray, which fails on non-numeric indexes. caller can manipulate and \"collect\"\n\n\n  RefMap.prototype.collect = function (startIndex, endIndex, step) {\n    return collectFromHash(this.currentMap, startIndex, endIndex, step);\n  };\n\n  RefMap.prototype.getAll = function () {\n    return hashValuesToArray(this.currentMap);\n  };\n\n  return RefMap;\n}();\n\nfunction computeShrinkWidth(chunkEls) {\n  var shrinkCells = findElements(chunkEls, '.fc-scrollgrid-shrink');\n  var largestWidth = 0;\n\n  for (var _i = 0, shrinkCells_1 = shrinkCells; _i < shrinkCells_1.length; _i++) {\n    var shrinkCell = shrinkCells_1[_i];\n    largestWidth = Math.max(largestWidth, computeSmallestCellWidth(shrinkCell));\n  }\n\n  return Math.ceil(largestWidth); // <table> elements work best with integers. round up to ensure contents fits\n}\n\nfunction getSectionHasLiquidHeight(props, sectionConfig) {\n  return props.liquid && sectionConfig.liquid; // does the section do liquid-height? (need to have whole scrollgrid liquid-height as well)\n}\n\nfunction getAllowYScrolling(props, sectionConfig) {\n  return sectionConfig.maxHeight != null || // if its possible for the height to max out, we might need scrollbars\n  getSectionHasLiquidHeight(props, sectionConfig); // if the section is liquid height, it might condense enough to require scrollbars\n} // TODO: ONLY use `arg`. force out internal function to use same API\n\n\nfunction renderChunkContent(sectionConfig, chunkConfig, arg) {\n  var expandRows = arg.expandRows;\n  var content = typeof chunkConfig.content === 'function' ? chunkConfig.content(arg) : Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])('table', {\n    className: [chunkConfig.tableClassName, sectionConfig.syncRowHeights ? 'fc-scrollgrid-sync-table' : ''].join(' '),\n    style: {\n      minWidth: arg.tableMinWidth,\n      width: arg.clientWidth,\n      height: expandRows ? arg.clientHeight : '' // css `height` on a <table> serves as a min-height\n\n    }\n  }, arg.tableColGroupNode, Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])('tbody', {}, typeof chunkConfig.rowContent === 'function' ? chunkConfig.rowContent(arg) : chunkConfig.rowContent));\n  return content;\n}\n\nfunction isColPropsEqual(cols0, cols1) {\n  return isArraysEqual(cols0, cols1, isPropsEqual);\n}\n\nfunction renderMicroColGroup(cols, shrinkWidth) {\n  var colNodes = [];\n  /*\n  for ColProps with spans, it would have been great to make a single <col span=\"\">\n  HOWEVER, Chrome was getting messing up distributing the width to <td>/<th> elements with colspans.\n  SOLUTION: making individual <col> elements makes Chrome behave.\n  */\n\n  for (var _i = 0, cols_1 = cols; _i < cols_1.length; _i++) {\n    var colProps = cols_1[_i];\n    var span = colProps.span || 1;\n\n    for (var i = 0; i < span; i++) {\n      colNodes.push(Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"col\", {\n        style: {\n          width: colProps.width === 'shrink' ? sanitizeShrinkWidth(shrinkWidth) : colProps.width || '',\n          minWidth: colProps.minWidth || ''\n        }\n      }));\n    }\n  }\n\n  return _vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"].apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__spreadArrays\"])(['colgroup', {}], colNodes));\n}\n\nfunction sanitizeShrinkWidth(shrinkWidth) {\n  /* why 4? if we do 0, it will kill any border, which are needed for computeSmallestCellWidth\n  4 accounts for 2 2-pixel borders. TODO: better solution? */\n  return shrinkWidth == null ? 4 : shrinkWidth;\n}\n\nfunction hasShrinkWidth(cols) {\n  for (var _i = 0, cols_2 = cols; _i < cols_2.length; _i++) {\n    var col = cols_2[_i];\n\n    if (col.width === 'shrink') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getScrollGridClassNames(liquid, context) {\n  var classNames = ['fc-scrollgrid', context.theme.getClass('table')];\n\n  if (liquid) {\n    classNames.push('fc-scrollgrid-liquid');\n  }\n\n  return classNames;\n}\n\nfunction getSectionClassNames(sectionConfig, wholeTableVGrow) {\n  var classNames = ['fc-scrollgrid-section', sectionConfig.className // used?\n  ];\n\n  if (wholeTableVGrow && sectionConfig.liquid && sectionConfig.maxHeight == null) {\n    classNames.push('fc-scrollgrid-section-liquid');\n  }\n\n  if (sectionConfig.isSticky) {\n    classNames.push('fc-scrollgrid-section-sticky');\n  }\n\n  return classNames;\n}\n\nfunction renderScrollShim(arg) {\n  return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"div\", {\n    className: 'fc-scrollgrid-sticky-shim',\n    style: {\n      width: arg.clientWidth,\n      minWidth: arg.tableMinWidth\n    }\n  });\n}\n\nfunction getStickyHeaderDates(options) {\n  var stickyHeaderDates = options.stickyHeaderDates;\n\n  if (stickyHeaderDates == null || stickyHeaderDates === 'auto') {\n    stickyHeaderDates = options.height === 'auto' || options.viewHeight === 'auto';\n  }\n\n  return stickyHeaderDates;\n}\n\nfunction getStickyFooterScrollbar(options) {\n  var stickyFooterScrollbar = options.stickyFooterScrollbar;\n\n  if (stickyFooterScrollbar == null || stickyFooterScrollbar === 'auto') {\n    stickyFooterScrollbar = options.height === 'auto' || options.viewHeight === 'auto';\n  }\n\n  return stickyFooterScrollbar;\n}\n\nvar SimpleScrollGrid =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(SimpleScrollGrid, _super);\n\n  function SimpleScrollGrid() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.processCols = memoize(function (a) {\n      return a;\n    }, isColPropsEqual); // so we get same `cols` props every time\n\n    _this.renderMicroColGroup = memoize(renderMicroColGroup); // yucky to memoize VNodes, but much more efficient for consumers\n\n    _this.scrollerRefs = new RefMap();\n    _this.scrollerElRefs = new RefMap(_this._handleScrollerEl.bind(_this));\n    _this.state = {\n      shrinkWidth: null,\n      forceYScrollbars: false,\n      scrollerClientWidths: {},\n      scrollerClientHeights: {}\n    }; // TODO: can do a really simple print-view. dont need to join rows\n\n    _this.handleSizing = function () {\n      _this.setState(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({\n        shrinkWidth: _this.computeShrinkWidth()\n      }, _this.computeScrollerDims()));\n    };\n\n    return _this;\n  }\n\n  SimpleScrollGrid.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        state = _a.state,\n        context = _a.context;\n\n    var sectionConfigs = props.sections || [];\n    var cols = this.processCols(props.cols);\n    var microColGroupNode = this.renderMicroColGroup(cols, state.shrinkWidth);\n    var classNames = getScrollGridClassNames(props.liquid, context); // TODO: make DRY\n\n    var configCnt = sectionConfigs.length;\n    var configI = 0;\n    var currentConfig;\n    var headSectionNodes = [];\n    var bodySectionNodes = [];\n    var footSectionNodes = [];\n\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'header') {\n      headSectionNodes.push(this.renderSection(currentConfig, configI, microColGroupNode));\n      configI++;\n    }\n\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'body') {\n      bodySectionNodes.push(this.renderSection(currentConfig, configI, microColGroupNode));\n      configI++;\n    }\n\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'footer') {\n      footSectionNodes.push(this.renderSection(currentConfig, configI, microColGroupNode));\n      configI++;\n    }\n\n    return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"table\", {\n      className: classNames.join(' '),\n      style: {\n        height: props.height\n      }\n    }, Boolean(headSectionNodes.length) && _vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"].apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__spreadArrays\"])(['thead', {}], headSectionNodes)), Boolean(bodySectionNodes.length) && _vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"].apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__spreadArrays\"])(['tbody', {}], bodySectionNodes)), Boolean(footSectionNodes.length) && _vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"].apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__spreadArrays\"])(['tfoot', {}], footSectionNodes)));\n  };\n\n  SimpleScrollGrid.prototype.renderSection = function (sectionConfig, sectionI, microColGroupNode) {\n    if ('outerContent' in sectionConfig) {\n      return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"Fragment\"], {\n        key: sectionConfig.key\n      }, sectionConfig.outerContent);\n    }\n\n    return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"tr\", {\n      key: sectionConfig.key,\n      className: getSectionClassNames(sectionConfig, this.props.liquid).join(' ')\n    }, this.renderChunkTd(sectionConfig, sectionI, microColGroupNode, sectionConfig.chunk));\n  };\n\n  SimpleScrollGrid.prototype.renderChunkTd = function (sectionConfig, sectionI, microColGroupNode, chunkConfig) {\n    if ('outerContent' in chunkConfig) {\n      return chunkConfig.outerContent;\n    }\n\n    var props = this.props;\n    var _a = this.state,\n        forceYScrollbars = _a.forceYScrollbars,\n        scrollerClientWidths = _a.scrollerClientWidths,\n        scrollerClientHeights = _a.scrollerClientHeights;\n    var needsYScrolling = getAllowYScrolling(props, sectionConfig); // TODO: do lazily. do in section config?\n\n    var isLiquid = getSectionHasLiquidHeight(props, sectionConfig); // for `!props.liquid` - is WHOLE scrollgrid natural height?\n    // TODO: do same thing in advanced scrollgrid? prolly not b/c always has horizontal scrollbars\n\n    var overflowY = !props.liquid ? 'visible' : forceYScrollbars ? 'scroll' : !needsYScrolling ? 'hidden' : 'auto';\n    var content = renderChunkContent(sectionConfig, chunkConfig, {\n      tableColGroupNode: microColGroupNode,\n      tableMinWidth: '',\n      clientWidth: scrollerClientWidths[sectionI] !== undefined ? scrollerClientWidths[sectionI] : null,\n      clientHeight: scrollerClientHeights[sectionI] !== undefined ? scrollerClientHeights[sectionI] : null,\n      expandRows: sectionConfig.expandRows,\n      syncRowHeights: false,\n      rowSyncHeights: [],\n      reportRowHeightChange: function reportRowHeightChange() {}\n    });\n    return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"td\", {\n      ref: chunkConfig.elRef\n    }, Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"div\", {\n      className: 'fc-scroller-harness' + (isLiquid ? ' fc-scroller-harness-liquid' : '')\n    }, Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(Scroller, {\n      ref: this.scrollerRefs.createRef(sectionI),\n      elRef: this.scrollerElRefs.createRef(sectionI),\n      overflowY: overflowY,\n      overflowX: !props.liquid ? 'visible' : 'hidden'\n      /* natural height? */\n      ,\n      maxHeight: sectionConfig.maxHeight,\n      liquid: isLiquid,\n      liquidIsAbsolute: true\n      /* because its within a harness */\n\n    }, content)));\n  };\n\n  SimpleScrollGrid.prototype._handleScrollerEl = function (scrollerEl, key) {\n    var sectionI = parseInt(key, 10);\n    var chunkConfig = this.props.sections[sectionI].chunk;\n    setRef(chunkConfig.scrollerElRef, scrollerEl);\n  };\n\n  SimpleScrollGrid.prototype.componentDidMount = function () {\n    this.handleSizing();\n    this.context.addResizeHandler(this.handleSizing);\n  };\n\n  SimpleScrollGrid.prototype.componentDidUpdate = function () {\n    // TODO: need better solution when state contains non-sizing things\n    this.handleSizing();\n  };\n\n  SimpleScrollGrid.prototype.componentWillUnmount = function () {\n    this.context.removeResizeHandler(this.handleSizing);\n  };\n\n  SimpleScrollGrid.prototype.computeShrinkWidth = function () {\n    return hasShrinkWidth(this.props.cols) ? computeShrinkWidth(this.scrollerElRefs.getAll()) : 0;\n  };\n\n  SimpleScrollGrid.prototype.computeScrollerDims = function () {\n    var scrollbarWidth = getScrollbarWidths();\n    var sectionCnt = this.props.sections.length;\n\n    var _a = this,\n        scrollerRefs = _a.scrollerRefs,\n        scrollerElRefs = _a.scrollerElRefs;\n\n    var forceYScrollbars = false;\n    var scrollerClientWidths = {};\n    var scrollerClientHeights = {};\n\n    for (var sectionI = 0; sectionI < sectionCnt; sectionI++) {\n      // along edge\n      var scroller = scrollerRefs.currentMap[sectionI];\n\n      if (scroller && scroller.needsYScrolling()) {\n        forceYScrollbars = true;\n        break;\n      }\n    }\n\n    for (var sectionI = 0; sectionI < sectionCnt; sectionI++) {\n      // along edge\n      var scrollerEl = scrollerElRefs.currentMap[sectionI];\n\n      if (scrollerEl) {\n        var harnessEl = scrollerEl.parentNode; // TODO: weird way to get this. need harness b/c doesn't include table borders\n\n        scrollerClientWidths[sectionI] = Math.floor(harnessEl.getBoundingClientRect().width - (forceYScrollbars ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future\n        : 0));\n        scrollerClientHeights[sectionI] = Math.floor(harnessEl.getBoundingClientRect().height // never has horizontal scrollbars\n        );\n      }\n    }\n\n    return {\n      forceYScrollbars: forceYScrollbars,\n      scrollerClientWidths: scrollerClientWidths,\n      scrollerClientHeights: scrollerClientHeights\n    };\n  };\n\n  return SimpleScrollGrid;\n}(BaseComponent);\n\nSimpleScrollGrid.addStateEquality({\n  scrollerClientWidths: isPropsEqual,\n  scrollerClientHeights: isPropsEqual\n});\n\nvar EventRoot =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(EventRoot, _super);\n\n  function EventRoot() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.elRef = Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createRef\"])();\n    return _this;\n  }\n\n  EventRoot.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var options = context.options;\n    var seg = props.seg;\n    var eventRange = seg.eventRange;\n    var ui = eventRange.ui;\n    var hookProps = {\n      event: new EventApi(context, eventRange.def, eventRange.instance),\n      view: context.viewApi,\n      timeText: props.timeText,\n      textColor: ui.textColor,\n      backgroundColor: ui.backgroundColor,\n      borderColor: ui.borderColor,\n      isDraggable: !props.disableDragging && computeSegDraggable(seg, context),\n      isStartResizable: !props.disableResizing && computeSegStartResizable(seg, context),\n      isEndResizable: !props.disableResizing && computeSegEndResizable(seg),\n      isMirror: Boolean(props.isDragging || props.isResizing || props.isDateSelecting),\n      isStart: Boolean(seg.isStart),\n      isEnd: Boolean(seg.isEnd),\n      isPast: Boolean(props.isPast),\n      isFuture: Boolean(props.isFuture),\n      isToday: Boolean(props.isToday),\n      isSelected: Boolean(props.isSelected),\n      isDragging: Boolean(props.isDragging),\n      isResizing: Boolean(props.isResizing)\n    };\n    var standardClassNames = getEventClassNames(hookProps).concat(ui.classNames);\n    return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.eventClassNames,\n      content: options.eventContent,\n      defaultContent: props.defaultContent,\n      didMount: options.eventDidMount,\n      willUnmount: options.eventWillUnmount,\n      elRef: this.elRef\n    }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n      return props.children(rootElRef, standardClassNames.concat(customClassNames), innerElRef, innerContent, hookProps);\n    });\n  };\n\n  EventRoot.prototype.componentDidMount = function () {\n    setElSeg(this.elRef.current, this.props.seg);\n  };\n  /*\n  need to re-assign seg to the element if seg changes, even if the element is the same\n  */\n\n\n  EventRoot.prototype.componentDidUpdate = function (prevProps) {\n    var seg = this.props.seg;\n\n    if (seg !== prevProps.seg) {\n      setElSeg(this.elRef.current, seg);\n    }\n  };\n\n  return EventRoot;\n}(BaseComponent); // should not be a purecomponent\n\n\nvar StandardEvent =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(StandardEvent, _super);\n\n  function StandardEvent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  StandardEvent.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var seg = props.seg;\n    var timeFormat = context.options.eventTimeFormat || props.defaultTimeFormat;\n    var timeText = buildSegTimeText(seg, timeFormat, context, props.defaultDisplayEventTime, props.defaultDisplayEventEnd);\n    return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(EventRoot, {\n      seg: seg,\n      timeText: timeText,\n      disableDragging: props.disableDragging,\n      disableResizing: props.disableResizing,\n      defaultContent: props.defaultContent || renderInnerContent,\n      isDragging: props.isDragging,\n      isResizing: props.isResizing,\n      isDateSelecting: props.isDateSelecting,\n      isSelected: props.isSelected,\n      isPast: props.isPast,\n      isFuture: props.isFuture,\n      isToday: props.isToday\n    }, function (rootElRef, classNames, innerElRef, innerContent, hookProps) {\n      return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"a\", Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({\n        className: props.extraClassNames.concat(classNames).join(' '),\n        style: {\n          borderColor: hookProps.borderColor,\n          backgroundColor: hookProps.backgroundColor\n        },\n        ref: rootElRef\n      }, getSegAnchorAttrs(seg)), Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"div\", {\n        className: 'fc-event-main',\n        ref: innerElRef,\n        style: {\n          color: hookProps.textColor\n        }\n      }, innerContent), hookProps.isStartResizable && Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"div\", {\n        className: 'fc-event-resizer fc-event-resizer-start'\n      }), hookProps.isEndResizable && Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"div\", {\n        className: 'fc-event-resizer fc-event-resizer-end'\n      }));\n    });\n  };\n\n  return StandardEvent;\n}(BaseComponent);\n\nfunction renderInnerContent(innerProps) {\n  return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"Fragment\"], null, innerProps.timeText && Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"div\", {\n    className: 'fc-event-time'\n  }, innerProps.timeText), Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"div\", {\n    className: 'fc-event-title-frame'\n  }, Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"div\", {\n    className: 'fc-event-title fc-sticky'\n  }, innerProps.event.title || Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"Fragment\"], null, \"\\xA0\"))));\n}\n\nfunction getSegAnchorAttrs(seg) {\n  var url = seg.eventRange.def.url;\n  return url ? {\n    href: url\n  } : {};\n}\n\nvar NowIndicatorRoot = function NowIndicatorRoot(props) {\n  return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(ViewContextType.Consumer, null, function (context) {\n    var options = context.options;\n    var hookProps = {\n      isAxis: props.isAxis,\n      date: context.dateEnv.toDate(props.date),\n      view: context.viewApi\n    };\n    return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.nowIndicatorClassNames,\n      content: options.nowIndicatorContent,\n      didMount: options.nowIndicatorDidMount,\n      willUnmount: options.nowIndicatorWillUnmount\n    }, props.children);\n  });\n};\n\nvar DAY_NUM_FORMAT = createFormatter({\n  day: 'numeric'\n});\n\nvar DayCellRoot =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(DayCellRoot, _super);\n\n  function DayCellRoot() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.refineHookProps = memoizeObjArg(refineHookProps);\n    _this.normalizeClassNames = buildClassNameNormalizer();\n    return _this;\n  }\n\n  DayCellRoot.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var options = context.options;\n    var hookProps = this.refineHookProps({\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      showDayNumber: props.showDayNumber,\n      extraProps: props.extraHookProps,\n      viewApi: context.viewApi,\n      dateEnv: context.dateEnv\n    });\n    var classNames = getDayClassNames(hookProps, context.theme).concat(hookProps.isDisabled ? [] // don't use custom classNames if disabled\n    : this.normalizeClassNames(options.dayCellClassNames, hookProps));\n    var dataAttrs = hookProps.isDisabled ? {} : {\n      'data-date': formatDayString(props.date)\n    };\n    return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(MountHook, {\n      hookProps: hookProps,\n      didMount: options.dayCellDidMount,\n      willUnmount: options.dayCellWillUnmount,\n      elRef: props.elRef\n    }, function (rootElRef) {\n      return props.children(rootElRef, classNames, dataAttrs, hookProps.isDisabled);\n    });\n  };\n\n  return DayCellRoot;\n}(BaseComponent);\n\nvar DayCellContent =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(DayCellContent, _super);\n\n  function DayCellContent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DayCellContent.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var options = context.options;\n    var hookProps = refineHookProps({\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      showDayNumber: props.showDayNumber,\n      extraProps: props.extraHookProps,\n      viewApi: context.viewApi,\n      dateEnv: context.dateEnv\n    });\n    return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(ContentHook, {\n      hookProps: hookProps,\n      content: options.dayCellContent,\n      defaultContent: props.defaultContent\n    }, props.children);\n  };\n\n  return DayCellContent;\n}(BaseComponent);\n\nfunction refineHookProps(raw) {\n  var date = raw.date,\n      dateEnv = raw.dateEnv;\n  var dayMeta = getDateMeta(date, raw.todayRange, null, raw.dateProfile);\n  return Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({\n    date: dateEnv.toDate(date),\n    view: raw.viewApi\n  }, dayMeta), {\n    dayNumberText: raw.showDayNumber ? dateEnv.format(date, DAY_NUM_FORMAT) : ''\n  }), raw.extraProps);\n}\n\nfunction renderFill(fillType) {\n  return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"div\", {\n    className: \"fc-\" + fillType\n  });\n}\n\nvar BgEvent = function BgEvent(props) {\n  return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(EventRoot, {\n    defaultContent: renderInnerContent$1,\n    seg: props.seg\n    /* uselesss i think */\n    ,\n    timeText: ''\n    /* weird */\n    ,\n    disableDragging: true,\n    disableResizing: true,\n    isDragging: false,\n    isResizing: false,\n    isDateSelecting: false,\n    isSelected: false,\n    isPast: props.isPast,\n    isFuture: props.isFuture,\n    isToday: props.isToday\n  }, function (rootElRef, classNames, innerElRef, innerContent, hookProps) {\n    return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"div\", {\n      ref: rootElRef,\n      className: ['fc-bg-event'].concat(classNames).join(' '),\n      style: {\n        backgroundColor: hookProps.backgroundColor\n      }\n    }, innerContent);\n  });\n};\n\nfunction renderInnerContent$1(props) {\n  var title = props.event.title;\n  return title && Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(\"div\", {\n    className: 'fc-event-title'\n  }, props.event.title);\n}\n\nvar WeekNumberRoot = function WeekNumberRoot(props) {\n  return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(ViewContextType.Consumer, null, function (context) {\n    var dateEnv = context.dateEnv,\n        options = context.options;\n    var date = props.date;\n    var format = options.weekNumberFormat || props.defaultFormat;\n    var num = dateEnv.computeWeekNumber(date); // TODO: somehow use for formatting as well?\n\n    var text = dateEnv.format(date, format);\n    var hookProps = {\n      num: num,\n      text: text,\n      date: date\n    };\n    return Object(_vdom__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.weekNumberClassNames,\n      content: options.weekNumberContent,\n      defaultContent: renderInner$1,\n      didMount: options.weekNumberDidMount,\n      willUnmount: options.weekNumberWillUnmount\n    }, props.children);\n  });\n};\n\nfunction renderInner$1(innerProps) {\n  return innerProps.text;\n} // exports\n// --------------------------------------------------------------------------------------------------\n\n\nvar version = '<%= version %>'; // important to type it, so .d.ts has generic string\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb21tb24vbWFpbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvYXBpL0V2ZW50U291cmNlQXBpLnRzPzUwYTQiLCJ3ZWJwYWNrOi8vL3NyYy91dGlsL2FycmF5LnRzPzllYWMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlsL2RvbS1tYW5pcC50cz8zOTE1Iiwid2VicGFjazovLy9zcmMvdXRpbC9kb20tZXZlbnQudHM/OTE2OSIsIndlYnBhY2s6Ly8vc3JjL3V0aWwvbWlzYy50cz8zYjRiIiwid2VicGFjazovLy9zcmMvZGF0ZWxpYi9tYXJrZXIudHM/OTFmMSIsIndlYnBhY2s6Ly8vc3JjL3N0cnVjdHMvZXZlbnQtaW5zdGFuY2UudHM/MzE3ZiIsIndlYnBhY2s6Ly8vc3JjL3V0aWwvb2JqZWN0LnRzPzZkYWQiLCJ3ZWJwYWNrOi8vL3NyYy9zdHJ1Y3RzL3JlY3VycmluZy1ldmVudC50cz84MGQyIiwid2VicGFjazovLy9zcmMvZGF0ZWxpYi9kdXJhdGlvbi50cz84ZjRmIiwid2VicGFjazovLy9zcmMvZGF0ZWxpYi9mb3JtYXR0aW5nLXV0aWxzLnRzPzYzOTEiLCJ3ZWJwYWNrOi8vL3NyYy91dGlsL21lbW9pemUudHM/N2VmMSIsIndlYnBhY2s6Ly8vc3JjL2RhdGVsaWIvZm9ybWF0dGluZy1uYXRpdmUudHM/M2U3YyIsIndlYnBhY2s6Ly8vc3JjL2RhdGVsaWIvem9uZWQtbWFya2VyLnRzPzQwYjUiLCJ3ZWJwYWNrOi8vL3NyYy9kYXRlbGliL0RhdGVGb3JtYXR0ZXIudHM/OGIwOSIsIndlYnBhY2s6Ly8vc3JjL2RhdGVsaWIvZm9ybWF0dGluZy1jbWQudHM/N2NkZSIsIndlYnBhY2s6Ly8vc3JjL2RhdGVsaWIvZm9ybWF0dGluZy1mdW5jLnRzPzhjNzIiLCJ3ZWJwYWNrOi8vL3NyYy9kYXRlbGliL2Zvcm1hdHRpbmcudHM/NzkxYSIsIndlYnBhY2s6Ly8vc3JjL29wdGlvbnMudHM/OTE4MSIsIndlYnBhY2s6Ly8vc3JjL3N0cnVjdHMvZXZlbnQtc3RvcmUudHM/N2VkMiIsIndlYnBhY2s6Ly8vc3JjL3N0cnVjdHMvY29uc3RyYWludC50cz9mMWNiIiwid2VicGFjazovLy9zcmMvdXRpbC9odG1sLnRzPzIzYTkiLCJ3ZWJwYWNrOi8vL3NyYy9jb21wb25lbnQvZXZlbnQtdWkudHM/MzIzYSIsIndlYnBhY2s6Ly8vc3JjL3N0cnVjdHMvZXZlbnQtcGFyc2UudHM/YTBkMCIsIndlYnBhY2s6Ly8vc3JjL3V0aWwvZGF0ZS50cz80NzBjIiwid2VicGFjazovLy9zcmMvZGF0ZWxpYi9kYXRlLXJhbmdlLnRzP2M5ZjkiLCJ3ZWJwYWNrOi8vL3NyYy9jb21wb25lbnQvZXZlbnQtcmVuZGVyaW5nLnRzP2Q3NTMiLCJ3ZWJwYWNrOi8vL3NyYy9zdHJ1Y3RzL2RhdGUtc3Bhbi50cz8wYzAyIiwid2VicGFjazovLy9zcmMvY2FsZW5kYXItdXRpbHMudHM/M2MwYyIsIndlYnBhY2s6Ly8vc3JjL3N0cnVjdHMvZXZlbnQtbXV0YXRpb24udHM/YWE5OSIsIndlYnBhY2s6Ly8vc3JjL1ZpZXdBcGkudHM/OGYyNSIsIndlYnBhY2s6Ly8vc3JjL3N0cnVjdHMvZXZlbnQtc291cmNlLXBhcnNlLnRzPzFjYWMiLCJ3ZWJwYWNrOi8vL3NyYy9yZWR1Y2Vycy9jdXJyZW50LWRhdGUudHM/YzQ2OSIsIndlYnBhY2s6Ly8vc3JjL0NhbGVuZGFyQXBpLnRzeD83NWZlIiwid2VicGFjazovLy9zcmMvYXBpL0V2ZW50QXBpLnRzP2I4NzYiLCJ3ZWJwYWNrOi8vL3NyYy9kYXRlbGliL2NhbGVuZGFyLXN5c3RlbS50cz9lNDQzIiwid2VicGFjazovLy9zcmMvZGF0ZWxpYi9wYXJzaW5nLnRzP2ExMWYiLCJ3ZWJwYWNrOi8vL3NyYy9kYXRlbGliL2Vudi50cz9kNDNiIiwid2VicGFjazovLy9zcmMvZ2xvYmFsLWxvY2FsZXMudHM/MTgyNiIsIndlYnBhY2s6Ly8vc3JjL2RhdGVsaWIvbG9jYWxlLnRzPzIyNjciLCJ3ZWJwYWNrOi8vL3NyYy9mb3JtYXR0aW5nLWFwaS50cz81M2YzIiwid2VicGFjazovLy9zcmMvc3RydWN0cy9idXNpbmVzcy1ob3Vycy50cz82OGYwIiwid2VicGFjazovLy9zcmMvdXRpbC9nZW9tLnRzP2NmYzEiLCJ3ZWJwYWNrOi8vL3NyYy9jb21wb25lbnQvZXZlbnQtc3BsaXR0aW5nLnRzPzM1MWEiLCJ3ZWJwYWNrOi8vL3NyYy9jb21wb25lbnQvZGF0ZS1yZW5kZXJpbmcudHN4P2VhNTAiLCJ3ZWJwYWNrOi8vL3NyYy9jb21tb24vbmF2LWxpbmsudHM/ZWM0ZCIsIndlYnBhY2s6Ly8vc3JjL3V0aWwvc2Nyb2xsYmFyLXNpZGUudHM/ODhjMyIsIndlYnBhY2s6Ly8vc3JjL3V0aWwvc2Nyb2xsYmFyLXdpZHRoLnRzPzQwYWQiLCJ3ZWJwYWNrOi8vL3NyYy91dGlsL2RvbS1nZW9tLnRzP2Q4MDUiLCJ3ZWJwYWNrOi8vL3NyYy91dGlsL3Byb21pc2UudHM/ZDk3MyIsIndlYnBhY2s6Ly8vc3JjL2NvbW1vbi9FbWl0dGVyLnRzPzZkNjkiLCJ3ZWJwYWNrOi8vL3NyYy9jb21tb24vUG9zaXRpb25DYWNoZS50cz8xYzljIiwid2VicGFjazovLy9zcmMvY29tbW9uL3Njcm9sbC1jb250cm9sbGVyLnRzPzYyZTEiLCJ3ZWJwYWNrOi8vL3NyYy90aGVtZS9UaGVtZS50cz9mM2YxIiwid2VicGFjazovLy9zcmMvU2Nyb2xsUmVzcG9uZGVyLnRzPzJmNjIiLCJ3ZWJwYWNrOi8vL3NyYy9WaWV3Q29udGV4dC50cz8xMjc3Iiwid2VicGFjazovLy9zcmMvdmRvbS11dGlsLnRzeD83ODE3Iiwid2VicGFjazovLy9zcmMvcmVkdWNlcnMvZXZlbnRTdG9yZS50cz8xM2ViIiwid2VicGFjazovLy9zcmMvdmFsaWRhdGlvbi50cz9lZmJjIiwid2VicGFjazovLy9zcmMvY29tcG9uZW50L0RhdGVDb21wb25lbnQudHM/NGUzNiIsIndlYnBhY2s6Ly8vc3JjL3BsdWdpbi1zeXN0ZW0udHM/OWEyYiIsIndlYnBhY2s6Ly8vc3JjL3RoZW1lL1N0YW5kYXJkVGhlbWUudHM/Y2E2NSIsIndlYnBhY2s6Ly8vc3JjL3N0cnVjdHMvdmlldy1kZWYudHM/MzgzMiIsIndlYnBhY2s6Ly8vc3JjL2NvbW1vbi9yZW5kZXItaG9vay50c3g/Mzc0YyIsIndlYnBhY2s6Ly8vc3JjL2NvbW1vbi9WaWV3Um9vdC50c3g/MGRjNSIsIndlYnBhY2s6Ly8vc3JjL3N0cnVjdHMvdmlldy1jb25maWcudHN4Pzc1ZDEiLCJ3ZWJwYWNrOi8vL3NyYy9zdHJ1Y3RzL3ZpZXctc3BlYy50cz9lZGY5Iiwid2VicGFjazovLy9zcmMvRGF0ZVByb2ZpbGVHZW5lcmF0b3IudHM/NjI4NCIsIndlYnBhY2s6Ly8vc3JjL3JlZHVjZXJzL3ZpZXctdHlwZS50cz8yOTdhIiwid2VicGFjazovLy9zcmMvcmVkdWNlcnMvb3B0aW9ucy50cz85YmI3Iiwid2VicGFjazovLy9zcmMvcmVkdWNlcnMvZGF0ZS1wcm9maWxlLnRzPzA2OTciLCJ3ZWJwYWNrOi8vL3NyYy9yZWR1Y2Vycy9ldmVudFNvdXJjZXMudHM/MTFiYiIsIndlYnBhY2s6Ly8vc3JjL3JlZHVjZXJzL2RhdGUtc2VsZWN0aW9uLnRzPzZlZDkiLCJ3ZWJwYWNrOi8vL3NyYy9yZWR1Y2Vycy9zZWxlY3RlZC1ldmVudC50cz9hM2M3Iiwid2VicGFjazovLy9zcmMvcmVkdWNlcnMvZXZlbnQtZHJhZy50cz9jYmNkIiwid2VicGFjazovLy9zcmMvcmVkdWNlcnMvZXZlbnQtcmVzaXplLnRzP2ZlYTIiLCJ3ZWJwYWNrOi8vL3NyYy90b29sYmFyLXBhcnNlLnRzPzM4NmMiLCJ3ZWJwYWNrOi8vL3NyYy9ldmVudC1zb3VyY2VzL2FycmF5LWV2ZW50LXNvdXJjZS50cz9lNzZhIiwid2VicGFjazovLy9zcmMvZXZlbnQtc291cmNlcy9mdW5jLWV2ZW50LXNvdXJjZS50cz80N2IxIiwid2VicGFjazovLy9zcmMvdXRpbC9yZXF1ZXN0SnNvbi50cz8yYWI5Iiwid2VicGFjazovLy9zcmMvZXZlbnQtc291cmNlcy9qc29uLWZlZWQtZXZlbnQtc291cmNlLXJlZmluZXJzLnRzPzlkNTIiLCJ3ZWJwYWNrOi8vL3NyYy9ldmVudC1zb3VyY2VzL2pzb24tZmVlZC1ldmVudC1zb3VyY2UudHM/ZGFmOSIsIndlYnBhY2s6Ly8vc3JjL3N0cnVjdHMvcmVjdXJyaW5nLWV2ZW50LXNpbXBsZS1yZWZpbmVycy50cz9jZWFhIiwid2VicGFjazovLy9zcmMvc3RydWN0cy9yZWN1cnJpbmctZXZlbnQtc2ltcGxlLnRzPzM0ZjYiLCJ3ZWJwYWNrOi8vL3NyYy9vcHRpb24tY2hhbmdlLWhhbmRsZXJzLnRzP2M3NjkiLCJ3ZWJwYWNrOi8vL3NyYy9kYXRlcy1zZXQudHM/MDE3MyIsIndlYnBhY2s6Ly8vc3JjL2V2ZW50LWNydWQudHM/NmVlNCIsIndlYnBhY2s6Ly8vc3JjL2dsb2JhbC1wbHVnaW5zLnRzP2U2YzYiLCJ3ZWJwYWNrOi8vL3NyYy91dGlsL3J1bm5lci50cz9kOGZiIiwid2VicGFjazovLy9zcmMvcmVkdWNlcnMvdGl0bGUtZm9ybWF0dGluZy50cz8wOTZlIiwid2VicGFjazovLy9zcmMvcmVkdWNlcnMvQ2FsZW5kYXJEYXRhTWFuYWdlci50cz8zM2ZmIiwid2VicGFjazovLy9zcmMvY29tcG9uZW50L0NhbGVuZGFyRGF0YVByb3ZpZGVyLnRzPzhiMzkiLCJ3ZWJwYWNrOi8vL3NyYy9WaWV3LnRzP2MzMTciLCJ3ZWJwYWNrOi8vL3NyYy9kYXRlbGliL3RpbWV6b25lLnRzP2E4MmIiLCJ3ZWJwYWNrOi8vL3NyYy9pbnRlcmFjdGlvbnMvaW50ZXJhY3Rpb24udHM/OGYwZCIsIndlYnBhY2s6Ly8vc3JjL2ludGVyYWN0aW9ucy9FbGVtZW50RHJhZ2dpbmcudHM/YTBiZiIsIndlYnBhY2s6Ly8vc3JjL2dsb2JhbC1jb25maWcudHM/ZmZlMSIsIndlYnBhY2s6Ly8vc3JjL3N0cnVjdHMvZHJhZy1tZXRhLnRzPzg4YzgiLCJ3ZWJwYWNrOi8vL3NyYy9Ub29sYmFyLnRzeD80MWY1Iiwid2VicGFjazovLy9zcmMvVmlld0NvbnRhaW5lci50c3g/YjBjYSIsIndlYnBhY2s6Ly8vc3JjL2ludGVyYWN0aW9ucy9FdmVudENsaWNraW5nLnRzPzNjOTYiLCJ3ZWJwYWNrOi8vL3NyYy9pbnRlcmFjdGlvbnMvRXZlbnRIb3ZlcmluZy50cz8xOWM0Iiwid2VicGFjazovLy9zcmMvQ2FsZW5kYXJDb250ZW50LnRzeD8yNGQ1Iiwid2VicGFjazovLy9zcmMvdXRpbC90YWJsZS1zdHlsaW5nLnRzPzA2YjYiLCJ3ZWJwYWNrOi8vL3NyYy9DYWxlbmRhclJvb3QudHN4PzY4YjIiLCJ3ZWJwYWNrOi8vL3NyYy9jb21tb24vdGFibGUtdXRpbHMudHM/OGYyNyIsIndlYnBhY2s6Ly8vc3JjL2NvbW1vbi9UYWJsZURhdGVDZWxsLnRzeD9hOWFhIiwid2VicGFjazovLy9zcmMvTm93VGltZXIudHM/ZmJmYyIsIndlYnBhY2s6Ly8vc3JjL2NvbW1vbi9EYXlIZWFkZXIudHN4PzUyZjYiLCJ3ZWJwYWNrOi8vL3NyYy9jb21tb24vRGF5U2VyaWVzTW9kZWwudHM/YjVhYSIsIndlYnBhY2s6Ly8vc3JjL2NvbW1vbi9EYXlUYWJsZU1vZGVsLnRzPzYyNzEiLCJ3ZWJwYWNrOi8vL3NyYy9jb21tb24vc2xpY2luZy11dGlscy50cz85MmQyIiwid2VicGFjazovLy9zcmMvc2Nyb2xsZ3JpZC9TY3JvbGxlci50c3g/NjcwNSIsIndlYnBhY2s6Ly8vc3JjL3V0aWwvUmVmTWFwLnRzPzIxODIiLCJ3ZWJwYWNrOi8vL3NyYy9zY3JvbGxncmlkL3V0aWwudHN4PzcwZDUiLCJ3ZWJwYWNrOi8vL3NyYy9zY3JvbGxncmlkL1NpbXBsZVNjcm9sbEdyaWQudHN4PzQyMDEiLCJ3ZWJwYWNrOi8vL3NyYy9jb21tb24vRXZlbnRSb290LnRzeD9kNzkyIiwid2VicGFjazovLy9zcmMvY29tbW9uL1N0YW5kYXJkRXZlbnQudHN4PzNlMDciLCJ3ZWJwYWNrOi8vL3NyYy9jb21tb24vTm93SW5kaWNhdG9yUm9vdC50c3g/OWUwMyIsIndlYnBhY2s6Ly8vc3JjL2NvbW1vbi9EYXlDZWxsUm9vdC50c3g/MTk3ZCIsIndlYnBhY2s6Ly8vc3JjL2NvbW1vbi9iZy1maWxsLnRzeD9lNjE2Iiwid2VicGFjazovLy9zcmMvY29tbW9uL1dlZWtOdW1iZXJSb290LnRzeD9hOTkzIiwid2VicGFjazovLy9zcmMvbWFpbi50cz9iOTljIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV2ZW50U291cmNlIH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1zb3VyY2UnXG5pbXBvcnQgeyBDYWxlbmRhckNvbnRleHQgfSBmcm9tICcuLi9DYWxlbmRhckNvbnRleHQnXG5cbi8vIG5vIHB1YmxpYyB0eXBlcyB5ZXQuIHdoZW4gdGhlcmUgYXJlLCBleHBvcnQgZnJvbTpcbi8vIGltcG9ydCB7fSBmcm9tICcuL2FwaS10eXBlLWRlcHMnXG5cbmV4cG9ydCBjbGFzcyBFdmVudFNvdXJjZUFwaSB7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQsXG4gICAgcHVibGljIGludGVybmFsRXZlbnRTb3VyY2U6IEV2ZW50U291cmNlPGFueT4gLy8gcmVuYW1lP1xuICApIHtcbiAgfVxuXG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLmNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnLFxuICAgICAgc291cmNlSWQ6IHRoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5zb3VyY2VJZFxuICAgIH0pXG4gIH1cblxuICByZWZldGNoKCkge1xuICAgIHRoaXMuY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiAnRkVUQ0hfRVZFTlRfU09VUkNFUycsXG4gICAgICBzb3VyY2VJZHM6IFsgdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlLnNvdXJjZUlkIF1cbiAgICB9KVxuICB9XG5cbiAgZ2V0IGlkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5wdWJsaWNJZFxuICB9XG5cbiAgLy8gb25seSByZWxldmFudCB0byBqc29uLWZlZWQgZXZlbnQgc291cmNlc1xuICBnZXQgdXJsKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5tZXRhLnVybFxuICB9XG5cbn1cbiIsIlxuXG4vLyBUT0RPOiBuZXcgdXRpbCBhcnJheWlmeT9cbi8vIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKFxuXG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVNYXRjaGluZyhhcnJheSwgdGVzdEZ1bmMpIHtcbiAgbGV0IHJlbW92ZUNudCA9IDBcbiAgbGV0IGkgPSAwXG5cbiAgd2hpbGUgKGkgPCBhcnJheS5sZW5ndGgpIHtcbiAgICBpZiAodGVzdEZ1bmMoYXJyYXlbaV0pKSB7IC8vIHRydXRoeSB2YWx1ZSBtZWFucyAqcmVtb3ZlKlxuICAgICAgYXJyYXkuc3BsaWNlKGksIDEpXG4gICAgICByZW1vdmVDbnQrK1xuICAgIH0gZWxzZSB7XG4gICAgICBpKytcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVtb3ZlQ250XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUV4YWN0KGFycmF5LCBleGFjdFZhbCkge1xuICBsZXQgcmVtb3ZlQ250ID0gMFxuICBsZXQgaSA9IDBcblxuICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCkge1xuICAgIGlmIChhcnJheVtpXSA9PT0gZXhhY3RWYWwpIHtcbiAgICAgIGFycmF5LnNwbGljZShpLCAxKVxuICAgICAgcmVtb3ZlQ250KytcbiAgICB9IGVsc2Uge1xuICAgICAgaSsrXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlbW92ZUNudFxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5c0VxdWFsKGEwLCBhMSwgZXF1YWxpdHlGdW5jPzogKHYwLCB2MSkgPT4gYm9vbGVhbikgeyAvLyBUT0RPOiBiZXR0ZXIgdHlwaW5nXG5cbiAgaWYgKGEwID09PSBhMSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBsZXQgbGVuID0gYTAubGVuZ3RoXG4gIGxldCBpXG5cbiAgaWYgKGxlbiAhPT0gYTEubGVuZ3RoKSB7IC8vIG5vdCBhcnJheT8gb3Igbm90IHNhbWUgbGVuZ3RoP1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCEoZXF1YWxpdHlGdW5jID8gZXF1YWxpdHlGdW5jKGEwW2ldLCBhMVtpXSkgOiBhMFtpXSA9PT0gYTFbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwiaW1wb3J0IHsgaXNBcnJheXNFcXVhbCB9IGZyb20gJy4vYXJyYXknXG5pbXBvcnQgeyBEaWN0aW9uYXJ5IH0gZnJvbSAnLi4vb3B0aW9ucydcblxuXG5leHBvcnQgZnVuY3Rpb24gaHRtbFRvRWxlbWVudChodG1sOiBzdHJpbmcpOiBIVE1MRWxlbWVudCB7XG4gIGh0bWwgPSBodG1sLnRyaW0oKVxuICBsZXQgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgY29udGFpbmVyLmlubmVySFRNTCA9IGh0bWxcbiAgcmV0dXJuIGNvbnRhaW5lci5maXJzdENoaWxkIGFzIEhUTUxFbGVtZW50XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZWw6IEhUTUxFbGVtZW50KSB7IC8vIHJlbW92ZXMgbm9kZXMgaW4gYWRkaXRpb24gdG8gZWxlbWVudHMuIGJhZCBuYW1lXG4gIGlmIChlbC5wYXJlbnROb2RlKSB7XG4gICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbClcbiAgfVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBpbmplY3RIdG1sKGVsOiBIVE1MRWxlbWVudCwgaHRtbDogc3RyaW5nKSB7XG4gIGVsLmlubmVySFRNTCA9IGh0bWxcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gaW5qZWN0RG9tTm9kZXMoZWw6IEhUTUxFbGVtZW50LCBkb21Ob2RlczogTm9kZVtdIHwgTm9kZUxpc3QpIHtcbiAgbGV0IG9sZE5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZWwuY2hpbGROb2RlcykgLy8gVE9ETzogdXNlIGFycmF5IHV0aWxcbiAgbGV0IG5ld05vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9tTm9kZXMpIC8vIFRPRE86IHVzZSBhcnJheSB1dGlsXG5cbiAgaWYgKCFpc0FycmF5c0VxdWFsKG9sZE5vZGVzLCBuZXdOb2RlcykpIHtcbiAgICBmb3IgKGxldCBuZXdOb2RlIG9mIG5ld05vZGVzKSB7XG4gICAgICBlbC5hcHBlbmRDaGlsZChuZXdOb2RlKVxuICAgIH1cbiAgICBvbGROb2Rlcy5mb3JFYWNoKHJlbW92ZUVsZW1lbnQpXG4gIH1cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gaXNFbFZpc2libGUoZWw6IEhUTUxFbGVtZW50KSB7XG4gIHJldHVybiBCb29sZWFuKGVsLm9mZnNldFdpZHRoICYmIGVsLm9mZnNldEhlaWdodClcbn1cblxuXG4vLyBRdWVyeWluZ1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2Nsb3Nlc3RcbmNvbnN0IG1hdGNoZXNNZXRob2QgPVxuICBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8XG4gIChFbGVtZW50LnByb3RvdHlwZSBhcyBhbnkpLm1hdGNoZXNTZWxlY3RvciB8fFxuICAoRWxlbWVudC5wcm90b3R5cGUgYXMgYW55KS5tc01hdGNoZXNTZWxlY3RvclxuXG5jb25zdCBjbG9zZXN0TWV0aG9kID0gRWxlbWVudC5wcm90b3R5cGUuY2xvc2VzdCB8fCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAvLyBwb2x5ZmlsbFxuICBsZXQgZWwgPSB0aGlzXG4gIGlmICghZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKGVsKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgZG8ge1xuICAgIGlmIChlbGVtZW50TWF0Y2hlcyhlbCwgc2VsZWN0b3IpKSB7XG4gICAgICByZXR1cm4gZWxcbiAgICB9XG4gICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50IHx8IGVsLnBhcmVudE5vZGVcbiAgfSB3aGlsZSAoZWwgIT09IG51bGwgJiYgZWwubm9kZVR5cGUgPT09IDEpXG4gIHJldHVybiBudWxsXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGVsZW1lbnRDbG9zZXN0KGVsOiBIVE1MRWxlbWVudCwgc2VsZWN0b3I6IHN0cmluZyk6IEhUTUxFbGVtZW50IHtcbiAgcmV0dXJuIChjbG9zZXN0TWV0aG9kIGFzIGFueSkuY2FsbChlbCwgc2VsZWN0b3IpXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVzKGVsOiBIVE1MRWxlbWVudCwgc2VsZWN0b3I6IHN0cmluZyk6IEhUTUxFbGVtZW50IHtcbiAgcmV0dXJuIG1hdGNoZXNNZXRob2QuY2FsbChlbCwgc2VsZWN0b3IpXG59XG5cblxuLy8gYWNjZXB0cyBtdWx0aXBsZSBzdWJqZWN0IGVsc1xuLy8gcmV0dXJucyBhIHJlYWwgYXJyYXkuIGdvb2QgZm9yIG1ldGhvZHMgbGlrZSBmb3JFYWNoXG4vLyBUT0RPOiBhY2NlcHQgdGhlIGRvY3VtZW50XG5leHBvcnQgZnVuY3Rpb24gZmluZEVsZW1lbnRzKGNvbnRhaW5lcjogSFRNTEVsZW1lbnRbXSB8IEhUTUxFbGVtZW50IHwgTm9kZUxpc3RPZjxIVE1MRWxlbWVudD4sIHNlbGVjdG9yOiBzdHJpbmcpOiBIVE1MRWxlbWVudFtdIHtcbiAgbGV0IGNvbnRhaW5lcnMgPSBjb250YWluZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IFsgY29udGFpbmVyIF0gOiBjb250YWluZXJcbiAgbGV0IGFsbE1hdGNoZXM6IEhUTUxFbGVtZW50W10gPSBbXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGFpbmVycy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBtYXRjaGVzID0gY29udGFpbmVyc1tpXS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKVxuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRjaGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICBhbGxNYXRjaGVzLnB1c2gobWF0Y2hlc1tqXSBhcyBIVE1MRWxlbWVudClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYWxsTWF0Y2hlc1xufVxuXG5cbi8vIGFjY2VwdHMgbXVsdGlwbGUgc3ViamVjdCBlbHNcbi8vIG9ubHkgcXVlcmllcyBkaXJlY3QgY2hpbGQgZWxlbWVudHMgLy8gVE9ETzogcmVuYW1lIHRvIGZpbmREaXJlY3RDaGlsZHJlbiFcbmV4cG9ydCBmdW5jdGlvbiBmaW5kRGlyZWN0Q2hpbGRyZW4ocGFyZW50OiBIVE1MRWxlbWVudFtdIHwgSFRNTEVsZW1lbnQsIHNlbGVjdG9yPzogc3RyaW5nKTogSFRNTEVsZW1lbnRbXSB7XG4gIGxldCBwYXJlbnRzID0gcGFyZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyBbIHBhcmVudCBdIDogcGFyZW50XG4gIGxldCBhbGxNYXRjaGVzID0gW11cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgY2hpbGROb2RlcyA9IHBhcmVudHNbaV0uY2hpbGRyZW4gLy8gb25seSBldmVyIGVsZW1lbnRzXG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoaWxkTm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGxldCBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2pdXG5cbiAgICAgIGlmICghc2VsZWN0b3IgfHwgZWxlbWVudE1hdGNoZXMoY2hpbGROb2RlIGFzIEhUTUxFbGVtZW50LCBzZWxlY3RvcikpIHtcbiAgICAgICAgYWxsTWF0Y2hlcy5wdXNoKGNoaWxkTm9kZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gYWxsTWF0Y2hlc1xufVxuXG5cbi8vIFN0eWxlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IFBJWEVMX1BST1BfUkUgPSAvKHRvcHxsZWZ0fHJpZ2h0fGJvdHRvbXx3aWR0aHxoZWlnaHQpJC9pXG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVN0eWxlKGVsOiBIVE1MRWxlbWVudCwgcHJvcHM6IERpY3Rpb25hcnkpIHtcbiAgZm9yIChsZXQgcHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICBhcHBseVN0eWxlUHJvcChlbCwgcHJvcE5hbWUsIHByb3BzW3Byb3BOYW1lXSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlTdHlsZVByb3AoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBzdHJpbmcsIHZhbCkge1xuICBpZiAodmFsID09IG51bGwpIHtcbiAgICBlbC5zdHlsZVtuYW1lXSA9ICcnXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgUElYRUxfUFJPUF9SRS50ZXN0KG5hbWUpKSB7XG4gICAgZWwuc3R5bGVbbmFtZV0gPSB2YWwgKyAncHgnXG4gIH0gZWxzZSB7XG4gICAgZWwuc3R5bGVbbmFtZV0gPSB2YWxcbiAgfVxufVxuIiwiaW1wb3J0IHsgZWxlbWVudENsb3Nlc3QgfSBmcm9tICcuL2RvbS1tYW5pcCdcbmltcG9ydCB7IFZVSUV2ZW50IH0gZnJvbSAnLi4vdmRvbSdcblxuXG4vLyBTdG9wcyBhIG1vdXNlL3RvdWNoIGV2ZW50IGZyb20gZG9pbmcgaXQncyBuYXRpdmUgYnJvd3NlciBhY3Rpb25cbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldikge1xuICBldi5wcmV2ZW50RGVmYXVsdCgpXG59XG5cblxuLy8gRXZlbnQgRGVsZWdhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGREZWxlZ2F0aW9uSGFuZGxlcjxFdmVudFR5cGUgZXh0ZW5kcyAoRXZlbnQgfCBWVUlFdmVudCk+KFxuICBzZWxlY3Rvcjogc3RyaW5nLFxuICBoYW5kbGVyOiAoZXY6IEV2ZW50VHlwZSwgbWF0Y2hlZFRhcmdldDogSFRNTEVsZW1lbnQpID0+IHZvaWRcbikge1xuICByZXR1cm4gZnVuY3Rpb24oZXY6IEV2ZW50VHlwZSkge1xuICAgIGxldCBtYXRjaGVkQ2hpbGQgPSBlbGVtZW50Q2xvc2VzdChldi50YXJnZXQgYXMgSFRNTEVsZW1lbnQsIHNlbGVjdG9yKVxuXG4gICAgaWYgKG1hdGNoZWRDaGlsZCkge1xuICAgICAgaGFuZGxlci5jYWxsKG1hdGNoZWRDaGlsZCwgZXYsIG1hdGNoZWRDaGlsZClcbiAgICB9XG4gIH1cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuQnlTZWxlY3RvcihcbiAgY29udGFpbmVyOiBIVE1MRWxlbWVudCxcbiAgZXZlbnRUeXBlOiBzdHJpbmcsXG4gIHNlbGVjdG9yOiBzdHJpbmcsXG4gIGhhbmRsZXI6IChldjogRXZlbnQsIG1hdGNoZWRUYXJnZXQ6IEhUTUxFbGVtZW50KSA9PiB2b2lkXG4pIHtcbiAgbGV0IGF0dGFjaGVkSGFuZGxlciA9IGJ1aWxkRGVsZWdhdGlvbkhhbmRsZXIoc2VsZWN0b3IsIGhhbmRsZXIpXG5cbiAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBhdHRhY2hlZEhhbmRsZXIpXG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgYXR0YWNoZWRIYW5kbGVyKVxuICB9XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlblRvSG92ZXJCeVNlbGVjdG9yKFxuICBjb250YWluZXI6IEhUTUxFbGVtZW50LFxuICBzZWxlY3Rvcjogc3RyaW5nLFxuICBvbk1vdXNlRW50ZXI6IChldjogRXZlbnQsIG1hdGNoZWRUYXJnZXQ6IEhUTUxFbGVtZW50KSA9PiB2b2lkLFxuICBvbk1vdXNlTGVhdmU6IChldjogRXZlbnQsIG1hdGNoZWRUYXJnZXQ6IEhUTUxFbGVtZW50KSA9PiB2b2lkXG4pIHtcbiAgbGV0IGN1cnJlbnRNYXRjaGVkQ2hpbGRcblxuICByZXR1cm4gbGlzdGVuQnlTZWxlY3Rvcihjb250YWluZXIsICdtb3VzZW92ZXInLCBzZWxlY3RvciwgZnVuY3Rpb24oZXYsIG1hdGNoZWRDaGlsZCkge1xuICAgIGlmIChtYXRjaGVkQ2hpbGQgIT09IGN1cnJlbnRNYXRjaGVkQ2hpbGQpIHtcbiAgICAgIGN1cnJlbnRNYXRjaGVkQ2hpbGQgPSBtYXRjaGVkQ2hpbGRcbiAgICAgIG9uTW91c2VFbnRlcihldiwgbWF0Y2hlZENoaWxkKVxuXG4gICAgICBsZXQgcmVhbE9uTW91c2VMZWF2ZSA9IChldikgPT4ge1xuICAgICAgICBjdXJyZW50TWF0Y2hlZENoaWxkID0gbnVsbFxuICAgICAgICBvbk1vdXNlTGVhdmUoZXYsIG1hdGNoZWRDaGlsZClcbiAgICAgICAgbWF0Y2hlZENoaWxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCByZWFsT25Nb3VzZUxlYXZlKVxuICAgICAgfVxuXG4gICAgICAvLyBsaXN0ZW4gdG8gdGhlIG5leHQgbW91c2VsZWF2ZSwgYW5kIHRoZW4gdW5hdHRhY2hcbiAgICAgIG1hdGNoZWRDaGlsZC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgcmVhbE9uTW91c2VMZWF2ZSlcbiAgICB9XG4gIH0pXG59XG5cblxuLy8gQW5pbWF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IHRyYW5zaXRpb25FdmVudE5hbWVzID0gW1xuICAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICdvdHJhbnNpdGlvbmVuZCcsXG4gICdvVHJhbnNpdGlvbkVuZCcsXG4gICdtc1RyYW5zaXRpb25FbmQnLFxuICAndHJhbnNpdGlvbmVuZCdcbl1cblxuLy8gdHJpZ2dlcmVkIG9ubHkgd2hlbiB0aGUgbmV4dCBzaW5nbGUgc3Vic2VxdWVudCB0cmFuc2l0aW9uIGZpbmlzaGVzXG5leHBvcnQgZnVuY3Rpb24gd2hlblRyYW5zaXRpb25Eb25lKGVsOiBIVE1MRWxlbWVudCwgY2FsbGJhY2s6IChldjogRXZlbnQpID0+IHZvaWQpIHtcbiAgbGV0IHJlYWxDYWxsYmFjayA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgY2FsbGJhY2soZXYpXG4gICAgdHJhbnNpdGlvbkV2ZW50TmFtZXMuZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCByZWFsQ2FsbGJhY2spXG4gICAgfSlcbiAgfVxuXG4gIHRyYW5zaXRpb25FdmVudE5hbWVzLmZvckVhY2goZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHJlYWxDYWxsYmFjaykgLy8gY3Jvc3MtYnJvd3NlciB3YXkgdG8gZGV0ZXJtaW5lIHdoZW4gdGhlIHRyYW5zaXRpb24gZmluaXNoZXNcbiAgfSlcbn1cbiIsImltcG9ydCB7IHByZXZlbnREZWZhdWx0IH0gZnJvbSAnLi9kb20tZXZlbnQnXG5cblxuZXhwb3J0IHR5cGUgR2VuZXJpY0hhc2ggPSB7IFtrZXk6IHN0cmluZ106IGFueSB9IC8vIGFscmVhZHkgZGlkIHRoaXMgc29tZXdoZXJlXG5cblxubGV0IGd1aWROdW1iZXIgPSAwXG5cbmV4cG9ydCBmdW5jdGlvbiBndWlkKCkge1xuICByZXR1cm4gU3RyaW5nKGd1aWROdW1iZXIrKylcbn1cblxuXG4vKiBGdWxsQ2FsZW5kYXItc3BlY2lmaWMgRE9NIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuLy8gTWFrZSB0aGUgbW91c2UgY3Vyc29yIGV4cHJlc3MgdGhhdCBhbiBldmVudCBpcyBub3QgYWxsb3dlZCBpbiB0aGUgY3VycmVudCBhcmVhXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZUN1cnNvcigpIHtcbiAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdmYy1ub3QtYWxsb3dlZCcpXG59XG5cblxuLy8gUmV0dXJucyB0aGUgbW91c2UgY3Vyc29yIHRvIGl0cyBvcmlnaW5hbCBsb29rXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlQ3Vyc29yKCkge1xuICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ2ZjLW5vdC1hbGxvd2VkJylcbn1cblxuXG4vKiBTZWxlY3Rpb25cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50U2VsZWN0aW9uKGVsOiBIVE1MRWxlbWVudCkge1xuICBlbC5jbGFzc0xpc3QuYWRkKCdmYy11bnNlbGVjdGFibGUnKVxuICBlbC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBhbGxvd1NlbGVjdGlvbihlbDogSFRNTEVsZW1lbnQpIHtcbiAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnZmMtdW5zZWxlY3RhYmxlJylcbiAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdClcbn1cblxuXG4vKiBDb250ZXh0IE1lbnVcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50Q29udGV4dE1lbnUoZWw6IEhUTUxFbGVtZW50KSB7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgcHJldmVudERlZmF1bHQpXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGFsbG93Q29udGV4dE1lbnUoZWw6IEhUTUxFbGVtZW50KSB7XG4gIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgcHJldmVudERlZmF1bHQpXG59XG5cblxuLyogT2JqZWN0IE9yZGVyaW5nIGJ5IEZpZWxkXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuZXhwb3J0IGludGVyZmFjZSBPcmRlclNwZWM8U3ViamVjdD4ge1xuICBmaWVsZD86IHN0cmluZ1xuICBvcmRlcj86IG51bWJlclxuICBmdW5jPzogRmllbGRTcGVjSW5wdXRGdW5jPFN1YmplY3Q+XG59XG5cblxuZXhwb3J0IHR5cGUgRmllbGRTcGVjSW5wdXQ8U3ViamVjdD4gPSBzdHJpbmcgfCBzdHJpbmdbXSB8IEZpZWxkU3BlY0lucHV0RnVuYzxTdWJqZWN0PiB8IEZpZWxkU3BlY0lucHV0RnVuYzxTdWJqZWN0PltdXG5leHBvcnQgdHlwZSBGaWVsZFNwZWNJbnB1dEZ1bmM8U3ViamVjdD4gPSAoYTogU3ViamVjdCwgYjogU3ViamVjdCkgPT4gbnVtYmVyXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZpZWxkU3BlY3M8U3ViamVjdD4oaW5wdXQ6IEZpZWxkU3BlY0lucHV0PFN1YmplY3Q+KTogT3JkZXJTcGVjPFN1YmplY3Q+W10ge1xuICBsZXQgc3BlY3M6IE9yZGVyU3BlYzxTdWJqZWN0PltdID0gW11cbiAgbGV0IHRva2VucyA9IFtdXG4gIGxldCBpXG4gIGxldCB0b2tlblxuXG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgdG9rZW5zID0gaW5wdXQuc3BsaXQoL1xccyosXFxzKi8pXG4gIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdG9rZW5zID0gWyBpbnB1dCBdXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICB0b2tlbnMgPSBpbnB1dFxuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIHRva2VuID0gdG9rZW5zW2ldXG5cbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgc3BlY3MucHVzaChcbiAgICAgICAgdG9rZW4uY2hhckF0KDApID09PSAnLScgP1xuICAgICAgICAgIHsgZmllbGQ6IHRva2VuLnN1YnN0cmluZygxKSwgb3JkZXI6IC0xIH0gOlxuICAgICAgICAgIHsgZmllbGQ6IHRva2VuLCBvcmRlcjogMSB9XG4gICAgICApXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdG9rZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNwZWNzLnB1c2goeyBmdW5jOiB0b2tlbiB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzcGVjc1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlQnlGaWVsZFNwZWNzPFN1YmplY3Q+KG9iajA6IFN1YmplY3QsIG9iajE6IFN1YmplY3QsIGZpZWxkU3BlY3M6IE9yZGVyU3BlYzxTdWJqZWN0PltdKTogbnVtYmVyIHtcbiAgbGV0IGlcbiAgbGV0IGNtcFxuXG4gIGZvciAoaSA9IDA7IGkgPCBmaWVsZFNwZWNzLmxlbmd0aDsgaSsrKSB7XG4gICAgY21wID0gY29tcGFyZUJ5RmllbGRTcGVjKG9iajAsIG9iajEsIGZpZWxkU3BlY3NbaV0pXG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVCeUZpZWxkU3BlYzxTdWJqZWN0PihvYmowOiBTdWJqZWN0LCBvYmoxOiBTdWJqZWN0LCBmaWVsZFNwZWM6IE9yZGVyU3BlYzxTdWJqZWN0Pik6IG51bWJlciB7XG4gIGlmIChmaWVsZFNwZWMuZnVuYykge1xuICAgIHJldHVybiBmaWVsZFNwZWMuZnVuYyhvYmowLCBvYmoxKVxuICB9XG5cbiAgcmV0dXJuIGZsZXhpYmxlQ29tcGFyZShvYmowW2ZpZWxkU3BlYy5maWVsZF0sIG9iajFbZmllbGRTcGVjLmZpZWxkXSlcbiAgICAqIChmaWVsZFNwZWMub3JkZXIgfHwgMSlcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZmxleGlibGVDb21wYXJlKGEsIGIpIHtcbiAgaWYgKCFhICYmICFiKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAoYiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKGEgPT0gbnVsbCkge1xuICAgIHJldHVybiAxXG4gIH1cbiAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpLmxvY2FsZUNvbXBhcmUoU3RyaW5nKGIpKVxuICB9XG4gIHJldHVybiBhIC0gYlxufVxuXG5cbi8qIFN0cmluZyBVdGlsaXRpZXNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBwYWRTdGFydCh2YWwsIGxlbikgeyAvLyBkb2Vzbid0IHdvcmsgd2l0aCB0b3RhbCBsZW5ndGggbW9yZSB0aGFuIDNcbiAgbGV0IHMgPSBTdHJpbmcodmFsKVxuICByZXR1cm4gJzAwMCcuc3Vic3RyKDAsIGxlbiAtIHMubGVuZ3RoKSArIHNcbn1cblxuXG4vKiBOdW1iZXIgVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZU51bWJlcnMoYSwgYikgeyAvLyBmb3IgLnNvcnQoKVxuICByZXR1cm4gYSAtIGJcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gaXNJbnQobikge1xuICByZXR1cm4gbiAlIDEgPT09IDBcbn1cblxuXG4vKiBXZWlyZCBVdGlsaXRpZXNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBmaXJzdERlZmluZWQoLi4uYXJncykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJnc1tpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gYXJnc1tpXVxuICAgIH1cbiAgfVxufVxuXG5cbi8qIEZDLXNwZWNpZmljIERPTSBkaW1lbnNpb24gc3R1ZmZcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoKGNlbGxFbDogSFRNTEVsZW1lbnQpIHtcbiAgbGV0IGFsbFdpZHRoRWwgPSBjZWxsRWwucXVlcnlTZWxlY3RvcignLmZjLXNjcm9sbGdyaWQtc2hyaW5rLWZyYW1lJylcbiAgbGV0IGNvbnRlbnRXaWR0aEVsID0gY2VsbEVsLnF1ZXJ5U2VsZWN0b3IoJy5mYy1zY3JvbGxncmlkLXNocmluay1jdXNoaW9uJylcblxuICBpZiAoIWFsbFdpZHRoRWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZWRzIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWZyYW1lIGNsYXNzTmFtZScpIC8vIFRPRE86IHVzZSBjb25zdFxuICB9XG4gIGlmICghY29udGVudFdpZHRoRWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZWRzIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWN1c2hpb24gY2xhc3NOYW1lJylcbiAgfVxuXG4gIHJldHVybiBjZWxsRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSBhbGxXaWR0aEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICsgLy8gdGhlIGNlbGwgcGFkZGluZytib3JkZXJcbiAgICBjb250ZW50V2lkdGhFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aFxufVxuIiwiaW1wb3J0IHsgRHVyYXRpb24gfSBmcm9tICcuL2R1cmF0aW9uJ1xuXG5leHBvcnQgdHlwZSBEYXRlTWFya2VyID0gRGF0ZVxuXG5leHBvcnQgY29uc3QgREFZX0lEUyA9IFsgJ3N1bicsICdtb24nLCAndHVlJywgJ3dlZCcsICd0aHUnLCAnZnJpJywgJ3NhdCcgXVxuXG5cbi8vIEFkZGluZ1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkV2Vla3MobTogRGF0ZU1hcmtlciwgbjogbnVtYmVyKSB7XG4gIGxldCBhID0gZGF0ZVRvVXRjQXJyYXkobSlcbiAgYVsyXSArPSBuICogN1xuICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoYSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZERheXMobTogRGF0ZU1hcmtlciwgbjogbnVtYmVyKSB7XG4gIGxldCBhID0gZGF0ZVRvVXRjQXJyYXkobSlcbiAgYVsyXSArPSBuXG4gIHJldHVybiBhcnJheVRvVXRjRGF0ZShhKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkTXMobTogRGF0ZU1hcmtlciwgbjogbnVtYmVyKSB7XG4gIGxldCBhID0gZGF0ZVRvVXRjQXJyYXkobSlcbiAgYVs2XSArPSBuXG4gIHJldHVybiBhcnJheVRvVXRjRGF0ZShhKVxufVxuXG5cbi8vIERpZmZpbmcgKGFsbCByZXR1cm4gZmxvYXRzKVxuLy8gVE9ETzogd2h5IG5vdCB1c2UgcmFuZ2VzP1xuXG5leHBvcnQgZnVuY3Rpb24gZGlmZldlZWtzKG0wLCBtMSkge1xuICByZXR1cm4gZGlmZkRheXMobTAsIG0xKSAvIDdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZEYXlzKG0wLCBtMSkge1xuICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZIb3VycyhtMCwgbTEpIHtcbiAgcmV0dXJuIChtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkpIC8gKDEwMDAgKiA2MCAqIDYwKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlmZk1pbnV0ZXMobTAsIG0xKSB7XG4gIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvICgxMDAwICogNjApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWZmU2Vjb25kcyhtMCwgbTEpIHtcbiAgcmV0dXJuIChtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkpIC8gMTAwMFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlmZkRheUFuZFRpbWUobTA6IERhdGVNYXJrZXIsIG0xOiBEYXRlTWFya2VyKTogRHVyYXRpb24ge1xuICBsZXQgbTBkYXkgPSBzdGFydE9mRGF5KG0wKVxuICBsZXQgbTFkYXkgPSBzdGFydE9mRGF5KG0xKVxuXG4gIHJldHVybiB7XG4gICAgeWVhcnM6IDAsXG4gICAgbW9udGhzOiAwLFxuICAgIGRheXM6IE1hdGgucm91bmQoZGlmZkRheXMobTBkYXksIG0xZGF5KSksXG4gICAgbWlsbGlzZWNvbmRzOiAobTEudmFsdWVPZigpIC0gbTFkYXkudmFsdWVPZigpKSAtIChtMC52YWx1ZU9mKCkgLSBtMGRheS52YWx1ZU9mKCkpXG4gIH1cbn1cblxuXG4vLyBEaWZmaW5nIFdob2xlIFVuaXRzXG5cbmV4cG9ydCBmdW5jdGlvbiBkaWZmV2hvbGVXZWVrcyhtMDogRGF0ZU1hcmtlciwgbTE6IERhdGVNYXJrZXIpOiBudW1iZXIge1xuICBsZXQgZCA9IGRpZmZXaG9sZURheXMobTAsIG0xKVxuXG4gIGlmIChkICE9PSBudWxsICYmIGQgJSA3ID09PSAwKSB7XG4gICAgcmV0dXJuIGQgLyA3XG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlmZldob2xlRGF5cyhtMDogRGF0ZU1hcmtlciwgbTE6IERhdGVNYXJrZXIpOiBudW1iZXIge1xuICBpZiAodGltZUFzTXMobTApID09PSB0aW1lQXNNcyhtMSkpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChkaWZmRGF5cyhtMCwgbTEpKVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cblxuLy8gU3RhcnQtT2ZcblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0T2ZEYXkobTogRGF0ZU1hcmtlcik6IERhdGVNYXJrZXIge1xuICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoW1xuICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICBtLmdldFVUQ01vbnRoKCksXG4gICAgbS5nZXRVVENEYXRlKClcbiAgXSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0T2ZIb3VyKG06IERhdGVNYXJrZXIpIHtcbiAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKFtcbiAgICBtLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgbS5nZXRVVENNb250aCgpLFxuICAgIG0uZ2V0VVRDRGF0ZSgpLFxuICAgIG0uZ2V0VVRDSG91cnMoKVxuICBdKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRPZk1pbnV0ZShtOiBEYXRlTWFya2VyKSB7XG4gIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgbS5nZXRVVENGdWxsWWVhcigpLFxuICAgIG0uZ2V0VVRDTW9udGgoKSxcbiAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICBtLmdldFVUQ0hvdXJzKCksXG4gICAgbS5nZXRVVENNaW51dGVzKClcbiAgXSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0T2ZTZWNvbmQobTogRGF0ZU1hcmtlcikge1xuICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoW1xuICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICBtLmdldFVUQ01vbnRoKCksXG4gICAgbS5nZXRVVENEYXRlKCksXG4gICAgbS5nZXRVVENIb3VycygpLFxuICAgIG0uZ2V0VVRDTWludXRlcygpLFxuICAgIG0uZ2V0VVRDU2Vjb25kcygpXG4gIF0pXG59XG5cblxuLy8gV2VlayBDb21wdXRhdGlvblxuXG5leHBvcnQgZnVuY3Rpb24gd2Vla09mWWVhcihtYXJrZXIsIGRvdywgZG95KSB7XG4gIGxldCB5ID0gbWFya2VyLmdldFVUQ0Z1bGxZZWFyKClcbiAgbGV0IHcgPSB3ZWVrT2ZHaXZlblllYXIobWFya2VyLCB5LCBkb3csIGRveSlcblxuICBpZiAodyA8IDEpIHtcbiAgICByZXR1cm4gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSAtIDEsIGRvdywgZG95KVxuICB9XG5cbiAgbGV0IG5leHRXID0gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSArIDEsIGRvdywgZG95KVxuICBpZiAobmV4dFcgPj0gMSkge1xuICAgIHJldHVybiBNYXRoLm1pbih3LCBuZXh0VylcbiAgfVxuXG4gIHJldHVybiB3XG59XG5cbmZ1bmN0aW9uIHdlZWtPZkdpdmVuWWVhcihtYXJrZXIsIHllYXIsIGRvdywgZG95KSB7XG4gIGxldCBmaXJzdFdlZWtTdGFydCA9IGFycmF5VG9VdGNEYXRlKFsgeWVhciwgMCwgMSArIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkgXSlcbiAgbGV0IGRheVN0YXJ0ID0gc3RhcnRPZkRheShtYXJrZXIpXG4gIGxldCBkYXlzID0gTWF0aC5yb3VuZChkaWZmRGF5cyhmaXJzdFdlZWtTdGFydCwgZGF5U3RhcnQpKVxuXG4gIHJldHVybiBNYXRoLmZsb29yKGRheXMgLyA3KSArIDEgLy8gemVyby1pbmRleGVkXG59XG5cbi8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG5mdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcblxuICAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgbGV0IGZ3ZCA9IDcgKyBkb3cgLSBkb3lcblxuICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gIGxldCBmd2RsdyA9ICg3ICsgYXJyYXlUb1V0Y0RhdGUoWyB5ZWFyLCAwLCBmd2QgXSkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgN1xuXG4gIHJldHVybiAtZndkbHcgKyBmd2QgLSAxXG59XG5cblxuLy8gQXJyYXkgQ29udmVyc2lvblxuXG5leHBvcnQgZnVuY3Rpb24gZGF0ZVRvTG9jYWxBcnJheShkYXRlKSB7XG4gIHJldHVybiBbXG4gICAgZGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgIGRhdGUuZ2V0TW9udGgoKSxcbiAgICBkYXRlLmdldERhdGUoKSxcbiAgICBkYXRlLmdldEhvdXJzKCksXG4gICAgZGF0ZS5nZXRNaW51dGVzKCksXG4gICAgZGF0ZS5nZXRTZWNvbmRzKCksXG4gICAgZGF0ZS5nZXRNaWxsaXNlY29uZHMoKVxuICBdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcnJheVRvTG9jYWxEYXRlKGEpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKFxuICAgIGFbMF0sXG4gICAgYVsxXSB8fCAwLFxuICAgIGFbMl0gPT0gbnVsbCA/IDEgOiBhWzJdLCAvLyBkYXkgb2YgbW9udGhcbiAgICBhWzNdIHx8IDAsXG4gICAgYVs0XSB8fCAwLFxuICAgIGFbNV0gfHwgMFxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkYXRlVG9VdGNBcnJheShkYXRlKSB7XG4gIHJldHVybiBbXG4gICAgZGF0ZS5nZXRVVENGdWxsWWVhcigpLFxuICAgIGRhdGUuZ2V0VVRDTW9udGgoKSxcbiAgICBkYXRlLmdldFVUQ0RhdGUoKSxcbiAgICBkYXRlLmdldFVUQ0hvdXJzKCksXG4gICAgZGF0ZS5nZXRVVENNaW51dGVzKCksXG4gICAgZGF0ZS5nZXRVVENTZWNvbmRzKCksXG4gICAgZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKVxuICBdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcnJheVRvVXRjRGF0ZShhKSB7XG5cbiAgLy8gYWNjb3JkaW5nIHRvIHdlYiBzdGFuZGFyZHMgKGFuZCBTYWZhcmkpLCBhIG1vbnRoIGluZGV4IGlzIHJlcXVpcmVkLlxuICAvLyBtYXNzYWdlIGlmIG9ubHkgZ2l2ZW4gYSB5ZWFyLlxuICBpZiAoYS5sZW5ndGggPT09IDEpIHtcbiAgICBhID0gYS5jb25jYXQoWyAwIF0pXG4gIH1cblxuICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkoRGF0ZSwgYSkpXG59XG5cblxuLy8gT3RoZXIgVXRpbHNcblxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWREYXRlKG06IERhdGVNYXJrZXIpIHtcbiAgcmV0dXJuICFpc05hTihtLnZhbHVlT2YoKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVBc01zKG06IERhdGVNYXJrZXIpIHtcbiAgcmV0dXJuIG0uZ2V0VVRDSG91cnMoKSAqIDEwMDAgKiA2MCAqIDYwICtcbiAgICBtLmdldFVUQ01pbnV0ZXMoKSAqIDEwMDAgKiA2MCArXG4gICAgbS5nZXRVVENTZWNvbmRzKCkgKiAxMDAwICtcbiAgICBtLmdldFVUQ01pbGxpc2Vjb25kcygpXG59XG4iLCJpbXBvcnQgeyBEYXRlUmFuZ2UgfSBmcm9tICcuLi9kYXRlbGliL2RhdGUtcmFuZ2UnXG5pbXBvcnQgeyBndWlkIH0gZnJvbSAnLi4vdXRpbC9taXNjJ1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnRJbnN0YW5jZSB7XG4gIGluc3RhbmNlSWQ6IHN0cmluZ1xuICBkZWZJZDogc3RyaW5nXG4gIHJhbmdlOiBEYXRlUmFuZ2VcbiAgZm9yY2VkU3RhcnRUem86IG51bWJlciB8IG51bGxcbiAgZm9yY2VkRW5kVHpvOiBudW1iZXIgfCBudWxsXG59XG5cblxuZXhwb3J0IHR5cGUgRXZlbnRJbnN0YW5jZUhhc2ggPSB7IFtpbnN0YW5jZUlkOiBzdHJpbmddOiBFdmVudEluc3RhbmNlIH1cblxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXZlbnRJbnN0YW5jZShcbiAgZGVmSWQ6IHN0cmluZyxcbiAgcmFuZ2U6IERhdGVSYW5nZSxcbiAgZm9yY2VkU3RhcnRUem8/OiBudW1iZXIsXG4gIGZvcmNlZEVuZFR6bz86IG51bWJlclxuKTogRXZlbnRJbnN0YW5jZSB7XG4gIHJldHVybiB7XG4gICAgaW5zdGFuY2VJZDogZ3VpZCgpLFxuICAgIGRlZklkLFxuICAgIHJhbmdlLFxuICAgIGZvcmNlZFN0YXJ0VHpvOiBmb3JjZWRTdGFydFR6byA9PSBudWxsID8gbnVsbCA6IGZvcmNlZFN0YXJ0VHpvLFxuICAgIGZvcmNlZEVuZFR6bzogZm9yY2VkRW5kVHpvID09IG51bGwgPyBudWxsIDogZm9yY2VkRW5kVHpvXG4gIH1cbn1cbiIsIlxuY29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG5cbi8vIE1lcmdlcyBhbiBhcnJheSBvZiBvYmplY3RzIGludG8gYSBzaW5nbGUgb2JqZWN0LlxuLy8gVGhlIHNlY29uZCBhcmd1bWVudCBhbGxvd3MgZm9yIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHdobydzIG9iamVjdCB2YWx1ZXMgd2lsbCBiZSBtZXJnZWQgdG9nZXRoZXIuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VQcm9wcyhwcm9wT2JqcywgY29tcGxleFByb3BzTWFwPyk6IGFueSB7XG4gIGxldCBkZXN0ID0ge31cblxuICBpZiAoY29tcGxleFByb3BzTWFwKSB7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBjb21wbGV4UHJvcHNNYXApIHtcbiAgICAgIGxldCBjb21wbGV4T2JqcyA9IFtdXG5cbiAgICAgIC8vIGNvbGxlY3QgdGhlIHRyYWlsaW5nIG9iamVjdCB2YWx1ZXMsIHN0b3BwaW5nIHdoZW4gYSBub24tb2JqZWN0IGlzIGRpc2NvdmVyZWRcbiAgICAgIGZvciAobGV0IGkgPSBwcm9wT2Jqcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgdmFsID0gcHJvcE9ianNbaV1bbmFtZV1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsKSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICAgIGNvbXBsZXhPYmpzLnVuc2hpZnQodmFsKVxuICAgICAgICB9IGVsc2UgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGVzdFtuYW1lXSA9IHZhbCAvLyBpZiB0aGVyZSB3ZXJlIG5vIG9iamVjdHMsIHRoaXMgdmFsdWUgd2lsbCBiZSB1c2VkXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBpZiB0aGUgdHJhaWxpbmcgdmFsdWVzIHdlcmUgb2JqZWN0cywgdXNlIHRoZSBtZXJnZWQgdmFsdWVcbiAgICAgIGlmIChjb21wbGV4T2Jqcy5sZW5ndGgpIHtcbiAgICAgICAgZGVzdFtuYW1lXSA9IG1lcmdlUHJvcHMoY29tcGxleE9ianMpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gY29weSB2YWx1ZXMgaW50byB0aGUgZGVzdGluYXRpb24sIGdvaW5nIGZyb20gbGFzdCB0byBmaXJzdFxuICBmb3IgKGxldCBpID0gcHJvcE9ianMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsZXQgcHJvcHMgPSBwcm9wT2Jqc1tpXVxuXG4gICAgZm9yIChsZXQgbmFtZSBpbiBwcm9wcykge1xuICAgICAgaWYgKCEobmFtZSBpbiBkZXN0KSkgeyAvLyBpZiBhbHJlYWR5IGFzc2lnbmVkIGJ5IHByZXZpb3VzIHByb3BzIG9yIGNvbXBsZXggcHJvcHMsIGRvbid0IHJlYXNzaWduXG4gICAgICAgIGRlc3RbbmFtZV0gPSBwcm9wc1tuYW1lXVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZXN0XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlckhhc2goaGFzaCwgZnVuYykge1xuICBsZXQgZmlsdGVyZWQgPSB7fVxuXG4gIGZvciAobGV0IGtleSBpbiBoYXNoKSB7XG4gICAgaWYgKGZ1bmMoaGFzaFtrZXldLCBrZXkpKSB7XG4gICAgICBmaWx0ZXJlZFtrZXldID0gaGFzaFtrZXldXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbHRlcmVkXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcEhhc2g8SW5wdXRJdGVtLCBPdXRwdXRJdGVtPihcbiAgaGFzaDogeyBba2V5OiBzdHJpbmddOiBJbnB1dEl0ZW0gfSxcbiAgZnVuYzogKGlucHV0OiBJbnB1dEl0ZW0sIGtleTogc3RyaW5nKSA9PiBPdXRwdXRJdGVtXG4pOiB7IFtrZXk6IHN0cmluZ106IE91dHB1dEl0ZW0gfSB7XG4gIGxldCBuZXdIYXNoID0ge31cblxuICBmb3IgKGxldCBrZXkgaW4gaGFzaCkge1xuICAgIG5ld0hhc2hba2V5XSA9IGZ1bmMoaGFzaFtrZXldLCBrZXkpXG4gIH1cblxuICByZXR1cm4gbmV3SGFzaFxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBhcnJheVRvSGFzaChhKTogeyBba2V5OiBzdHJpbmddOiB0cnVlIH0geyAvLyBUT0RPOiByZW5hbWUgdG8gc3RyaW5BcnJheVRvSGFzaCBvciBzb21ldGhpbmdcbiAgbGV0IGhhc2ggPSB7fVxuXG4gIGZvciAobGV0IGl0ZW0gb2YgYSkge1xuICAgIGhhc2hbaXRlbV0gPSB0cnVlXG4gIH1cblxuICByZXR1cm4gaGFzaFxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEhhc2hGcm9tQXJyYXk8SXRlbSwgSXRlbVJlcz4oYTogSXRlbVtdLCBmdW5jOiAoaXRlbTogSXRlbSwgaW5kZXg6IG51bWJlcikgPT4gWyBzdHJpbmcsIEl0ZW1SZXMgXSkge1xuICBsZXQgaGFzaDogeyBba2V5OiBzdHJpbmddOiBJdGVtUmVzIH0gPSB7fVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGxldCB0dXBsZSA9IGZ1bmMoYVtpXSwgaSlcblxuICAgIGhhc2hbdHVwbGVbMF1dID0gdHVwbGVbMV1cbiAgfVxuXG4gIHJldHVybiBoYXNoXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc2hWYWx1ZXNUb0FycmF5KG9iaikgeyAvLyBjYW4ndCB1c2UgT2JqZWN0LnZhbHVlcyB5ZXQgYmVjYXVzZSBvZiBubyBJRSBzdXBwb3J0XG4gIGxldCBhID0gW11cblxuICBmb3IgKGxldCBrZXkgaW4gb2JqKSB7XG4gICAgYS5wdXNoKG9ialtrZXldKVxuICB9XG5cbiAgcmV0dXJuIGFcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gaXNQcm9wc0VxdWFsKG9iajAsIG9iajEpIHsgLy8gVE9ETzogbWVyZ2Ugd2l0aCBjb21wYXJlT2Jqc1xuXG4gIGlmIChvYmowID09PSBvYmoxKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZvciAobGV0IGtleSBpbiBvYmowKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqMCwga2V5KSkge1xuICAgICAgaWYgKCEoa2V5IGluIG9iajEpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGtleSBpbiBvYmoxKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqMSwga2V5KSkge1xuICAgICAgaWYgKG9iajBba2V5XSAhPT0gb2JqMVtrZXldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVuZXF1YWxQcm9wcyhvYmowLCBvYmoxKSB7XG4gIGxldCBrZXlzOiBzdHJpbmdbXSA9IFtdXG5cbiAgZm9yIChsZXQga2V5IGluIG9iajApIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmowLCBrZXkpKSB7XG4gICAgICBpZiAoIShrZXkgaW4gb2JqMSkpIHtcbiAgICAgICAga2V5cy5wdXNoKGtleSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCBrZXkgaW4gb2JqMSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajEsIGtleSkpIHtcbiAgICAgIGlmIChvYmowW2tleV0gIT09IG9iajFba2V5XSkge1xuICAgICAgICBrZXlzLnB1c2goa2V5KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBrZXlzXG59XG5cblxuXG5leHBvcnQgdHlwZSBFcXVhbGl0eUZ1bmM8VD4gPSAoYTogVCwgYjogVCkgPT4gYm9vbGVhblxuZXhwb3J0IHR5cGUgRXF1YWxpdHlUaGluZzxUPiA9IEVxdWFsaXR5RnVuYzxUPiB8IHRydWVcblxuZXhwb3J0IHR5cGUgRXF1YWxpdHlGdW5jczxPYmpUeXBlPiA9IHsgLy8gbm90IHJlYWxseSBqdXN0IGEgXCJmdW5jXCIgYW55bW9yZVxuICBbSyBpbiBrZXlvZiBPYmpUeXBlXT86IEVxdWFsaXR5VGhpbmc8T2JqVHlwZVtLXT5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVPYmpzKG9sZFByb3BzLCBuZXdQcm9wcywgZXF1YWxpdHlGdW5jczogRXF1YWxpdHlGdW5jczxhbnk+ID0ge30pIHtcblxuICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZvciAobGV0IGtleSBpbiBuZXdQcm9wcykge1xuICAgIGlmIChrZXkgaW4gb2xkUHJvcHMgJiYgaXNPYmpWYWxzRXF1YWwob2xkUHJvcHNba2V5XSwgbmV3UHJvcHNba2V5XSwgZXF1YWxpdHlGdW5jc1trZXldKSkge1xuICAgICAgLy8gZXF1YWxcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgZm9yIHByb3BzIHRoYXQgd2VyZSBvbWl0dGVkIGluIHRoZSBuZXdcbiAgZm9yIChsZXQga2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKCEoa2V5IGluIG5ld1Byb3BzKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLypcbmFzc3VtZWQgXCJ0cnVlXCIgZXF1YWxpdHkgZm9yIGhhbmRsZXIgbmFtZXMgbGlrZSBcIm9uUmVjZWl2ZVNvbWV0aGluZ1wiXG4qL1xuZnVuY3Rpb24gaXNPYmpWYWxzRXF1YWw8VD4odmFsMDogVCwgdmFsMTogVCwgY29tcGFyYXRvcjogRXF1YWxpdHlUaGluZzxUPikge1xuICBpZiAodmFsMCA9PT0gdmFsMSB8fCBjb21wYXJhdG9yID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoY29tcGFyYXRvcikge1xuICAgIHJldHVybiBjb21wYXJhdG9yKHZhbDAsIHZhbDEpXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbGxlY3RGcm9tSGFzaDxJdGVtPihcbiAgaGFzaDogeyBba2V5OiBzdHJpbmddOiBJdGVtIH0sXG4gIHN0YXJ0SW5kZXggPSAwLFxuICBlbmRJbmRleD86IG51bWJlcixcbiAgc3RlcCA9IDEsXG4pIHtcbiAgbGV0IHJlczogSXRlbVtdID0gW11cblxuICBpZiAoZW5kSW5kZXggPT0gbnVsbCkge1xuICAgIGVuZEluZGV4ID0gT2JqZWN0LmtleXMoaGFzaCkubGVuZ3RoXG4gIH1cblxuICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpICs9IHN0ZXApIHtcbiAgICBsZXQgdmFsID0gaGFzaFtpXVxuXG4gICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7IC8vIHdpbGwgZGlzcmVnYXJkIHVuZGVmaW5lZCBmb3Igc3BhcnNlIGFycmF5c1xuICAgICAgcmVzLnB1c2godmFsKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXNcbn1cbiIsImltcG9ydCB7IEV2ZW50RGVmIH0gZnJvbSAnLi9ldmVudC1kZWYnXG5pbXBvcnQgeyBFdmVudEluc3RhbmNlLCBjcmVhdGVFdmVudEluc3RhbmNlIH0gZnJvbSAnLi9ldmVudC1pbnN0YW5jZSdcbmltcG9ydCB7IERhdGVSYW5nZSB9IGZyb20gJy4uL2RhdGVsaWIvZGF0ZS1yYW5nZSdcbmltcG9ydCB7IERhdGVFbnYgfSBmcm9tICcuLi9kYXRlbGliL2VudidcbmltcG9ydCB7IER1cmF0aW9uIH0gZnJvbSAnLi4vZGF0ZWxpYi9kdXJhdGlvbidcbmltcG9ydCB7IERhdGVNYXJrZXIsIHN0YXJ0T2ZEYXkgfSBmcm9tICcuLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IEV2ZW50U3RvcmUgfSBmcm9tICcuL2V2ZW50LXN0b3JlJ1xuaW1wb3J0IHsgQ2FsZW5kYXJDb250ZXh0IH0gZnJvbSAnLi4vQ2FsZW5kYXJDb250ZXh0J1xuaW1wb3J0IHsgZmlsdGVySGFzaCB9IGZyb20gJy4uL3V0aWwvb2JqZWN0J1xuaW1wb3J0IHsgRXZlbnRSZWZpbmVkIH0gZnJvbSAnLi9ldmVudC1wYXJzZSdcblxuLypcblRoZSBwbHVnaW4gc3lzdGVtIGZvciBkZWZpbmluZyBob3cgYSByZWN1cnJpbmcgZXZlbnQgaXMgZXhwYW5kZWQgaW50byBpbmRpdmlkdWFsIGluc3RhbmNlcy5cbiovXG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFyc2VkUmVjdXJyaW5nPFJlY3VycmluZ0RhdGE+IHtcbiAgdHlwZURhdGE6IFJlY3VycmluZ0RhdGFcbiAgYWxsRGF5R3Vlc3M6IGJvb2xlYW4gfCBudWxsXG4gIGR1cmF0aW9uOiBEdXJhdGlvbiB8IG51bGwgLy8gc2lnbmFscyBoYXNFbmRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWN1cnJpbmdUeXBlPFJlY3VycmluZ0RhdGE+IHtcbiAgcGFyc2U6IChyZWZpbmVkOiBFdmVudFJlZmluZWQsIGRhdGVFbnY6IERhdGVFbnYpID0+IFBhcnNlZFJlY3VycmluZzxSZWN1cnJpbmdEYXRhPiB8IG51bGwgLy8gVE9ETzogcmVuYW1lIHRvIHBvc3QtcHJvY2VzcyBvciBzb21ldGhpbmdcbiAgZXhwYW5kOiAodHlwZURhdGE6IGFueSwgZnJhbWluZ1JhbmdlOiBEYXRlUmFuZ2UsIGRhdGVFbnY6IERhdGVFbnYpID0+IERhdGVNYXJrZXJbXVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJlY3VycmluZyhcbiAgcmVmaW5lZDogRXZlbnRSZWZpbmVkLFxuICBkZWZhdWx0QWxsRGF5OiBib29sZWFuIHwgbnVsbCxcbiAgZGF0ZUVudjogRGF0ZUVudixcbiAgcmVjdXJyaW5nVHlwZXM6IFJlY3VycmluZ1R5cGU8YW55PltdXG4pIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN1cnJpbmdUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBwYXJzZWQgPSByZWN1cnJpbmdUeXBlc1tpXS5wYXJzZShyZWZpbmVkLCBkYXRlRW52KVxuXG4gICAgaWYgKHBhcnNlZCkge1xuXG4gICAgICBsZXQgYWxsRGF5ID0gcmVmaW5lZC5hbGxEYXlcbiAgICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICBhbGxEYXkgPSBkZWZhdWx0QWxsRGF5XG4gICAgICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICAgIGFsbERheSA9IHBhcnNlZC5hbGxEYXlHdWVzc1xuICAgICAgICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgYWxsRGF5ID0gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWxsRGF5LFxuICAgICAgICBkdXJhdGlvbjogcGFyc2VkLmR1cmF0aW9uLFxuICAgICAgICB0eXBlRGF0YTogcGFyc2VkLnR5cGVEYXRhLFxuICAgICAgICB0eXBlSWQ6IGlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRSZWN1cnJpbmcoZXZlbnRTdG9yZTogRXZlbnRTdG9yZSwgZnJhbWluZ1JhbmdlOiBEYXRlUmFuZ2UsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCk6IEV2ZW50U3RvcmUge1xuICBsZXQgeyBkYXRlRW52LCBwbHVnaW5Ib29rcywgb3B0aW9ucyB9ID0gY29udGV4dFxuICBsZXQgeyBkZWZzLCBpbnN0YW5jZXMgfSA9IGV2ZW50U3RvcmVcblxuICAvLyByZW1vdmUgZXhpc3RpbmcgcmVjdXJyaW5nIGluc3RhbmNlc1xuICAvLyBUT0RPOiBiYWQuIGFsd2F5cyBleHBhbmQgZXZlbnRzIGFzIGEgc2Vjb25kIHN0ZXBcbiAgaW5zdGFuY2VzID0gZmlsdGVySGFzaChpbnN0YW5jZXMsIGZ1bmN0aW9uKGluc3RhbmNlOiBFdmVudEluc3RhbmNlKSB7XG4gICAgcmV0dXJuICFkZWZzW2luc3RhbmNlLmRlZklkXS5yZWN1cnJpbmdEZWZcbiAgfSlcblxuICBmb3IgKGxldCBkZWZJZCBpbiBkZWZzKSB7XG4gICAgbGV0IGRlZiA9IGRlZnNbZGVmSWRdXG5cbiAgICBpZiAoZGVmLnJlY3VycmluZ0RlZikge1xuICAgICAgbGV0IGR1cmF0aW9uID0gZGVmLnJlY3VycmluZ0RlZi5kdXJhdGlvblxuXG4gICAgICBpZiAoIWR1cmF0aW9uKSB7XG4gICAgICAgIGR1cmF0aW9uID0gZGVmLmFsbERheSA/XG4gICAgICAgICAgb3B0aW9ucy5kZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbiA6XG4gICAgICAgICAgb3B0aW9ucy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uXG4gICAgICB9XG5cbiAgICAgIGxldCBzdGFydHMgPSBleHBhbmRSZWN1cnJpbmdSYW5nZXMoZGVmLCBkdXJhdGlvbiwgZnJhbWluZ1JhbmdlLCBkYXRlRW52LCBwbHVnaW5Ib29rcy5yZWN1cnJpbmdUeXBlcylcblxuICAgICAgZm9yIChsZXQgc3RhcnQgb2Ygc3RhcnRzKSB7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmSWQsIHtcbiAgICAgICAgICBzdGFydCxcbiAgICAgICAgICBlbmQ6IGRhdGVFbnYuYWRkKHN0YXJ0LCBkdXJhdGlvbilcbiAgICAgICAgfSlcbiAgICAgICAgaW5zdGFuY2VzW2luc3RhbmNlLmluc3RhbmNlSWRdID0gaW5zdGFuY2VcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4geyBkZWZzLCBpbnN0YW5jZXMgfVxufVxuXG5cbi8qXG5FdmVudCBNVVNUIGhhdmUgYSByZWN1cnJpbmdEZWZcbiovXG5mdW5jdGlvbiBleHBhbmRSZWN1cnJpbmdSYW5nZXMoXG4gIGV2ZW50RGVmOiBFdmVudERlZixcbiAgZHVyYXRpb246IER1cmF0aW9uLFxuICBmcmFtaW5nUmFuZ2U6IERhdGVSYW5nZSxcbiAgZGF0ZUVudjogRGF0ZUVudixcbiAgcmVjdXJyaW5nVHlwZXM6IFJlY3VycmluZ1R5cGU8YW55PltdXG4pOiBEYXRlTWFya2VyW10ge1xuICBsZXQgdHlwZURlZiA9IHJlY3VycmluZ1R5cGVzW2V2ZW50RGVmLnJlY3VycmluZ0RlZi50eXBlSWRdXG4gIGxldCBtYXJrZXJzID0gdHlwZURlZi5leHBhbmQoXG4gICAgZXZlbnREZWYucmVjdXJyaW5nRGVmLnR5cGVEYXRhLFxuICAgIHtcbiAgICAgIHN0YXJ0OiBkYXRlRW52LnN1YnRyYWN0KGZyYW1pbmdSYW5nZS5zdGFydCwgZHVyYXRpb24pLCAvLyBmb3Igd2hlbiBldmVudCBzdGFydHMgYmVmb3JlIGZyYW1pbmcgcmFuZ2UgYW5kIGdvZXMgaW50b1xuICAgICAgZW5kOiBmcmFtaW5nUmFuZ2UuZW5kXG4gICAgfSxcbiAgICBkYXRlRW52XG4gIClcblxuICAvLyB0aGUgcmVjdXJyZW5jZSBwbHVnaW5zIGRvbid0IGd1YXJhbnRlZSB0aGF0IGFsbC1kYXkgZXZlbnRzIGFyZSBzdGFydC1vZi1kYXksIHNvIHdlIGhhdmUgdG9cbiAgaWYgKGV2ZW50RGVmLmFsbERheSkge1xuICAgIG1hcmtlcnMgPSBtYXJrZXJzLm1hcChzdGFydE9mRGF5KVxuICB9XG5cbiAgcmV0dXJuIG1hcmtlcnNcbn1cbiIsImltcG9ydCB7IGlzSW50IH0gZnJvbSAnLi4vdXRpbC9taXNjJ1xuXG5leHBvcnQgdHlwZSBEdXJhdGlvbklucHV0ID0gRHVyYXRpb25PYmplY3RJbnB1dCB8IHN0cmluZyB8IG51bWJlclxuXG5leHBvcnQgaW50ZXJmYWNlIER1cmF0aW9uT2JqZWN0SW5wdXQge1xuICB5ZWFycz86IG51bWJlclxuICB5ZWFyPzogbnVtYmVyXG4gIG1vbnRocz86IG51bWJlclxuICBtb250aD86IG51bWJlclxuICB3ZWVrcz86IG51bWJlclxuICB3ZWVrPzogbnVtYmVyXG4gIGRheXM/OiBudW1iZXJcbiAgZGF5PzogbnVtYmVyXG4gIGhvdXJzPzogbnVtYmVyXG4gIGhvdXI/OiBudW1iZXJcbiAgbWludXRlcz86IG51bWJlclxuICBtaW51dGU/OiBudW1iZXJcbiAgc2Vjb25kcz86IG51bWJlclxuICBzZWNvbmQ/OiBudW1iZXJcbiAgbWlsbGlzZWNvbmRzPzogbnVtYmVyXG4gIG1pbGxpc2Vjb25kPzogbnVtYmVyXG4gIG1zPzogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRHVyYXRpb24ge1xuICB5ZWFyczogbnVtYmVyXG4gIG1vbnRoczogbnVtYmVyXG4gIGRheXM6IG51bWJlclxuICBtaWxsaXNlY29uZHM6IG51bWJlclxuICBzcGVjaWZpZWRXZWVrcz86IGJvb2xlYW5cbn1cblxuY29uc3QgSU5URVJOQUxfVU5JVFMgPSBbICd5ZWFycycsICdtb250aHMnLCAnZGF5cycsICdtaWxsaXNlY29uZHMnIF1cbmNvbnN0IFBBUlNFX1JFID0gL14oLT8pKD86KFxcZCspXFwuKT8oXFxkKyk6KFxcZFxcZCkoPzo6KFxcZFxcZCkoPzpcXC4oXFxkXFxkXFxkKSk/KT8vXG5cblxuLy8gUGFyc2luZyBhbmQgQ3JlYXRpb25cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uKGlucHV0OiBEdXJhdGlvbklucHV0LCB1bml0Pzogc3RyaW5nKTogRHVyYXRpb24gfCBudWxsIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VTdHJpbmcoaW5wdXQpXG4gIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICByZXR1cm4gcGFyc2VPYmplY3QoaW5wdXQpXG4gIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBwYXJzZU9iamVjdCh7IFt1bml0IHx8ICdtaWxsaXNlY29uZHMnXTogaW5wdXQgfSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHM6IHN0cmluZyk6IER1cmF0aW9uIHtcbiAgbGV0IG0gPSBQQVJTRV9SRS5leGVjKHMpXG4gIGlmIChtKSB7XG4gICAgbGV0IHNpZ24gPSBtWzFdID8gLTEgOiAxXG4gICAgcmV0dXJuIHtcbiAgICAgIHllYXJzOiAwLFxuICAgICAgbW9udGhzOiAwLFxuICAgICAgZGF5czogc2lnbiAqIChtWzJdID8gcGFyc2VJbnQobVsyXSwgMTApIDogMCksXG4gICAgICBtaWxsaXNlY29uZHM6IHNpZ24gKiAoXG4gICAgICAgIChtWzNdID8gcGFyc2VJbnQobVszXSwgMTApIDogMCkgKiA2MCAqIDYwICogMTAwMCArIC8vIGhvdXJzXG4gICAgICAgIChtWzRdID8gcGFyc2VJbnQobVs0XSwgMTApIDogMCkgKiA2MCAqIDEwMDAgKyAvLyBtaW51dGVzXG4gICAgICAgIChtWzVdID8gcGFyc2VJbnQobVs1XSwgMTApIDogMCkgKiAxMDAwICsgLy8gc2Vjb25kc1xuICAgICAgICAobVs2XSA/IHBhcnNlSW50KG1bNl0sIDEwKSA6IDApIC8vIG1zXG4gICAgICApXG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIHBhcnNlT2JqZWN0KG9iajogRHVyYXRpb25PYmplY3RJbnB1dCk6IER1cmF0aW9uIHtcbiAgbGV0IGR1cmF0aW9uOiBEdXJhdGlvbiA9IHtcbiAgICB5ZWFyczogb2JqLnllYXJzIHx8IG9iai55ZWFyIHx8IDAsXG4gICAgbW9udGhzOiBvYmoubW9udGhzIHx8IG9iai5tb250aCB8fCAwLFxuICAgIGRheXM6IG9iai5kYXlzIHx8IG9iai5kYXkgfHwgMCxcbiAgICBtaWxsaXNlY29uZHM6XG4gICAgICAob2JqLmhvdXJzIHx8IG9iai5ob3VyIHx8IDApICogNjAgKiA2MCAqIDEwMDAgKyAvLyBob3Vyc1xuICAgICAgKG9iai5taW51dGVzIHx8IG9iai5taW51dGUgfHwgMCkgKiA2MCAqIDEwMDAgKyAvLyBtaW51dGVzXG4gICAgICAob2JqLnNlY29uZHMgfHwgb2JqLnNlY29uZCB8fCAwKSAqIDEwMDAgKyAvLyBzZWNvbmRzXG4gICAgICAob2JqLm1pbGxpc2Vjb25kcyB8fCBvYmoubWlsbGlzZWNvbmQgfHwgb2JqLm1zIHx8IDApIC8vIG1zXG4gIH1cblxuICBsZXQgd2Vla3MgPSBvYmoud2Vla3MgfHwgb2JqLndlZWtcbiAgaWYgKHdlZWtzKSB7XG4gICAgZHVyYXRpb24uZGF5cyArPSB3ZWVrcyAqIDdcbiAgICBkdXJhdGlvbi5zcGVjaWZpZWRXZWVrcyA9IHRydWVcbiAgfVxuXG4gIHJldHVybiBkdXJhdGlvblxufVxuXG5cbi8vIEVxdWFsaXR5XG5cbmV4cG9ydCBmdW5jdGlvbiBkdXJhdGlvbnNFcXVhbChkMDogRHVyYXRpb24sIGQxOiBEdXJhdGlvbik6IGJvb2xlYW4ge1xuICByZXR1cm4gZDAueWVhcnMgPT09IGQxLnllYXJzICYmXG4gICAgZDAubW9udGhzID09PSBkMS5tb250aHMgJiZcbiAgICBkMC5kYXlzID09PSBkMS5kYXlzICYmXG4gICAgZDAubWlsbGlzZWNvbmRzID09PSBkMS5taWxsaXNlY29uZHNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2luZ2xlRGF5KGR1cjogRHVyYXRpb24pIHtcbiAgcmV0dXJuIGR1ci55ZWFycyA9PT0gMCAmJiBkdXIubW9udGhzID09PSAwICYmIGR1ci5kYXlzID09PSAxICYmIGR1ci5taWxsaXNlY29uZHMgPT09IDBcbn1cblxuXG4vLyBTaW1wbGUgTWF0aFxuXG5leHBvcnQgZnVuY3Rpb24gYWRkRHVyYXRpb25zKGQwOiBEdXJhdGlvbiwgZDE6IER1cmF0aW9uKSB7XG4gIHJldHVybiB7XG4gICAgeWVhcnM6IGQwLnllYXJzICsgZDEueWVhcnMsXG4gICAgbW9udGhzOiBkMC5tb250aHMgKyBkMS5tb250aHMsXG4gICAgZGF5czogZDAuZGF5cyArIGQxLmRheXMsXG4gICAgbWlsbGlzZWNvbmRzOiBkMC5taWxsaXNlY29uZHMgKyBkMS5taWxsaXNlY29uZHNcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3REdXJhdGlvbnMoZDE6IER1cmF0aW9uLCBkMDogRHVyYXRpb24pOiBEdXJhdGlvbiB7XG4gIHJldHVybiB7XG4gICAgeWVhcnM6IGQxLnllYXJzIC0gZDAueWVhcnMsXG4gICAgbW9udGhzOiBkMS5tb250aHMgLSBkMC5tb250aHMsXG4gICAgZGF5czogZDEuZGF5cyAtIGQwLmRheXMsXG4gICAgbWlsbGlzZWNvbmRzOiBkMS5taWxsaXNlY29uZHMgLSBkMC5taWxsaXNlY29uZHNcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlEdXJhdGlvbihkOiBEdXJhdGlvbiwgbjogbnVtYmVyKSB7XG4gIHJldHVybiB7XG4gICAgeWVhcnM6IGQueWVhcnMgKiBuLFxuICAgIG1vbnRoczogZC5tb250aHMgKiBuLFxuICAgIGRheXM6IGQuZGF5cyAqIG4sXG4gICAgbWlsbGlzZWNvbmRzOiBkLm1pbGxpc2Vjb25kcyAqIG5cbiAgfVxufVxuXG5cbi8vIENvbnZlcnNpb25zXG4vLyBcIlJvdWdoXCIgYmVjYXVzZSB0aGV5IGFyZSBiYXNlZCBvbiBhdmVyYWdlLWNhc2UgR3JlZ29yaWFuIG1vbnRocy95ZWFyc1xuXG5leHBvcnQgZnVuY3Rpb24gYXNSb3VnaFllYXJzKGR1cjogRHVyYXRpb24pIHtcbiAgcmV0dXJuIGFzUm91Z2hEYXlzKGR1cikgLyAzNjVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzUm91Z2hNb250aHMoZHVyOiBEdXJhdGlvbikge1xuICByZXR1cm4gYXNSb3VnaERheXMoZHVyKSAvIDMwXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc1JvdWdoRGF5cyhkdXI6IER1cmF0aW9uKSB7XG4gIHJldHVybiBhc1JvdWdoTXMoZHVyKSAvIDg2NGU1XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc1JvdWdoSG91cnMoZHVyOiBEdXJhdGlvbikge1xuICByZXR1cm4gYXNSb3VnaE1zKGR1cikgLyAoMTAwMCAqIDYwICogNjApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc1JvdWdoTWludXRlcyhkdXI6IER1cmF0aW9uKSB7XG4gIHJldHVybiBhc1JvdWdoTXMoZHVyKSAvICgxMDAwICogNjApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc1JvdWdoU2Vjb25kcyhkdXI6IER1cmF0aW9uKSB7XG4gIHJldHVybiBhc1JvdWdoTXMoZHVyKSAvIDEwMDBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzUm91Z2hNcyhkdXI6IER1cmF0aW9uKSB7XG4gIHJldHVybiBkdXIueWVhcnMgKiAoMzY1ICogODY0ZTUpICtcbiAgICBkdXIubW9udGhzICogKDMwICogODY0ZTUpICtcbiAgICBkdXIuZGF5cyAqIDg2NGU1ICtcbiAgICBkdXIubWlsbGlzZWNvbmRzXG59XG5cblxuLy8gQWR2YW5jZWQgTWF0aFxuXG5leHBvcnQgZnVuY3Rpb24gd2hvbGVEaXZpZGVEdXJhdGlvbnMobnVtZXJhdG9yOiBEdXJhdGlvbiwgZGVub21pbmF0b3I6IER1cmF0aW9uKTogbnVtYmVyIHtcbiAgbGV0IHJlcyA9IG51bGxcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IElOVEVSTkFMX1VOSVRTLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IHVuaXQgPSBJTlRFUk5BTF9VTklUU1tpXVxuXG4gICAgaWYgKGRlbm9taW5hdG9yW3VuaXRdKSB7XG4gICAgICBsZXQgbG9jYWxSZXMgPSBudW1lcmF0b3JbdW5pdF0gLyBkZW5vbWluYXRvclt1bml0XVxuXG4gICAgICBpZiAoIWlzSW50KGxvY2FsUmVzKSB8fCAocmVzICE9PSBudWxsICYmIHJlcyAhPT0gbG9jYWxSZXMpKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIHJlcyA9IGxvY2FsUmVzXG5cbiAgICB9IGVsc2UgaWYgKG51bWVyYXRvclt1bml0XSkge1xuICAgICAgLy8gbmVlZHMgdG8gZGl2aWRlIGJ5IHNvbWV0aGluZyBidXQgY2FuJ3QhXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXI6IER1cmF0aW9uKSB7XG4gIGxldCBtcyA9IGR1ci5taWxsaXNlY29uZHNcbiAgaWYgKG1zKSB7XG4gICAgaWYgKG1zICUgMTAwMCAhPT0gMCkge1xuICAgICAgcmV0dXJuIHsgdW5pdDogJ21pbGxpc2Vjb25kJywgdmFsdWU6IG1zIH1cbiAgICB9XG4gICAgaWYgKG1zICUgKDEwMDAgKiA2MCkgIT09IDApIHtcbiAgICAgIHJldHVybiB7IHVuaXQ6ICdzZWNvbmQnLCB2YWx1ZTogbXMgLyAxMDAwIH1cbiAgICB9XG4gICAgaWYgKG1zICUgKDEwMDAgKiA2MCAqIDYwKSAhPT0gMCkge1xuICAgICAgcmV0dXJuIHsgdW5pdDogJ21pbnV0ZScsIHZhbHVlOiBtcyAvICgxMDAwICogNjApIH1cbiAgICB9XG4gICAgaWYgKG1zKSB7XG4gICAgICByZXR1cm4geyB1bml0OiAnaG91cicsIHZhbHVlOiBtcyAvICgxMDAwICogNjAgKiA2MCkgfVxuICAgIH1cbiAgfVxuICBpZiAoZHVyLmRheXMpIHtcbiAgICBpZiAoZHVyLnNwZWNpZmllZFdlZWtzICYmIGR1ci5kYXlzICUgNyA9PT0gMCkge1xuICAgICAgcmV0dXJuIHsgdW5pdDogJ3dlZWsnLCB2YWx1ZTogZHVyLmRheXMgLyA3IH1cbiAgICB9XG4gICAgcmV0dXJuIHsgdW5pdDogJ2RheScsIHZhbHVlOiBkdXIuZGF5cyB9XG4gIH1cbiAgaWYgKGR1ci5tb250aHMpIHtcbiAgICByZXR1cm4geyB1bml0OiAnbW9udGgnLCB2YWx1ZTogZHVyLm1vbnRocyB9XG4gIH1cbiAgaWYgKGR1ci55ZWFycykge1xuICAgIHJldHVybiB7IHVuaXQ6ICd5ZWFyJywgdmFsdWU6IGR1ci55ZWFycyB9XG4gIH1cbiAgcmV0dXJuIHsgdW5pdDogJ21pbGxpc2Vjb25kJywgdmFsdWU6IDAgfVxufVxuIiwiaW1wb3J0IHsgRGF0ZU1hcmtlciB9IGZyb20gJy4vbWFya2VyJ1xuaW1wb3J0IHsgcGFkU3RhcnQgfSBmcm9tICcuLi91dGlsL21pc2MnXG5cblxuLy8gdGltZVpvbmVPZmZzZXQgaXMgaW4gbWludXRlc1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkSXNvU3RyaW5nKG1hcmtlcjogRGF0ZU1hcmtlciwgdGltZVpvbmVPZmZzZXQ/OiBudW1iZXIsIHN0cmlwWmVyb1RpbWU6IGJvb2xlYW4gPSBmYWxzZSkge1xuICBsZXQgcyA9IG1hcmtlci50b0lTT1N0cmluZygpXG5cbiAgcyA9IHMucmVwbGFjZSgnLjAwMCcsICcnKVxuXG4gIGlmIChzdHJpcFplcm9UaW1lKSB7XG4gICAgcyA9IHMucmVwbGFjZSgnVDAwOjAwOjAwWicsICcnKVxuICB9XG5cbiAgaWYgKHMubGVuZ3RoID4gMTApIHsgLy8gdGltZSBwYXJ0IHdhc24ndCBzdHJpcHBlZCwgY2FuIGFkZCB0aW1lem9uZSBpbmZvXG4gICAgaWYgKHRpbWVab25lT2Zmc2V0ID09IG51bGwpIHtcbiAgICAgIHMgPSBzLnJlcGxhY2UoJ1onLCAnJylcbiAgICB9IGVsc2UgaWYgKHRpbWVab25lT2Zmc2V0ICE9PSAwKSB7XG4gICAgICBzID0gcy5yZXBsYWNlKCdaJywgZm9ybWF0VGltZVpvbmVPZmZzZXQodGltZVpvbmVPZmZzZXQsIHRydWUpKVxuICAgIH1cbiAgICAvLyBvdGhlcndpc2UsIGl0cyBVVEMtMCBhbmQgd2Ugd2FudCB0byBrZWVwIHRoZSBaXG4gIH1cblxuICByZXR1cm4gc1xufVxuXG5cbi8vIGZvcm1hdHMgdGhlIGRhdGUsIGJ1dCB3aXRoIG5vIHRpbWUgcGFydFxuLy8gVE9ETzogc29tZWhvdyBtZXJnZSB3aXRoIGJ1aWxkSXNvU3RyaW5nIGFuZCBzdHJpcFplcm9UaW1lXG4vLyBUT0RPOiByZW5hbWUuIG9taXQgXCJzdHJpbmdcIlxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERheVN0cmluZyhtYXJrZXI6IERhdGVNYXJrZXIpIHtcbiAgcmV0dXJuIG1hcmtlci50b0lTT1N0cmluZygpLnJlcGxhY2UoL1QuKiQvLCAnJylcbn1cblxuXG4vLyBUT0RPOiB1c2UgRGF0ZTo6dG9JU09TdHJpbmcgYW5kIHVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBUP1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdElzb1RpbWVTdHJpbmcobWFya2VyOiBEYXRlTWFya2VyKSB7XG4gIHJldHVybiBwYWRTdGFydChtYXJrZXIuZ2V0VVRDSG91cnMoKSwgMikgKyAnOicgK1xuICAgIHBhZFN0YXJ0KG1hcmtlci5nZXRVVENNaW51dGVzKCksIDIpICsgJzonICtcbiAgICBwYWRTdGFydChtYXJrZXIuZ2V0VVRDU2Vjb25kcygpLCAyKVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRUaW1lWm9uZU9mZnNldChtaW51dGVzOiBudW1iZXIsIGRvSXNvID0gZmFsc2UpIHtcbiAgbGV0IHNpZ24gPSBtaW51dGVzIDwgMCA/ICctJyA6ICcrJ1xuICBsZXQgYWJzID0gTWF0aC5hYnMobWludXRlcylcbiAgbGV0IGhvdXJzID0gTWF0aC5mbG9vcihhYnMgLyA2MClcbiAgbGV0IG1pbnMgPSBNYXRoLnJvdW5kKGFicyAlIDYwKVxuXG4gIGlmIChkb0lzbykge1xuICAgIHJldHVybiBzaWduICsgcGFkU3RhcnQoaG91cnMsIDIpICsgJzonICsgcGFkU3RhcnQobWlucywgMilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJ0dNVCcgKyBzaWduICsgaG91cnMgKyAobWlucyA/ICc6JyArIHBhZFN0YXJ0KG1pbnMsIDIpIDogJycpXG4gIH1cbn1cbiIsImltcG9ydCB7IGlzQXJyYXlzRXF1YWwgfSBmcm9tICcuL2FycmF5J1xuaW1wb3J0IHsgaXNQcm9wc0VxdWFsIH0gZnJvbSAnLi9vYmplY3QnXG5pbXBvcnQgeyBEaWN0aW9uYXJ5IH0gZnJvbSAnLi4vb3B0aW9ucydcblxuXG5leHBvcnQgZnVuY3Rpb24gbWVtb2l6ZTxBcmdzIGV4dGVuZHMgYW55W10sIFJlcz4oXG4gIHdvcmtlckZ1bmM6ICguLi5hcmdzOiBBcmdzKSA9PiBSZXMsXG4gIHJlc0VxdWFsaXR5PzogKHJlczA6IFJlcywgcmVzMTogUmVzKSA9PiBib29sZWFuLFxuICB0ZWFyZG93bkZ1bmM/OiAocmVzOiBSZXMpID0+IHZvaWRcbik6ICguLi5hcmdzOiBBcmdzKSA9PiBSZXMge1xuXG4gIGxldCBjdXJyZW50QXJnczogQXJncyB8IHVuZGVmaW5lZFxuICBsZXQgY3VycmVudFJlczogUmVzIHwgdW5kZWZpbmVkXG5cbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLm5ld0FyZ3M6IEFyZ3MpIHtcblxuICAgIGlmICghY3VycmVudEFyZ3MpIHtcbiAgICAgIGN1cnJlbnRSZXMgPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ3MpXG5cbiAgICB9IGVsc2UgaWYgKCFpc0FycmF5c0VxdWFsKGN1cnJlbnRBcmdzLCBuZXdBcmdzKSkge1xuXG4gICAgICBpZiAodGVhcmRvd25GdW5jKSB7XG4gICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzKVxuICAgICAgfVxuXG4gICAgICBsZXQgcmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdzKVxuXG4gICAgICBpZiAoIXJlc0VxdWFsaXR5IHx8ICFyZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXMpKSB7XG4gICAgICAgIGN1cnJlbnRSZXMgPSByZXNcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50QXJncyA9IG5ld0FyZ3NcblxuICAgIHJldHVybiBjdXJyZW50UmVzXG4gIH1cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gbWVtb2l6ZU9iakFyZzxBcmcgZXh0ZW5kcyBEaWN0aW9uYXJ5LCBSZXM+KFxuICB3b3JrZXJGdW5jOiAoYXJnOiBBcmcpID0+IFJlcyxcbiAgcmVzRXF1YWxpdHk/OiAocmVzMDogUmVzLCByZXMxOiBSZXMpID0+IGJvb2xlYW4sXG4gIHRlYXJkb3duRnVuYz86IChyZXM6IFJlcykgPT4gdm9pZFxuKTogKGFyZzogQXJnKSA9PiBSZXMge1xuXG4gIGxldCBjdXJyZW50QXJnOiBBcmcgfCB1bmRlZmluZWRcbiAgbGV0IGN1cnJlbnRSZXM6IFJlcyB8IHVuZGVmaW5lZFxuXG4gIHJldHVybiBmdW5jdGlvbihuZXdBcmc6IEFyZykge1xuXG4gICAgaWYgKCFjdXJyZW50QXJnKSB7XG4gICAgICBjdXJyZW50UmVzID0gd29ya2VyRnVuYy5jYWxsKHRoaXMsIG5ld0FyZylcblxuICAgIH0gZWxzZSBpZiAoIWlzUHJvcHNFcXVhbChjdXJyZW50QXJnLCBuZXdBcmcpKSB7XG5cbiAgICAgIGlmICh0ZWFyZG93bkZ1bmMpIHtcbiAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXMpXG4gICAgICB9XG5cbiAgICAgIGxldCByZXMgPSB3b3JrZXJGdW5jLmNhbGwodGhpcywgbmV3QXJnKVxuXG4gICAgICBpZiAoIXJlc0VxdWFsaXR5IHx8ICFyZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXMpKSB7XG4gICAgICAgIGN1cnJlbnRSZXMgPSByZXNcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50QXJnID0gbmV3QXJnXG5cbiAgICByZXR1cm4gY3VycmVudFJlc1xuICB9XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIG1lbW9pemVBcnJheWxpa2U8QXJncyBleHRlbmRzIGFueVtdLCBSZXM+KCAvLyB1c2VkIGF0IGFsbD9cbiAgd29ya2VyRnVuYzogKC4uLmFyZ3M6IEFyZ3MpID0+IFJlcyxcbiAgcmVzRXF1YWxpdHk/OiAocmVzMDogUmVzLCByZXMxOiBSZXMpID0+IGJvb2xlYW4sXG4gIHRlYXJkb3duRnVuYz86IChyZXM6IFJlcykgPT4gdm9pZFxuKTogKGFyZ1NldHM6IEFyZ3NbXSkgPT4gUmVzW10ge1xuXG4gIGxldCBjdXJyZW50QXJnU2V0czogQXJnc1tdID0gW11cbiAgbGV0IGN1cnJlbnRSZXN1bHRzOiBSZXNbXSA9IFtdXG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG5ld0FyZ1NldHM6IEFyZ3NbXSkge1xuICAgIGxldCBjdXJyZW50TGVuID0gY3VycmVudEFyZ1NldHMubGVuZ3RoXG4gICAgbGV0IG5ld0xlbiA9IG5ld0FyZ1NldHMubGVuZ3RoXG4gICAgbGV0IGkgPSAwXG5cbiAgICBmb3IgKDsgaSA8IGN1cnJlbnRMZW47IGkrKykge1xuXG4gICAgICBpZiAoIW5ld0FyZ1NldHNbaV0pIHsgLy8gb25lIG9mIHRoZSBvbGQgc2V0cyBubyBsb25nZXIgZXhpc3RzXG4gICAgICAgIGlmICh0ZWFyZG93bkZ1bmMpIHtcbiAgICAgICAgICB0ZWFyZG93bkZ1bmMoY3VycmVudFJlc3VsdHNbaV0pXG4gICAgICAgIH1cblxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIWlzQXJyYXlzRXF1YWwoY3VycmVudEFyZ1NldHNbaV0sIG5ld0FyZ1NldHNbaV0pKSB7XG5cbiAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzdWx0c1tpXSlcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXMgPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ1NldHNbaV0pXG5cbiAgICAgICAgaWYgKCFyZXNFcXVhbGl0eSB8fCAhcmVzRXF1YWxpdHkocmVzLCBjdXJyZW50UmVzdWx0c1tpXSkpIHtcbiAgICAgICAgICBjdXJyZW50UmVzdWx0c1tpXSA9IHJlc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICg7IGkgPCBuZXdMZW47IGkrKykge1xuICAgICAgY3VycmVudFJlc3VsdHNbaV0gPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ1NldHNbaV0pXG4gICAgfVxuXG4gICAgY3VycmVudEFyZ1NldHMgPSBuZXdBcmdTZXRzXG4gICAgY3VycmVudFJlc3VsdHMuc3BsaWNlKG5ld0xlbikgLy8gcmVtb3ZlIGV4Y2Vzc1xuXG4gICAgcmV0dXJuIGN1cnJlbnRSZXN1bHRzXG4gIH1cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gbWVtb2l6ZUhhc2hsaWtlPEFyZ3MgZXh0ZW5kcyBhbnlbXSwgUmVzPiggLy8gdXNlZD9cbiAgd29ya2VyRnVuYzogKC4uLmFyZ3M6IEFyZ3MpID0+IFJlcyxcbiAgcmVzRXF1YWxpdHk/OiAocmVzMDogUmVzLCByZXMxOiBSZXMpID0+IGJvb2xlYW4sXG4gIHRlYXJkb3duRnVuYz86IChyZXM6IFJlcykgPT4gdm9pZCAvLyBUT0RPOiBjaGFuZ2UgYXJnIG9yZGVyXG4pOiAoYXJnSGFzaDogeyBba2V5OiBzdHJpbmddOiBBcmdzIH0pID0+IHsgW2tleTogc3RyaW5nXTogUmVzIH0ge1xuXG4gIGxldCBjdXJyZW50QXJnSGFzaDogeyBba2V5OiBzdHJpbmddOiBBcmdzIH0gPSB7fVxuICBsZXQgY3VycmVudFJlc0hhc2g6IHsgW2tleTogc3RyaW5nXTogUmVzIH0gPSB7fVxuXG4gIHJldHVybiBmdW5jdGlvbihuZXdBcmdIYXNoOiB7IFtrZXk6IHN0cmluZ106IEFyZ3MgfSkge1xuICAgIGxldCBuZXdSZXNIYXNoOiB7IFtrZXk6IHN0cmluZ106IFJlcyB9ID0ge31cblxuICAgIGZvciAobGV0IGtleSBpbiBuZXdBcmdIYXNoKSB7XG5cbiAgICAgIGlmICghY3VycmVudFJlc0hhc2hba2V5XSkge1xuICAgICAgICBuZXdSZXNIYXNoW2tleV0gPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ0hhc2hba2V5XSlcblxuICAgICAgfSBlbHNlIGlmICghaXNBcnJheXNFcXVhbChjdXJyZW50QXJnSGFzaFtrZXldLCBuZXdBcmdIYXNoW2tleV0pKSB7XG5cbiAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzSGFzaFtrZXldKVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlcyA9IHdvcmtlckZ1bmMuYXBwbHkodGhpcywgbmV3QXJnSGFzaFtrZXldKVxuXG4gICAgICAgIG5ld1Jlc0hhc2hba2V5XSA9IChyZXNFcXVhbGl0eSAmJiByZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXNIYXNoW2tleV0pKVxuICAgICAgICAgID8gY3VycmVudFJlc0hhc2hba2V5XVxuICAgICAgICAgIDogcmVzXG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1Jlc0hhc2hba2V5XSA9IGN1cnJlbnRSZXNIYXNoW2tleV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50QXJnSGFzaCA9IG5ld0FyZ0hhc2hcbiAgICBjdXJyZW50UmVzSGFzaCA9IG5ld1Jlc0hhc2hcblxuICAgIHJldHVybiBuZXdSZXNIYXNoXG4gIH1cbn1cbiIsImltcG9ydCB7IERhdGVNYXJrZXIsIHRpbWVBc01zIH0gZnJvbSAnLi9tYXJrZXInXG5pbXBvcnQgeyBDYWxlbmRhclN5c3RlbSB9IGZyb20gJy4vY2FsZW5kYXItc3lzdGVtJ1xuaW1wb3J0IHsgTG9jYWxlIH0gZnJvbSAnLi9sb2NhbGUnXG5pbXBvcnQgeyBEYXRlRm9ybWF0dGVyLCBEYXRlRm9ybWF0dGluZ0NvbnRleHQgfSBmcm9tICcuL0RhdGVGb3JtYXR0ZXInXG5pbXBvcnQgeyBab25lZE1hcmtlciB9IGZyb20gJy4vem9uZWQtbWFya2VyJ1xuaW1wb3J0IHsgZm9ybWF0VGltZVpvbmVPZmZzZXQgfSBmcm9tICcuL2Zvcm1hdHRpbmctdXRpbHMnXG5pbXBvcnQgeyBtZW1vaXplIH0gZnJvbSAnLi4vdXRpbC9tZW1vaXplJ1xuXG5jb25zdCBFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFUyA9IHtcbiAgd2VlazogMyxcbiAgc2VwYXJhdG9yOiAwLCAvLyAwID0gbm90IGFwcGxpY2FibGVcbiAgb21pdFplcm9NaW51dGU6IDAsXG4gIG1lcmlkaWVtOiAwLCAvLyBsaWtlIGFtL3BtXG4gIG9taXRDb21tYXM6IDBcbn1cblxuY29uc3QgU1RBTkRBUkRfREFURV9QUk9QX1NFVkVSSVRJRVMgPSB7XG4gIHRpbWVab25lTmFtZTogNyxcbiAgZXJhOiA2LFxuICB5ZWFyOiA1LFxuICBtb250aDogNCxcbiAgZGF5OiAyLFxuICB3ZWVrZGF5OiAyLFxuICBob3VyOiAxLFxuICBtaW51dGU6IDEsXG4gIHNlY29uZDogMVxufVxuXG5jb25zdCBNRVJJRElFTV9SRSA9IC9cXHMqKFthcF0pXFwuP21cXC4/L2kgLy8gZWF0cyB1cCBsZWFkaW5nIHNwYWNlcyB0b29cbmNvbnN0IENPTU1BX1JFID0gLywvZyAvLyB3ZSBuZWVkIHJlIGZvciBnbG9iYWxuZXNzXG5jb25zdCBNVUxUSV9TUEFDRV9SRSA9IC9cXHMrL2dcbmNvbnN0IExUUl9SRSA9IC9cXHUyMDBlL2cgLy8gY29udHJvbCBjaGFyYWN0ZXJcbmNvbnN0IFVUQ19SRSA9IC9VVEN8R01UL1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgTmF0aXZlRm9ybWF0dGVyT3B0aW9ucyBleHRlbmRzIEludGwuRGF0ZVRpbWVGb3JtYXRPcHRpb25zIHtcbiAgd2Vlaz86ICdzaG9ydCcgfCAnbmFycm93JyB8ICdudW1lcmljJ1xuICBtZXJpZGllbT86ICdsb3dlcmNhc2UnIHwgJ3Nob3J0JyB8ICduYXJyb3cnIHwgYm9vbGVhblxuICBvbWl0WmVyb01pbnV0ZT86IGJvb2xlYW5cbiAgb21pdENvbW1hcz86IGJvb2xlYW5cbiAgc2VwYXJhdG9yPzogc3RyaW5nXG59XG5cbmV4cG9ydCBjbGFzcyBOYXRpdmVGb3JtYXR0ZXIgaW1wbGVtZW50cyBEYXRlRm9ybWF0dGVyIHtcblxuICBzdGFuZGFyZERhdGVQcm9wczogYW55XG4gIGV4dGVuZGVkU2V0dGluZ3M6IGFueVxuICBzZXZlcml0eTogbnVtYmVyXG4gIHByaXZhdGUgYnVpbGRGb3JtYXR0aW5nRnVuYzogdHlwZW9mIGJ1aWxkRm9ybWF0dGluZ0Z1bmMgLy8gY2FjaGluZyBmb3IgZWZmaWNpZW5jeSB3aXRoIHNhbWUgZGF0ZSBlbnZcblxuICBjb25zdHJ1Y3Rvcihmb3JtYXRTZXR0aW5nczogTmF0aXZlRm9ybWF0dGVyT3B0aW9ucykge1xuICAgIGxldCBzdGFuZGFyZERhdGVQcm9wczogYW55ID0ge31cbiAgICBsZXQgZXh0ZW5kZWRTZXR0aW5nczogYW55ID0ge31cbiAgICBsZXQgc2V2ZXJpdHkgPSAwXG5cbiAgICBmb3IgKGxldCBuYW1lIGluIGZvcm1hdFNldHRpbmdzKSB7XG4gICAgICBpZiAobmFtZSBpbiBFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFUykge1xuICAgICAgICBleHRlbmRlZFNldHRpbmdzW25hbWVdID0gZm9ybWF0U2V0dGluZ3NbbmFtZV1cbiAgICAgICAgc2V2ZXJpdHkgPSBNYXRoLm1heChFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFU1tuYW1lXSwgc2V2ZXJpdHkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFuZGFyZERhdGVQcm9wc1tuYW1lXSA9IGZvcm1hdFNldHRpbmdzW25hbWVdXG5cbiAgICAgICAgaWYgKG5hbWUgaW4gU1RBTkRBUkRfREFURV9QUk9QX1NFVkVSSVRJRVMpIHsgLy8gVE9ETzogd2hhdCBhYm91dCBob3VyMTI/IG5vIHNldmVyaXR5XG4gICAgICAgICAgc2V2ZXJpdHkgPSBNYXRoLm1heChTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFU1tuYW1lXSwgc2V2ZXJpdHkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnN0YW5kYXJkRGF0ZVByb3BzID0gc3RhbmRhcmREYXRlUHJvcHNcbiAgICB0aGlzLmV4dGVuZGVkU2V0dGluZ3MgPSBleHRlbmRlZFNldHRpbmdzXG4gICAgdGhpcy5zZXZlcml0eSA9IHNldmVyaXR5XG5cbiAgICB0aGlzLmJ1aWxkRm9ybWF0dGluZ0Z1bmMgPSBtZW1vaXplKGJ1aWxkRm9ybWF0dGluZ0Z1bmMpXG4gIH1cblxuICBmb3JtYXQoZGF0ZTogWm9uZWRNYXJrZXIsIGNvbnRleHQ6IERhdGVGb3JtYXR0aW5nQ29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLmJ1aWxkRm9ybWF0dGluZ0Z1bmModGhpcy5zdGFuZGFyZERhdGVQcm9wcywgdGhpcy5leHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KShkYXRlKVxuICB9XG5cbiAgZm9ybWF0UmFuZ2Uoc3RhcnQ6IFpvbmVkTWFya2VyLCBlbmQ6IFpvbmVkTWFya2VyLCBjb250ZXh0OiBEYXRlRm9ybWF0dGluZ0NvbnRleHQpIHtcbiAgICBsZXQgeyBzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncyB9ID0gdGhpc1xuXG4gICAgbGV0IGRpZmZTZXZlcml0eSA9IGNvbXB1dGVNYXJrZXJEaWZmU2V2ZXJpdHkoc3RhcnQubWFya2VyLCBlbmQubWFya2VyLCBjb250ZXh0LmNhbGVuZGFyU3lzdGVtKVxuICAgIGlmICghZGlmZlNldmVyaXR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5mb3JtYXQoc3RhcnQsIGNvbnRleHQpXG4gICAgfVxuXG4gICAgbGV0IGJpZ2dlc3RVbml0Rm9yUGFydGlhbCA9IGRpZmZTZXZlcml0eVxuICAgIGlmIChcbiAgICAgIGJpZ2dlc3RVbml0Rm9yUGFydGlhbCA+IDEgJiYgLy8gdGhlIHR3byBkYXRlcyBhcmUgZGlmZmVyZW50IGluIGEgd2F5IHRoYXQncyBsYXJnZXIgc2NhbGUgdGhhbiB0aW1lXG4gICAgICAoc3RhbmRhcmREYXRlUHJvcHMueWVhciA9PT0gJ251bWVyaWMnIHx8IHN0YW5kYXJkRGF0ZVByb3BzLnllYXIgPT09ICcyLWRpZ2l0JykgJiZcbiAgICAgIChzdGFuZGFyZERhdGVQcm9wcy5tb250aCA9PT0gJ251bWVyaWMnIHx8IHN0YW5kYXJkRGF0ZVByb3BzLm1vbnRoID09PSAnMi1kaWdpdCcpICYmXG4gICAgICAoc3RhbmRhcmREYXRlUHJvcHMuZGF5ID09PSAnbnVtZXJpYycgfHwgc3RhbmRhcmREYXRlUHJvcHMuZGF5ID09PSAnMi1kaWdpdCcpXG4gICAgKSB7XG4gICAgICBiaWdnZXN0VW5pdEZvclBhcnRpYWwgPSAxIC8vIG1ha2UgaXQgbG9vayBsaWtlIHRoZSBkYXRlcyBhcmUgb25seSBkaWZmZXJlbnQgaW4gdGVybXMgb2YgdGltZVxuICAgIH1cblxuICAgIGxldCBmdWxsMCA9IHRoaXMuZm9ybWF0KHN0YXJ0LCBjb250ZXh0KVxuICAgIGxldCBmdWxsMSA9IHRoaXMuZm9ybWF0KGVuZCwgY29udGV4dClcblxuICAgIGlmIChmdWxsMCA9PT0gZnVsbDEpIHtcbiAgICAgIHJldHVybiBmdWxsMFxuICAgIH1cblxuICAgIGxldCBwYXJ0aWFsRGF0ZVByb3BzID0gY29tcHV0ZVBhcnRpYWxGb3JtYXR0aW5nT3B0aW9ucyhzdGFuZGFyZERhdGVQcm9wcywgYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsKVxuICAgIGxldCBwYXJ0aWFsRm9ybWF0dGluZ0Z1bmMgPSBidWlsZEZvcm1hdHRpbmdGdW5jKHBhcnRpYWxEYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpXG4gICAgbGV0IHBhcnRpYWwwID0gcGFydGlhbEZvcm1hdHRpbmdGdW5jKHN0YXJ0KVxuICAgIGxldCBwYXJ0aWFsMSA9IHBhcnRpYWxGb3JtYXR0aW5nRnVuYyhlbmQpXG5cbiAgICBsZXQgaW5zZXJ0aW9uID0gZmluZENvbW1vbkluc2VydGlvbihmdWxsMCwgcGFydGlhbDAsIGZ1bGwxLCBwYXJ0aWFsMSlcbiAgICBsZXQgc2VwYXJhdG9yID0gZXh0ZW5kZWRTZXR0aW5ncy5zZXBhcmF0b3IgfHwgY29udGV4dC5kZWZhdWx0U2VwYXJhdG9yIHx8ICcnXG5cbiAgICBpZiAoaW5zZXJ0aW9uKSB7XG4gICAgICByZXR1cm4gaW5zZXJ0aW9uLmJlZm9yZSArIHBhcnRpYWwwICsgc2VwYXJhdG9yICsgcGFydGlhbDEgKyBpbnNlcnRpb24uYWZ0ZXJcbiAgICB9XG5cbiAgICByZXR1cm4gZnVsbDAgKyBzZXBhcmF0b3IgKyBmdWxsMVxuICB9XG5cbiAgZ2V0TGFyZ2VzdFVuaXQoKSB7XG4gICAgc3dpdGNoICh0aGlzLnNldmVyaXR5KSB7XG4gICAgICBjYXNlIDc6XG4gICAgICBjYXNlIDY6XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHJldHVybiAneWVhcidcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgcmV0dXJuICdtb250aCdcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuICd3ZWVrJ1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gJ2RheSdcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAndGltZScgLy8gcmVhbGx5P1xuICAgIH1cbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGJ1aWxkRm9ybWF0dGluZ0Z1bmMoXG4gIHN0YW5kYXJkRGF0ZVByb3BzLFxuICBleHRlbmRlZFNldHRpbmdzLFxuICBjb250ZXh0OiBEYXRlRm9ybWF0dGluZ0NvbnRleHRcbik6IChkYXRlOiBab25lZE1hcmtlcikgPT4gc3RyaW5nIHtcbiAgbGV0IHN0YW5kYXJkRGF0ZVByb3BDbnQgPSBPYmplY3Qua2V5cyhzdGFuZGFyZERhdGVQcm9wcykubGVuZ3RoXG5cbiAgaWYgKHN0YW5kYXJkRGF0ZVByb3BDbnQgPT09IDEgJiYgc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lID09PSAnc2hvcnQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGU6IFpvbmVkTWFya2VyKSB7XG4gICAgICByZXR1cm4gZm9ybWF0VGltZVpvbmVPZmZzZXQoZGF0ZS50aW1lWm9uZU9mZnNldClcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhbmRhcmREYXRlUHJvcENudCA9PT0gMCAmJiBleHRlbmRlZFNldHRpbmdzLndlZWspIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZGF0ZTogWm9uZWRNYXJrZXIpIHtcbiAgICAgIHJldHVybiBmb3JtYXRXZWVrTnVtYmVyKFxuICAgICAgICBjb250ZXh0LmNvbXB1dGVXZWVrTnVtYmVyKGRhdGUubWFya2VyKSxcbiAgICAgICAgY29udGV4dC53ZWVrVGV4dCxcbiAgICAgICAgY29udGV4dC5sb2NhbGUsXG4gICAgICAgIGV4dGVuZGVkU2V0dGluZ3Mud2Vla1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWlsZE5hdGl2ZUZvcm1hdHRpbmdGdW5jKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KVxufVxuXG5mdW5jdGlvbiBidWlsZE5hdGl2ZUZvcm1hdHRpbmdGdW5jKFxuICBzdGFuZGFyZERhdGVQcm9wcyxcbiAgZXh0ZW5kZWRTZXR0aW5ncyxcbiAgY29udGV4dDogRGF0ZUZvcm1hdHRpbmdDb250ZXh0XG4pOiAoZGF0ZTogWm9uZWRNYXJrZXIpID0+IHN0cmluZyB7XG4gIHN0YW5kYXJkRGF0ZVByb3BzID0geyAuLi5zdGFuZGFyZERhdGVQcm9wcyB9IC8vIGNvcHlcbiAgZXh0ZW5kZWRTZXR0aW5ncyA9IHsgLi4uZXh0ZW5kZWRTZXR0aW5ncyB9IC8vIGNvcHlcblxuICBzYW5pdGl6ZVNldHRpbmdzKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzKVxuXG4gIHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lID0gJ1VUQycgLy8gd2UgbGV2ZXJhZ2UgdGhlIG9ubHkgZ3VhcmFudGVlZCB0aW1lWm9uZSBmb3Igb3VyIFVUQyBtYXJrZXJzXG5cbiAgbGV0IG5vcm1hbEZvcm1hdCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGNvbnRleHQubG9jYWxlLmNvZGVzLCBzdGFuZGFyZERhdGVQcm9wcylcbiAgbGV0IHplcm9Gb3JtYXQgLy8gbmVlZGVkP1xuXG4gIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlKSB7XG4gICAgbGV0IHplcm9Qcm9wcyA9IHsgLi4uc3RhbmRhcmREYXRlUHJvcHMgfVxuICAgIGRlbGV0ZSB6ZXJvUHJvcHMubWludXRlIC8vIHNlY29uZHMgYW5kIG1zIHdlcmUgYWxyZWFkeSBjb25zaWRlcmVkIGluIHNhbml0aXplU2V0dGluZ3NcbiAgICB6ZXJvRm9ybWF0ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoY29udGV4dC5sb2NhbGUuY29kZXMsIHplcm9Qcm9wcylcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihkYXRlOiBab25lZE1hcmtlcikge1xuICAgIGxldCBtYXJrZXIgPSBkYXRlLm1hcmtlclxuICAgIGxldCBmb3JtYXRcblxuICAgIGlmICh6ZXJvRm9ybWF0ICYmICFtYXJrZXIuZ2V0VVRDTWludXRlcygpKSB7XG4gICAgICBmb3JtYXQgPSB6ZXJvRm9ybWF0XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcm1hdCA9IG5vcm1hbEZvcm1hdFxuICAgIH1cblxuICAgIGxldCBzID0gZm9ybWF0LmZvcm1hdChtYXJrZXIpXG5cbiAgICByZXR1cm4gcG9zdFByb2Nlc3MocywgZGF0ZSwgc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpXG4gIH1cbn1cblxuZnVuY3Rpb24gc2FuaXRpemVTZXR0aW5ncyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncykge1xuXG4gIC8vIGRlYWwgd2l0aCBhIGJyb3dzZXIgaW5jb25zaXN0ZW5jeSB3aGVyZSBmb3JtYXR0aW5nIHRoZSB0aW1lem9uZVxuICAvLyByZXF1aXJlcyB0aGF0IHRoZSBob3VyL21pbnV0ZSBiZSBwcmVzZW50LlxuICBpZiAoc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lKSB7XG4gICAgaWYgKCFzdGFuZGFyZERhdGVQcm9wcy5ob3VyKSB7XG4gICAgICBzdGFuZGFyZERhdGVQcm9wcy5ob3VyID0gJzItZGlnaXQnXG4gICAgfVxuICAgIGlmICghc3RhbmRhcmREYXRlUHJvcHMubWludXRlKSB7XG4gICAgICBzdGFuZGFyZERhdGVQcm9wcy5taW51dGUgPSAnMi1kaWdpdCdcbiAgICB9XG4gIH1cblxuICAvLyBvbmx5IHN1cHBvcnQgc2hvcnQgdGltZXpvbmUgbmFtZXNcbiAgaWYgKHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9PT0gJ2xvbmcnKSB7XG4gICAgc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lID0gJ3Nob3J0J1xuICB9XG5cbiAgLy8gaWYgcmVxdWVzdGluZyB0byBkaXNwbGF5IHNlY29uZHMsIE1VU1QgZGlzcGxheSBtaW51dGVzXG4gIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlICYmIChzdGFuZGFyZERhdGVQcm9wcy5zZWNvbmQgfHwgc3RhbmRhcmREYXRlUHJvcHMubWlsbGlzZWNvbmQpKSB7XG4gICAgZGVsZXRlIGV4dGVuZGVkU2V0dGluZ3Mub21pdFplcm9NaW51dGVcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0UHJvY2VzcyhzOiBzdHJpbmcsIGRhdGU6IFpvbmVkTWFya2VyLCBzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dDogRGF0ZUZvcm1hdHRpbmdDb250ZXh0KTogc3RyaW5nIHtcblxuICBzID0gcy5yZXBsYWNlKExUUl9SRSwgJycpIC8vIHJlbW92ZSBsZWZ0LXRvLXJpZ2h0IGNvbnRyb2wgY2hhcnMuIGRvIGZpcnN0LiBnb29kIGZvciBvdGhlciByZWdleGVzXG5cbiAgaWYgKHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9PT0gJ3Nob3J0Jykge1xuICAgIHMgPSBpbmplY3RUem9TdHIoXG4gICAgICBzLFxuICAgICAgKGNvbnRleHQudGltZVpvbmUgPT09ICdVVEMnIHx8IGRhdGUudGltZVpvbmVPZmZzZXQgPT0gbnVsbCkgP1xuICAgICAgICAnVVRDJyA6IC8vIGltcG9ydGFudCB0byBub3JtYWxpemUgZm9yIElFLCB3aGljaCBkb2VzIFwiR01UXCJcbiAgICAgICAgZm9ybWF0VGltZVpvbmVPZmZzZXQoZGF0ZS50aW1lWm9uZU9mZnNldClcbiAgICApXG4gIH1cblxuICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0Q29tbWFzKSB7XG4gICAgcyA9IHMucmVwbGFjZShDT01NQV9SRSwgJycpLnRyaW0oKVxuICB9XG5cbiAgaWYgKGV4dGVuZGVkU2V0dGluZ3Mub21pdFplcm9NaW51dGUpIHtcbiAgICBzID0gcy5yZXBsYWNlKCc6MDAnLCAnJykgLy8gemVyb0Zvcm1hdCBkb2Vzbid0IGFsd2F5cyBhY2hpZXZlIHRoaXNcbiAgfVxuXG4gIC8vIF4gZG8gYW55dGhpbmcgdGhhdCBtaWdodCBjcmVhdGUgYWRqYWNlbnQgc3BhY2VzIGJlZm9yZSB0aGlzIHBvaW50LFxuICAvLyBiZWNhdXNlIE1FUklESUVNX1JFIGxpa2VzIHRvIGVhdCB1cCBsb2FkaW5nIHNwYWNlc1xuXG4gIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSBmYWxzZSkge1xuICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsICcnKS50cmltKClcbiAgfSBlbHNlIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSAnbmFycm93JykgeyAvLyBhL3BcbiAgICBzID0gcy5yZXBsYWNlKE1FUklESUVNX1JFLCBmdW5jdGlvbihtMCwgbTEpIHtcbiAgICAgIHJldHVybiBtMS50b0xvY2FsZUxvd2VyQ2FzZSgpXG4gICAgfSlcbiAgfSBlbHNlIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSAnc2hvcnQnKSB7IC8vIGFtL3BtXG4gICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgZnVuY3Rpb24obTAsIG0xKSB7XG4gICAgICByZXR1cm4gbTEudG9Mb2NhbGVMb3dlckNhc2UoKSArICdtJ1xuICAgIH0pXG4gIH0gZWxzZSBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5tZXJpZGllbSA9PT0gJ2xvd2VyY2FzZScpIHsgLy8gb3RoZXIgbWVyaWRpZW0gdHJhbnNmb3JtZXJzIGFscmVhZHkgY29udmVydGVkIHRvIGxvd2VyY2FzZVxuICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIGZ1bmN0aW9uKG0wKSB7XG4gICAgICByZXR1cm4gbTAudG9Mb2NhbGVMb3dlckNhc2UoKVxuICAgIH0pXG4gIH1cblxuICBzID0gcy5yZXBsYWNlKE1VTFRJX1NQQUNFX1JFLCAnICcpXG4gIHMgPSBzLnRyaW0oKVxuXG4gIHJldHVybiBzXG59XG5cbmZ1bmN0aW9uIGluamVjdFR6b1N0cihzOiBzdHJpbmcsIHR6b1N0cjogc3RyaW5nKTogc3RyaW5nIHtcbiAgbGV0IHJlcGxhY2VkID0gZmFsc2VcblxuICBzID0gcy5yZXBsYWNlKFVUQ19SRSwgZnVuY3Rpb24oKSB7XG4gICAgcmVwbGFjZWQgPSB0cnVlXG4gICAgcmV0dXJuIHR6b1N0clxuICB9KVxuXG4gIC8vIElFMTEgZG9lc24ndCBpbmNsdWRlIFVUQy9HTVQgaW4gdGhlIG9yaWdpbmFsIHN0cmluZywgc28gYXBwZW5kIHRvIGVuZFxuICBpZiAoIXJlcGxhY2VkKSB7XG4gICAgcyArPSAnICcgKyB0em9TdHJcbiAgfVxuXG4gIHJldHVybiBzXG59XG5cbmZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXIobnVtOiBudW1iZXIsIHdlZWtUZXh0OiBzdHJpbmcsIGxvY2FsZTogTG9jYWxlLCBkaXNwbGF5PzogJ251bWVyaWMnIHwgJ25hcnJvdycgfCAnc2hvcnQnKTogc3RyaW5nIHtcbiAgbGV0IHBhcnRzID0gW11cblxuICBpZiAoZGlzcGxheSA9PT0gJ25hcnJvdycpIHtcbiAgICBwYXJ0cy5wdXNoKHdlZWtUZXh0KVxuICB9IGVsc2UgaWYgKGRpc3BsYXkgPT09ICdzaG9ydCcpIHtcbiAgICBwYXJ0cy5wdXNoKHdlZWtUZXh0LCAnICcpXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCBjb25zaWRlcmVkICdudW1lcmljJ1xuXG4gIHBhcnRzLnB1c2gobG9jYWxlLnNpbXBsZU51bWJlckZvcm1hdC5mb3JtYXQobnVtKSlcblxuICBpZiAobG9jYWxlLm9wdGlvbnMuZGlyZWN0aW9uID09PSAncnRsJykgeyAvLyBUT0RPOiB1c2UgY29udHJvbCBjaGFyYWN0ZXJzIGluc3RlYWQ/XG4gICAgcGFydHMucmV2ZXJzZSgpXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cblxuXG4vLyBSYW5nZSBGb3JtYXR0aW5nIFV0aWxzXG5cbi8vIDAgPSBleGFjdGx5IHRoZSBzYW1lXG4vLyAxID0gZGlmZmVyZW50IGJ5IHRpbWVcbi8vIGFuZCBiaWdnZXJcbmZ1bmN0aW9uIGNvbXB1dGVNYXJrZXJEaWZmU2V2ZXJpdHkoZDA6IERhdGVNYXJrZXIsIGQxOiBEYXRlTWFya2VyLCBjYTogQ2FsZW5kYXJTeXN0ZW0pIHtcbiAgaWYgKGNhLmdldE1hcmtlclllYXIoZDApICE9PSBjYS5nZXRNYXJrZXJZZWFyKGQxKSkge1xuICAgIHJldHVybiA1XG4gIH1cbiAgaWYgKGNhLmdldE1hcmtlck1vbnRoKGQwKSAhPT0gY2EuZ2V0TWFya2VyTW9udGgoZDEpKSB7XG4gICAgcmV0dXJuIDRcbiAgfVxuICBpZiAoY2EuZ2V0TWFya2VyRGF5KGQwKSAhPT0gY2EuZ2V0TWFya2VyRGF5KGQxKSkge1xuICAgIHJldHVybiAyXG4gIH1cbiAgaWYgKHRpbWVBc01zKGQwKSAhPT0gdGltZUFzTXMoZDEpKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBjb21wdXRlUGFydGlhbEZvcm1hdHRpbmdPcHRpb25zKG9wdGlvbnMsIGJpZ2dlc3RVbml0KSB7XG4gIGxldCBwYXJ0aWFsT3B0aW9ucyA9IHt9XG5cbiAgZm9yIChsZXQgbmFtZSBpbiBvcHRpb25zKSB7XG4gICAgaWYgKFxuICAgICAgIShuYW1lIGluIFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTKSB8fCAvLyBub3QgYSBkYXRlIHBhcnQgcHJvcCAobGlrZSB0aW1lWm9uZSlcbiAgICAgIFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTW25hbWVdIDw9IGJpZ2dlc3RVbml0XG4gICAgKSB7XG4gICAgICBwYXJ0aWFsT3B0aW9uc1tuYW1lXSA9IG9wdGlvbnNbbmFtZV1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydGlhbE9wdGlvbnNcbn1cblxuZnVuY3Rpb24gZmluZENvbW1vbkluc2VydGlvbihmdWxsMCwgcGFydGlhbDAsIGZ1bGwxLCBwYXJ0aWFsMSkge1xuXG4gIGxldCBpMCA9IDBcbiAgd2hpbGUgKGkwIDwgZnVsbDAubGVuZ3RoKSB7XG5cbiAgICBsZXQgZm91bmQwID0gZnVsbDAuaW5kZXhPZihwYXJ0aWFsMCwgaTApXG4gICAgaWYgKGZvdW5kMCA9PT0gLTEpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgbGV0IGJlZm9yZTAgPSBmdWxsMC5zdWJzdHIoMCwgZm91bmQwKVxuICAgIGkwID0gZm91bmQwICsgcGFydGlhbDAubGVuZ3RoXG4gICAgbGV0IGFmdGVyMCA9IGZ1bGwwLnN1YnN0cihpMClcblxuICAgIGxldCBpMSA9IDBcbiAgICB3aGlsZSAoaTEgPCBmdWxsMS5sZW5ndGgpIHtcblxuICAgICAgbGV0IGZvdW5kMSA9IGZ1bGwxLmluZGV4T2YocGFydGlhbDEsIGkxKVxuICAgICAgaWYgKGZvdW5kMSA9PT0gLTEpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgbGV0IGJlZm9yZTEgPSBmdWxsMS5zdWJzdHIoMCwgZm91bmQxKVxuICAgICAgaTEgPSBmb3VuZDEgKyBwYXJ0aWFsMS5sZW5ndGhcbiAgICAgIGxldCBhZnRlcjEgPSBmdWxsMS5zdWJzdHIoaTEpXG5cbiAgICAgIGlmIChiZWZvcmUwID09PSBiZWZvcmUxICYmIGFmdGVyMCA9PT0gYWZ0ZXIxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYmVmb3JlOiBiZWZvcmUwLFxuICAgICAgICAgIGFmdGVyOiBhZnRlcjBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG4iLCJpbXBvcnQgeyBEYXRlTWFya2VyIH0gZnJvbSAnLi9tYXJrZXInXG5pbXBvcnQgeyBDYWxlbmRhclN5c3RlbSB9IGZyb20gJy4vY2FsZW5kYXItc3lzdGVtJ1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgWm9uZWRNYXJrZXIge1xuICBtYXJrZXI6IERhdGVNYXJrZXIsXG4gIHRpbWVab25lT2Zmc2V0OiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeHBhbmRlZFpvbmVkTWFya2VyIGV4dGVuZHMgWm9uZWRNYXJrZXIge1xuICBhcnJheTogbnVtYmVyW10sXG4gIHllYXI6IG51bWJlcixcbiAgbW9udGg6IG51bWJlcixcbiAgZGF5OiBudW1iZXIsXG4gIGhvdXI6IG51bWJlcixcbiAgbWludXRlOiBudW1iZXIsXG4gIHNlY29uZDogbnVtYmVyLFxuICBtaWxsaXNlY29uZDogbnVtYmVyXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZFpvbmVkTWFya2VyKGRhdGVJbmZvOiBab25lZE1hcmtlciwgY2FsZW5kYXJTeXN0ZW06IENhbGVuZGFyU3lzdGVtKTogRXhwYW5kZWRab25lZE1hcmtlciB7XG4gIGxldCBhID0gY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShkYXRlSW5mby5tYXJrZXIpXG5cbiAgcmV0dXJuIHtcbiAgICBtYXJrZXI6IGRhdGVJbmZvLm1hcmtlcixcbiAgICB0aW1lWm9uZU9mZnNldDogZGF0ZUluZm8udGltZVpvbmVPZmZzZXQsXG4gICAgYXJyYXk6IGEsXG4gICAgeWVhcjogYVswXSxcbiAgICBtb250aDogYVsxXSxcbiAgICBkYXk6IGFbMl0sXG4gICAgaG91cjogYVszXSxcbiAgICBtaW51dGU6IGFbNF0sXG4gICAgc2Vjb25kOiBhWzVdLFxuICAgIG1pbGxpc2Vjb25kOiBhWzZdXG4gIH1cbn1cbiIsImltcG9ydCB7IERhdGVNYXJrZXIgfSBmcm9tICcuL21hcmtlcidcbmltcG9ydCB7IENhbGVuZGFyU3lzdGVtIH0gZnJvbSAnLi9jYWxlbmRhci1zeXN0ZW0nXG5pbXBvcnQgeyBMb2NhbGUgfSBmcm9tICcuL2xvY2FsZSdcbmltcG9ydCB7IFpvbmVkTWFya2VyLCBFeHBhbmRlZFpvbmVkTWFya2VyLCBleHBhbmRab25lZE1hcmtlciB9IGZyb20gJy4vem9uZWQtbWFya2VyJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFZlcmJvc2VGb3JtYXR0aW5nQXJnIHsgLy8gVE9ETzoga2lsbCB0aGlzXG4gIGRhdGU6IEV4cGFuZGVkWm9uZWRNYXJrZXJcbiAgc3RhcnQ6IEV4cGFuZGVkWm9uZWRNYXJrZXJcbiAgZW5kPzogRXhwYW5kZWRab25lZE1hcmtlclxuICB0aW1lWm9uZTogc3RyaW5nXG4gIGxvY2FsZUNvZGVzOiBzdHJpbmdbXSxcbiAgc2VwYXJhdG9yOiBzdHJpbmdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKHN0YXJ0OiBab25lZE1hcmtlciwgZW5kOiBab25lZE1hcmtlciwgY29udGV4dDogRGF0ZUZvcm1hdHRpbmdDb250ZXh0LCBzZXBhcmF0b3I/OiBzdHJpbmcpOiBWZXJib3NlRm9ybWF0dGluZ0FyZyB7XG4gIGxldCBzdGFydEluZm8gPSBleHBhbmRab25lZE1hcmtlcihzdGFydCwgY29udGV4dC5jYWxlbmRhclN5c3RlbSlcbiAgbGV0IGVuZEluZm8gPSBlbmQgPyBleHBhbmRab25lZE1hcmtlcihlbmQsIGNvbnRleHQuY2FsZW5kYXJTeXN0ZW0pIDogbnVsbFxuXG4gIHJldHVybiB7XG4gICAgZGF0ZTogc3RhcnRJbmZvLFxuICAgIHN0YXJ0OiBzdGFydEluZm8sXG4gICAgZW5kOiBlbmRJbmZvLFxuICAgIHRpbWVab25lOiBjb250ZXh0LnRpbWVab25lLFxuICAgIGxvY2FsZUNvZGVzOiBjb250ZXh0LmxvY2FsZS5jb2RlcyxcbiAgICBzZXBhcmF0b3JcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBDbWRGb3JtYXR0ZXJGdW5jID0gKGNtZDogc3RyaW5nLCBhcmc6IFZlcmJvc2VGb3JtYXR0aW5nQXJnKSA9PiBzdHJpbmdcblxuZXhwb3J0IGludGVyZmFjZSBEYXRlRm9ybWF0dGluZ0NvbnRleHQge1xuICB0aW1lWm9uZTogc3RyaW5nLFxuICBsb2NhbGU6IExvY2FsZSxcbiAgY2FsZW5kYXJTeXN0ZW06IENhbGVuZGFyU3lzdGVtXG4gIGNvbXB1dGVXZWVrTnVtYmVyOiAoZDogRGF0ZU1hcmtlcikgPT4gbnVtYmVyXG4gIHdlZWtUZXh0OiBzdHJpbmdcbiAgY21kRm9ybWF0dGVyPzogQ21kRm9ybWF0dGVyRnVuY1xuICBkZWZhdWx0U2VwYXJhdG9yOiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXRlRm9ybWF0dGVyIHtcbiAgZm9ybWF0KGRhdGU6IFpvbmVkTWFya2VyLCBjb250ZXh0OiBEYXRlRm9ybWF0dGluZ0NvbnRleHQpOiBzdHJpbmdcbiAgZm9ybWF0UmFuZ2Uoc3RhcnQ6IFpvbmVkTWFya2VyLCBlbmQ6IFpvbmVkTWFya2VyLCBjb250ZXh0OiBEYXRlRm9ybWF0dGluZ0NvbnRleHQsIHNlcGFyYXRvck92ZXJyaWRlPzogc3RyaW5nKTogc3RyaW5nXG59XG4iLCJpbXBvcnQgeyBEYXRlRm9ybWF0dGVyLCBEYXRlRm9ybWF0dGluZ0NvbnRleHQsIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnIH0gZnJvbSAnLi9EYXRlRm9ybWF0dGVyJ1xuaW1wb3J0IHsgWm9uZWRNYXJrZXIgfSBmcm9tICcuL3pvbmVkLW1hcmtlcidcblxuXG4vKlxuVE9ETzogZml4IHRoZSB0ZXJtaW5vbG9neSBvZiBcImZvcm1hdHRlclwiIHZzIFwiZm9ybWF0dGluZyBmdW5jXCJcbiovXG5cbi8qXG5BdCB0aGUgdGltZSBvZiBpbnN0YW50aWF0aW9uLCB0aGlzIG9iamVjdCBkb2VzIG5vdCBrbm93IHdoaWNoIGNtZC1mb3JtYXR0aW5nIHN5c3RlbSBpdCB3aWxsIHVzZS5cbkl0IHJlY2VpdmVzIHRoaXMgYXQgdGhlIHRpbWUgb2YgZm9ybWF0dGluZywgYXMgYSBzZXR0aW5nLlxuKi9cbmV4cG9ydCBjbGFzcyBDbWRGb3JtYXR0ZXIgaW1wbGVtZW50cyBEYXRlRm9ybWF0dGVyIHtcblxuICBjbWRTdHI6IHN0cmluZ1xuICBzZXBhcmF0b3I6IHN0cmluZ1xuXG4gIGNvbnN0cnVjdG9yKGNtZFN0cjogc3RyaW5nLCBzZXBhcmF0b3I/OiBzdHJpbmcpIHtcbiAgICB0aGlzLmNtZFN0ciA9IGNtZFN0clxuICAgIHRoaXMuc2VwYXJhdG9yID0gc2VwYXJhdG9yXG4gIH1cblxuICBmb3JtYXQoZGF0ZTogWm9uZWRNYXJrZXIsIGNvbnRleHQ6IERhdGVGb3JtYXR0aW5nQ29udGV4dCkge1xuICAgIHJldHVybiBjb250ZXh0LmNtZEZvcm1hdHRlcih0aGlzLmNtZFN0ciwgY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoZGF0ZSwgbnVsbCwgY29udGV4dCwgdGhpcy5zZXBhcmF0b3IpKVxuICB9XG5cbiAgZm9ybWF0UmFuZ2Uoc3RhcnQ6IFpvbmVkTWFya2VyLCBlbmQ6IFpvbmVkTWFya2VyLCBjb250ZXh0OiBEYXRlRm9ybWF0dGluZ0NvbnRleHQpIHtcbiAgICByZXR1cm4gY29udGV4dC5jbWRGb3JtYXR0ZXIodGhpcy5jbWRTdHIsIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKHN0YXJ0LCBlbmQsIGNvbnRleHQsIHRoaXMuc2VwYXJhdG9yKSlcbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBEYXRlRm9ybWF0dGVyLCBEYXRlRm9ybWF0dGluZ0NvbnRleHQsIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnLCBWZXJib3NlRm9ybWF0dGluZ0FyZyB9IGZyb20gJy4vRGF0ZUZvcm1hdHRlcidcbmltcG9ydCB7IFpvbmVkTWFya2VyIH0gZnJvbSAnLi96b25lZC1tYXJrZXInXG5cblxuZXhwb3J0IHR5cGUgRnVuY0Zvcm1hdHRlckZ1bmMgPSAoYXJnOiBWZXJib3NlRm9ybWF0dGluZ0FyZykgPT4gc3RyaW5nXG5cblxuZXhwb3J0IGNsYXNzIEZ1bmNGb3JtYXR0ZXIgaW1wbGVtZW50cyBEYXRlRm9ybWF0dGVyIHtcblxuICBmdW5jOiBGdW5jRm9ybWF0dGVyRnVuY1xuXG4gIGNvbnN0cnVjdG9yKGZ1bmM6IEZ1bmNGb3JtYXR0ZXJGdW5jKSB7XG4gICAgdGhpcy5mdW5jID0gZnVuY1xuICB9XG5cbiAgZm9ybWF0KGRhdGU6IFpvbmVkTWFya2VyLCBjb250ZXh0OiBEYXRlRm9ybWF0dGluZ0NvbnRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5mdW5jKGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKGRhdGUsIG51bGwsIGNvbnRleHQpKVxuICB9XG5cbiAgZm9ybWF0UmFuZ2Uoc3RhcnQ6IFpvbmVkTWFya2VyLCBlbmQ6IFpvbmVkTWFya2VyLCBjb250ZXh0OiBEYXRlRm9ybWF0dGluZ0NvbnRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5mdW5jKGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKHN0YXJ0LCBlbmQsIGNvbnRleHQpKVxuICB9XG5cbn1cbiIsImltcG9ydCB7IE5hdGl2ZUZvcm1hdHRlciwgTmF0aXZlRm9ybWF0dGVyT3B0aW9ucyB9IGZyb20gJy4vZm9ybWF0dGluZy1uYXRpdmUnXG5pbXBvcnQgeyBDbWRGb3JtYXR0ZXIgfSBmcm9tICcuL2Zvcm1hdHRpbmctY21kJ1xuaW1wb3J0IHsgRnVuY0Zvcm1hdHRlciwgRnVuY0Zvcm1hdHRlckZ1bmMgfSBmcm9tICcuL2Zvcm1hdHRpbmctZnVuYydcbmltcG9ydCB7IERhdGVGb3JtYXR0ZXIgfSBmcm9tICcuL0RhdGVGb3JtYXR0ZXInXG5cblxuLy8gVE9ETzogdXNlIEludGwuRGF0ZVRpbWVGb3JtYXRPcHRpb25zXG5leHBvcnQgdHlwZSBGb3JtYXR0ZXJJbnB1dCA9IE5hdGl2ZUZvcm1hdHRlck9wdGlvbnMgfCBzdHJpbmcgfCBGdW5jRm9ybWF0dGVyRnVuY1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGb3JtYXR0ZXIoaW5wdXQ6IEZvcm1hdHRlcklucHV0LCBkZWZhdWx0U2VwYXJhdG9yPzogc3RyaW5nKTogRGF0ZUZvcm1hdHRlciB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0KSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgIGlmICh0eXBlb2YgZGVmYXVsdFNlcGFyYXRvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlucHV0ID0geyBzZXBhcmF0b3I6IGRlZmF1bHRTZXBhcmF0b3IsIC4uLmlucHV0IH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBOYXRpdmVGb3JtYXR0ZXIoaW5wdXQpXG5cbiAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG5ldyBDbWRGb3JtYXR0ZXIoaW5wdXQsIGRlZmF1bHRTZXBhcmF0b3IpXG5cbiAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbmV3IEZ1bmNGb3JtYXR0ZXIoaW5wdXQgYXMgRnVuY0Zvcm1hdHRlckZ1bmMpXG4gIH1cbn1cbiIsImltcG9ydCB7IGNyZWF0ZUR1cmF0aW9uIH0gZnJvbSAnLi9kYXRlbGliL2R1cmF0aW9uJ1xuaW1wb3J0IHsgbWVyZ2VQcm9wcywgaXNQcm9wc0VxdWFsIH0gZnJvbSAnLi91dGlsL29iamVjdCdcbmltcG9ydCB7IGNyZWF0ZUZvcm1hdHRlciB9IGZyb20gJy4vZGF0ZWxpYi9mb3JtYXR0aW5nJ1xuaW1wb3J0IHsgcGFyc2VGaWVsZFNwZWNzIH0gZnJvbSAnLi91dGlsL21pc2MnXG5pbXBvcnQgeyBEYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzIH0gZnJvbSAnLi9EYXRlUHJvZmlsZUdlbmVyYXRvcidcblxuLy8gcHVibGljXG5pbXBvcnQge1xuICBDc3NEaW1WYWx1ZSxcbiAgRGF0ZUlucHV0LFxuICBEYXRlUmFuZ2VJbnB1dCxcbiAgQnVzaW5lc3NIb3Vyc0lucHV0LFxuICBFdmVudFNvdXJjZUlucHV0LFxuICBWaWV3QXBpLFxuICBMb2NhbGVTaW5ndWxhckFyZywgTG9jYWxlSW5wdXQsXG4gIEV2ZW50SW5wdXQsIEV2ZW50SW5wdXRUcmFuc2Zvcm1lcixcbiAgT3ZlcmxhcEZ1bmMsIENvbnN0cmFpbnRJbnB1dCwgQWxsb3dGdW5jLFxuICBQbHVnaW5EZWYsXG4gIFZpZXdDb21wb25lbnRUeXBlLFxuICBTcGVjaWZpY1ZpZXdDb250ZW50QXJnLCBTcGVjaWZpY1ZpZXdNb3VudEFyZyxcbiAgQ2xhc3NOYW1lc0dlbmVyYXRvciwgQ3VzdG9tQ29udGVudEdlbmVyYXRvciwgRGlkTW91bnRIYW5kbGVyLCBXaWxsVW5tb3VudEhhbmRsZXIsXG4gIE5vd0luZGljYXRvckNvbnRlbnRBcmcsIE5vd0luZGljYXRvck1vdW50QXJnLFxuICBXZWVrTnVtYmVyQ29udGVudEFyZywgV2Vla051bWJlck1vdW50QXJnLFxuICBTbG90TGFuZUNvbnRlbnRBcmcsIFNsb3RMYW5lTW91bnRBcmcsXG4gIFNsb3RMYWJlbENvbnRlbnRBcmcsIFNsb3RMYWJlbE1vdW50QXJnLFxuICBBbGxEYXlDb250ZW50QXJnLCBBbGxEYXlNb3VudEFyZyxcbiAgRGF5SGVhZGVyQ29udGVudEFyZywgRGF5SGVhZGVyTW91bnRBcmcsXG4gIERheUNlbGxDb250ZW50QXJnLCBEYXlDZWxsTW91bnRBcmcsXG4gIFZpZXdDb250ZW50QXJnLCBWaWV3TW91bnRBcmcsXG4gIEV2ZW50Q2xpY2tBcmcsXG4gIEV2ZW50SG92ZXJpbmdBcmcsXG4gIERhdGVTZWxlY3RBcmcsIERhdGVVbnNlbGVjdEFyZyxcbiAgQ2FsZW5kYXJBcGksXG4gIFZVSUV2ZW50LFxuICBXZWVrTnVtYmVyQ2FsY3VsYXRpb24sXG4gIEZvcm1hdHRlcklucHV0LFxuICBUb29sYmFySW5wdXQsIEN1c3RvbUJ1dHRvbklucHV0LCBCdXR0b25JY29uc0lucHV0LCBCdXR0b25UZXh0Q29tcG91bmRJbnB1dCxcbiAgRXZlbnRDb250ZW50QXJnLCBFdmVudE1vdW50QXJnLFxuICBEYXRlc1NldEFyZyxcbiAgRXZlbnRBcGksIEV2ZW50QWRkQXJnLCBFdmVudENoYW5nZUFyZywgRXZlbnRSZW1vdmVBcmdcbn0gZnJvbSAnLi9hcGktdHlwZS1kZXBzJ1xuXG5cbi8vIGJhc2Ugb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBCQVNFX09QVElPTl9SRUZJTkVSUyA9IHtcbiAgbmF2TGlua0RheUNsaWNrOiBpZGVudGl0eSBhcyBJZGVudGl0eTxzdHJpbmcgfCAoKHRoaXM6IENhbGVuZGFyQXBpLCBkYXRlOiBEYXRlLCBqc0V2ZW50OiBWVUlFdmVudCkgPT4gdm9pZCk+LFxuICBuYXZMaW5rV2Vla0NsaWNrOiBpZGVudGl0eSBhcyBJZGVudGl0eTxzdHJpbmcgfCAoKHRoaXM6IENhbGVuZGFyQXBpLCB3ZWVrU3RhcnQ6IERhdGUsIGpzRXZlbnQ6IFZVSUV2ZW50KSA9PiB2b2lkKT4sXG4gIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgYm9vdHN0cmFwRm9udEF3ZXNvbWU6IGlkZW50aXR5IGFzIElkZW50aXR5PEJ1dHRvbkljb25zSW5wdXQgfCBmYWxzZT4sIC8vIFRPRE86IG1vdmUgdG8gYm9vdHN0cmFwIHBsdWdpblxuICBidXR0b25JY29uczogaWRlbnRpdHkgYXMgSWRlbnRpdHk8QnV0dG9uSWNvbnNJbnB1dCB8IGZhbHNlPixcbiAgY3VzdG9tQnV0dG9uczogaWRlbnRpdHkgYXMgSWRlbnRpdHk8eyBbbmFtZTogc3RyaW5nXTogQ3VzdG9tQnV0dG9uSW5wdXQgfT4sXG4gIGRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXG4gIG5leHREYXlUaHJlc2hvbGQ6IGNyZWF0ZUR1cmF0aW9uLFxuICBzY3JvbGxUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgc2xvdE1pblRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICBzbG90TWF4VGltZTogY3JlYXRlRHVyYXRpb24sXG4gIGRheVBvcG92ZXJGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgc2xvdER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgc25hcER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgaGVhZGVyVG9vbGJhcjogaWRlbnRpdHkgYXMgSWRlbnRpdHk8VG9vbGJhcklucHV0IHwgZmFsc2U+LFxuICBmb290ZXJUb29sYmFyOiBpZGVudGl0eSBhcyBJZGVudGl0eTxUb29sYmFySW5wdXQgfCBmYWxzZT4sXG4gIGRlZmF1bHRSYW5nZVNlcGFyYXRvcjogU3RyaW5nLFxuICB0aXRsZVJhbmdlU2VwYXJhdG9yOiBTdHJpbmcsXG4gIGZvcmNlRXZlbnREdXJhdGlvbjogQm9vbGVhbixcblxuICBkYXlIZWFkZXJzOiBCb29sZWFuLFxuICBkYXlIZWFkZXJGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgZGF5SGVhZGVyQ2xhc3NOYW1lczogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q2xhc3NOYW1lc0dlbmVyYXRvcjxEYXlIZWFkZXJDb250ZW50QXJnPj4sXG4gIGRheUhlYWRlckNvbnRlbnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PEN1c3RvbUNvbnRlbnRHZW5lcmF0b3I8RGF5SGVhZGVyQ29udGVudEFyZz4+LFxuICBkYXlIZWFkZXJEaWRNb3VudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGlkTW91bnRIYW5kbGVyPERheUhlYWRlck1vdW50QXJnPj4sXG4gIGRheUhlYWRlcldpbGxVbm1vdW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxXaWxsVW5tb3VudEhhbmRsZXI8RGF5SGVhZGVyTW91bnRBcmc+PixcblxuICBkYXlDZWxsQ2xhc3NOYW1lczogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q2xhc3NOYW1lc0dlbmVyYXRvcjxEYXlDZWxsQ29udGVudEFyZz4+LFxuICBkYXlDZWxsQ29udGVudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q3VzdG9tQ29udGVudEdlbmVyYXRvcjxEYXlDZWxsQ29udGVudEFyZz4+LFxuICBkYXlDZWxsRGlkTW91bnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PERpZE1vdW50SGFuZGxlcjxEYXlDZWxsTW91bnRBcmc+PixcbiAgZGF5Q2VsbFdpbGxVbm1vdW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxXaWxsVW5tb3VudEhhbmRsZXI8RGF5Q2VsbE1vdW50QXJnPj4sXG5cbiAgaW5pdGlhbFZpZXc6IFN0cmluZyxcbiAgYXNwZWN0UmF0aW86IE51bWJlcixcbiAgd2Vla2VuZHM6IEJvb2xlYW4sXG5cbiAgd2Vla051bWJlckNhbGN1bGF0aW9uOiBpZGVudGl0eSBhcyBJZGVudGl0eTxXZWVrTnVtYmVyQ2FsY3VsYXRpb24+LFxuICB3ZWVrTnVtYmVyczogQm9vbGVhbixcbiAgd2Vla051bWJlckNsYXNzTmFtZXM6IGlkZW50aXR5IGFzIElkZW50aXR5PENsYXNzTmFtZXNHZW5lcmF0b3I8V2Vla051bWJlckNvbnRlbnRBcmc+PixcbiAgd2Vla051bWJlckNvbnRlbnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PEN1c3RvbUNvbnRlbnRHZW5lcmF0b3I8V2Vla051bWJlckNvbnRlbnRBcmc+PixcbiAgd2Vla051bWJlckRpZE1vdW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxEaWRNb3VudEhhbmRsZXI8V2Vla051bWJlck1vdW50QXJnPj4sXG4gIHdlZWtOdW1iZXJXaWxsVW5tb3VudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8V2lsbFVubW91bnRIYW5kbGVyPFdlZWtOdW1iZXJNb3VudEFyZz4+LFxuXG4gIGVkaXRhYmxlOiBCb29sZWFuLFxuXG4gIHZpZXdDbGFzc05hbWVzOiBpZGVudGl0eSBhcyBJZGVudGl0eTxDbGFzc05hbWVzR2VuZXJhdG9yPFZpZXdDb250ZW50QXJnPj4sXG4gIHZpZXdEaWRNb3VudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGlkTW91bnRIYW5kbGVyPFZpZXdNb3VudEFyZz4+LFxuICB2aWV3V2lsbFVubW91bnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PFdpbGxVbm1vdW50SGFuZGxlcjxWaWV3TW91bnRBcmc+PixcblxuICBub3dJbmRpY2F0b3I6IEJvb2xlYW4sXG4gIG5vd0luZGljYXRvckNsYXNzTmFtZXM6IGlkZW50aXR5IGFzIElkZW50aXR5PENsYXNzTmFtZXNHZW5lcmF0b3I8Tm93SW5kaWNhdG9yQ29udGVudEFyZz4+LFxuICBub3dJbmRpY2F0b3JDb250ZW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxDdXN0b21Db250ZW50R2VuZXJhdG9yPE5vd0luZGljYXRvckNvbnRlbnRBcmc+PixcbiAgbm93SW5kaWNhdG9yRGlkTW91bnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PERpZE1vdW50SGFuZGxlcjxOb3dJbmRpY2F0b3JNb3VudEFyZz4+LFxuICBub3dJbmRpY2F0b3JXaWxsVW5tb3VudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8V2lsbFVubW91bnRIYW5kbGVyPE5vd0luZGljYXRvck1vdW50QXJnPj4sXG5cbiAgc2hvd05vbkN1cnJlbnREYXRlczogQm9vbGVhbixcbiAgbGF6eUZldGNoaW5nOiBCb29sZWFuLFxuICBzdGFydFBhcmFtOiBTdHJpbmcsXG4gIGVuZFBhcmFtOiBTdHJpbmcsXG4gIHRpbWVab25lUGFyYW06IFN0cmluZyxcbiAgdGltZVpvbmU6IFN0cmluZyxcbiAgbG9jYWxlczogaWRlbnRpdHkgYXMgSWRlbnRpdHk8TG9jYWxlSW5wdXRbXT4sXG4gIGxvY2FsZTogaWRlbnRpdHkgYXMgSWRlbnRpdHk8TG9jYWxlU2luZ3VsYXJBcmc+LFxuICB0aGVtZVN5c3RlbTogU3RyaW5nIGFzIElkZW50aXR5PCdzdGFuZGFyZCcgfCBzdHJpbmc+LFxuICBkcmFnUmV2ZXJ0RHVyYXRpb246IE51bWJlcixcbiAgZHJhZ1Njcm9sbDogQm9vbGVhbixcbiAgYWxsRGF5TWFpbnRhaW5EdXJhdGlvbjogQm9vbGVhbixcbiAgdW5zZWxlY3RBdXRvOiBCb29sZWFuLFxuICBkcm9wQWNjZXB0OiBpZGVudGl0eSBhcyBJZGVudGl0eTxzdHJpbmcgfCAoKHRoaXM6IENhbGVuZGFyQXBpLCBkcmFnZ2FibGU6IGFueSkgPT4gYm9vbGVhbik+LCAvLyBUT0RPOiB0eXBlIGRyYWdnYWJsZVxuICBldmVudE9yZGVyOiBwYXJzZUZpZWxkU3BlY3MsXG5cbiAgaGFuZGxlV2luZG93UmVzaXplOiBCb29sZWFuLFxuICB3aW5kb3dSZXNpemVEZWxheTogTnVtYmVyLFxuICBsb25nUHJlc3NEZWxheTogTnVtYmVyLFxuICBldmVudERyYWdNaW5EaXN0YW5jZTogTnVtYmVyLFxuICBleHBhbmRSb3dzOiBCb29sZWFuLFxuICBoZWlnaHQ6IGlkZW50aXR5IGFzIElkZW50aXR5PENzc0RpbVZhbHVlPixcbiAgY29udGVudEhlaWdodDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q3NzRGltVmFsdWU+LFxuICBkaXJlY3Rpb246IFN0cmluZyBhcyBJZGVudGl0eTwnbHRyJyB8ICdydGwnPixcbiAgd2Vla051bWJlckZvcm1hdDogY3JlYXRlRm9ybWF0dGVyLFxuICBldmVudFJlc2l6YWJsZUZyb21TdGFydDogQm9vbGVhbixcbiAgZGlzcGxheUV2ZW50VGltZTogQm9vbGVhbixcbiAgZGlzcGxheUV2ZW50RW5kOiBCb29sZWFuLFxuICB3ZWVrVGV4dDogU3RyaW5nLFxuICBwcm9ncmVzc2l2ZUV2ZW50UmVuZGVyaW5nOiBCb29sZWFuLFxuICBidXNpbmVzc0hvdXJzOiBpZGVudGl0eSBhcyBJZGVudGl0eTxCdXNpbmVzc0hvdXJzSW5wdXQ+LFxuICBpbml0aWFsRGF0ZTogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGF0ZUlucHV0PixcbiAgbm93OiBpZGVudGl0eSBhcyBJZGVudGl0eTxEYXRlSW5wdXQgfCAoKHRoaXM6IENhbGVuZGFyQXBpKSA9PiBEYXRlSW5wdXQpPixcbiAgZXZlbnREYXRhVHJhbnNmb3JtOiBpZGVudGl0eSBhcyBJZGVudGl0eTxFdmVudElucHV0VHJhbnNmb3JtZXI+LFxuICBzdGlja3lIZWFkZXJEYXRlczogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Ym9vbGVhbiB8ICdhdXRvJz4sXG4gIHN0aWNreUZvb3RlclNjcm9sbGJhcjogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Ym9vbGVhbiB8ICdhdXRvJz4sXG4gIHZpZXdIZWlnaHQ6IGlkZW50aXR5IGFzIElkZW50aXR5PENzc0RpbVZhbHVlPixcbiAgZGVmYXVsdEFsbERheTogQm9vbGVhbixcbiAgZXZlbnRTb3VyY2VGYWlsdXJlOiBpZGVudGl0eSBhcyBJZGVudGl0eTwodGhpczogQ2FsZW5kYXJBcGksIGVycm9yOiBhbnkpID0+IHZvaWQ+LFxuICBldmVudFNvdXJjZVN1Y2Nlc3M6IGlkZW50aXR5IGFzIElkZW50aXR5PCh0aGlzOiBDYWxlbmRhckFwaSwgZXZlbnRzSW5wdXQ6IEV2ZW50SW5wdXRbXSwgeGhyPzogWE1MSHR0cFJlcXVlc3QpID0+IEV2ZW50SW5wdXRbXSB8IHZvaWQ+LFxuXG4gIGV2ZW50RGlzcGxheTogU3RyaW5nLCAvLyBUT0RPOiBnaXZlIG1vcmUgc3BlY2lmaWNcbiAgZXZlbnRTdGFydEVkaXRhYmxlOiBCb29sZWFuLFxuICBldmVudER1cmF0aW9uRWRpdGFibGU6IEJvb2xlYW4sXG4gIGV2ZW50T3ZlcmxhcDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Ym9vbGVhbiB8IE92ZXJsYXBGdW5jPixcbiAgZXZlbnRDb25zdHJhaW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxDb25zdHJhaW50SW5wdXQ+LFxuICBldmVudEFsbG93OiBpZGVudGl0eSBhcyBJZGVudGl0eTxBbGxvd0Z1bmM+LFxuICBldmVudEJhY2tncm91bmRDb2xvcjogU3RyaW5nLFxuICBldmVudEJvcmRlckNvbG9yOiBTdHJpbmcsXG4gIGV2ZW50VGV4dENvbG9yOiBTdHJpbmcsXG4gIGV2ZW50Q29sb3I6IFN0cmluZyxcbiAgZXZlbnRDbGFzc05hbWVzOiBpZGVudGl0eSBhcyBJZGVudGl0eTxDbGFzc05hbWVzR2VuZXJhdG9yPEV2ZW50Q29udGVudEFyZz4+LFxuICBldmVudENvbnRlbnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PEN1c3RvbUNvbnRlbnRHZW5lcmF0b3I8RXZlbnRDb250ZW50QXJnPj4sXG4gIGV2ZW50RGlkTW91bnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PERpZE1vdW50SGFuZGxlcjxFdmVudE1vdW50QXJnPj4sXG4gIGV2ZW50V2lsbFVubW91bnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PFdpbGxVbm1vdW50SGFuZGxlcjxFdmVudE1vdW50QXJnPj4sXG5cbiAgc2VsZWN0Q29uc3RyYWludDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q29uc3RyYWludElucHV0PixcbiAgc2VsZWN0T3ZlcmxhcDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Ym9vbGVhbiB8IE92ZXJsYXBGdW5jPixcbiAgc2VsZWN0QWxsb3c6IGlkZW50aXR5IGFzIElkZW50aXR5PEFsbG93RnVuYz4sXG5cbiAgZHJvcHBhYmxlOiBCb29sZWFuLFxuICB1bnNlbGVjdENhbmNlbDogU3RyaW5nLFxuXG4gIHNsb3RMYWJlbEZvcm1hdDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Rm9ybWF0dGVySW5wdXQgfCBGb3JtYXR0ZXJJbnB1dFtdPixcblxuICBzbG90TGFuZUNsYXNzTmFtZXM6IGlkZW50aXR5IGFzIElkZW50aXR5PENsYXNzTmFtZXNHZW5lcmF0b3I8U2xvdExhbmVDb250ZW50QXJnPj4sXG4gIHNsb3RMYW5lQ29udGVudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q3VzdG9tQ29udGVudEdlbmVyYXRvcjxTbG90TGFuZUNvbnRlbnRBcmc+PixcbiAgc2xvdExhbmVEaWRNb3VudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGlkTW91bnRIYW5kbGVyPFNsb3RMYW5lTW91bnRBcmc+PixcbiAgc2xvdExhbmVXaWxsVW5tb3VudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8V2lsbFVubW91bnRIYW5kbGVyPFNsb3RMYW5lTW91bnRBcmc+PixcblxuICBzbG90TGFiZWxDbGFzc05hbWVzOiBpZGVudGl0eSBhcyBJZGVudGl0eTxDbGFzc05hbWVzR2VuZXJhdG9yPFNsb3RMYWJlbENvbnRlbnRBcmc+PixcbiAgc2xvdExhYmVsQ29udGVudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q3VzdG9tQ29udGVudEdlbmVyYXRvcjxTbG90TGFiZWxDb250ZW50QXJnPj4sXG4gIHNsb3RMYWJlbERpZE1vdW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxEaWRNb3VudEhhbmRsZXI8U2xvdExhYmVsTW91bnRBcmc+PixcbiAgc2xvdExhYmVsV2lsbFVubW91bnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PFdpbGxVbm1vdW50SGFuZGxlcjxTbG90TGFiZWxNb3VudEFyZz4+LFxuXG4gIGRheU1heEV2ZW50czogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Ym9vbGVhbiB8IG51bWJlcj4sXG4gIGRheU1heEV2ZW50Um93czogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Ym9vbGVhbiB8IG51bWJlcj4sXG4gIGRheU1pbldpZHRoOiBOdW1iZXIsXG4gIHNsb3RMYWJlbEludGVydmFsOiBjcmVhdGVEdXJhdGlvbixcblxuICBhbGxEYXlUZXh0OiBTdHJpbmcsXG4gIGFsbERheUNsYXNzTmFtZXM6IGlkZW50aXR5IGFzIElkZW50aXR5PENsYXNzTmFtZXNHZW5lcmF0b3I8QWxsRGF5Q29udGVudEFyZz4+LFxuICBhbGxEYXlDb250ZW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxDdXN0b21Db250ZW50R2VuZXJhdG9yPEFsbERheUNvbnRlbnRBcmc+PixcbiAgYWxsRGF5RGlkTW91bnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PERpZE1vdW50SGFuZGxlcjxBbGxEYXlNb3VudEFyZz4+LFxuICBhbGxEYXlXaWxsVW5tb3VudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8V2lsbFVubW91bnRIYW5kbGVyPEFsbERheU1vdW50QXJnPj4sXG5cbiAgc2xvdE1pbldpZHRoOiBOdW1iZXIsIC8vIG1vdmUgdG8gdGltZWxpbmU/XG4gIG5hdkxpbmtzOiBCb29sZWFuLFxuICBldmVudFRpbWVGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgcmVyZW5kZXJEZWxheTogTnVtYmVyLCAvLyBUT0RPOiBtb3ZlIHRvIEBmdWxsY2FsZW5kYXIvY29yZSByaWdodD8gbmFoIGtlZXAgaGVyZVxuICBtb3JlTGlua1RleHQ6IGlkZW50aXR5IGFzIElkZW50aXR5PHN0cmluZyB8ICgodGhpczogQ2FsZW5kYXJBcGksIG51bTogbnVtYmVyKSA9PiBzdHJpbmcpPiwgLy8gdGhpcyBub3QgZW5mb3JjZWQgOiggY2hlY2sgb3RoZXJzIHRvb1xuICBzZWxlY3RNaW5EaXN0YW5jZTogTnVtYmVyLFxuICBzZWxlY3RhYmxlOiBCb29sZWFuLFxuICBzZWxlY3RMb25nUHJlc3NEZWxheTogTnVtYmVyLFxuICBldmVudExvbmdQcmVzc0RlbGF5OiBOdW1iZXIsXG5cbiAgc2VsZWN0TWlycm9yOiBCb29sZWFuLFxuICBldmVudE1pbkhlaWdodDogTnVtYmVyLCAvLyBUT0RPOiBraWxsIHRoaXMgc2V0dGluZ1xuICBzbG90RXZlbnRPdmVybGFwOiBCb29sZWFuLFxuICBwbHVnaW5zOiBpZGVudGl0eSBhcyBJZGVudGl0eTxQbHVnaW5EZWZbXT4sXG4gIGZpcnN0RGF5OiBOdW1iZXIsXG4gIGRheUNvdW50OiBOdW1iZXIsXG4gIGRhdGVBbGlnbm1lbnQ6IFN0cmluZyxcbiAgZGF0ZUluY3JlbWVudDogY3JlYXRlRHVyYXRpb24sXG4gIGhpZGRlbkRheXM6IGlkZW50aXR5IGFzIElkZW50aXR5PG51bWJlcltdPixcbiAgbW9udGhNb2RlOiBCb29sZWFuLFxuICBmaXhlZFdlZWtDb3VudDogQm9vbGVhbixcbiAgdmFsaWRSYW5nZTogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGF0ZVJhbmdlSW5wdXQgfCAoKHRoaXM6IENhbGVuZGFyQXBpLCBub3dEYXRlOiBEYXRlKSA9PiBEYXRlUmFuZ2VJbnB1dCk+LCAvLyBgdGhpc2Agd29ya3M/XG4gIHZpc2libGVSYW5nZTogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGF0ZVJhbmdlSW5wdXQgfCAoKHRoaXM6IENhbGVuZGFyQXBpLCBjdXJyZW50RGF0ZTogRGF0ZSkgPT4gRGF0ZVJhbmdlSW5wdXQpPiwgLy8gYHRoaXNgIHdvcmtzP1xuICB0aXRsZUZvcm1hdDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Rm9ybWF0dGVySW5wdXQ+LCAvLyBET05UIHBhcnNlIGp1c3QgeWV0LiB3ZSBuZWVkIHRvIGluamVjdCB0aXRsZVNlcGFyYXRvclxuXG4gIC8vIG9ubHkgdXNlZCBieSBsaXN0LXZpZXcsIGJ1dCBsYW5ndWFnZXMgZGVmaW5lIHRoZSB2YWx1ZSwgc28gd2UgbmVlZCBpdCBpbiBiYXNlIG9wdGlvbnNcbiAgbm9FdmVudHNUZXh0OiBTdHJpbmdcbn1cblxudHlwZSBCdWlsdEluQmFzZU9wdGlvblJlZmluZXJzID0gdHlwZW9mIEJBU0VfT1BUSU9OX1JFRklORVJTXG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFzZU9wdGlvblJlZmluZXJzIGV4dGVuZHMgQnVpbHRJbkJhc2VPcHRpb25SZWZpbmVycyB7XG4gIC8vIGZvciBhbWJpZW50LWV4dGVuZGluZ1xufVxuXG5leHBvcnQgdHlwZSBCYXNlT3B0aW9ucyA9IFJhd09wdGlvbnNGcm9tUmVmaW5lcnM8IC8vIGFzIFJhd09wdGlvbnNcbiAgUmVxdWlyZWQ8QmFzZU9wdGlvblJlZmluZXJzPiAvLyBSZXF1aXJlZCBpcyBhIGhhY2sgZm9yIFwiSW5kZXggc2lnbmF0dXJlIGlzIG1pc3NpbmdcIlxuPlxuXG4vLyBkbyBOT1QgZ2l2ZSBhIHR5cGUgaGVyZS4gbmVlZCBgdHlwZW9mIEJBU0VfT1BUSU9OX0RFRkFVTFRTYCB0byBnaXZlIHJlYWwgcmVzdWx0cy5cbi8vIHJhdyB2YWx1ZXMuXG5leHBvcnQgY29uc3QgQkFTRV9PUFRJT05fREVGQVVMVFMgPSB7XG4gIGV2ZW50RGlzcGxheTogJ2F1dG8nLFxuICBkZWZhdWx0UmFuZ2VTZXBhcmF0b3I6ICcgLSAnLFxuICB0aXRsZVJhbmdlU2VwYXJhdG9yOiAnIFxcdTIwMTMgJywgLy8gZW4gZGFzaFxuICBkZWZhdWx0VGltZWRFdmVudER1cmF0aW9uOiAnMDE6MDA6MDAnLFxuICBkZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbjogeyBkYXk6IDEgfSxcbiAgZm9yY2VFdmVudER1cmF0aW9uOiBmYWxzZSxcbiAgbmV4dERheVRocmVzaG9sZDogJzAwOjAwOjAwJyxcbiAgZGF5SGVhZGVyczogdHJ1ZSxcbiAgaW5pdGlhbFZpZXc6ICcnLFxuICBhc3BlY3RSYXRpbzogMS4zNSxcbiAgaGVhZGVyVG9vbGJhcjoge1xuICAgIHN0YXJ0OiAndGl0bGUnLFxuICAgIGNlbnRlcjogJycsXG4gICAgZW5kOiAndG9kYXkgcHJldixuZXh0J1xuICB9LFxuICB3ZWVrZW5kczogdHJ1ZSxcbiAgd2Vla051bWJlcnM6IGZhbHNlLFxuICB3ZWVrTnVtYmVyQ2FsY3VsYXRpb246ICdsb2NhbCcgYXMgV2Vla051bWJlckNhbGN1bGF0aW9uLFxuICBlZGl0YWJsZTogZmFsc2UsXG4gIG5vd0luZGljYXRvcjogZmFsc2UsXG4gIHNjcm9sbFRpbWU6ICcwNjowMDowMCcsXG4gIHNsb3RNaW5UaW1lOiAnMDA6MDA6MDAnLFxuICBzbG90TWF4VGltZTogJzI0OjAwOjAwJyxcbiAgc2hvd05vbkN1cnJlbnREYXRlczogdHJ1ZSxcbiAgbGF6eUZldGNoaW5nOiB0cnVlLFxuICBzdGFydFBhcmFtOiAnc3RhcnQnLFxuICBlbmRQYXJhbTogJ2VuZCcsXG4gIHRpbWVab25lUGFyYW06ICd0aW1lWm9uZScsXG4gIHRpbWVab25lOiAnbG9jYWwnLCAvLyBUT0RPOiB0aHJvdyBlcnJvciBpZiBnaXZlbiBmYWxzeSB2YWx1ZT9cbiAgbG9jYWxlczogW10sXG4gIGxvY2FsZTogJycsIC8vIGJsYW5rIHZhbHVlcyBtZWFucyBpdCB3aWxsIGNvbXB1dGUgYmFzZWQgb2ZmIGxvY2FsZXNbXVxuICB0aGVtZVN5c3RlbTogJ3N0YW5kYXJkJyxcbiAgZHJhZ1JldmVydER1cmF0aW9uOiA1MDAsXG4gIGRyYWdTY3JvbGw6IHRydWUsXG4gIGFsbERheU1haW50YWluRHVyYXRpb246IGZhbHNlLFxuICB1bnNlbGVjdEF1dG86IHRydWUsXG4gIGRyb3BBY2NlcHQ6ICcqJyxcbiAgZXZlbnRPcmRlcjogJ3N0YXJ0LC1kdXJhdGlvbixhbGxEYXksdGl0bGUnLFxuICBkYXlQb3BvdmVyRm9ybWF0OiB7IG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnLCB5ZWFyOiAnbnVtZXJpYycgfSxcbiAgaGFuZGxlV2luZG93UmVzaXplOiB0cnVlLFxuICB3aW5kb3dSZXNpemVEZWxheTogMTAwLCAvLyBtaWxsaXNlY29uZHMgYmVmb3JlIGFuIHVwZGF0ZVNpemUgaGFwcGVuc1xuICBsb25nUHJlc3NEZWxheTogMTAwMCxcbiAgZXZlbnREcmFnTWluRGlzdGFuY2U6IDUsIC8vIG9ubHkgYXBwbGllcyB0byBtb3VzZVxuICBleHBhbmRSb3dzOiBmYWxzZSxcbiAgbmF2TGlua3M6IGZhbHNlLFxuICBzZWxlY3RhYmxlOiBmYWxzZVxufVxuXG5leHBvcnQgdHlwZSBCYXNlT3B0aW9uc1JlZmluZWQgPSBEZWZhdWx0ZWRSZWZpbmVkT3B0aW9uczxcbiAgUmVmaW5lZE9wdGlvbnNGcm9tUmVmaW5lcnM8UmVxdWlyZWQ8QmFzZU9wdGlvblJlZmluZXJzPj4sIC8vIFJlcXVpcmVkIGlzIGEgaGFjayBmb3IgXCJJbmRleCBzaWduYXR1cmUgaXMgbWlzc2luZ1wiXG4gIGtleW9mIHR5cGVvZiBCQVNFX09QVElPTl9ERUZBVUxUU1xuPlxuXG5cbi8vIGNhbGVuZGFyIGxpc3RlbmVyc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyA9IHtcbiAgZGF0ZXNTZXQ6IGlkZW50aXR5IGFzIElkZW50aXR5PChhcmc6IERhdGVzU2V0QXJnKSA9PiB2b2lkPixcbiAgZXZlbnRzU2V0OiBpZGVudGl0eSBhcyBJZGVudGl0eTwoZXZlbnRzOiBFdmVudEFwaVtdKSA9PiB2b2lkPixcbiAgZXZlbnRBZGQ6IGlkZW50aXR5IGFzIElkZW50aXR5PChhcmc6IEV2ZW50QWRkQXJnKSA9PiB2b2lkPixcbiAgZXZlbnRDaGFuZ2U6IGlkZW50aXR5IGFzIElkZW50aXR5PChhcmc6IEV2ZW50Q2hhbmdlQXJnKSA9PiB2b2lkPixcbiAgZXZlbnRSZW1vdmU6IGlkZW50aXR5IGFzIElkZW50aXR5PChhcmc6IEV2ZW50UmVtb3ZlQXJnKSA9PiB2b2lkPixcbiAgd2luZG93UmVzaXplOiBpZGVudGl0eSBhcyBJZGVudGl0eTwoYXJnOiB7IHZpZXc6IFZpZXdBcGkgfSkgPT4gdm9pZD4sXG4gIGV2ZW50Q2xpY2s6IGlkZW50aXR5IGFzIElkZW50aXR5PChhcmc6IEV2ZW50Q2xpY2tBcmcpID0+IHZvaWQ+LCAvLyBUT0RPOiByZXNvdXJjZSBmb3Igc2NoZWR1bGVyPz8/P1xuICBldmVudE1vdXNlRW50ZXI6IGlkZW50aXR5IGFzIElkZW50aXR5PChhcmc6IEV2ZW50SG92ZXJpbmdBcmcpID0+IHZvaWQ+LFxuICBldmVudE1vdXNlTGVhdmU6IGlkZW50aXR5IGFzIElkZW50aXR5PChhcmc6IEV2ZW50SG92ZXJpbmdBcmcpID0+IHZvaWQ+LFxuICBzZWxlY3Q6IGlkZW50aXR5IGFzIElkZW50aXR5PChhcmc6IERhdGVTZWxlY3RBcmcpID0+IHZvaWQ+LCAvLyByZXNvdXJjZSBmb3Igc2NoZWR1bGVyPz8/P1xuICB1bnNlbGVjdDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KGFyZzogRGF0ZVVuc2VsZWN0QXJnKSA9PiB2b2lkPixcbiAgbG9hZGluZzogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KGlzTG9hZGluZzogYm9vbGVhbikgPT4gdm9pZD4sXG5cbiAgLy8gaW50ZXJuYWxcbiAgX3VubW91bnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PCgpID0+IHZvaWQ+LFxuICBfYmVmb3JlcHJpbnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PCgpID0+IHZvaWQ+LFxuICBfYWZ0ZXJwcmludDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KCkgPT4gdm9pZD4sXG4gIF9ub0V2ZW50RHJvcDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KCkgPT4gdm9pZD4sXG4gIF9ub0V2ZW50UmVzaXplOiBpZGVudGl0eSBhcyBJZGVudGl0eTwoKSA9PiB2b2lkPixcbiAgX3Jlc2l6ZTogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KGZvcmNlZDogYm9vbGVhbikgPT4gdm9pZD4sXG4gIF9zY3JvbGxSZXF1ZXN0OiBpZGVudGl0eSBhcyBJZGVudGl0eTwoYXJnOiBhbnkpID0+IHZvaWQ+XG59XG5cbnR5cGUgQnVpbHRJbkNhbGVuZGFyTGlzdGVuZXJSZWZpbmVycyA9IHR5cGVvZiBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSU1xuXG5leHBvcnQgaW50ZXJmYWNlIENhbGVuZGFyTGlzdGVuZXJSZWZpbmVycyBleHRlbmRzIEJ1aWx0SW5DYWxlbmRhckxpc3RlbmVyUmVmaW5lcnMge1xuICAvLyBmb3IgYW1iaWVudCBleHRlbmRpbmdcbn1cblxudHlwZSBDYWxlbmRhckxpc3RlbmVyc0xvb3NlID0gUmVmaW5lZE9wdGlvbnNGcm9tUmVmaW5lcnM8UmVxdWlyZWQ8Q2FsZW5kYXJMaXN0ZW5lclJlZmluZXJzPj4gLy8gUmVxdWlyZWQgaGFja1xuZXhwb3J0IHR5cGUgQ2FsZW5kYXJMaXN0ZW5lcnMgPSBSZXF1aXJlZDxDYWxlbmRhckxpc3RlbmVyc0xvb3NlPiAvLyBtdWNoIG1vcmUgY29udmVuaWVudCBmb3IgRW1pdHRlcnMgYW5kIHdoYXRub3RcblxuXG4vLyBjYWxlbmRhci1zcGVjaWZpYyBvcHRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBDQUxFTkRBUl9PUFRJT05fUkVGSU5FUlMgPSB7IC8vIGRvZXMgbm90IGluY2x1ZGUgYmFzZSBub3IgY2FsZW5kYXIgbGlzdGVuZXJzXG4gIGJ1dHRvblRleHQ6IGlkZW50aXR5IGFzIElkZW50aXR5PEJ1dHRvblRleHRDb21wb3VuZElucHV0PixcbiAgdmlld3M6IGlkZW50aXR5IGFzIElkZW50aXR5PHsgW3ZpZXdJZDogc3RyaW5nXTogVmlld09wdGlvbnMgfT4sXG4gIHBsdWdpbnM6IGlkZW50aXR5IGFzIElkZW50aXR5PFBsdWdpbkRlZltdPixcbiAgaW5pdGlhbEV2ZW50czogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RXZlbnRTb3VyY2VJbnB1dD4sXG4gIGV2ZW50czogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RXZlbnRTb3VyY2VJbnB1dD4sXG4gIGV2ZW50U291cmNlczogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RXZlbnRTb3VyY2VJbnB1dFtdPlxufVxuXG50eXBlIEJ1aWx0SW5DYWxlbmRhck9wdGlvblJlZmluZXJzID0gdHlwZW9mIENBTEVOREFSX09QVElPTl9SRUZJTkVSU1xuXG5leHBvcnQgaW50ZXJmYWNlIENhbGVuZGFyT3B0aW9uUmVmaW5lcnMgZXh0ZW5kcyBCdWlsdEluQ2FsZW5kYXJPcHRpb25SZWZpbmVycyB7XG4gIC8vIGZvciBhbWJpZW50LWV4dGVuZGluZ1xufVxuXG5leHBvcnQgdHlwZSBDYWxlbmRhck9wdGlvbnMgPVxuICBCYXNlT3B0aW9ucyAmXG4gIENhbGVuZGFyTGlzdGVuZXJzTG9vc2UgJlxuICBSYXdPcHRpb25zRnJvbVJlZmluZXJzPFJlcXVpcmVkPENhbGVuZGFyT3B0aW9uUmVmaW5lcnM+PiAvLyBSZXF1aXJlZCBoYWNrIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMTUzMDBcblxuZXhwb3J0IHR5cGUgQ2FsZW5kYXJPcHRpb25zUmVmaW5lZCA9XG4gIEJhc2VPcHRpb25zUmVmaW5lZCAmXG4gIENhbGVuZGFyTGlzdGVuZXJzTG9vc2UgJlxuICBSZWZpbmVkT3B0aW9uc0Zyb21SZWZpbmVyczxSZXF1aXJlZDxDYWxlbmRhck9wdGlvblJlZmluZXJzPj4gLy8gUmVxdWlyZWQgaGFja1xuXG5leHBvcnQgY29uc3QgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlM6IHtcbiAgW29wdGlvbk5hbWUgaW4ga2V5b2YgQ2FsZW5kYXJPcHRpb25zXTogKGE6IENhbGVuZGFyT3B0aW9uc1tvcHRpb25OYW1lXSwgYjogQ2FsZW5kYXJPcHRpb25zW29wdGlvbk5hbWVdKSA9PiBib29sZWFuXG59ID0ge1xuICBoZWFkZXJUb29sYmFyOiBpc0Jvb2xDb21wbGV4RXF1YWwsXG4gIGZvb3RlclRvb2xiYXI6IGlzQm9vbENvbXBsZXhFcXVhbCxcbiAgYnV0dG9uVGV4dDogaXNCb29sQ29tcGxleEVxdWFsLFxuICBidXR0b25JY29uczogaXNCb29sQ29tcGxleEVxdWFsXG59XG5cbmZ1bmN0aW9uIGlzQm9vbENvbXBsZXhFcXVhbChhLCBiKSB7XG4gIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT09ICdvYmplY3QnICYmIGEgJiYgYikgeyAvLyBib3RoIG5vbi1udWxsIG9iamVjdHNcbiAgICByZXR1cm4gaXNQcm9wc0VxdWFsKGEsIGIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGEgPT09IGJcbiAgfVxufVxuXG5cblxuLy8gdmlldy1zcGVjaWZpYyBvcHRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IFZJRVdfT1BUSU9OX1JFRklORVJTID0ge1xuICB0eXBlOiBTdHJpbmcsXG4gIGNvbXBvbmVudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Vmlld0NvbXBvbmVudFR5cGU+LFxuICBidXR0b25UZXh0OiBTdHJpbmcsXG4gIGJ1dHRvblRleHRLZXk6IFN0cmluZywgLy8gaW50ZXJuYWwgb25seVxuICBkYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzOiBpZGVudGl0eSBhcyBJZGVudGl0eTxEYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzPixcbiAgdXNlc01pbk1heFRpbWU6IEJvb2xlYW4sIC8vIGludGVybmFsIG9ubHlcbiAgY2xhc3NOYW1lczogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q2xhc3NOYW1lc0dlbmVyYXRvcjxTcGVjaWZpY1ZpZXdDb250ZW50QXJnPj4sXG4gIGNvbnRlbnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PEN1c3RvbUNvbnRlbnRHZW5lcmF0b3I8U3BlY2lmaWNWaWV3Q29udGVudEFyZz4+LFxuICBkaWRNb3VudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGlkTW91bnRIYW5kbGVyPFNwZWNpZmljVmlld01vdW50QXJnPj4sXG4gIHdpbGxVbm1vdW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxXaWxsVW5tb3VudEhhbmRsZXI8U3BlY2lmaWNWaWV3TW91bnRBcmc+PlxufVxuXG50eXBlIEJ1aWx0SW5WaWV3T3B0aW9uUmVmaW5lcnMgPSB0eXBlb2YgVklFV19PUFRJT05fUkVGSU5FUlNcblxuZXhwb3J0IGludGVyZmFjZSBWaWV3T3B0aW9uUmVmaW5lcnMgZXh0ZW5kcyBCdWlsdEluVmlld09wdGlvblJlZmluZXJzIHtcbiAgLy8gZm9yIGFtYmllbnQtZXh0ZW5kaW5nXG59XG5cbmV4cG9ydCB0eXBlIFZpZXdPcHRpb25zID1cbiAgQmFzZU9wdGlvbnMgJlxuICBDYWxlbmRhckxpc3RlbmVyc0xvb3NlICZcbiAgUmF3T3B0aW9uc0Zyb21SZWZpbmVyczxSZXF1aXJlZDxWaWV3T3B0aW9uUmVmaW5lcnM+PiAvLyBSZXF1aXJlZCBoYWNrXG5cbmV4cG9ydCB0eXBlIFZpZXdPcHRpb25zUmVmaW5lZCA9XG4gIEJhc2VPcHRpb25zUmVmaW5lZCAmXG4gIENhbGVuZGFyTGlzdGVuZXJzTG9vc2UgJlxuICBSZWZpbmVkT3B0aW9uc0Zyb21SZWZpbmVyczxSZXF1aXJlZDxWaWV3T3B0aW9uUmVmaW5lcnM+PiAvLyBSZXF1aXJlZCBoYWNrXG5cblxuXG4vLyB1dGlsIGZ1bmNzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlUmF3T3B0aW9ucyhvcHRpb25TZXRzOiBEaWN0aW9uYXJ5W10pIHtcbiAgcmV0dXJuIG1lcmdlUHJvcHMob3B0aW9uU2V0cywgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlMpXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZmluZVByb3BzPFJlZmluZXJzIGV4dGVuZHMgR2VuZXJpY1JlZmluZXJzLCBSYXcgZXh0ZW5kcyBSYXdPcHRpb25zRnJvbVJlZmluZXJzPFJlZmluZXJzPj4oaW5wdXQ6IFJhdywgcmVmaW5lcnM6IFJlZmluZXJzKTogeyByZWZpbmVkOiBSZWZpbmVkT3B0aW9uc0Zyb21SZWZpbmVyczxSZWZpbmVycz4sIGV4dHJhOiBEaWN0aW9uYXJ5IH0ge1xuICBsZXQgcmVmaW5lZCA9IHt9IGFzIGFueVxuICBsZXQgZXh0cmEgPSB7fSBhcyBhbnlcblxuICBmb3IgKGxldCBwcm9wTmFtZSBpbiByZWZpbmVycykge1xuICAgIGlmIChwcm9wTmFtZSBpbiBpbnB1dCkge1xuICAgICAgcmVmaW5lZFtwcm9wTmFtZV0gPSByZWZpbmVyc1twcm9wTmFtZV0oaW5wdXRbcHJvcE5hbWVdKVxuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IHByb3BOYW1lIGluIGlucHV0KSB7XG4gICAgaWYgKCEocHJvcE5hbWUgaW4gcmVmaW5lcnMpKSB7XG4gICAgICBleHRyYVtwcm9wTmFtZV0gPSBpbnB1dFtwcm9wTmFtZV1cbiAgICB9XG4gIH1cblxuICByZXR1cm4geyByZWZpbmVkLCBleHRyYSB9XG59XG5cblxuXG4vLyBkZWZpbml0aW9uIHV0aWxzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuZXhwb3J0IHR5cGUgR2VuZXJpY1JlZmluZXJzID0ge1xuICBbcHJvcE5hbWU6IHN0cmluZ106IChpbnB1dDogYW55KSA9PiBhbnlcbn1cblxuZXhwb3J0IHR5cGUgR2VuZXJpY0xpc3RlbmVyUmVmaW5lcnMgPSB7XG4gIFtsaXN0ZW5lck5hbWU6IHN0cmluZ106IElkZW50aXR5PCh0aGlzOiBDYWxlbmRhckFwaSwgLi4uYXJnczogYW55W10pID0+IHZvaWQ+XG59XG5cbmV4cG9ydCB0eXBlIFJhd09wdGlvbnNGcm9tUmVmaW5lcnM8UmVmaW5lcnMgZXh0ZW5kcyBHZW5lcmljUmVmaW5lcnM+ID0ge1xuICBbUHJvcCBpbiBrZXlvZiBSZWZpbmVyc10/OiAvLyBhbGwgb3B0aW9uYWxcbiAgICBSZWZpbmVyc1tQcm9wXSBleHRlbmRzICgoaW5wdXQ6IGluZmVyIFJhd1R5cGUpID0+IGluZmVyIFJlZmluZWRUeXBlKVxuICAgICAgPyAoYW55IGV4dGVuZHMgUmF3VHlwZSA/IFJlZmluZWRUeXBlIDogUmF3VHlwZSkgLy8gaWYgaW5wdXQgdHlwZSBgYW55YCwgdXNlIG91dHB1dCAoZm9yIEJvb2xlYW4vTnVtYmVyL1N0cmluZylcbiAgICAgIDogbmV2ZXJcbn1cblxuZXhwb3J0IHR5cGUgUmVmaW5lZE9wdGlvbnNGcm9tUmVmaW5lcnM8UmVmaW5lcnMgZXh0ZW5kcyBHZW5lcmljUmVmaW5lcnM+ID0ge1xuICBbUHJvcCBpbiBrZXlvZiBSZWZpbmVyc10/OiAvLyBhbGwgb3B0aW9uYWxcbiAgICBSZWZpbmVyc1tQcm9wXSBleHRlbmRzICgoaW5wdXQ6IGFueSkgPT4gaW5mZXIgUmVmaW5lZFR5cGUpID8gUmVmaW5lZFR5cGUgOiBuZXZlclxufVxuXG5leHBvcnQgdHlwZSBEZWZhdWx0ZWRSZWZpbmVkT3B0aW9uczxSZWZpbmVkT3B0aW9ucyBleHRlbmRzIERpY3Rpb25hcnksIERlZmF1bHRLZXkgZXh0ZW5kcyBrZXlvZiBSZWZpbmVkT3B0aW9ucz4gPVxuICBSZXF1aXJlZDxQaWNrPFJlZmluZWRPcHRpb25zLCBEZWZhdWx0S2V5Pj4gJlxuICBQYXJ0aWFsPE9taXQ8UmVmaW5lZE9wdGlvbnMsIERlZmF1bHRLZXk+PlxuXG5cbmV4cG9ydCB0eXBlIERpY3Rpb25hcnkgPSBSZWNvcmQ8c3RyaW5nLCBhbnk+XG5cbmV4cG9ydCB0eXBlIElkZW50aXR5PFQgPSBhbnk+ID0gKHJhdzogVCkgPT4gVFxuXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHk8VD4ocmF3OiBUKTogVCB7XG4gIHJldHVybiByYXdcbn1cbiIsImltcG9ydCB7IEV2ZW50RGVmLCBFdmVudERlZkhhc2ggfSBmcm9tICcuL2V2ZW50LWRlZidcbmltcG9ydCB7IEV2ZW50SW5zdGFuY2UsIEV2ZW50SW5zdGFuY2VIYXNoIH0gZnJvbSAnLi9ldmVudC1pbnN0YW5jZSdcbmltcG9ydCB7IEV2ZW50SW5wdXQsIHBhcnNlRXZlbnQsIEV2ZW50VHVwbGUsIGJ1aWxkRXZlbnRSZWZpbmVycyB9IGZyb20gJy4vZXZlbnQtcGFyc2UnXG5pbXBvcnQgeyBmaWx0ZXJIYXNoIH0gZnJvbSAnLi4vdXRpbC9vYmplY3QnXG5pbXBvcnQgeyBDYWxlbmRhckNvbnRleHQgfSBmcm9tICcuLi9DYWxlbmRhckNvbnRleHQnXG5pbXBvcnQgeyBFdmVudFNvdXJjZSB9IGZyb20gJy4vZXZlbnQtc291cmNlJ1xuXG4vKlxuQSBkYXRhIHN0cnVjdHVyZSB0aGF0IGVuY2Fwc3VsYXRlcyBFdmVudERlZnMgYW5kIEV2ZW50SW5zdGFuY2VzLlxuVXRpbHMgZm9yIHBhcnNpbmcgdGhpcyBkYXRhIGZyb20gcmF3IEV2ZW50SW5wdXRzLlxuVXRpbHMgZm9yIG1hbmlwdWxhdGluZyBhbiBFdmVudFN0b3JlLlxuKi9cblxuZXhwb3J0IGludGVyZmFjZSBFdmVudFN0b3JlIHtcbiAgZGVmczogRXZlbnREZWZIYXNoXG4gIGluc3RhbmNlczogRXZlbnRJbnN0YW5jZUhhc2hcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VFdmVudHMoXG4gIHJhd0V2ZW50czogRXZlbnRJbnB1dFtdLFxuICBldmVudFNvdXJjZTogRXZlbnRTb3VyY2U8YW55PiB8IG51bGwsXG4gIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCxcbiAgYWxsb3dPcGVuUmFuZ2U/OiBib29sZWFuXG4pOiBFdmVudFN0b3JlIHtcbiAgbGV0IGV2ZW50U3RvcmUgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKVxuICBsZXQgZXZlbnRSZWZpbmVycyA9IGJ1aWxkRXZlbnRSZWZpbmVycyhjb250ZXh0KVxuXG4gIGZvciAobGV0IHJhd0V2ZW50IG9mIHJhd0V2ZW50cykge1xuICAgIGxldCB0dXBsZSA9IHBhcnNlRXZlbnQocmF3RXZlbnQsIGV2ZW50U291cmNlLCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSwgZXZlbnRSZWZpbmVycylcblxuICAgIGlmICh0dXBsZSkge1xuICAgICAgZXZlbnRUdXBsZVRvU3RvcmUodHVwbGUsIGV2ZW50U3RvcmUpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50U3RvcmVcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZXZlbnRUdXBsZVRvU3RvcmUodHVwbGU6IEV2ZW50VHVwbGUsIGV2ZW50U3RvcmU6IEV2ZW50U3RvcmUgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSkge1xuICBldmVudFN0b3JlLmRlZnNbdHVwbGUuZGVmLmRlZklkXSA9IHR1cGxlLmRlZlxuXG4gIGlmICh0dXBsZS5pbnN0YW5jZSkge1xuICAgIGV2ZW50U3RvcmUuaW5zdGFuY2VzW3R1cGxlLmluc3RhbmNlLmluc3RhbmNlSWRdID0gdHVwbGUuaW5zdGFuY2VcbiAgfVxuXG4gIHJldHVybiBldmVudFN0b3JlXG59XG5cblxuLy8gcmV0cmlldmVzIGV2ZW50cyB0aGF0IGhhdmUgdGhlIHNhbWUgZ3JvdXBJZCBhcyB0aGUgaW5zdGFuY2Ugc3BlY2lmaWVkIGJ5IGBpbnN0YW5jZUlkYFxuLy8gb3IgdGhleSBhcmUgdGhlIHNhbWUgYXMgdGhlIGluc3RhbmNlLlxuLy8gd2h5IG1pZ2h0IGluc3RhbmNlSWQgbm90IGJlIGluIHRoZSBzdG9yZT8gYW4gZXZlbnQgZnJvbSBhbm90aGVyIGNhbGVuZGFyP1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJlbGV2YW50RXZlbnRzKGV2ZW50U3RvcmU6IEV2ZW50U3RvcmUsIGluc3RhbmNlSWQ6IHN0cmluZyk6IEV2ZW50U3RvcmUge1xuICBsZXQgaW5zdGFuY2UgPSBldmVudFN0b3JlLmluc3RhbmNlc1tpbnN0YW5jZUlkXVxuXG4gIGlmIChpbnN0YW5jZSkge1xuICAgIGxldCBkZWYgPSBldmVudFN0b3JlLmRlZnNbaW5zdGFuY2UuZGVmSWRdXG5cbiAgICAvLyBnZXQgZXZlbnRzL2luc3RhbmNlcyB3aXRoIHNhbWUgZ3JvdXBcbiAgICBsZXQgbmV3U3RvcmUgPSBmaWx0ZXJFdmVudFN0b3JlRGVmcyhldmVudFN0b3JlLCBmdW5jdGlvbihsb29rRGVmKSB7XG4gICAgICByZXR1cm4gaXNFdmVudERlZnNHcm91cGVkKGRlZiwgbG9va0RlZilcbiAgICB9KVxuXG4gICAgLy8gYWRkIHRoZSBvcmlnaW5hbFxuICAgIC8vIFRPRE86IHdpc2ggd2UgY291bGQgdXNlIGV2ZW50VHVwbGVUb1N0b3JlIG9yIHNvbWV0aGluZyBsaWtlIGl0XG4gICAgbmV3U3RvcmUuZGVmc1tkZWYuZGVmSWRdID0gZGVmXG4gICAgbmV3U3RvcmUuaW5zdGFuY2VzW2luc3RhbmNlLmluc3RhbmNlSWRdID0gaW5zdGFuY2VcblxuICAgIHJldHVybiBuZXdTdG9yZVxuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpXG59XG5cblxuZnVuY3Rpb24gaXNFdmVudERlZnNHcm91cGVkKGRlZjA6IEV2ZW50RGVmLCBkZWYxOiBFdmVudERlZik6IGJvb2xlYW4ge1xuICByZXR1cm4gQm9vbGVhbihkZWYwLmdyb3VwSWQgJiYgZGVmMC5ncm91cElkID09PSBkZWYxLmdyb3VwSWQpXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpOiBFdmVudFN0b3JlIHtcbiAgcmV0dXJuIHsgZGVmczoge30sIGluc3RhbmNlczoge30gfVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUV2ZW50U3RvcmVzKHN0b3JlMDogRXZlbnRTdG9yZSwgc3RvcmUxOiBFdmVudFN0b3JlKTogRXZlbnRTdG9yZSB7XG4gIHJldHVybiB7XG4gICAgZGVmczogeyAuLi5zdG9yZTAuZGVmcywgLi4uc3RvcmUxLmRlZnMgfSxcbiAgICBpbnN0YW5jZXM6IHsgLi4uc3RvcmUwLmluc3RhbmNlcywgLi4uc3RvcmUxLmluc3RhbmNlcyB9XG4gIH1cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyRXZlbnRTdG9yZURlZnMoZXZlbnRTdG9yZTogRXZlbnRTdG9yZSwgZmlsdGVyRnVuYzogKGV2ZW50RGVmOiBFdmVudERlZikgPT4gYm9vbGVhbik6IEV2ZW50U3RvcmUge1xuICBsZXQgZGVmcyA9IGZpbHRlckhhc2goZXZlbnRTdG9yZS5kZWZzLCBmaWx0ZXJGdW5jKVxuICBsZXQgaW5zdGFuY2VzID0gZmlsdGVySGFzaChldmVudFN0b3JlLmluc3RhbmNlcywgZnVuY3Rpb24oaW5zdGFuY2U6IEV2ZW50SW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZGVmc1tpbnN0YW5jZS5kZWZJZF0gLy8gc3RpbGwgZXhpc3RzP1xuICB9KVxuICByZXR1cm4geyBkZWZzLCBpbnN0YW5jZXMgfVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBleGNsdWRlU3ViRXZlbnRTdG9yZShtYXN0ZXI6IEV2ZW50U3RvcmUsIHN1YjogRXZlbnRTdG9yZSk6IEV2ZW50U3RvcmUge1xuICBsZXQgeyBkZWZzLCBpbnN0YW5jZXMgfSA9IG1hc3RlclxuICBsZXQgZmlsdGVyZWREZWZzOiB7IFtkZWZJZDogc3RyaW5nXTogRXZlbnREZWYgfSA9IHt9XG4gIGxldCBmaWx0ZXJlZEluc3RhbmNlczogeyBbaW5zdGFuY2VJZDogc3RyaW5nXTogRXZlbnRJbnN0YW5jZSB9ID0ge31cblxuICBmb3IgKGxldCBkZWZJZCBpbiBkZWZzKSB7XG4gICAgaWYgKCFzdWIuZGVmc1tkZWZJZF0pIHsgLy8gbm90IGV4cGxpY2l0bHkgZXhjbHVkZWRcbiAgICAgIGZpbHRlcmVkRGVmc1tkZWZJZF0gPSBkZWZzW2RlZklkXVxuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgaWYgKFxuICAgICAgIXN1Yi5pbnN0YW5jZXNbaW5zdGFuY2VJZF0gJiYgLy8gbm90IGV4cGxpY2l0bHkgZXhjbHVkZWRcbiAgICAgIGZpbHRlcmVkRGVmc1tpbnN0YW5jZXNbaW5zdGFuY2VJZF0uZGVmSWRdIC8vIGRlZiB3YXNuJ3QgZmlsdGVyZWQgYXdheVxuICAgICkge1xuICAgICAgZmlsdGVyZWRJbnN0YW5jZXNbaW5zdGFuY2VJZF0gPSBpbnN0YW5jZXNbaW5zdGFuY2VJZF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRlZnM6IGZpbHRlcmVkRGVmcyxcbiAgICBpbnN0YW5jZXM6IGZpbHRlcmVkSW5zdGFuY2VzXG4gIH1cbn1cbiIsImltcG9ydCB7IEV2ZW50U3RvcmUsIHBhcnNlRXZlbnRzIH0gZnJvbSAnLi9ldmVudC1zdG9yZSdcbmltcG9ydCB7IEV2ZW50SW5wdXQgfSBmcm9tICcuL2V2ZW50LXBhcnNlJ1xuaW1wb3J0IHsgRGF0ZVNwYW5BcGkgfSBmcm9tICcuL2RhdGUtc3BhbidcbmltcG9ydCB7IEV2ZW50QXBpIH0gZnJvbSAnLi4vYXBpL0V2ZW50QXBpJ1xuaW1wb3J0IHsgU3BsaXR0YWJsZVByb3BzIH0gZnJvbSAnLi4vY29tcG9uZW50L2V2ZW50LXNwbGl0dGluZydcbmltcG9ydCB7IENhbGVuZGFyQ29udGV4dCB9IGZyb20gJy4uL0NhbGVuZGFyQ29udGV4dCdcblxuXG4vLyBUT0RPOiByZW5hbWUgdG8gXCJjcml0ZXJpYVwiID9cbmV4cG9ydCB0eXBlIENvbnN0cmFpbnRJbnB1dCA9ICdidXNpbmVzc0hvdXJzJyB8IHN0cmluZyB8IEV2ZW50SW5wdXQgfCBFdmVudElucHV0W11cbmV4cG9ydCB0eXBlIENvbnN0cmFpbnQgPSAnYnVzaW5lc3NIb3VycycgfCBzdHJpbmcgfCBFdmVudFN0b3JlIHwgZmFsc2UgLy8gZmFsc2UgbWVhbnMgd29uJ3QgcGFzcyBhdCBhbGxcbmV4cG9ydCB0eXBlIE92ZXJsYXBGdW5jID0gKChzdGlsbEV2ZW50OiBFdmVudEFwaSwgbW92aW5nRXZlbnQ6IEV2ZW50QXBpIHwgbnVsbCkgPT4gYm9vbGVhbilcbmV4cG9ydCB0eXBlIEFsbG93RnVuYyA9IChzcGFuOiBEYXRlU3BhbkFwaSwgbW92aW5nRXZlbnQ6IEV2ZW50QXBpIHwgbnVsbCkgPT4gYm9vbGVhblxuZXhwb3J0IHR5cGUgaXNQcm9wc1ZhbGlkVGVzdGVyID0gKHByb3BzOiBTcGxpdHRhYmxlUHJvcHMsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCkgPT4gYm9vbGVhblxuXG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVDb25zdHJhaW50KGlucHV0OiBDb25zdHJhaW50SW5wdXQsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCk6IENvbnN0cmFpbnQgfCBudWxsIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgcmV0dXJuIHBhcnNlRXZlbnRzKGlucHV0LCBudWxsLCBjb250ZXh0LCB0cnVlKSAvLyBhbGxvd09wZW5SYW5nZT10cnVlXG5cbiAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0KSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgIHJldHVybiBwYXJzZUV2ZW50cyhbIGlucHV0IF0sIG51bGwsIGNvbnRleHQsIHRydWUpIC8vIGFsbG93T3BlblJhbmdlPXRydWVcblxuICB9IGVsc2UgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICByZXR1cm4gU3RyaW5nKGlucHV0KVxuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuIiwiXG5leHBvcnQgdHlwZSBDbGFzc05hbWVzSW5wdXQgPSBzdHJpbmcgfCBzdHJpbmdbXVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNsYXNzTmFtZXMocmF3OiBDbGFzc05hbWVzSW5wdXQpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocmF3KSkge1xuICAgIHJldHVybiByYXdcbiAgfSBlbHNlIGlmICh0eXBlb2YgcmF3ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiByYXcuc3BsaXQoL1xccysvKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBbXVxuICB9XG59XG4iLCJpbXBvcnQgeyBDb25zdHJhaW50LCBBbGxvd0Z1bmMsIG5vcm1hbGl6ZUNvbnN0cmFpbnQgfSBmcm9tICcuLi9zdHJ1Y3RzL2NvbnN0cmFpbnQnXG5pbXBvcnQgeyBwYXJzZUNsYXNzTmFtZXMgfSBmcm9tICcuLi91dGlsL2h0bWwnXG5pbXBvcnQgeyBDYWxlbmRhckNvbnRleHQgfSBmcm9tICcuLi9DYWxlbmRhckNvbnRleHQnXG5pbXBvcnQgeyBSYXdPcHRpb25zRnJvbVJlZmluZXJzLCBSZWZpbmVkT3B0aW9uc0Zyb21SZWZpbmVycywgaWRlbnRpdHksIElkZW50aXR5IH0gZnJvbSAnLi4vb3B0aW9ucydcblxuXG4vLyBUT0RPOiBiZXR0ZXIgY2FsbGVkIFwiRXZlbnRTZXR0aW5nc1wiIG9yIFwiRXZlbnRDb25maWdcIlxuLy8gVE9ETzogbW92ZSB0aGlzIGZpbGUgaW50byBzdHJ1Y3RzXG4vLyBUT0RPOiBzZXBhcmF0ZSBjb25zdHJhaW50L292ZXJsYXAvYWxsb3csIGJlY2F1c2Ugc2VsZWN0aW9uIHVzZXMgb25seSB0aGF0LCBub3Qgb3RoZXIgcHJvcHNcblxuZXhwb3J0IGNvbnN0IEVWRU5UX1VJX1JFRklORVJTID0ge1xuICBkaXNwbGF5OiBTdHJpbmcsXG4gIGVkaXRhYmxlOiBCb29sZWFuLFxuICBzdGFydEVkaXRhYmxlOiBCb29sZWFuLFxuICBkdXJhdGlvbkVkaXRhYmxlOiBCb29sZWFuLFxuICBjb25zdHJhaW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxhbnk+LCAvLyBJZGVudGl0eTxDb25zdHJhaW50SW5wdXQ+LCAvLyBjaXJjdWxhciByZWZlcmVuY2UuIHRzIGRpZXMuIGV2ZW50LT5jb25zdHJhaW50LT5ldmVudFxuICBvdmVybGFwOiBpZGVudGl0eSBhcyBJZGVudGl0eTxib29sZWFuPixcbiAgYWxsb3c6IGlkZW50aXR5IGFzIElkZW50aXR5PEFsbG93RnVuYz4sXG4gIGNsYXNzTmFtZTogcGFyc2VDbGFzc05hbWVzLCAvLyB3aWxsIGJvdGggZW5kIHVwIGFzIGFycmF5IG9mIHN0cmluZ3NcbiAgY2xhc3NOYW1lczogcGFyc2VDbGFzc05hbWVzLCAvLyBcIlxuICBjb2xvcjogU3RyaW5nLFxuICBiYWNrZ3JvdW5kQ29sb3I6IFN0cmluZyxcbiAgYm9yZGVyQ29sb3I6IFN0cmluZyxcbiAgdGV4dENvbG9yOiBTdHJpbmdcbn1cblxudHlwZSBCdWlsdEluRXZlbnRVaVJlZmluZXJzID0gdHlwZW9mIEVWRU5UX1VJX1JFRklORVJTXG5cbmludGVyZmFjZSBFdmVudFVpUmVmaW5lcnMgZXh0ZW5kcyBCdWlsdEluRXZlbnRVaVJlZmluZXJzIHtcbiAgLy8gdG8gcHJldmVudCBjaXJjdWxhciByZWZlcmVuY2UgKGFuZCBnaXZlIGlzIHRoZSBvcHRpb24gZm9yIGFtYmllbnQgbW9kaWZpY2F0aW9uIGZvciBsYXRlcilcbn1cblxuZXhwb3J0IHR5cGUgRXZlbnRVaUlucHV0ID0gUmF3T3B0aW9uc0Zyb21SZWZpbmVyczxSZXF1aXJlZDxFdmVudFVpUmVmaW5lcnM+PiAvLyBSZXF1aXJlZCBoYWNrXG5leHBvcnQgdHlwZSBFdmVudFVpUmVmaW5lZCA9IFJlZmluZWRPcHRpb25zRnJvbVJlZmluZXJzPFJlcXVpcmVkPEV2ZW50VWlSZWZpbmVycz4+IC8vIFJlcXVpcmVkIGhhY2tcblxuZXhwb3J0IGludGVyZmFjZSBFdmVudFVpIHtcbiAgZGlzcGxheTogc3RyaW5nIHwgbnVsbFxuICBzdGFydEVkaXRhYmxlOiBib29sZWFuIHwgbnVsbFxuICBkdXJhdGlvbkVkaXRhYmxlOiBib29sZWFuIHwgbnVsbFxuICBjb25zdHJhaW50czogQ29uc3RyYWludFtdXG4gIG92ZXJsYXA6IGJvb2xlYW4gfCBudWxsXG4gIGFsbG93czogQWxsb3dGdW5jW10gLy8gY3JhcHB5IG5hbWUgdG8gaW5kaWNhdGUgcGx1cmFsXG4gIGJhY2tncm91bmRDb2xvcjogc3RyaW5nXG4gIGJvcmRlckNvbG9yOiBzdHJpbmdcbiAgdGV4dENvbG9yOiBzdHJpbmcsXG4gIGNsYXNzTmFtZXM6IHN0cmluZ1tdXG59XG5cbmV4cG9ydCB0eXBlIEV2ZW50VWlIYXNoID0geyBbZGVmSWQ6IHN0cmluZ106IEV2ZW50VWkgfVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFdmVudFVpKHJlZmluZWQ6IEV2ZW50VWlSZWZpbmVkLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpOiBFdmVudFVpIHtcbiAgbGV0IGNvbnN0cmFpbnQgPSBub3JtYWxpemVDb25zdHJhaW50KHJlZmluZWQuY29uc3RyYWludCwgY29udGV4dClcblxuICByZXR1cm4ge1xuICAgIGRpc3BsYXk6IHJlZmluZWQuZGlzcGxheSB8fCBudWxsLFxuICAgIHN0YXJ0RWRpdGFibGU6IHJlZmluZWQuc3RhcnRFZGl0YWJsZSAhPSBudWxsID8gcmVmaW5lZC5zdGFydEVkaXRhYmxlIDogcmVmaW5lZC5lZGl0YWJsZSxcbiAgICBkdXJhdGlvbkVkaXRhYmxlOiByZWZpbmVkLmR1cmF0aW9uRWRpdGFibGUgIT0gbnVsbCA/IHJlZmluZWQuZHVyYXRpb25FZGl0YWJsZSA6IHJlZmluZWQuZWRpdGFibGUsXG4gICAgY29uc3RyYWludHM6IGNvbnN0cmFpbnQgIT0gbnVsbCA/IFsgY29uc3RyYWludCBdIDogW10sXG4gICAgb3ZlcmxhcDogcmVmaW5lZC5vdmVybGFwICE9IG51bGwgPyByZWZpbmVkLm92ZXJsYXAgOiBudWxsLFxuICAgIGFsbG93czogcmVmaW5lZC5hbGxvdyAhPSBudWxsID8gWyByZWZpbmVkLmFsbG93IF0gOiBbXSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IHJlZmluZWQuYmFja2dyb3VuZENvbG9yIHx8IHJlZmluZWQuY29sb3IgfHwgJycsXG4gICAgYm9yZGVyQ29sb3I6IHJlZmluZWQuYm9yZGVyQ29sb3IgfHwgcmVmaW5lZC5jb2xvciB8fCAnJyxcbiAgICB0ZXh0Q29sb3I6IHJlZmluZWQudGV4dENvbG9yIHx8ICcnLFxuICAgIGNsYXNzTmFtZXM6IChyZWZpbmVkLmNsYXNzTmFtZSB8fCBbXSkuY29uY2F0KHJlZmluZWQuY2xhc3NOYW1lcyB8fCBbXSkgLy8gam9pbiBzaW5ndWxhciBhbmQgcGx1cmFsXG4gIH1cbn1cblxuXG4vLyBUT0RPOiBwcmV2ZW50IGFnYWluc3QgcHJvYmxlbXMgd2l0aCA8MiBhcmdzIVxuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVFdmVudFVpcyh1aXM6IEV2ZW50VWlbXSk6IEV2ZW50VWkge1xuICByZXR1cm4gdWlzLnJlZHVjZShjb21iaW5lVHdvRXZlbnRVaXMsIEVNUFRZX0VWRU5UX1VJKVxufVxuXG5cbmZ1bmN0aW9uIGNvbWJpbmVUd29FdmVudFVpcyhpdGVtMDogRXZlbnRVaSwgaXRlbTE6IEV2ZW50VWkpOiBFdmVudFVpIHsgLy8gaGFzaDEgaGFzIGhpZ2hlciBwcmVjZWRlbmNlXG4gIHJldHVybiB7XG4gICAgZGlzcGxheTogaXRlbTEuZGlzcGxheSAhPSBudWxsID8gaXRlbTEuZGlzcGxheSA6IGl0ZW0wLmRpc3BsYXksXG4gICAgc3RhcnRFZGl0YWJsZTogaXRlbTEuc3RhcnRFZGl0YWJsZSAhPSBudWxsID8gaXRlbTEuc3RhcnRFZGl0YWJsZSA6IGl0ZW0wLnN0YXJ0RWRpdGFibGUsXG4gICAgZHVyYXRpb25FZGl0YWJsZTogaXRlbTEuZHVyYXRpb25FZGl0YWJsZSAhPSBudWxsID8gaXRlbTEuZHVyYXRpb25FZGl0YWJsZSA6IGl0ZW0wLmR1cmF0aW9uRWRpdGFibGUsXG4gICAgY29uc3RyYWludHM6IGl0ZW0wLmNvbnN0cmFpbnRzLmNvbmNhdChpdGVtMS5jb25zdHJhaW50cyksXG4gICAgb3ZlcmxhcDogdHlwZW9mIGl0ZW0xLm92ZXJsYXAgPT09ICdib29sZWFuJyA/IGl0ZW0xLm92ZXJsYXAgOiBpdGVtMC5vdmVybGFwLFxuICAgIGFsbG93czogaXRlbTAuYWxsb3dzLmNvbmNhdChpdGVtMS5hbGxvd3MpLFxuICAgIGJhY2tncm91bmRDb2xvcjogaXRlbTEuYmFja2dyb3VuZENvbG9yIHx8IGl0ZW0wLmJhY2tncm91bmRDb2xvcixcbiAgICBib3JkZXJDb2xvcjogaXRlbTEuYm9yZGVyQ29sb3IgfHwgaXRlbTAuYm9yZGVyQ29sb3IsXG4gICAgdGV4dENvbG9yOiBpdGVtMS50ZXh0Q29sb3IgfHwgaXRlbTAudGV4dENvbG9yLFxuICAgIGNsYXNzTmFtZXM6IGl0ZW0wLmNsYXNzTmFtZXMuY29uY2F0KGl0ZW0xLmNsYXNzTmFtZXMpXG4gIH1cbn1cblxuXG5jb25zdCBFTVBUWV9FVkVOVF9VSTogRXZlbnRVaSA9IHtcbiAgZGlzcGxheTogbnVsbCxcbiAgc3RhcnRFZGl0YWJsZTogbnVsbCxcbiAgZHVyYXRpb25FZGl0YWJsZTogbnVsbCxcbiAgY29uc3RyYWludHM6IFtdLFxuICBvdmVybGFwOiBudWxsLFxuICBhbGxvd3M6IFtdLFxuICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxuICBib3JkZXJDb2xvcjogJycsXG4gIHRleHRDb2xvcjogJycsXG4gIGNsYXNzTmFtZXM6IFtdXG59XG4iLCJpbXBvcnQgeyBndWlkIH0gZnJvbSAnLi4vdXRpbC9taXNjJ1xuaW1wb3J0IHsgRGF0ZUlucHV0IH0gZnJvbSAnLi4vZGF0ZWxpYi9lbnYnXG5pbXBvcnQgeyBzdGFydE9mRGF5IH0gZnJvbSAnLi4vZGF0ZWxpYi9tYXJrZXInXG5pbXBvcnQgeyBwYXJzZVJlY3VycmluZyB9IGZyb20gJy4vcmVjdXJyaW5nLWV2ZW50J1xuaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYidcbmltcG9ydCB7IENhbGVuZGFyQ29udGV4dCB9IGZyb20gJy4uL0NhbGVuZGFyQ29udGV4dCdcbmltcG9ydCB7IEV2ZW50RGVmIH0gZnJvbSAnLi9ldmVudC1kZWYnXG5pbXBvcnQgeyBjcmVhdGVFdmVudEluc3RhbmNlLCBFdmVudEluc3RhbmNlIH0gZnJvbSAnLi9ldmVudC1pbnN0YW5jZSdcbmltcG9ydCB7IEV2ZW50U291cmNlIH0gZnJvbSAnLi9ldmVudC1zb3VyY2UnXG5pbXBvcnQgeyBSZWZpbmVkT3B0aW9uc0Zyb21SZWZpbmVycywgUmF3T3B0aW9uc0Zyb21SZWZpbmVycywgaWRlbnRpdHksIElkZW50aXR5LCBEaWN0aW9uYXJ5LCByZWZpbmVQcm9wcyB9IGZyb20gJy4uL29wdGlvbnMnXG5pbXBvcnQgeyBFVkVOVF9VSV9SRUZJTkVSUywgY3JlYXRlRXZlbnRVaSwgRXZlbnRVaUlucHV0LCBFdmVudFVpUmVmaW5lZCB9IGZyb20gJy4uL2NvbXBvbmVudC9ldmVudC11aSdcblxuXG5leHBvcnQgY29uc3QgRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMgPSB7XG4gIGlkOiBTdHJpbmcsXG4gIGdyb3VwSWQ6IFN0cmluZyxcbiAgdGl0bGU6IFN0cmluZyxcbiAgdXJsOiBTdHJpbmdcbn1cblxuZXhwb3J0IGNvbnN0IEVWRU5UX0RBVEVfUkVGSU5FUlMgPSB7XG4gIHN0YXJ0OiBpZGVudGl0eSBhcyBJZGVudGl0eTxEYXRlSW5wdXQ+LFxuICBlbmQ6IGlkZW50aXR5IGFzIElkZW50aXR5PERhdGVJbnB1dD4sXG4gIGRhdGU6IGlkZW50aXR5IGFzIElkZW50aXR5PERhdGVJbnB1dD4sXG4gIGFsbERheTogQm9vbGVhblxufVxuXG5jb25zdCBFVkVOVF9SRUZJTkVSUyA9IHsgLy8gZG9lcyBOT1QgaW5jbHVkZSBFVkVOVF9VSV9SRUZJTkVSU1xuICAuLi5FVkVOVF9OT05fREFURV9SRUZJTkVSUyxcbiAgLi4uRVZFTlRfREFURV9SRUZJTkVSUyxcbiAgZXh0ZW5kZWRQcm9wczogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGljdGlvbmFyeT5cbn1cblxudHlwZSBCdWlsdEluRXZlbnRSZWZpbmVycyA9IHR5cGVvZiBFVkVOVF9SRUZJTkVSU1xuXG5leHBvcnQgaW50ZXJmYWNlIEV2ZW50UmVmaW5lcnMgZXh0ZW5kcyBCdWlsdEluRXZlbnRSZWZpbmVycyB7XG4gIC8vIGZvciBhbWJpZW50XG59XG5cbmV4cG9ydCB0eXBlIEV2ZW50SW5wdXQgPVxuICBFdmVudFVpSW5wdXQgJlxuICBSYXdPcHRpb25zRnJvbVJlZmluZXJzPFJlcXVpcmVkPEV2ZW50UmVmaW5lcnM+PiAmIC8vIFJlcXVpcmVkIGhhY2tcbiAgeyBbZXh0ZW5kZWRQcm9wOiBzdHJpbmddOiBhbnkgfVxuXG5leHBvcnQgdHlwZSBFdmVudFJlZmluZWQgPVxuICBFdmVudFVpUmVmaW5lZCAmXG4gIFJlZmluZWRPcHRpb25zRnJvbVJlZmluZXJzPFJlcXVpcmVkPEV2ZW50UmVmaW5lcnM+PiAvLyBSZXF1aXJlZCBoYWNrXG5cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnRUdXBsZSB7XG4gIGRlZjogRXZlbnREZWZcbiAgaW5zdGFuY2U6IEV2ZW50SW5zdGFuY2UgfCBudWxsXG59XG5cblxuZXhwb3J0IHR5cGUgRXZlbnRJbnB1dFRyYW5zZm9ybWVyID0gKGlucHV0OiBFdmVudElucHV0KSA9PiBFdmVudElucHV0XG5leHBvcnQgdHlwZSBFdmVudERlZk1lbWJlckFkZGVyID0gKHJlZmluZWQ6IEV2ZW50UmVmaW5lZCkgPT4gUGFydGlhbDxFdmVudERlZj5cblxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VFdmVudChcbiAgcmF3OiBFdmVudElucHV0LFxuICBldmVudFNvdXJjZTogRXZlbnRTb3VyY2U8YW55PiB8IG51bGwsXG4gIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCxcbiAgYWxsb3dPcGVuUmFuZ2U6IGJvb2xlYW4sXG4gIHJlZmluZXJzID0gYnVpbGRFdmVudFJlZmluZXJzKGNvbnRleHQpXG4pOiBFdmVudFR1cGxlIHwgbnVsbCB7XG4gIGxldCB7IHJlZmluZWQsIGV4dHJhIH0gPSByZWZpbmVFdmVudERlZihyYXcsIGNvbnRleHQsIHJlZmluZXJzKVxuXG4gIGxldCBkZWZhdWx0QWxsRGF5ID0gY29tcHV0ZUlzRGVmYXVsdEFsbERheShldmVudFNvdXJjZSwgY29udGV4dClcbiAgbGV0IHJlY3VycmluZ1JlcyA9IHBhcnNlUmVjdXJyaW5nKFxuICAgIHJlZmluZWQsXG4gICAgZGVmYXVsdEFsbERheSxcbiAgICBjb250ZXh0LmRhdGVFbnYsXG4gICAgY29udGV4dC5wbHVnaW5Ib29rcy5yZWN1cnJpbmdUeXBlc1xuICApXG5cbiAgaWYgKHJlY3VycmluZ1Jlcykge1xuICAgIGxldCBkZWYgPSBwYXJzZUV2ZW50RGVmKHJlZmluZWQsIGV4dHJhLCBldmVudFNvdXJjZSA/IGV2ZW50U291cmNlLnNvdXJjZUlkIDogJycsIHJlY3VycmluZ1Jlcy5hbGxEYXksIEJvb2xlYW4ocmVjdXJyaW5nUmVzLmR1cmF0aW9uKSwgY29udGV4dClcblxuICAgIGRlZi5yZWN1cnJpbmdEZWYgPSB7IC8vIGRvbid0IHdhbnQgYWxsIHRoZSBwcm9wcyBmcm9tIHJlY3VycmluZ1Jlcy4gVE9ETzogbW9yZSBlZmZpY2llbnQgd2F5IHRvIGRvIHRoaXNcbiAgICAgIHR5cGVJZDogcmVjdXJyaW5nUmVzLnR5cGVJZCxcbiAgICAgIHR5cGVEYXRhOiByZWN1cnJpbmdSZXMudHlwZURhdGEsXG4gICAgICBkdXJhdGlvbjogcmVjdXJyaW5nUmVzLmR1cmF0aW9uXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgZGVmLCBpbnN0YW5jZTogbnVsbCB9XG5cbiAgfSBlbHNlIHtcbiAgICBsZXQgc2luZ2xlUmVzID0gcGFyc2VTaW5nbGUocmVmaW5lZCwgZGVmYXVsdEFsbERheSwgY29udGV4dCwgYWxsb3dPcGVuUmFuZ2UpXG5cbiAgICBpZiAoc2luZ2xlUmVzKSB7XG4gICAgICBsZXQgZGVmID0gcGFyc2VFdmVudERlZihyZWZpbmVkLCBleHRyYSwgZXZlbnRTb3VyY2UgPyBldmVudFNvdXJjZS5zb3VyY2VJZCA6ICcnLCBzaW5nbGVSZXMuYWxsRGF5LCBzaW5nbGVSZXMuaGFzRW5kLCBjb250ZXh0KVxuICAgICAgbGV0IGluc3RhbmNlID0gY3JlYXRlRXZlbnRJbnN0YW5jZShkZWYuZGVmSWQsIHNpbmdsZVJlcy5yYW5nZSwgc2luZ2xlUmVzLmZvcmNlZFN0YXJ0VHpvLCBzaW5nbGVSZXMuZm9yY2VkRW5kVHpvKVxuXG4gICAgICByZXR1cm4geyBkZWYsIGluc3RhbmNlIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiByZWZpbmVFdmVudERlZihyYXc6IEV2ZW50SW5wdXQsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCwgcmVmaW5lcnMgPSBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCkpIHtcbiAgcmV0dXJuIHJlZmluZVByb3BzKHJhdywgcmVmaW5lcnMpXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRXZlbnRSZWZpbmVycyhjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpIHtcbiAgcmV0dXJuIHsgLi4uRVZFTlRfVUlfUkVGSU5FUlMsIC4uLkVWRU5UX1JFRklORVJTLCAuLi5jb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50UmVmaW5lcnMgfVxufVxuXG5cbi8qXG5XaWxsIE5PVCBwb3B1bGF0ZSBleHRlbmRlZFByb3BzIHdpdGggdGhlIGxlZnRvdmVyIHByb3BlcnRpZXMuXG5XaWxsIE5PVCBwb3B1bGF0ZSBkYXRlLXJlbGF0ZWQgcHJvcHMuXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRXZlbnREZWYocmVmaW5lZDogRXZlbnRSZWZpbmVkLCBleHRyYTogRGljdGlvbmFyeSwgc291cmNlSWQ6IHN0cmluZywgYWxsRGF5OiBib29sZWFuLCBoYXNFbmQ6IGJvb2xlYW4sIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCk6IEV2ZW50RGVmIHtcbiAgbGV0IGRlZjogRXZlbnREZWYgPSB7XG4gICAgdGl0bGU6IHJlZmluZWQudGl0bGUgfHwgJycsXG4gICAgZ3JvdXBJZDogcmVmaW5lZC5ncm91cElkIHx8ICcnLFxuICAgIHB1YmxpY0lkOiByZWZpbmVkLmlkIHx8ICcnLFxuICAgIHVybDogcmVmaW5lZC51cmwgfHwgJycsXG4gICAgcmVjdXJyaW5nRGVmOiBudWxsLFxuICAgIGRlZklkOiBndWlkKCksXG4gICAgc291cmNlSWQsXG4gICAgYWxsRGF5LFxuICAgIGhhc0VuZCxcbiAgICB1aTogY3JlYXRlRXZlbnRVaShyZWZpbmVkLCBjb250ZXh0KSxcbiAgICBleHRlbmRlZFByb3BzOiB7XG4gICAgICAuLi4ocmVmaW5lZC5leHRlbmRlZFByb3BzIHx8IHt9KSxcbiAgICAgIC4uLmV4dHJhXG4gICAgfVxuICB9XG5cbiAgZm9yIChsZXQgbWVtYmVyQWRkZXIgb2YgY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudERlZk1lbWJlckFkZGVycykge1xuICAgIF9fYXNzaWduKGRlZiwgbWVtYmVyQWRkZXIocmVmaW5lZCkpXG4gIH1cblxuICAvLyBoZWxwIG91dCBFdmVudEFwaSBmcm9tIGhhdmluZyB1c2VyIG1vZGlmeSBwcm9wc1xuICBPYmplY3QuZnJlZXplKGRlZi51aS5jbGFzc05hbWVzKVxuICBPYmplY3QuZnJlZXplKGRlZi5leHRlbmRlZFByb3BzKVxuXG4gIHJldHVybiBkZWZcbn1cblxuXG5mdW5jdGlvbiBwYXJzZVNpbmdsZShyZWZpbmVkOiBFdmVudFJlZmluZWQsIGRlZmF1bHRBbGxEYXk6IGJvb2xlYW4gfCBudWxsLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQsIGFsbG93T3BlblJhbmdlPzogYm9vbGVhbikge1xuICBsZXQgYWxsRGF5ID0gcmVmaW5lZC5hbGxEYXlcbiAgbGV0IHN0YXJ0TWV0YVxuICBsZXQgc3RhcnRNYXJrZXIgPSBudWxsXG4gIGxldCBoYXNFbmQgPSBmYWxzZVxuICBsZXQgZW5kTWV0YVxuICBsZXQgZW5kTWFya2VyID0gbnVsbFxuXG4gIGxldCBzdGFydElucHV0ID0gcmVmaW5lZC5zdGFydCAhPSBudWxsID8gcmVmaW5lZC5zdGFydCA6IHJlZmluZWQuZGF0ZVxuICBzdGFydE1ldGEgPSBjb250ZXh0LmRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFydElucHV0KVxuXG4gIGlmIChzdGFydE1ldGEpIHtcbiAgICBzdGFydE1hcmtlciA9IHN0YXJ0TWV0YS5tYXJrZXJcbiAgfSBlbHNlIGlmICghYWxsb3dPcGVuUmFuZ2UpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgaWYgKHJlZmluZWQuZW5kICE9IG51bGwpIHtcbiAgICBlbmRNZXRhID0gY29udGV4dC5kYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEocmVmaW5lZC5lbmQpXG4gIH1cblxuICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICBpZiAoZGVmYXVsdEFsbERheSAhPSBudWxsKSB7XG4gICAgICBhbGxEYXkgPSBkZWZhdWx0QWxsRGF5XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZhbGwgYmFjayB0byB0aGUgZGF0ZSBwcm9wcyBMQVNUXG4gICAgICBhbGxEYXkgPSAoIXN0YXJ0TWV0YSB8fCBzdGFydE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpICYmXG4gICAgICAgICghZW5kTWV0YSB8fCBlbmRNZXRhLmlzVGltZVVuc3BlY2lmaWVkKVxuICAgIH1cbiAgfVxuXG4gIGlmIChhbGxEYXkgJiYgc3RhcnRNYXJrZXIpIHtcbiAgICBzdGFydE1hcmtlciA9IHN0YXJ0T2ZEYXkoc3RhcnRNYXJrZXIpXG4gIH1cblxuICBpZiAoZW5kTWV0YSkge1xuICAgIGVuZE1hcmtlciA9IGVuZE1ldGEubWFya2VyXG5cbiAgICBpZiAoYWxsRGF5KSB7XG4gICAgICBlbmRNYXJrZXIgPSBzdGFydE9mRGF5KGVuZE1hcmtlcilcbiAgICB9XG5cbiAgICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyIDw9IHN0YXJ0TWFya2VyKSB7XG4gICAgICBlbmRNYXJrZXIgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZE1hcmtlcikge1xuICAgIGhhc0VuZCA9IHRydWVcbiAgfSBlbHNlIGlmICghYWxsb3dPcGVuUmFuZ2UpIHtcbiAgICBoYXNFbmQgPSBjb250ZXh0Lm9wdGlvbnMuZm9yY2VFdmVudER1cmF0aW9uIHx8IGZhbHNlXG5cbiAgICBlbmRNYXJrZXIgPSBjb250ZXh0LmRhdGVFbnYuYWRkKFxuICAgICAgc3RhcnRNYXJrZXIsXG4gICAgICBhbGxEYXkgP1xuICAgICAgICBjb250ZXh0Lm9wdGlvbnMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24gOlxuICAgICAgICBjb250ZXh0Lm9wdGlvbnMuZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvblxuICAgIClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYWxsRGF5LFxuICAgIGhhc0VuZCxcbiAgICByYW5nZTogeyBzdGFydDogc3RhcnRNYXJrZXIsIGVuZDogZW5kTWFya2VyIH0sXG4gICAgZm9yY2VkU3RhcnRUem86IHN0YXJ0TWV0YSA/IHN0YXJ0TWV0YS5mb3JjZWRUem8gOiBudWxsLFxuICAgIGZvcmNlZEVuZFR6bzogZW5kTWV0YSA/IGVuZE1ldGEuZm9yY2VkVHpvIDogbnVsbFxuICB9XG59XG5cblxuZnVuY3Rpb24gY29tcHV0ZUlzRGVmYXVsdEFsbERheShldmVudFNvdXJjZTogRXZlbnRTb3VyY2U8YW55PiB8IG51bGwsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCk6IGJvb2xlYW4gfCBudWxsIHtcbiAgbGV0IHJlcyA9IG51bGxcblxuICBpZiAoZXZlbnRTb3VyY2UpIHtcbiAgICByZXMgPSBldmVudFNvdXJjZS5kZWZhdWx0QWxsRGF5XG4gIH1cblxuICBpZiAocmVzID09IG51bGwpIHtcbiAgICByZXMgPSBjb250ZXh0Lm9wdGlvbnMuZGVmYXVsdEFsbERheVxuICB9XG5cbiAgcmV0dXJuIHJlc1xufVxuIiwiaW1wb3J0IHsgRGF0ZU1hcmtlciwgc3RhcnRPZkRheSwgYWRkRGF5cywgZGlmZkRheXMsIGRpZmZEYXlBbmRUaW1lIH0gZnJvbSAnLi4vZGF0ZWxpYi9tYXJrZXInXG5pbXBvcnQgeyBEdXJhdGlvbiwgYXNSb3VnaE1zLCBjcmVhdGVEdXJhdGlvbiB9IGZyb20gJy4uL2RhdGVsaWIvZHVyYXRpb24nXG5pbXBvcnQgeyBEYXRlRW52IH0gZnJvbSAnLi4vZGF0ZWxpYi9lbnYnXG5pbXBvcnQgeyBEYXRlUmFuZ2UsIE9wZW5EYXRlUmFuZ2UgfSBmcm9tICcuLi9kYXRlbGliL2RhdGUtcmFuZ2UnXG5cblxuLyogRGF0ZSBzdHVmZiB0aGF0IGRvZXNuJ3QgYmVsb25nIGluIGRhdGVsaWIgY29yZVxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuLy8gZ2l2ZW4gYSB0aW1lZCByYW5nZSwgY29tcHV0ZXMgYW4gYWxsLWRheSByYW5nZSB0aGF0IGhhcyB0aGUgc2FtZSBleGFjdCBkdXJhdGlvbixcbi8vIGJ1dCB3aG9zZSBzdGFydCB0aW1lIGlzIGFsaWduZWQgd2l0aCB0aGUgc3RhcnQgb2YgdGhlIGRheS5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlQWxpZ25lZERheVJhbmdlKHRpbWVkUmFuZ2U6IERhdGVSYW5nZSk6IERhdGVSYW5nZSB7XG4gIGxldCBkYXlDbnQgPSBNYXRoLmZsb29yKGRpZmZEYXlzKHRpbWVkUmFuZ2Uuc3RhcnQsIHRpbWVkUmFuZ2UuZW5kKSkgfHwgMVxuICBsZXQgc3RhcnQgPSBzdGFydE9mRGF5KHRpbWVkUmFuZ2Uuc3RhcnQpXG4gIGxldCBlbmQgPSBhZGREYXlzKHN0YXJ0LCBkYXlDbnQpXG4gIHJldHVybiB7IHN0YXJ0LCBlbmQgfVxufVxuXG5cbi8vIGdpdmVuIGEgdGltZWQgcmFuZ2UsIGNvbXB1dGVzIGFuIGFsbC1kYXkgcmFuZ2UgYmFzZWQgb24gaG93IGZvciB0aGUgZW5kIGRhdGUgYmxlZWRzIGludG8gdGhlIG5leHQgZGF5XG4vLyBUT0RPOiBnaXZlIG5leHREYXlUaHJlc2hvbGQgYSBkZWZhdWx0IGFyZ1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UodGltZWRSYW5nZTogT3BlbkRhdGVSYW5nZSwgbmV4dERheVRocmVzaG9sZDogRHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbigwKSk6IE9wZW5EYXRlUmFuZ2Uge1xuICBsZXQgc3RhcnREYXk6IERhdGVNYXJrZXIgPSBudWxsXG4gIGxldCBlbmREYXk6IERhdGVNYXJrZXIgPSBudWxsXG5cbiAgaWYgKHRpbWVkUmFuZ2UuZW5kKSB7XG4gICAgZW5kRGF5ID0gc3RhcnRPZkRheSh0aW1lZFJhbmdlLmVuZClcblxuICAgIGxldCBlbmRUaW1lTVM6IG51bWJlciA9IHRpbWVkUmFuZ2UuZW5kLnZhbHVlT2YoKSAtIGVuZERheS52YWx1ZU9mKCkgLy8gIyBvZiBtaWxsaXNlY29uZHMgaW50byBgZW5kRGF5YFxuXG4gICAgLy8gSWYgdGhlIGVuZCB0aW1lIGlzIGFjdHVhbGx5IGluY2x1c2l2ZWx5IHBhcnQgb2YgdGhlIG5leHQgZGF5IGFuZCBpcyBlcXVhbCB0byBvclxuICAgIC8vIGJleW9uZCB0aGUgbmV4dCBkYXkgdGhyZXNob2xkLCBhZGp1c3QgdGhlIGVuZCB0byBiZSB0aGUgZXhjbHVzaXZlIGVuZCBvZiBgZW5kRGF5YC5cbiAgICAvLyBPdGhlcndpc2UsIGxlYXZpbmcgaXQgYXMgaW5jbHVzaXZlIHdpbGwgY2F1c2UgaXQgdG8gZXhjbHVkZSBgZW5kRGF5YC5cbiAgICBpZiAoZW5kVGltZU1TICYmIGVuZFRpbWVNUyA+PSBhc1JvdWdoTXMobmV4dERheVRocmVzaG9sZCkpIHtcbiAgICAgIGVuZERheSA9IGFkZERheXMoZW5kRGF5LCAxKVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aW1lZFJhbmdlLnN0YXJ0KSB7XG4gICAgc3RhcnREYXkgPSBzdGFydE9mRGF5KHRpbWVkUmFuZ2Uuc3RhcnQpIC8vIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRheSB0aGUgcmFuZ2Ugc3RhcnRzXG5cbiAgICAvLyBJZiBlbmQgaXMgd2l0aGluIGBzdGFydERheWAgYnV0IG5vdCBwYXN0IG5leHREYXlUaHJlc2hvbGQsIGFzc2lnbiB0aGUgZGVmYXVsdCBkdXJhdGlvbiBvZiBvbmUgZGF5LlxuICAgIGlmIChlbmREYXkgJiYgZW5kRGF5IDw9IHN0YXJ0RGF5KSB7XG4gICAgICBlbmREYXkgPSBhZGREYXlzKHN0YXJ0RGF5LCAxKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IHN0YXJ0OiBzdGFydERheSwgZW5kOiBlbmREYXkgfVxufVxuXG5cbi8vIHNwYW5zIGZyb20gb25lIGRheSBpbnRvIGFub3RoZXI/XG5leHBvcnQgZnVuY3Rpb24gaXNNdWx0aURheVJhbmdlKHJhbmdlOiBEYXRlUmFuZ2UpIHtcbiAgbGV0IHZpc2libGVSYW5nZSA9IGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UocmFuZ2UpXG5cbiAgcmV0dXJuIGRpZmZEYXlzKHZpc2libGVSYW5nZS5zdGFydCwgdmlzaWJsZVJhbmdlLmVuZCkgPiAxXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZEYXRlcyhkYXRlMDogRGF0ZU1hcmtlciwgZGF0ZTE6IERhdGVNYXJrZXIsIGRhdGVFbnY6IERhdGVFbnYsIGxhcmdlVW5pdD86IHN0cmluZykge1xuICBpZiAobGFyZ2VVbml0ID09PSAneWVhcicpIHtcbiAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oZGF0ZUVudi5kaWZmV2hvbGVZZWFycyhkYXRlMCwgZGF0ZTEpLCAneWVhcicpIVxuICB9IGVsc2UgaWYgKGxhcmdlVW5pdCA9PT0gJ21vbnRoJykge1xuICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbihkYXRlRW52LmRpZmZXaG9sZU1vbnRocyhkYXRlMCwgZGF0ZTEpLCAnbW9udGgnKSFcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGlmZkRheUFuZFRpbWUoZGF0ZTAsIGRhdGUxKSAvLyByZXR1cm5zIGEgZHVyYXRpb25cbiAgfVxufVxuIiwiaW1wb3J0IHsgRGF0ZU1hcmtlciB9IGZyb20gJy4vbWFya2VyJ1xuaW1wb3J0IHsgRGF0ZUVudiwgRGF0ZUlucHV0IH0gZnJvbSAnLi9lbnYnXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZVJhbmdlSW5wdXQge1xuICBzdGFydD86IERhdGVJbnB1dFxuICBlbmQ/OiBEYXRlSW5wdXRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcGVuRGF0ZVJhbmdlIHtcbiAgc3RhcnQ6IERhdGVNYXJrZXIgfCBudWxsXG4gIGVuZDogRGF0ZU1hcmtlciB8IG51bGxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXRlUmFuZ2Uge1xuICBzdGFydDogRGF0ZU1hcmtlclxuICBlbmQ6IERhdGVNYXJrZXJcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUmFuZ2UoaW5wdXQ6IERhdGVSYW5nZUlucHV0LCBkYXRlRW52OiBEYXRlRW52KTogT3BlbkRhdGVSYW5nZSB7XG4gIGxldCBzdGFydCA9IG51bGxcbiAgbGV0IGVuZCA9IG51bGxcblxuICBpZiAoaW5wdXQuc3RhcnQpIHtcbiAgICBzdGFydCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKGlucHV0LnN0YXJ0KVxuICB9XG5cbiAgaWYgKGlucHV0LmVuZCkge1xuICAgIGVuZCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKGlucHV0LmVuZClcbiAgfVxuXG4gIGlmICghc3RhcnQgJiYgIWVuZCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBpZiAoc3RhcnQgJiYgZW5kICYmIGVuZCA8IHN0YXJ0KSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHJldHVybiB7IHN0YXJ0LCBlbmQgfVxufVxuXG4vLyBTSURFLUVGRkVDVDogd2lsbCBtdXRhdGUgcmFuZ2VzLlxuLy8gV2lsbCByZXR1cm4gYSBuZXcgYXJyYXkgcmVzdWx0LlxuZXhwb3J0IGZ1bmN0aW9uIGludmVydFJhbmdlcyhyYW5nZXM6IERhdGVSYW5nZVtdLCBjb25zdHJhaW50UmFuZ2U6IERhdGVSYW5nZSk6IERhdGVSYW5nZVtdIHtcbiAgbGV0IGludmVydGVkUmFuZ2VzOiBEYXRlUmFuZ2VbXSA9IFtdXG4gIGxldCBzdGFydCA9IGNvbnN0cmFpbnRSYW5nZS5zdGFydCAvLyB0aGUgZW5kIG9mIHRoZSBwcmV2aW91cyByYW5nZS4gdGhlIHN0YXJ0IG9mIHRoZSBuZXcgcmFuZ2VcbiAgbGV0IGlcbiAgbGV0IGRhdGVSYW5nZVxuXG4gIC8vIHJhbmdlcyBuZWVkIHRvIGJlIGluIG9yZGVyLiByZXF1aXJlZCBmb3Igb3VyIGRhdGUtd2Fsa2luZyBhbGdvcml0aG1cbiAgcmFuZ2VzLnNvcnQoY29tcGFyZVJhbmdlcylcblxuICBmb3IgKGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGF0ZVJhbmdlID0gcmFuZ2VzW2ldXG5cbiAgICAvLyBhZGQgdGhlIHNwYW4gb2YgdGltZSBiZWZvcmUgdGhlIGV2ZW50IChpZiB0aGVyZSBpcyBhbnkpXG4gICAgaWYgKGRhdGVSYW5nZS5zdGFydCA+IHN0YXJ0KSB7IC8vIGNvbXBhcmUgbWlsbGlzZWNvbmQgdGltZSAoc2tpcCBhbnkgYW1iaWcgbG9naWMpXG4gICAgICBpbnZlcnRlZFJhbmdlcy5wdXNoKHsgc3RhcnQsIGVuZDogZGF0ZVJhbmdlLnN0YXJ0IH0pXG4gICAgfVxuXG4gICAgaWYgKGRhdGVSYW5nZS5lbmQgPiBzdGFydCkge1xuICAgICAgc3RhcnQgPSBkYXRlUmFuZ2UuZW5kXG4gICAgfVxuICB9XG5cbiAgLy8gYWRkIHRoZSBzcGFuIG9mIHRpbWUgYWZ0ZXIgdGhlIGxhc3QgZXZlbnQgKGlmIHRoZXJlIGlzIGFueSlcbiAgaWYgKHN0YXJ0IDwgY29uc3RyYWludFJhbmdlLmVuZCkgeyAvLyBjb21wYXJlIG1pbGxpc2Vjb25kIHRpbWUgKHNraXAgYW55IGFtYmlnIGxvZ2ljKVxuICAgIGludmVydGVkUmFuZ2VzLnB1c2goeyBzdGFydCwgZW5kOiBjb25zdHJhaW50UmFuZ2UuZW5kIH0pXG4gIH1cblxuICByZXR1cm4gaW52ZXJ0ZWRSYW5nZXNcbn1cblxuZnVuY3Rpb24gY29tcGFyZVJhbmdlcyhyYW5nZTA6IERhdGVSYW5nZSwgcmFuZ2UxOiBEYXRlUmFuZ2UpIHtcbiAgcmV0dXJuIHJhbmdlMC5zdGFydC52YWx1ZU9mKCkgLSByYW5nZTEuc3RhcnQudmFsdWVPZigpIC8vIGVhcmxpZXIgcmFuZ2VzIGdvIGZpcnN0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3RSYW5nZXMocmFuZ2UwOiBPcGVuRGF0ZVJhbmdlLCByYW5nZTE6IE9wZW5EYXRlUmFuZ2UpOiBPcGVuRGF0ZVJhbmdlIHtcbiAgbGV0IHN0YXJ0ID0gcmFuZ2UwLnN0YXJ0XG4gIGxldCBlbmQgPSByYW5nZTAuZW5kXG4gIGxldCBuZXdSYW5nZSA9IG51bGxcblxuICBpZiAocmFuZ2UxLnN0YXJ0ICE9PSBudWxsKSB7XG4gICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XG4gICAgICBzdGFydCA9IHJhbmdlMS5zdGFydFxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCA9IG5ldyBEYXRlKE1hdGgubWF4KHN0YXJ0LnZhbHVlT2YoKSwgcmFuZ2UxLnN0YXJ0LnZhbHVlT2YoKSkpXG4gICAgfVxuICB9XG5cbiAgaWYgKHJhbmdlMS5lbmQgIT0gbnVsbCkge1xuICAgIGlmIChlbmQgPT09IG51bGwpIHtcbiAgICAgIGVuZCA9IHJhbmdlMS5lbmRcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kID0gbmV3IERhdGUoTWF0aC5taW4oZW5kLnZhbHVlT2YoKSwgcmFuZ2UxLmVuZC52YWx1ZU9mKCkpKVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gbnVsbCB8fCBlbmQgPT09IG51bGwgfHwgc3RhcnQgPCBlbmQpIHtcbiAgICBuZXdSYW5nZSA9IHsgc3RhcnQsIGVuZCB9XG4gIH1cblxuICByZXR1cm4gbmV3UmFuZ2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlc0VxdWFsKHJhbmdlMDogT3BlbkRhdGVSYW5nZSwgcmFuZ2UxOiBPcGVuRGF0ZVJhbmdlKTogYm9vbGVhbiB7XG4gIHJldHVybiAocmFuZ2UwLnN0YXJ0ID09PSBudWxsID8gbnVsbCA6IHJhbmdlMC5zdGFydC52YWx1ZU9mKCkpID09PSAocmFuZ2UxLnN0YXJ0ID09PSBudWxsID8gbnVsbCA6IHJhbmdlMS5zdGFydC52YWx1ZU9mKCkpICYmXG4gICAgKHJhbmdlMC5lbmQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UwLmVuZC52YWx1ZU9mKCkpID09PSAocmFuZ2UxLmVuZCA9PT0gbnVsbCA/IG51bGwgOiByYW5nZTEuZW5kLnZhbHVlT2YoKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlc0ludGVyc2VjdChyYW5nZTA6IE9wZW5EYXRlUmFuZ2UsIHJhbmdlMTogT3BlbkRhdGVSYW5nZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gKHJhbmdlMC5lbmQgPT09IG51bGwgfHwgcmFuZ2UxLnN0YXJ0ID09PSBudWxsIHx8IHJhbmdlMC5lbmQgPiByYW5nZTEuc3RhcnQpICYmXG4gICAgKHJhbmdlMC5zdGFydCA9PT0gbnVsbCB8fCByYW5nZTEuZW5kID09PSBudWxsIHx8IHJhbmdlMC5zdGFydCA8IHJhbmdlMS5lbmQpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByYW5nZUNvbnRhaW5zUmFuZ2Uob3V0ZXJSYW5nZTogT3BlbkRhdGVSYW5nZSwgaW5uZXJSYW5nZTogT3BlbkRhdGVSYW5nZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gKG91dGVyUmFuZ2Uuc3RhcnQgPT09IG51bGwgfHwgKGlubmVyUmFuZ2Uuc3RhcnQgIT09IG51bGwgJiYgaW5uZXJSYW5nZS5zdGFydCA+PSBvdXRlclJhbmdlLnN0YXJ0KSkgJiZcbiAgICAob3V0ZXJSYW5nZS5lbmQgPT09IG51bGwgfHwgKGlubmVyUmFuZ2UuZW5kICE9PSBudWxsICYmIGlubmVyUmFuZ2UuZW5kIDw9IG91dGVyUmFuZ2UuZW5kKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlQ29udGFpbnNNYXJrZXIocmFuZ2U6IE9wZW5EYXRlUmFuZ2UsIGRhdGU6IERhdGVNYXJrZXIgfCBudW1iZXIpOiBib29sZWFuIHsgLy8gZGF0ZSBjYW4gYmUgYSBtaWxsaXNlY29uZCB0aW1lXG4gIHJldHVybiAocmFuZ2Uuc3RhcnQgPT09IG51bGwgfHwgZGF0ZSA+PSByYW5nZS5zdGFydCkgJiZcbiAgICAocmFuZ2UuZW5kID09PSBudWxsIHx8IGRhdGUgPCByYW5nZS5lbmQpXG59XG5cbi8vIElmIHRoZSBnaXZlbiBkYXRlIGlzIG5vdCB3aXRoaW4gdGhlIGdpdmVuIHJhbmdlLCBtb3ZlIGl0IGluc2lkZS5cbi8vIChJZiBpdCdzIHBhc3QgdGhlIGVuZCwgbWFrZSBpdCBvbmUgbWlsbGlzZWNvbmQgYmVmb3JlIHRoZSBlbmQpLlxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cmFpbk1hcmtlclRvUmFuZ2UoZGF0ZTogRGF0ZU1hcmtlciwgcmFuZ2U6IERhdGVSYW5nZSk6IERhdGVNYXJrZXIge1xuICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCAmJiBkYXRlIDwgcmFuZ2Uuc3RhcnQpIHtcbiAgICByZXR1cm4gcmFuZ2Uuc3RhcnRcbiAgfVxuXG4gIGlmIChyYW5nZS5lbmQgIT0gbnVsbCAmJiBkYXRlID49IHJhbmdlLmVuZCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShyYW5nZS5lbmQudmFsdWVPZigpIC0gMSlcbiAgfVxuXG4gIHJldHVybiBkYXRlXG59XG4iLCJpbXBvcnQgeyBFdmVudERlZiwgRXZlbnREZWZIYXNoIH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1kZWYnXG5pbXBvcnQgeyBFdmVudFR1cGxlIH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1wYXJzZSdcbmltcG9ydCB7IEV2ZW50U3RvcmUgfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LXN0b3JlJ1xuaW1wb3J0IHsgRGF0ZVJhbmdlLCBpbnZlcnRSYW5nZXMsIGludGVyc2VjdFJhbmdlcywgcmFuZ2VDb250YWluc01hcmtlciB9IGZyb20gJy4uL2RhdGVsaWIvZGF0ZS1yYW5nZSdcbmltcG9ydCB7IER1cmF0aW9uIH0gZnJvbSAnLi4vZGF0ZWxpYi9kdXJhdGlvbidcbmltcG9ydCB7IGNvbXBhcmVCeUZpZWxkU3BlY3MsIE9yZGVyU3BlYyB9IGZyb20gJy4uL3V0aWwvbWlzYydcbmltcG9ydCB7IGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UgfSBmcm9tICcuLi91dGlsL2RhdGUnXG5pbXBvcnQgeyBTZWcgfSBmcm9tICcuL0RhdGVDb21wb25lbnQnXG5pbXBvcnQgeyBFdmVudEFwaSB9IGZyb20gJy4uL2FwaS9FdmVudEFwaSdcbmltcG9ydCB7IEV2ZW50VWksIEV2ZW50VWlIYXNoLCBjb21iaW5lRXZlbnRVaXMgfSBmcm9tICcuL2V2ZW50LXVpJ1xuaW1wb3J0IHsgbWFwSGFzaCB9IGZyb20gJy4uL3V0aWwvb2JqZWN0J1xuaW1wb3J0IHsgVmlld0NvbnRleHQgfSBmcm9tICcuLi9WaWV3Q29udGV4dCdcbmltcG9ydCB7IERhdGVGb3JtYXR0ZXIgfSBmcm9tICcuLi9kYXRlbGliL0RhdGVGb3JtYXR0ZXInXG5pbXBvcnQgeyBEYXRlTWFya2VyIH0gZnJvbSAnLi4vZGF0ZWxpYi9tYXJrZXInXG5pbXBvcnQgeyBWaWV3QXBpIH0gZnJvbSAnLi4vVmlld0FwaSdcbmltcG9ydCB7IE1vdW50QXJnIH0gZnJvbSAnLi4vY29tbW9uL3JlbmRlci1ob29rJ1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnRSZW5kZXJSYW5nZSBleHRlbmRzIEV2ZW50VHVwbGUge1xuICB1aTogRXZlbnRVaVxuICByYW5nZTogRGF0ZVJhbmdlXG4gIGlzU3RhcnQ6IGJvb2xlYW5cbiAgaXNFbmQ6IGJvb2xlYW5cbn1cblxuXG4vKlxuU3BlY2lmeWluZyBuZXh0RGF5VGhyZXNob2xkIHNpZ25hbHMgdGhhdCBhbGwtZGF5IHJhbmdlcyBzaG91bGQgYmUgc2xpY2VkLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBzbGljZUV2ZW50U3RvcmUoZXZlbnRTdG9yZTogRXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzOiBFdmVudFVpSGFzaCwgZnJhbWluZ1JhbmdlOiBEYXRlUmFuZ2UsIG5leHREYXlUaHJlc2hvbGQ/OiBEdXJhdGlvbikge1xuICBsZXQgaW52ZXJzZUJnQnlHcm91cElkOiB7IFtncm91cElkOiBzdHJpbmddOiBEYXRlUmFuZ2VbXSB9ID0ge31cbiAgbGV0IGludmVyc2VCZ0J5RGVmSWQ6IHsgW2RlZklkOiBzdHJpbmddOiBEYXRlUmFuZ2VbXSB9ID0ge31cbiAgbGV0IGRlZkJ5R3JvdXBJZDogeyBbZ3JvdXBJZDogc3RyaW5nXTogRXZlbnREZWYgfSA9IHt9XG4gIGxldCBiZ1JhbmdlczogRXZlbnRSZW5kZXJSYW5nZVtdID0gW11cbiAgbGV0IGZnUmFuZ2VzOiBFdmVudFJlbmRlclJhbmdlW10gPSBbXVxuICBsZXQgZXZlbnRVaXMgPSBjb21waWxlRXZlbnRVaXMoZXZlbnRTdG9yZS5kZWZzLCBldmVudFVpQmFzZXMpXG5cbiAgZm9yIChsZXQgZGVmSWQgaW4gZXZlbnRTdG9yZS5kZWZzKSB7XG4gICAgbGV0IGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tkZWZJZF1cbiAgICBsZXQgdWkgPSBldmVudFVpc1tkZWYuZGVmSWRdXG5cbiAgICBpZiAodWkuZGlzcGxheSA9PT0gJ2ludmVyc2UtYmFja2dyb3VuZCcpIHtcbiAgICAgIGlmIChkZWYuZ3JvdXBJZCkge1xuICAgICAgICBpbnZlcnNlQmdCeUdyb3VwSWRbZGVmLmdyb3VwSWRdID0gW11cblxuICAgICAgICBpZiAoIWRlZkJ5R3JvdXBJZFtkZWYuZ3JvdXBJZF0pIHtcbiAgICAgICAgICBkZWZCeUdyb3VwSWRbZGVmLmdyb3VwSWRdID0gZGVmXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludmVyc2VCZ0J5RGVmSWRbZGVmSWRdID0gW11cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGV2ZW50U3RvcmUuaW5zdGFuY2VzKSB7XG4gICAgbGV0IGluc3RhbmNlID0gZXZlbnRTdG9yZS5pbnN0YW5jZXNbaW5zdGFuY2VJZF1cbiAgICBsZXQgZGVmID0gZXZlbnRTdG9yZS5kZWZzW2luc3RhbmNlLmRlZklkXVxuICAgIGxldCB1aSA9IGV2ZW50VWlzW2RlZi5kZWZJZF1cbiAgICBsZXQgb3JpZ1JhbmdlID0gaW5zdGFuY2UucmFuZ2VcblxuICAgIGxldCBub3JtYWxSYW5nZSA9ICghZGVmLmFsbERheSAmJiBuZXh0RGF5VGhyZXNob2xkKSA/XG4gICAgICBjb21wdXRlVmlzaWJsZURheVJhbmdlKG9yaWdSYW5nZSwgbmV4dERheVRocmVzaG9sZCkgOlxuICAgICAgb3JpZ1JhbmdlXG5cbiAgICBsZXQgc2xpY2VkUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMobm9ybWFsUmFuZ2UsIGZyYW1pbmdSYW5nZSlcblxuICAgIGlmIChzbGljZWRSYW5nZSkge1xuICAgICAgaWYgKHVpLmRpc3BsYXkgPT09ICdpbnZlcnNlLWJhY2tncm91bmQnKSB7XG4gICAgICAgIGlmIChkZWYuZ3JvdXBJZCkge1xuICAgICAgICAgIGludmVyc2VCZ0J5R3JvdXBJZFtkZWYuZ3JvdXBJZF0ucHVzaChzbGljZWRSYW5nZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnZlcnNlQmdCeURlZklkW2luc3RhbmNlLmRlZklkXS5wdXNoKHNsaWNlZFJhbmdlKVxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiAodWkuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICh1aS5kaXNwbGF5ID09PSAnYmFja2dyb3VuZCcgPyBiZ1JhbmdlcyA6IGZnUmFuZ2VzKS5wdXNoKHtcbiAgICAgICAgICBkZWYsXG4gICAgICAgICAgdWksXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgcmFuZ2U6IHNsaWNlZFJhbmdlLFxuICAgICAgICAgIGlzU3RhcnQ6IG5vcm1hbFJhbmdlLnN0YXJ0ICYmIG5vcm1hbFJhbmdlLnN0YXJ0LnZhbHVlT2YoKSA9PT0gc2xpY2VkUmFuZ2Uuc3RhcnQudmFsdWVPZigpLFxuICAgICAgICAgIGlzRW5kOiBub3JtYWxSYW5nZS5lbmQgJiYgbm9ybWFsUmFuZ2UuZW5kLnZhbHVlT2YoKSA9PT0gc2xpY2VkUmFuZ2UuZW5kLnZhbHVlT2YoKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGdyb3VwSWQgaW4gaW52ZXJzZUJnQnlHcm91cElkKSB7IC8vIEJZIEdST1VQXG4gICAgbGV0IHJhbmdlcyA9IGludmVyc2VCZ0J5R3JvdXBJZFtncm91cElkXVxuICAgIGxldCBpbnZlcnRlZFJhbmdlcyA9IGludmVydFJhbmdlcyhyYW5nZXMsIGZyYW1pbmdSYW5nZSlcblxuICAgIGZvciAobGV0IGludmVydGVkUmFuZ2Ugb2YgaW52ZXJ0ZWRSYW5nZXMpIHtcbiAgICAgIGxldCBkZWYgPSBkZWZCeUdyb3VwSWRbZ3JvdXBJZF1cbiAgICAgIGxldCB1aSA9IGV2ZW50VWlzW2RlZi5kZWZJZF1cblxuICAgICAgYmdSYW5nZXMucHVzaCh7XG4gICAgICAgIGRlZixcbiAgICAgICAgdWksXG4gICAgICAgIGluc3RhbmNlOiBudWxsLFxuICAgICAgICByYW5nZTogaW52ZXJ0ZWRSYW5nZSxcbiAgICAgICAgaXNTdGFydDogZmFsc2UsXG4gICAgICAgIGlzRW5kOiBmYWxzZVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCBkZWZJZCBpbiBpbnZlcnNlQmdCeURlZklkKSB7XG4gICAgbGV0IHJhbmdlcyA9IGludmVyc2VCZ0J5RGVmSWRbZGVmSWRdXG4gICAgbGV0IGludmVydGVkUmFuZ2VzID0gaW52ZXJ0UmFuZ2VzKHJhbmdlcywgZnJhbWluZ1JhbmdlKVxuXG4gICAgZm9yIChsZXQgaW52ZXJ0ZWRSYW5nZSBvZiBpbnZlcnRlZFJhbmdlcykge1xuICAgICAgYmdSYW5nZXMucHVzaCh7XG4gICAgICAgIGRlZjogZXZlbnRTdG9yZS5kZWZzW2RlZklkXSxcbiAgICAgICAgdWk6IGV2ZW50VWlzW2RlZklkXSxcbiAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgIHJhbmdlOiBpbnZlcnRlZFJhbmdlLFxuICAgICAgICBpc1N0YXJ0OiBmYWxzZSxcbiAgICAgICAgaXNFbmQ6IGZhbHNlXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IGJnOiBiZ1JhbmdlcywgZmc6IGZnUmFuZ2VzIH1cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gaGFzQmdSZW5kZXJpbmcoZGVmOiBFdmVudERlZikge1xuICByZXR1cm4gZGVmLnVpLmRpc3BsYXkgPT09ICdiYWNrZ3JvdW5kJyB8fCBkZWYudWkuZGlzcGxheSA9PT0gJ2ludmVyc2UtYmFja2dyb3VuZCdcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gc2V0RWxTZWcoZWw6IEhUTUxFbGVtZW50LCBzZWc6IFNlZykge1xuICAoZWwgYXMgYW55KS5mY1NlZyA9IHNlZ1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbFNlZyhlbDogSFRNTEVsZW1lbnQpOiBTZWcgfCBudWxsIHtcbiAgcmV0dXJuIChlbCBhcyBhbnkpLmZjU2VnIHx8XG4gICAgKGVsLnBhcmVudE5vZGUgYXMgYW55KS5mY1NlZyB8fCAvLyBmb3IgdGhlIGhhcm5lc3NcbiAgICBudWxsXG59XG5cblxuLy8gZXZlbnQgdWkgY29tcHV0YXRpb25cblxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGlsZUV2ZW50VWlzKGV2ZW50RGVmczogRXZlbnREZWZIYXNoLCBldmVudFVpQmFzZXM6IEV2ZW50VWlIYXNoKSB7XG4gIHJldHVybiBtYXBIYXNoKGV2ZW50RGVmcywgZnVuY3Rpb24oZXZlbnREZWY6IEV2ZW50RGVmKSB7XG4gICAgcmV0dXJuIGNvbXBpbGVFdmVudFVpKGV2ZW50RGVmLCBldmVudFVpQmFzZXMpXG4gIH0pXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBpbGVFdmVudFVpKGV2ZW50RGVmOiBFdmVudERlZiwgZXZlbnRVaUJhc2VzOiBFdmVudFVpSGFzaCkge1xuICBsZXQgdWlzID0gW11cblxuICBpZiAoZXZlbnRVaUJhc2VzWycnXSkge1xuICAgIHVpcy5wdXNoKGV2ZW50VWlCYXNlc1snJ10pXG4gIH1cblxuICBpZiAoZXZlbnRVaUJhc2VzW2V2ZW50RGVmLmRlZklkXSkge1xuICAgIHVpcy5wdXNoKGV2ZW50VWlCYXNlc1tldmVudERlZi5kZWZJZF0pXG4gIH1cblxuICB1aXMucHVzaChldmVudERlZi51aSlcblxuICByZXR1cm4gY29tYmluZUV2ZW50VWlzKHVpcylcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gc29ydEV2ZW50U2VncyhzZWdzLCBldmVudE9yZGVyU3BlY3M6IE9yZGVyU3BlYzxFdmVudEFwaT5bXSk6IFNlZ1tdIHtcbiAgbGV0IG9ianMgPSBzZWdzLm1hcChidWlsZFNlZ0NvbXBhcmVPYmopXG5cbiAgb2Jqcy5zb3J0KGZ1bmN0aW9uKG9iajAsIG9iajEpIHtcbiAgICByZXR1cm4gY29tcGFyZUJ5RmllbGRTcGVjcyhvYmowLCBvYmoxLCBldmVudE9yZGVyU3BlY3MpXG4gIH0pXG5cbiAgcmV0dXJuIG9ianMubWFwKGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4gYy5fc2VnXG4gIH0pXG59XG5cblxuLy8gcmV0dXJucyBhIG9iamVjdCB3aXRoIGFsbCBwcmltaXRpdmUgcHJvcHMgdGhhdCBjYW4gYmUgY29tcGFyZWRcbmV4cG9ydCBmdW5jdGlvbiBidWlsZFNlZ0NvbXBhcmVPYmooc2VnOiBTZWcpIHtcbiAgbGV0IHsgZXZlbnRSYW5nZSB9ID0gc2VnXG4gIGxldCBldmVudERlZiA9IGV2ZW50UmFuZ2UuZGVmXG4gIGxldCByYW5nZSA9IGV2ZW50UmFuZ2UuaW5zdGFuY2UgPyBldmVudFJhbmdlLmluc3RhbmNlLnJhbmdlIDogZXZlbnRSYW5nZS5yYW5nZVxuICBsZXQgc3RhcnQgPSByYW5nZS5zdGFydCA/IHJhbmdlLnN0YXJ0LnZhbHVlT2YoKSA6IDAgLy8gVE9ETzogYmV0dGVyIHN1cHBvcnQgZm9yIG9wZW4tcmFuZ2UgZXZlbnRzXG4gIGxldCBlbmQgPSByYW5nZS5lbmQgPyByYW5nZS5lbmQudmFsdWVPZigpIDogMCAvLyBcIlxuXG4gIHJldHVybiB7XG4gICAgLi4uZXZlbnREZWYuZXh0ZW5kZWRQcm9wcyxcbiAgICAuLi5ldmVudERlZixcbiAgICBpZDogZXZlbnREZWYucHVibGljSWQsXG4gICAgc3RhcnQsXG4gICAgZW5kLFxuICAgIGR1cmF0aW9uOiBlbmQgLSBzdGFydCxcbiAgICBhbGxEYXk6IE51bWJlcihldmVudERlZi5hbGxEYXkpLFxuICAgIF9zZWc6IHNlZyAvLyBmb3IgbGF0ZXIgcmV0cmlldmFsXG4gIH1cbn1cblxuXG4vLyBvdGhlciBzdHVmZlxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnRDb250ZW50QXJnIHsgLy8gZm9yICpDb250ZW50IGhhbmRsZXJzXG4gIGV2ZW50OiBFdmVudEFwaVxuICB0aW1lVGV4dDogc3RyaW5nXG4gIGJhY2tncm91bmRDb2xvcjogc3RyaW5nIC8vIFRPRE86IGFkZCBvdGhlciBFdmVudFVpIHByb3BzP1xuICBib3JkZXJDb2xvcjogc3RyaW5nICAgICAvL1xuICB0ZXh0Q29sb3I6IHN0cmluZyAgICAgICAvL1xuICBpc0RyYWdnYWJsZTogYm9vbGVhblxuICBpc1N0YXJ0UmVzaXphYmxlOiBib29sZWFuXG4gIGlzRW5kUmVzaXphYmxlOiBib29sZWFuXG4gIGlzTWlycm9yOiBib29sZWFuXG4gIGlzU3RhcnQ6IGJvb2xlYW5cbiAgaXNFbmQ6IGJvb2xlYW5cbiAgaXNQYXN0OiBib29sZWFuXG4gIGlzRnV0dXJlOiBib29sZWFuXG4gIGlzVG9kYXk6IGJvb2xlYW5cbiAgaXNTZWxlY3RlZDogYm9vbGVhblxuICBpc0RyYWdnaW5nOiBib29sZWFuXG4gIGlzUmVzaXppbmc6IGJvb2xlYW5cbiAgdmlldzogVmlld0FwaSAvLyBzcGVjaWZpY2FsbHkgZm9yIHRoZSBBUElcbn1cblxuZXhwb3J0IHR5cGUgRXZlbnRNb3VudEFyZyA9IE1vdW50QXJnPEV2ZW50Q29udGVudEFyZz5cblxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVNlZ0RyYWdnYWJsZShzZWc6IFNlZywgY29udGV4dDogVmlld0NvbnRleHQpIHtcbiAgbGV0IHsgcGx1Z2luSG9va3MgfSA9IGNvbnRleHRcbiAgbGV0IHRyYW5zZm9ybWVycyA9IHBsdWdpbkhvb2tzLmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzXG4gIGxldCB7IGRlZiwgdWkgfSA9IHNlZy5ldmVudFJhbmdlXG4gIGxldCB2YWwgPSB1aS5zdGFydEVkaXRhYmxlXG5cbiAgZm9yIChsZXQgdHJhbnNmb3JtZXIgb2YgdHJhbnNmb3JtZXJzKSB7XG4gICAgdmFsID0gdHJhbnNmb3JtZXIodmFsLCBkZWYsIHVpLCBjb250ZXh0KVxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlU2VnU3RhcnRSZXNpemFibGUoc2VnOiBTZWcsIGNvbnRleHQ6IFZpZXdDb250ZXh0KSB7XG4gIHJldHVybiBzZWcuaXNTdGFydCAmJiBzZWcuZXZlbnRSYW5nZS51aS5kdXJhdGlvbkVkaXRhYmxlICYmIGNvbnRleHQub3B0aW9ucy5ldmVudFJlc2l6YWJsZUZyb21TdGFydFxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlU2VnRW5kUmVzaXphYmxlKHNlZzogU2VnLCBjb250ZXh0OiBWaWV3Q29udGV4dCkge1xuICByZXR1cm4gc2VnLmlzRW5kICYmIHNlZy5ldmVudFJhbmdlLnVpLmR1cmF0aW9uRWRpdGFibGVcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRTZWdUaW1lVGV4dChcbiAgc2VnOiBTZWcsXG4gIHRpbWVGb3JtYXQ6IERhdGVGb3JtYXR0ZXIsXG4gIGNvbnRleHQ6IFZpZXdDb250ZXh0LFxuICBkZWZhdWx0RGlzcGxheUV2ZW50VGltZT86IGJvb2xlYW4sIC8vIGRlZmF1bHRzIHRvIHRydWVcbiAgZGVmYXVsdERpc3BsYXlFdmVudEVuZD86IGJvb2xlYW4sIC8vIGRlZmF1bHRzIHRvIHRydWVcbiAgc3RhcnRPdmVycmlkZT86IERhdGVNYXJrZXIsXG4gIGVuZE92ZXJyaWRlPzogRGF0ZU1hcmtlclxuKSB7XG4gIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMgfSA9IGNvbnRleHRcbiAgbGV0IHsgZGlzcGxheUV2ZW50VGltZSwgZGlzcGxheUV2ZW50RW5kIH0gPSBvcHRpb25zXG4gIGxldCBldmVudERlZiA9IHNlZy5ldmVudFJhbmdlLmRlZlxuICBsZXQgZXZlbnRJbnN0YW5jZSA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlXG5cbiAgaWYgKGRpc3BsYXlFdmVudFRpbWUgPT0gbnVsbCkgeyBkaXNwbGF5RXZlbnRUaW1lID0gZGVmYXVsdERpc3BsYXlFdmVudFRpbWUgIT09IGZhbHNlIH1cbiAgaWYgKGRpc3BsYXlFdmVudEVuZCA9PSBudWxsKSB7IGRpc3BsYXlFdmVudEVuZCA9IGRlZmF1bHREaXNwbGF5RXZlbnRFbmQgIT09IGZhbHNlIH1cblxuICBpZiAoZGlzcGxheUV2ZW50VGltZSAmJiAhZXZlbnREZWYuYWxsRGF5ICYmIChzZWcuaXNTdGFydCB8fCBzZWcuaXNFbmQpKSB7XG5cbiAgICBsZXQgc2VnU3RhcnQgPSBzdGFydE92ZXJyaWRlIHx8IChzZWcuaXNTdGFydCA/IGV2ZW50SW5zdGFuY2UucmFuZ2Uuc3RhcnQgOiAoc2VnLnN0YXJ0IHx8IHNlZy5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0KSlcbiAgICBsZXQgc2VnRW5kID0gZW5kT3ZlcnJpZGUgfHwgKHNlZy5pc0VuZCA/IGV2ZW50SW5zdGFuY2UucmFuZ2UuZW5kIDogKHNlZy5lbmQgfHwgc2VnLmV2ZW50UmFuZ2UucmFuZ2UuZW5kKSlcblxuICAgIGlmIChkaXNwbGF5RXZlbnRFbmQgJiYgZXZlbnREZWYuaGFzRW5kKSB7XG4gICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShzZWdTdGFydCwgc2VnRW5kLCB0aW1lRm9ybWF0LCB7XG4gICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBzdGFydE92ZXJyaWRlID8gbnVsbCA6IGV2ZW50SW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sIC8vIG5vb29vb29vb29vb29vLCBnaXZlIHR6byBpZiBzYW1lIGRhdGVcbiAgICAgICAgZm9yY2VkRW5kVHpvOiBlbmRPdmVycmlkZSA/IG51bGwgOiBldmVudEluc3RhbmNlLmZvcmNlZEVuZFR6b1xuICAgICAgfSlcblxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoc2VnU3RhcnQsIHRpbWVGb3JtYXQsIHtcbiAgICAgICAgZm9yY2VkVHpvOiBzdGFydE92ZXJyaWRlID8gbnVsbCA6IGV2ZW50SW5zdGFuY2UuZm9yY2VkU3RhcnRUem8gLy8gbm9vb29vLCBzYW1lXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJ1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWdNZXRhKHNlZzogU2VnLCB0b2RheVJhbmdlOiBEYXRlUmFuZ2UsIG5vd0RhdGU/OiBEYXRlTWFya2VyKSB7IC8vIFRPRE86IG1ha2UgYXJnIG9yZGVyIGNvbnNpc3RlbnQgd2l0aCBkYXRlIHV0aWxcbiAgbGV0IHNlZ1JhbmdlID0gc2VnLmV2ZW50UmFuZ2UucmFuZ2VcblxuICByZXR1cm4ge1xuICAgIGlzUGFzdDogc2VnUmFuZ2UuZW5kIDwgKG5vd0RhdGUgfHwgdG9kYXlSYW5nZS5zdGFydCksXG4gICAgaXNGdXR1cmU6IHNlZ1JhbmdlLnN0YXJ0ID49IChub3dEYXRlIHx8IHRvZGF5UmFuZ2UuZW5kKSxcbiAgICBpc1RvZGF5OiB0b2RheVJhbmdlICYmIHJhbmdlQ29udGFpbnNNYXJrZXIodG9kYXlSYW5nZSwgc2VnUmFuZ2Uuc3RhcnQpXG4gIH1cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXZlbnRDbGFzc05hbWVzKHByb3BzOiBFdmVudENvbnRlbnRBcmcpIHsgLy8gd2VpcmQgdGhhdCB3ZSB1c2UgdGhpcyBpbnRlcmZhY2UsIGJ1dCBjb252ZW5pZW50XG4gIGxldCBjbGFzc05hbWVzOiBzdHJpbmdbXSA9IFsgJ2ZjLWV2ZW50JyBdXG5cbiAgaWYgKHByb3BzLmlzTWlycm9yKSB7XG4gICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1taXJyb3InKVxuICB9XG5cbiAgaWYgKHByb3BzLmlzRHJhZ2dhYmxlKSB7XG4gICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1kcmFnZ2FibGUnKVxuICB9XG5cbiAgaWYgKHByb3BzLmlzU3RhcnRSZXNpemFibGUgfHwgcHJvcHMuaXNFbmRSZXNpemFibGUpIHtcbiAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXJlc2l6YWJsZScpXG4gIH1cblxuICBpZiAocHJvcHMuaXNEcmFnZ2luZykge1xuICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtZHJhZ2dpbmcnKVxuICB9XG5cbiAgaWYgKHByb3BzLmlzUmVzaXppbmcpIHtcbiAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXJlc2l6aW5nJylcbiAgfVxuXG4gIGlmIChwcm9wcy5pc1NlbGVjdGVkKSB7XG4gICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1zZWxlY3RlZCcpXG4gIH1cblxuICBpZiAocHJvcHMuaXNTdGFydCkge1xuICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtc3RhcnQnKVxuICB9XG5cbiAgaWYgKHByb3BzLmlzRW5kKSB7XG4gICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1lbmQnKVxuICB9XG5cbiAgaWYgKHByb3BzLmlzUGFzdCkge1xuICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtcGFzdCcpXG4gIH1cblxuICBpZiAocHJvcHMuaXNUb2RheSkge1xuICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtdG9kYXknKVxuICB9XG5cbiAgaWYgKHByb3BzLmlzRnV0dXJlKSB7XG4gICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1mdXR1cmUnKVxuICB9XG5cbiAgcmV0dXJuIGNsYXNzTmFtZXNcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRFdmVudFJhbmdlS2V5KGV2ZW50UmFuZ2U6IEV2ZW50UmVuZGVyUmFuZ2UpIHtcbiAgcmV0dXJuIGV2ZW50UmFuZ2UuaW5zdGFuY2VcbiAgICA/IGV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZFxuICAgIDogZXZlbnRSYW5nZS5kZWYuZGVmSWQgKyAnOicgKyBldmVudFJhbmdlLnJhbmdlLnN0YXJ0LnRvSVNPU3RyaW5nKClcbiAgICAgIC8vIGludmVyc2UtYmFja2dyb3VuZCBldmVudHMgZG9uJ3QgaGF2ZSBzcGVjaWZpYyBpbnN0YW5jZXMuIFRPRE86IGJldHRlciBzb2x1dGlvblxufVxuIiwiaW1wb3J0IHsgRGF0ZVJhbmdlLCByYW5nZXNFcXVhbCwgT3BlbkRhdGVSYW5nZSB9IGZyb20gJy4uL2RhdGVsaWIvZGF0ZS1yYW5nZSdcbmltcG9ydCB7IERhdGVJbnB1dCwgRGF0ZUVudiB9IGZyb20gJy4uL2RhdGVsaWIvZW52J1xuaW1wb3J0IHsgRHVyYXRpb24gfSBmcm9tICcuLi9kYXRlbGliL2R1cmF0aW9uJ1xuaW1wb3J0IHsgY3JlYXRlRXZlbnRJbnN0YW5jZSB9IGZyb20gJy4vZXZlbnQtaW5zdGFuY2UnXG5pbXBvcnQgeyBwYXJzZUV2ZW50RGVmLCByZWZpbmVFdmVudERlZiB9IGZyb20gJy4vZXZlbnQtcGFyc2UnXG5pbXBvcnQgeyBFdmVudFJlbmRlclJhbmdlLCBjb21waWxlRXZlbnRVaSB9IGZyb20gJy4uL2NvbXBvbmVudC9ldmVudC1yZW5kZXJpbmcnXG5pbXBvcnQgeyBFdmVudFVpSGFzaCB9IGZyb20gJy4uL2NvbXBvbmVudC9ldmVudC11aSdcbmltcG9ydCB7IENhbGVuZGFyQ29udGV4dCB9IGZyb20gJy4uL0NhbGVuZGFyQ29udGV4dCdcbmltcG9ydCB7IHJlZmluZVByb3BzLCBpZGVudGl0eSwgSWRlbnRpdHkgfSBmcm9tICcuLi9vcHRpb25zJ1xuXG4vKlxuQSBkYXRhLXN0cnVjdHVyZSBmb3IgYSBkYXRlLXJhbmdlIHRoYXQgd2lsbCBiZSB2aXN1YWxseSBkaXNwbGF5ZWQuXG5Db250YWlucyBvdGhlciBtZXRhZGF0YSBsaWtlIGFsbERheSwgYW5kIGFueXRoaW5nIGVsc2UgQ29tcG9uZW50cyBtaWdodCBsaWtlIHRvIHN0b3JlLlxuXG5UT0RPOiBpbiBmdXR1cmUsIHB1dCBvdGhlclByb3BzIGluIG93biBvYmplY3QuXG4qL1xuXG5leHBvcnQgaW50ZXJmYWNlIE9wZW5EYXRlU3BhbklucHV0IHtcbiAgc3RhcnQ/OiBEYXRlSW5wdXRcbiAgZW5kPzogRGF0ZUlucHV0XG4gIGFsbERheT86IGJvb2xlYW5cbiAgW290aGVyUHJvcDogc3RyaW5nXTogYW55XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZVNwYW5JbnB1dCBleHRlbmRzIE9wZW5EYXRlU3BhbklucHV0IHtcbiAgc3RhcnQ6IERhdGVJbnB1dFxuICBlbmQ6IERhdGVJbnB1dFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wZW5EYXRlU3BhbiB7XG4gIHJhbmdlOiBPcGVuRGF0ZVJhbmdlXG4gIGFsbERheTogYm9vbGVhblxuICBbb3RoZXJQcm9wOiBzdHJpbmddOiBhbnlcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXRlU3BhbiBleHRlbmRzIE9wZW5EYXRlU3BhbiB7XG4gIHJhbmdlOiBEYXRlUmFuZ2Vcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSYW5nZUFwaSB7XG4gIHN0YXJ0OiBEYXRlXG4gIGVuZDogRGF0ZVxuICBzdGFydFN0cjogc3RyaW5nXG4gIGVuZFN0cjogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZVNwYW5BcGkgZXh0ZW5kcyBSYW5nZUFwaSB7XG4gIGFsbERheTogYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJhbmdlQXBpV2l0aFRpbWVab25lIGV4dGVuZHMgUmFuZ2VBcGkge1xuICB0aW1lWm9uZTogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZVBvaW50QXBpIHtcbiAgZGF0ZTogRGF0ZVxuICBkYXRlU3RyOiBzdHJpbmdcbiAgYWxsRGF5OiBib29sZWFuXG59XG5cbmNvbnN0IFNUQU5EQVJEX1BST1BTID0ge1xuICBzdGFydDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGF0ZUlucHV0PixcbiAgZW5kOiBpZGVudGl0eSBhcyBJZGVudGl0eTxEYXRlSW5wdXQ+LFxuICBhbGxEYXk6IEJvb2xlYW5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRGF0ZVNwYW4ocmF3OiBEYXRlU3BhbklucHV0LCBkYXRlRW52OiBEYXRlRW52LCBkZWZhdWx0RHVyYXRpb24/OiBEdXJhdGlvbik6IERhdGVTcGFuIHwgbnVsbCB7XG4gIGxldCBzcGFuID0gcGFyc2VPcGVuRGF0ZVNwYW4ocmF3LCBkYXRlRW52KVxuICBsZXQgeyByYW5nZSB9ID0gc3BhblxuXG4gIGlmICghcmFuZ2Uuc3RhcnQpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgaWYgKCFyYW5nZS5lbmQpIHtcbiAgICBpZiAoZGVmYXVsdER1cmF0aW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlLmVuZCA9IGRhdGVFbnYuYWRkKHJhbmdlLnN0YXJ0LCBkZWZhdWx0RHVyYXRpb24pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNwYW4gYXMgRGF0ZVNwYW5cbn1cblxuLypcblRPRE86IHNvbWVob3cgY29tYmluZSB3aXRoIHBhcnNlUmFuZ2U/XG5XaWxsIHJldHVybiBudWxsIGlmIHRoZSBzdGFydC9lbmQgcHJvcHMgd2VyZSBwcmVzZW50IGJ1dCBwYXJzZWQgaW52YWxpZGx5LlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU9wZW5EYXRlU3BhbihyYXc6IE9wZW5EYXRlU3BhbklucHV0LCBkYXRlRW52OiBEYXRlRW52KTogT3BlbkRhdGVTcGFuIHwgbnVsbCB7XG4gIGxldCB7IHJlZmluZWQ6IHN0YW5kYXJkUHJvcHMsIGV4dHJhIH0gPSByZWZpbmVQcm9wcyhyYXcsIFNUQU5EQVJEX1BST1BTKVxuICBsZXQgc3RhcnRNZXRhID0gc3RhbmRhcmRQcm9wcy5zdGFydCA/IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFuZGFyZFByb3BzLnN0YXJ0KSA6IG51bGxcbiAgbGV0IGVuZE1ldGEgPSBzdGFuZGFyZFByb3BzLmVuZCA/IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFuZGFyZFByb3BzLmVuZCkgOiBudWxsXG4gIGxldCBhbGxEYXkgPSBzdGFuZGFyZFByb3BzLmFsbERheVxuXG4gIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgIGFsbERheSA9IChzdGFydE1ldGEgJiYgc3RhcnRNZXRhLmlzVGltZVVuc3BlY2lmaWVkKSAmJlxuICAgICAgKCFlbmRNZXRhIHx8IGVuZE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJhbmdlOiB7XG4gICAgICBzdGFydDogc3RhcnRNZXRhID8gc3RhcnRNZXRhLm1hcmtlciA6IG51bGwsXG4gICAgICBlbmQ6IGVuZE1ldGEgPyBlbmRNZXRhLm1hcmtlciA6IG51bGwsXG4gICAgfSxcbiAgICBhbGxEYXksXG4gICAgLi4uZXh0cmFcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEYXRlU3BhbnNFcXVhbChzcGFuMDogRGF0ZVNwYW4sIHNwYW4xOiBEYXRlU3Bhbik6IGJvb2xlYW4ge1xuICByZXR1cm4gcmFuZ2VzRXF1YWwoc3BhbjAucmFuZ2UsIHNwYW4xLnJhbmdlKSAmJlxuICAgIHNwYW4wLmFsbERheSA9PT0gc3BhbjEuYWxsRGF5ICYmXG4gICAgaXNTcGFuUHJvcHNFcXVhbChzcGFuMCwgc3BhbjEpXG59XG5cbi8vIHRoZSBOT04tREFURS1SRUxBVEVEIHByb3BzXG5mdW5jdGlvbiBpc1NwYW5Qcm9wc0VxdWFsKHNwYW4wOiBEYXRlU3Bhbiwgc3BhbjE6IERhdGVTcGFuKTogYm9vbGVhbiB7XG5cbiAgZm9yIChsZXQgcHJvcE5hbWUgaW4gc3BhbjEpIHtcbiAgICBpZiAocHJvcE5hbWUgIT09ICdyYW5nZScgJiYgcHJvcE5hbWUgIT09ICdhbGxEYXknKSB7XG4gICAgICBpZiAoc3BhbjBbcHJvcE5hbWVdICE9PSBzcGFuMVtwcm9wTmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gYXJlIHRoZXJlIGFueSBwcm9wcyB0aGF0IHNwYW4wIGhhcyB0aGF0IHNwYW4xIERPRVNOJ1QgaGF2ZT9cbiAgLy8gYm90aCBoYXZlIHJhbmdlL2FsbERheSwgc28gbm8gbmVlZCB0byBzcGVjaWFsLWNhc2UuXG4gIGZvciAobGV0IHByb3BOYW1lIGluIHNwYW4wKSB7XG4gICAgaWYgKCEocHJvcE5hbWUgaW4gc3BhbjEpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGREYXRlU3BhbkFwaShzcGFuOiBEYXRlU3BhbiwgZGF0ZUVudjogRGF0ZUVudik6IERhdGVTcGFuQXBpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5idWlsZFJhbmdlQXBpKHNwYW4ucmFuZ2UsIGRhdGVFbnYsIHNwYW4uYWxsRGF5KSxcbiAgICBhbGxEYXk6IHNwYW4uYWxsRGF5XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkUmFuZ2VBcGlXaXRoVGltZVpvbmUocmFuZ2U6IERhdGVSYW5nZSwgZGF0ZUVudjogRGF0ZUVudiwgb21pdFRpbWU/OiBib29sZWFuKTogUmFuZ2VBcGlXaXRoVGltZVpvbmUge1xuICByZXR1cm4ge1xuICAgIC4uLmJ1aWxkUmFuZ2VBcGkocmFuZ2UsIGRhdGVFbnYsIG9taXRUaW1lKSxcbiAgICB0aW1lWm9uZTogZGF0ZUVudi50aW1lWm9uZVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFJhbmdlQXBpKHJhbmdlOiBEYXRlUmFuZ2UsIGRhdGVFbnY6IERhdGVFbnYsIG9taXRUaW1lPzogYm9vbGVhbik6IFJhbmdlQXBpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogZGF0ZUVudi50b0RhdGUocmFuZ2Uuc3RhcnQpLFxuICAgIGVuZDogZGF0ZUVudi50b0RhdGUocmFuZ2UuZW5kKSxcbiAgICBzdGFydFN0cjogZGF0ZUVudi5mb3JtYXRJc28ocmFuZ2Uuc3RhcnQsIHsgb21pdFRpbWUgfSksXG4gICAgZW5kU3RyOiBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5lbmQsIHsgb21pdFRpbWUgfSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmFicmljYXRlRXZlbnRSYW5nZShkYXRlU3BhbjogRGF0ZVNwYW4sIGV2ZW50VWlCYXNlczogRXZlbnRVaUhhc2gsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCk6IEV2ZW50UmVuZGVyUmFuZ2Uge1xuICBsZXQgcmVzID0gcmVmaW5lRXZlbnREZWYoeyBlZGl0YWJsZTogZmFsc2UgfSwgY29udGV4dClcbiAgbGV0IGRlZiA9IHBhcnNlRXZlbnREZWYoXG4gICAgcmVzLnJlZmluZWQsXG4gICAgcmVzLmV4dHJhLFxuICAgICcnLCAvLyBzb3VyY2VJZFxuICAgIGRhdGVTcGFuLmFsbERheSxcbiAgICB0cnVlLCAvLyBoYXNFbmRcbiAgICBjb250ZXh0XG4gIClcblxuICByZXR1cm4ge1xuICAgIGRlZixcbiAgICB1aTogY29tcGlsZUV2ZW50VWkoZGVmLCBldmVudFVpQmFzZXMpLFxuICAgIGluc3RhbmNlOiBjcmVhdGVFdmVudEluc3RhbmNlKGRlZi5kZWZJZCwgZGF0ZVNwYW4ucmFuZ2UpLFxuICAgIHJhbmdlOiBkYXRlU3Bhbi5yYW5nZSxcbiAgICBpc1N0YXJ0OiB0cnVlLFxuICAgIGlzRW5kOiB0cnVlXG4gIH1cbn1cbiIsImltcG9ydCB7IFBvaW50ZXJEcmFnRXZlbnQgfSBmcm9tICcuL2ludGVyYWN0aW9ucy9wb2ludGVyJ1xuaW1wb3J0IHsgYnVpbGREYXRlU3BhbkFwaSwgRGF0ZVNwYW5BcGksIERhdGVQb2ludEFwaSwgRGF0ZVNwYW4gfSBmcm9tICcuL3N0cnVjdHMvZGF0ZS1zcGFuJ1xuaW1wb3J0IHsgQ2FsZW5kYXJDb250ZXh0IH0gZnJvbSAnLi9DYWxlbmRhckNvbnRleHQnXG5pbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJ1xuaW1wb3J0IHsgVmlld0FwaSB9IGZyb20gJy4vVmlld0FwaSdcbmltcG9ydCB7IERhdGVNYXJrZXIsIHN0YXJ0T2ZEYXkgfSBmcm9tICcuL2RhdGVsaWIvbWFya2VyJ1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZUNsaWNrQXBpIGV4dGVuZHMgRGF0ZVBvaW50QXBpIHtcbiAgZGF5RWw6IEhUTUxFbGVtZW50XG4gIGpzRXZlbnQ6IFVJRXZlbnRcbiAgdmlldzogVmlld0FwaVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVTZWxlY3Rpb25BcGkgZXh0ZW5kcyBEYXRlU3BhbkFwaSB7XG4gIGpzRXZlbnQ6IFVJRXZlbnRcbiAgdmlldzogVmlld0FwaVxufVxuXG5leHBvcnQgdHlwZSBEYXRlUG9pbnRUcmFuc2Zvcm0gPSAoZGF0ZVNwYW46IERhdGVTcGFuLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpID0+IGFueVxuZXhwb3J0IHR5cGUgRGF0ZVNwYW5UcmFuc2Zvcm0gPSAoZGF0ZVNwYW46IERhdGVTcGFuLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpID0+IGFueVxuXG5leHBvcnQgdHlwZSBDYWxlbmRhckludGVyYWN0aW9uID0geyBkZXN0cm95KCkgfVxuZXhwb3J0IHR5cGUgQ2FsZW5kYXJJbnRlcmFjdGlvbkNsYXNzID0geyBuZXcoY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KTogQ2FsZW5kYXJJbnRlcmFjdGlvbiB9XG5cbmV4cG9ydCB0eXBlIE9wdGlvbkNoYW5nZUhhbmRsZXIgPSAocHJvcFZhbHVlOiBhbnksIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCkgPT4gdm9pZFxuZXhwb3J0IHR5cGUgT3B0aW9uQ2hhbmdlSGFuZGxlck1hcCA9IHsgW3Byb3BOYW1lOiBzdHJpbmddOiBPcHRpb25DaGFuZ2VIYW5kbGVyIH1cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZVNlbGVjdEFyZyBleHRlbmRzIERhdGVTcGFuQXBpIHtcbiAganNFdmVudDogTW91c2VFdmVudCB8IG51bGxcbiAgdmlldzogVmlld0FwaVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJpZ2dlckRhdGVTZWxlY3Qoc2VsZWN0aW9uOiBEYXRlU3BhbiwgcGV2OiBQb2ludGVyRHJhZ0V2ZW50IHwgbnVsbCwgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0ICYgeyB2aWV3QXBpPzogVmlld0FwaSB9KSB7XG4gIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdzZWxlY3QnLCB7XG4gICAgLi4uYnVpbGREYXRlU3BhbkFwaVdpdGhDb250ZXh0KHNlbGVjdGlvbiwgY29udGV4dCksXG4gICAganNFdmVudDogcGV2ID8gcGV2Lm9yaWdFdmVudCBhcyBNb3VzZUV2ZW50IDogbnVsbCwgLy8gSXMgdGhpcyBhbHdheXMgYSBtb3VzZSBldmVudD8gU2VlICM0NjU1XG4gICAgdmlldzogY29udGV4dC52aWV3QXBpIHx8IGNvbnRleHQuY2FsZW5kYXJBcGkudmlld1xuICB9IGFzIERhdGVTZWxlY3RBcmcpXG59XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVVbnNlbGVjdEFyZyB7XG4gIGpzRXZlbnQ6IE1vdXNlRXZlbnRcbiAgdmlldzogVmlld0FwaVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJpZ2dlckRhdGVVbnNlbGVjdChwZXY6IFBvaW50ZXJEcmFnRXZlbnQgfCBudWxsLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQgJiB7IHZpZXdBcGk/OiBWaWV3QXBpIH0pIHtcbiAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ3Vuc2VsZWN0Jywge1xuICAgIGpzRXZlbnQ6IHBldiA/IHBldi5vcmlnRXZlbnQgOiBudWxsLFxuICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSB8fCBjb250ZXh0LmNhbGVuZGFyQXBpLnZpZXdcbiAgfSBhcyBEYXRlVW5zZWxlY3RBcmcpXG59XG5cblxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGREYXRlU3BhbkFwaVdpdGhDb250ZXh0KGRhdGVTcGFuOiBEYXRlU3BhbiwgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KSB7XG4gIGxldCBwcm9wcyA9IHt9IGFzIERhdGVTcGFuQXBpXG5cbiAgZm9yIChsZXQgdHJhbnNmb3JtIG9mIGNvbnRleHQucGx1Z2luSG9va3MuZGF0ZVNwYW5UcmFuc2Zvcm1zKSB7XG4gICAgX19hc3NpZ24ocHJvcHMsIHRyYW5zZm9ybShkYXRlU3BhbiwgY29udGV4dCkpXG4gIH1cblxuICBfX2Fzc2lnbihwcm9wcywgYnVpbGREYXRlU3BhbkFwaShkYXRlU3BhbiwgY29udGV4dC5kYXRlRW52KSlcblxuICByZXR1cm4gcHJvcHNcbn1cblxuXG5cbi8vIEdpdmVuIGFuIGV2ZW50J3MgYWxsRGF5IHN0YXR1cyBhbmQgc3RhcnQgZGF0ZSwgcmV0dXJuIHdoYXQgaXRzIGZhbGxiYWNrIGVuZCBkYXRlIHNob3VsZCBiZS5cbi8vIFRPRE86IHJlbmFtZSB0byBjb21wdXRlRGVmYXVsdEV2ZW50RW5kXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdEV2ZW50RW5kKGFsbERheTogYm9vbGVhbiwgbWFya2VyOiBEYXRlTWFya2VyLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpOiBEYXRlTWFya2VyIHtcbiAgbGV0IHsgZGF0ZUVudiwgb3B0aW9ucyB9ID0gY29udGV4dFxuICBsZXQgZW5kID0gbWFya2VyXG5cbiAgaWYgKGFsbERheSkge1xuICAgIGVuZCA9IHN0YXJ0T2ZEYXkoZW5kKVxuICAgIGVuZCA9IGRhdGVFbnYuYWRkKGVuZCwgb3B0aW9ucy5kZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbilcbiAgfSBlbHNlIHtcbiAgICBlbmQgPSBkYXRlRW52LmFkZChlbmQsIG9wdGlvbnMuZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbilcbiAgfVxuXG4gIHJldHVybiBlbmRcbn1cbiIsImltcG9ydCB7IER1cmF0aW9uIH0gZnJvbSAnLi4vZGF0ZWxpYi9kdXJhdGlvbidcbmltcG9ydCB7IEV2ZW50U3RvcmUsIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSB9IGZyb20gJy4vZXZlbnQtc3RvcmUnXG5pbXBvcnQgeyBFdmVudERlZiB9IGZyb20gJy4vZXZlbnQtZGVmJ1xuaW1wb3J0IHsgRXZlbnRJbnN0YW5jZSB9IGZyb20gJy4vZXZlbnQtaW5zdGFuY2UnXG5pbXBvcnQgeyBjb21wdXRlQWxpZ25lZERheVJhbmdlIH0gZnJvbSAnLi4vdXRpbC9kYXRlJ1xuaW1wb3J0IHsgc3RhcnRPZkRheSB9IGZyb20gJy4uL2RhdGVsaWIvbWFya2VyJ1xuaW1wb3J0IHsgRXZlbnRVaUhhc2gsIEV2ZW50VWkgfSBmcm9tICcuLi9jb21wb25lbnQvZXZlbnQtdWknXG5pbXBvcnQgeyBjb21waWxlRXZlbnRVaXMgfSBmcm9tICcuLi9jb21wb25lbnQvZXZlbnQtcmVuZGVyaW5nJ1xuaW1wb3J0IHsgQ2FsZW5kYXJDb250ZXh0IH0gZnJvbSAnLi4vQ2FsZW5kYXJDb250ZXh0J1xuaW1wb3J0IHsgZ2V0RGVmYXVsdEV2ZW50RW5kIH0gZnJvbSAnLi4vY2FsZW5kYXItdXRpbHMnXG5cbi8qXG5BIGRhdGEgc3RydWN0dXJlIGZvciBob3cgdG8gbW9kaWZ5IGFuIEV2ZW50RGVmL0V2ZW50SW5zdGFuY2Ugd2l0aGluIGFuIEV2ZW50U3RvcmVcbiovXG5cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnRNdXRhdGlvbiB7XG4gIGRhdGVzRGVsdGE/OiBEdXJhdGlvbiAvLyBib2R5IHN0YXJ0K2VuZCBtb3ZpbmcgdG9nZXRoZXIuIGZvciBkcmFnZ2luZ1xuICBzdGFydERlbHRhPzogRHVyYXRpb24gLy8gZm9yIHJlc2l6aW5nXG4gIGVuZERlbHRhPzogRHVyYXRpb24gLy8gZm9yIHJlc2l6aW5nXG4gIHN0YW5kYXJkUHJvcHM/OiBhbnkgLy8gZm9yIHRoZSBkZWYuIHNob3VsZCBub3QgaW5jbHVkZSBleHRlbmRlZFByb3BzXG4gIGV4dGVuZGVkUHJvcHM/OiBhbnkgLy8gZm9yIHRoZSBkZWZcbn1cblxuLy8gYXBwbGllcyB0aGUgbXV0YXRpb24gdG8gQUxMIGRlZnMvaW5zdGFuY2VzIHdpdGhpbiB0aGUgZXZlbnQgc3RvcmVcbmV4cG9ydCBmdW5jdGlvbiBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlKGV2ZW50U3RvcmU6IEV2ZW50U3RvcmUsIGV2ZW50Q29uZmlnQmFzZTogRXZlbnRVaUhhc2gsIG11dGF0aW9uOiBFdmVudE11dGF0aW9uLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpOiBFdmVudFN0b3JlIHtcbiAgbGV0IGV2ZW50Q29uZmlncyA9IGNvbXBpbGVFdmVudFVpcyhldmVudFN0b3JlLmRlZnMsIGV2ZW50Q29uZmlnQmFzZSlcbiAgbGV0IGRlc3QgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKVxuXG4gIGZvciAobGV0IGRlZklkIGluIGV2ZW50U3RvcmUuZGVmcykge1xuICAgIGxldCBkZWYgPSBldmVudFN0b3JlLmRlZnNbZGVmSWRdXG5cbiAgICBkZXN0LmRlZnNbZGVmSWRdID0gYXBwbHlNdXRhdGlvblRvRXZlbnREZWYoZGVmLCBldmVudENvbmZpZ3NbZGVmSWRdLCBtdXRhdGlvbiwgY29udGV4dClcbiAgfVxuXG4gIGZvciAobGV0IGluc3RhbmNlSWQgaW4gZXZlbnRTdG9yZS5pbnN0YW5jZXMpIHtcbiAgICBsZXQgaW5zdGFuY2UgPSBldmVudFN0b3JlLmluc3RhbmNlc1tpbnN0YW5jZUlkXVxuICAgIGxldCBkZWYgPSBkZXN0LmRlZnNbaW5zdGFuY2UuZGVmSWRdIC8vIGltcG9ydGFudCB0byBncmFiIHRoZSBuZXdseSBtb2RpZmllZCBkZWZcblxuICAgIGRlc3QuaW5zdGFuY2VzW2luc3RhbmNlSWRdID0gYXBwbHlNdXRhdGlvblRvRXZlbnRJbnN0YW5jZShpbnN0YW5jZSwgZGVmLCBldmVudENvbmZpZ3NbaW5zdGFuY2UuZGVmSWRdLCBtdXRhdGlvbiwgY29udGV4dClcbiAgfVxuXG4gIHJldHVybiBkZXN0XG59XG5cbmV4cG9ydCB0eXBlIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyID0gKGV2ZW50RGVmOiBFdmVudERlZiwgbXV0YXRpb246IEV2ZW50TXV0YXRpb24sIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCkgPT4gdm9pZFxuXG5cbmZ1bmN0aW9uIGFwcGx5TXV0YXRpb25Ub0V2ZW50RGVmKGV2ZW50RGVmOiBFdmVudERlZiwgZXZlbnRDb25maWc6IEV2ZW50VWksIG11dGF0aW9uOiBFdmVudE11dGF0aW9uLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpOiBFdmVudERlZiB7XG4gIGxldCBzdGFuZGFyZFByb3BzID0gbXV0YXRpb24uc3RhbmRhcmRQcm9wcyB8fCB7fVxuXG4gIC8vIGlmIGhhc0VuZCBoYXMgbm90IGJlZW4gc3BlY2lmaWVkLCBndWVzcyBhIGdvb2QgdmFsdWUgYmFzZWQgb24gZGVsdGFzLlxuICAvLyBpZiBkdXJhdGlvbiB3aWxsIGNoYW5nZSwgdGhlcmUncyBubyB3YXkgdGhlIGRlZmF1bHQgZHVyYXRpb24gd2lsbCBwZXJzaXN0LFxuICAvLyBhbmQgdGh1cywgd2UgbmVlZCB0byBtYXJrIHRoZSBldmVudCBhcyBoYXZpbmcgYSByZWFsIGVuZFxuICBpZiAoXG4gICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPT0gbnVsbCAmJlxuICAgIGV2ZW50Q29uZmlnLmR1cmF0aW9uRWRpdGFibGUgJiZcbiAgICAobXV0YXRpb24uc3RhcnREZWx0YSB8fCBtdXRhdGlvbi5lbmREZWx0YSlcbiAgKSB7XG4gICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSB0cnVlIC8vIFRPRE86IGlzIHRoaXMgbXV0YXRpb24gb2theT9cbiAgfVxuXG4gIGxldCBjb3B5OiBFdmVudERlZiA9IHtcbiAgICAuLi5ldmVudERlZixcbiAgICAuLi5zdGFuZGFyZFByb3BzLFxuICAgIHVpOiB7IC4uLmV2ZW50RGVmLnVpLCAuLi5zdGFuZGFyZFByb3BzLnVpIH0gLy8gdGhlIG9ubHkgcHJvcCB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IG92ZXJsYXlcbiAgfVxuXG4gIGlmIChtdXRhdGlvbi5leHRlbmRlZFByb3BzKSB7XG4gICAgY29weS5leHRlbmRlZFByb3BzID0geyAuLi5jb3B5LmV4dGVuZGVkUHJvcHMsIC4uLm11dGF0aW9uLmV4dGVuZGVkUHJvcHMgfVxuICB9XG5cbiAgZm9yIChsZXQgYXBwbGllciBvZiBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycykge1xuICAgIGFwcGxpZXIoY29weSwgbXV0YXRpb24sIGNvbnRleHQpXG4gIH1cblxuICBpZiAoIWNvcHkuaGFzRW5kICYmIGNvbnRleHQub3B0aW9ucy5mb3JjZUV2ZW50RHVyYXRpb24pIHtcbiAgICBjb3B5Lmhhc0VuZCA9IHRydWVcbiAgfVxuXG4gIHJldHVybiBjb3B5XG59XG5cblxuZnVuY3Rpb24gYXBwbHlNdXRhdGlvblRvRXZlbnRJbnN0YW5jZShcbiAgZXZlbnRJbnN0YW5jZTogRXZlbnRJbnN0YW5jZSxcbiAgZXZlbnREZWY6IEV2ZW50RGVmLCAvLyBtdXN0IGZpcnN0IGJlIG1vZGlmaWVkIGJ5IGFwcGx5TXV0YXRpb25Ub0V2ZW50RGVmXG4gIGV2ZW50Q29uZmlnOiBFdmVudFVpLFxuICBtdXRhdGlvbjogRXZlbnRNdXRhdGlvbixcbiAgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0XG4pOiBFdmVudEluc3RhbmNlIHtcbiAgbGV0IHsgZGF0ZUVudiB9ID0gY29udGV4dFxuICBsZXQgZm9yY2VBbGxEYXkgPSBtdXRhdGlvbi5zdGFuZGFyZFByb3BzICYmIG11dGF0aW9uLnN0YW5kYXJkUHJvcHMuYWxsRGF5ID09PSB0cnVlXG4gIGxldCBjbGVhckVuZCA9IG11dGF0aW9uLnN0YW5kYXJkUHJvcHMgJiYgbXV0YXRpb24uc3RhbmRhcmRQcm9wcy5oYXNFbmQgPT09IGZhbHNlXG4gIGxldCBjb3B5ID0geyAuLi5ldmVudEluc3RhbmNlIH0gYXMgRXZlbnRJbnN0YW5jZVxuXG4gIGlmIChmb3JjZUFsbERheSkge1xuICAgIGNvcHkucmFuZ2UgPSBjb21wdXRlQWxpZ25lZERheVJhbmdlKGNvcHkucmFuZ2UpXG4gIH1cblxuICBpZiAobXV0YXRpb24uZGF0ZXNEZWx0YSAmJiBldmVudENvbmZpZy5zdGFydEVkaXRhYmxlKSB7XG4gICAgY29weS5yYW5nZSA9IHtcbiAgICAgIHN0YXJ0OiBkYXRlRW52LmFkZChjb3B5LnJhbmdlLnN0YXJ0LCBtdXRhdGlvbi5kYXRlc0RlbHRhKSxcbiAgICAgIGVuZDogZGF0ZUVudi5hZGQoY29weS5yYW5nZS5lbmQsIG11dGF0aW9uLmRhdGVzRGVsdGEpXG4gICAgfVxuICB9XG5cbiAgaWYgKG11dGF0aW9uLnN0YXJ0RGVsdGEgJiYgZXZlbnRDb25maWcuZHVyYXRpb25FZGl0YWJsZSkge1xuICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICBzdGFydDogZGF0ZUVudi5hZGQoY29weS5yYW5nZS5zdGFydCwgbXV0YXRpb24uc3RhcnREZWx0YSksXG4gICAgICBlbmQ6IGNvcHkucmFuZ2UuZW5kXG4gICAgfVxuICB9XG5cbiAgaWYgKG11dGF0aW9uLmVuZERlbHRhICYmIGV2ZW50Q29uZmlnLmR1cmF0aW9uRWRpdGFibGUpIHtcbiAgICBjb3B5LnJhbmdlID0ge1xuICAgICAgc3RhcnQ6IGNvcHkucmFuZ2Uuc3RhcnQsXG4gICAgICBlbmQ6IGRhdGVFbnYuYWRkKGNvcHkucmFuZ2UuZW5kLCBtdXRhdGlvbi5lbmREZWx0YSlcbiAgICB9XG4gIH1cblxuICBpZiAoY2xlYXJFbmQpIHtcbiAgICBjb3B5LnJhbmdlID0ge1xuICAgICAgc3RhcnQ6IGNvcHkucmFuZ2Uuc3RhcnQsXG4gICAgICBlbmQ6IGdldERlZmF1bHRFdmVudEVuZChldmVudERlZi5hbGxEYXksIGNvcHkucmFuZ2Uuc3RhcnQsIGNvbnRleHQpXG4gICAgfVxuICB9XG5cbiAgLy8gaW4gY2FzZSBldmVudCB3YXMgYWxsLWRheSBidXQgdGhlIHN1cHBsaWVkIGRlbHRhcyB3ZXJlIG5vdFxuICAvLyBiZXR0ZXIgdXRpbCBmb3IgdGhpcz9cbiAgaWYgKGV2ZW50RGVmLmFsbERheSkge1xuICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICBzdGFydDogc3RhcnRPZkRheShjb3B5LnJhbmdlLnN0YXJ0KSxcbiAgICAgIGVuZDogc3RhcnRPZkRheShjb3B5LnJhbmdlLmVuZClcbiAgICB9XG4gIH1cblxuICAvLyBoYW5kbGUgaW52YWxpZCBkdXJhdGlvbnNcbiAgaWYgKGNvcHkucmFuZ2UuZW5kIDwgY29weS5yYW5nZS5zdGFydCkge1xuICAgIGNvcHkucmFuZ2UuZW5kID0gZ2V0RGVmYXVsdEV2ZW50RW5kKGV2ZW50RGVmLmFsbERheSwgY29weS5yYW5nZS5zdGFydCwgY29udGV4dClcbiAgfVxuXG4gIHJldHVybiBjb3B5XG59XG4iLCJpbXBvcnQgeyBEYXRlRW52IH0gZnJvbSAnLi9kYXRlbGliL2VudidcbmltcG9ydCB7IENhbGVuZGFyRGF0YSB9IGZyb20gJy4vcmVkdWNlcnMvZGF0YS10eXBlcydcblxuLy8gbm8gcHVibGljIHR5cGVzIHlldC4gd2hlbiB0aGVyZSBhcmUsIGV4cG9ydCBmcm9tOlxuLy8gaW1wb3J0IHt9IGZyb20gJy4vYXBpLXR5cGUtZGVwcydcblxuXG5leHBvcnQgY2xhc3MgVmlld0FwaSB7IC8vIGFsd2F5cyByZXByZXNlbnRzIHRoZSBjdXJyZW50IHZpZXcuIG90aGVyd2lzZSwgaXQnZCBuZWVkIHRvIGNoYW5nZSB2YWx1ZSBldmVyeSB0aW1lIGRhdGUgY2hhbmdlc1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyB0eXBlOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSBnZXRDdXJyZW50RGF0YTogKCkgPT4gQ2FsZW5kYXJEYXRhLFxuICAgIHByaXZhdGUgZGF0ZUVudjogRGF0ZUVudlxuICApIHtcbiAgfVxuXG5cbiAgZ2V0IGNhbGVuZGFyKCkge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnREYXRhKCkuY2FsZW5kYXJBcGlcbiAgfVxuXG5cbiAgZ2V0IHRpdGxlKCkge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnREYXRhKCkudmlld1RpdGxlXG4gIH1cblxuXG4gIGdldCBhY3RpdmVTdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlRW52LnRvRGF0ZSh0aGlzLmdldEN1cnJlbnREYXRhKCkuZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2Uuc3RhcnQpXG4gIH1cblxuXG4gIGdldCBhY3RpdmVFbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLmVuZClcbiAgfVxuXG5cbiAgZ2V0IGN1cnJlbnRTdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlRW52LnRvRGF0ZSh0aGlzLmdldEN1cnJlbnREYXRhKCkuZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLnN0YXJ0KVxuICB9XG5cblxuICBnZXQgY3VycmVudEVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlRW52LnRvRGF0ZSh0aGlzLmdldEN1cnJlbnREYXRhKCkuZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLmVuZClcbiAgfVxuXG5cbiAgZ2V0T3B0aW9uKG5hbWU6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnREYXRhKCkub3B0aW9uc1tuYW1lXSAvLyBhcmUgdGhlIHZpZXctc3BlY2lmaWMgb3B0aW9uc1xuICB9XG5cbn1cbiIsImltcG9ydCB7IEV2ZW50SW5wdXQsIEV2ZW50SW5wdXRUcmFuc2Zvcm1lciB9IGZyb20gJy4vZXZlbnQtcGFyc2UnXG5pbXBvcnQgeyBFdmVudFNvdXJjZUZ1bmMgfSBmcm9tICcuLi9ldmVudC1zb3VyY2VzL2Z1bmMtZXZlbnQtc291cmNlJ1xuaW1wb3J0IHsgRXZlbnRTb3VyY2UsIEV2ZW50U291cmNlU3VjY2Vzc1Jlc3BvbnNlSGFuZGxlciwgRXZlbnRTb3VyY2VFcnJvclJlc3BvbnNlSGFuZGxlciB9IGZyb20gJy4vZXZlbnQtc291cmNlJ1xuaW1wb3J0IHsgSlNPTl9GRUVEX0VWRU5UX1NPVVJDRV9SRUZJTkVSUyB9IGZyb20gJy4uL2V2ZW50LXNvdXJjZXMvanNvbi1mZWVkLWV2ZW50LXNvdXJjZS1yZWZpbmVycydcbmltcG9ydCB7IENhbGVuZGFyQ29udGV4dCB9IGZyb20gJy4uL0NhbGVuZGFyQ29udGV4dCdcbmltcG9ydCB7IGd1aWQgfSBmcm9tICcuLi91dGlsL21pc2MnXG5pbXBvcnQgeyBFVkVOVF9VSV9SRUZJTkVSUywgY3JlYXRlRXZlbnRVaSwgRXZlbnRVaUlucHV0LCBFdmVudFVpUmVmaW5lZCB9IGZyb20gJy4uL2NvbXBvbmVudC9ldmVudC11aSdcbmltcG9ydCB7IGlkZW50aXR5LCBJZGVudGl0eSwgUmF3T3B0aW9uc0Zyb21SZWZpbmVycywgcmVmaW5lUHJvcHMsIFJlZmluZWRPcHRpb25zRnJvbVJlZmluZXJzIH0gZnJvbSAnLi4vb3B0aW9ucydcblxuXG5jb25zdCBFVkVOVF9TT1VSQ0VfUkVGSU5FUlMgPSB7IC8vIGRvZXMgTk9UIGluY2x1ZGUgRVZFTlRfVUlfUkVGSU5FUlNcbiAgaWQ6IFN0cmluZyxcbiAgZGVmYXVsdEFsbERheTogQm9vbGVhbixcbiAgdXJsOiBTdHJpbmcsXG4gIGV2ZW50czogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RXZlbnRJbnB1dFtdIHwgRXZlbnRTb3VyY2VGdW5jPiwgLy8gYXJyYXkgb3IgZnVuY3Rpb25cbiAgZXZlbnREYXRhVHJhbnNmb3JtOiBpZGVudGl0eSBhcyBJZGVudGl0eTxFdmVudElucHV0VHJhbnNmb3JtZXI+LFxuXG4gIC8vIGZvciBhbnkgbmV0d29yay1yZWxhdGVkIHNvdXJjZXNcbiAgc3VjY2VzczogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RXZlbnRTb3VyY2VTdWNjZXNzUmVzcG9uc2VIYW5kbGVyPixcbiAgZmFpbHVyZTogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RXZlbnRTb3VyY2VFcnJvclJlc3BvbnNlSGFuZGxlcj4sXG59XG5cbnR5cGUgQnVpbHRJbkV2ZW50U291cmNlUmVmaW5lcnMgPSB0eXBlb2YgRVZFTlRfU09VUkNFX1JFRklORVJTICYgdHlwZW9mIEpTT05fRkVFRF9FVkVOVF9TT1VSQ0VfUkVGSU5FUlNcblxuZXhwb3J0IGludGVyZmFjZSBFdmVudFNvdXJjZVJlZmluZXJzIGV4dGVuZHMgQnVpbHRJbkV2ZW50U291cmNlUmVmaW5lcnMge1xuICAvLyBmb3IgZXh0ZW5kaW5nXG59XG5cbmV4cG9ydCB0eXBlIEV2ZW50U291cmNlSW5wdXRPYmplY3QgPVxuICBFdmVudFVpSW5wdXQgJlxuICBSYXdPcHRpb25zRnJvbVJlZmluZXJzPFJlcXVpcmVkPEV2ZW50U291cmNlUmVmaW5lcnM+PiAvLyBSZXF1aXJlZCBoYWNrXG5cbmV4cG9ydCB0eXBlIEV2ZW50U291cmNlSW5wdXQgPVxuICBFdmVudFNvdXJjZUlucHV0T2JqZWN0IHwgLy8gb2JqZWN0IGluIGV4dGVuZGVkIGZvcm1cbiAgRXZlbnRJbnB1dFtdIHxcbiAgRXZlbnRTb3VyY2VGdW5jIHwgLy8ganVzdCBhIGZ1bmN0aW9uXG4gIHN0cmluZyAvLyBhIFVSTCBmb3IgYSBKU09OIGZlZWRcblxuZXhwb3J0IHR5cGUgRXZlbnRTb3VyY2VSZWZpbmVkID1cbiAgRXZlbnRVaVJlZmluZWQgJlxuICBSZWZpbmVkT3B0aW9uc0Zyb21SZWZpbmVyczxSZXF1aXJlZDxFdmVudFNvdXJjZVJlZmluZXJzPj4gLy8gUmVxdWlyZWQgaGFja1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUV2ZW50U291cmNlKFxuICByYXc6IEV2ZW50U291cmNlSW5wdXQsXG4gIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCxcbiAgcmVmaW5lcnMgPSBidWlsZEV2ZW50U291cmNlUmVmaW5lcnMoY29udGV4dClcbik6IEV2ZW50U291cmNlPGFueT4gfCBudWxsIHtcbiAgbGV0IHJhd09iajogRXZlbnRTb3VyY2VJbnB1dE9iamVjdFxuXG4gIGlmICh0eXBlb2YgcmF3ID09PSAnc3RyaW5nJykge1xuICAgIHJhd09iaiA9IHsgdXJsOiByYXcgfVxuXG4gIH0gZWxzZSBpZiAodHlwZW9mIHJhdyA9PT0gJ2Z1bmN0aW9uJyB8fCBBcnJheS5pc0FycmF5KHJhdykpIHtcbiAgICByYXdPYmogPSB7IGV2ZW50czogcmF3IH1cblxuICB9IGVsc2UgaWYgKHR5cGVvZiByYXcgPT09ICdvYmplY3QnICYmIHJhdykgeyAvLyBub3QgbnVsbFxuICAgIHJhd09iaiA9IHJhd1xuICB9XG5cbiAgaWYgKHJhd09iaikge1xuICAgIGxldCB7IHJlZmluZWQsIGV4dHJhIH0gPSByZWZpbmVQcm9wcyhyYXdPYmosIHJlZmluZXJzKVxuICAgIGxldCBtZXRhUmVzID0gYnVpbGRFdmVudFNvdXJjZU1ldGEocmVmaW5lZCwgY29udGV4dClcblxuICAgIGlmIChtZXRhUmVzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfcmF3OiByYXcsXG4gICAgICAgIGlzRmV0Y2hpbmc6IGZhbHNlLFxuICAgICAgICBsYXRlc3RGZXRjaElkOiAnJyxcbiAgICAgICAgZmV0Y2hSYW5nZTogbnVsbCxcbiAgICAgICAgZGVmYXVsdEFsbERheTogcmVmaW5lZC5kZWZhdWx0QWxsRGF5LFxuICAgICAgICBldmVudERhdGFUcmFuc2Zvcm06IHJlZmluZWQuZXZlbnREYXRhVHJhbnNmb3JtLFxuICAgICAgICBzdWNjZXNzOiByZWZpbmVkLnN1Y2Nlc3MsXG4gICAgICAgIGZhaWx1cmU6IHJlZmluZWQuZmFpbHVyZSxcbiAgICAgICAgcHVibGljSWQ6IHJlZmluZWQuaWQgfHwgJycsXG4gICAgICAgIHNvdXJjZUlkOiBndWlkKCksXG4gICAgICAgIHNvdXJjZURlZklkOiBtZXRhUmVzLnNvdXJjZURlZklkLFxuICAgICAgICBtZXRhOiBtZXRhUmVzLm1ldGEsXG4gICAgICAgIHVpOiBjcmVhdGVFdmVudFVpKHJlZmluZWQsIGNvbnRleHQpLFxuICAgICAgICBleHRlbmRlZFByb3BzOiBleHRyYVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyhjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpIHtcbiAgcmV0dXJuIHsgLi4uRVZFTlRfVUlfUkVGSU5FUlMsIC4uLkVWRU5UX1NPVVJDRV9SRUZJTkVSUywgLi4uY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFNvdXJjZVJlZmluZXJzIH1cbn1cblxuXG5mdW5jdGlvbiBidWlsZEV2ZW50U291cmNlTWV0YShyYXc6IEV2ZW50U291cmNlUmVmaW5lZCwgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KSB7XG4gIGxldCBkZWZzID0gY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFNvdXJjZURlZnNcblxuICBmb3IgKGxldCBpID0gZGVmcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgeyAvLyBsYXRlci1hZGRlZCBwbHVnaW5zIHRha2UgcHJlY2VkZW5jZVxuICAgIGxldCBkZWYgPSBkZWZzW2ldXG4gICAgbGV0IG1ldGEgPSBkZWYucGFyc2VNZXRhKHJhdylcblxuICAgIGlmIChtZXRhKSB7XG4gICAgICByZXR1cm4geyBzb3VyY2VEZWZJZDogaSwgbWV0YSB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cbiIsImltcG9ydCB7IERhdGVFbnYsIERhdGVJbnB1dCB9IGZyb20gJy4uL2RhdGVsaWIvZW52J1xuaW1wb3J0IHsgRGF0ZU1hcmtlciB9IGZyb20gJy4uL2RhdGVsaWIvbWFya2VyJ1xuaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSAnLi9BY3Rpb24nXG5pbXBvcnQgeyBCYXNlT3B0aW9uc1JlZmluZWQgfSBmcm9tICcuLi9vcHRpb25zJ1xuXG5cbmV4cG9ydCBmdW5jdGlvbiByZWR1Y2VDdXJyZW50RGF0ZShjdXJyZW50RGF0ZTogRGF0ZU1hcmtlciwgYWN0aW9uOiBBY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcbiAgICAgIHJldHVybiBhY3Rpb24uZGF0ZU1hcmtlclxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gY3VycmVudERhdGVcbiAgfVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbml0aWFsRGF0ZShvcHRpb25zOiBCYXNlT3B0aW9uc1JlZmluZWQsIGRhdGVFbnY6IERhdGVFbnYpIHtcbiAgbGV0IGluaXRpYWxEYXRlSW5wdXQgPSBvcHRpb25zLmluaXRpYWxEYXRlXG5cbiAgLy8gY29tcHV0ZSB0aGUgaW5pdGlhbCBhbWJpZy10aW1lem9uZSBkYXRlXG4gIGlmIChpbml0aWFsRGF0ZUlucHV0ICE9IG51bGwpIHtcbiAgICByZXR1cm4gZGF0ZUVudi5jcmVhdGVNYXJrZXIoaW5pdGlhbERhdGVJbnB1dClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0Tm93KG9wdGlvbnMubm93LCBkYXRlRW52KSAvLyBnZXROb3cgYWxyZWFkeSByZXR1cm5zIHVuem9uZWRcbiAgfVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROb3cobm93SW5wdXQ6IERhdGVJbnB1dCB8ICgoKSA9PiBEYXRlSW5wdXQpLCBkYXRlRW52OiBEYXRlRW52KSB7XG5cbiAgaWYgKHR5cGVvZiBub3dJbnB1dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG5vd0lucHV0ID0gbm93SW5wdXQoKVxuICB9XG5cbiAgaWYgKG5vd0lucHV0ID09IG51bGwpIHtcbiAgICByZXR1cm4gZGF0ZUVudi5jcmVhdGVOb3dNYXJrZXIoKVxuICB9XG5cbiAgcmV0dXJuIGRhdGVFbnYuY3JlYXRlTWFya2VyKG5vd0lucHV0KVxufVxuIiwiaW1wb3J0IHsgRGF0ZU1hcmtlciB9IGZyb20gJy4vZGF0ZWxpYi9tYXJrZXInXG5pbXBvcnQgeyBjcmVhdGVGb3JtYXR0ZXIgfSBmcm9tICcuL2RhdGVsaWIvZm9ybWF0dGluZydcbmltcG9ydCB7IGNyZWF0ZUR1cmF0aW9uIH0gZnJvbSAnLi9kYXRlbGliL2R1cmF0aW9uJ1xuaW1wb3J0IHsgcGFyc2VEYXRlU3BhbiB9IGZyb20gJy4vc3RydWN0cy9kYXRlLXNwYW4nXG5pbXBvcnQgeyBwYXJzZUV2ZW50U291cmNlIH0gZnJvbSAnLi9zdHJ1Y3RzL2V2ZW50LXNvdXJjZS1wYXJzZSdcbmltcG9ydCB7IHBhcnNlRXZlbnQgfSBmcm9tICcuL3N0cnVjdHMvZXZlbnQtcGFyc2UnXG5pbXBvcnQgeyBldmVudFR1cGxlVG9TdG9yZSB9IGZyb20gJy4vc3RydWN0cy9ldmVudC1zdG9yZSdcbmltcG9ydCB7IFZpZXdTcGVjIH0gZnJvbSAnLi9zdHJ1Y3RzL3ZpZXctc3BlYydcbmltcG9ydCB7IFBvaW50ZXJEcmFnRXZlbnQgfSBmcm9tICcuL2ludGVyYWN0aW9ucy9wb2ludGVyJ1xuaW1wb3J0IHsgZ2V0Tm93IH0gZnJvbSAnLi9yZWR1Y2Vycy9jdXJyZW50LWRhdGUnXG5pbXBvcnQgeyB0cmlnZ2VyRGF0ZVNlbGVjdCwgdHJpZ2dlckRhdGVVbnNlbGVjdCB9IGZyb20gJy4vY2FsZW5kYXItdXRpbHMnXG5pbXBvcnQgeyBoYXNoVmFsdWVzVG9BcnJheSB9IGZyb20gJy4vdXRpbC9vYmplY3QnXG5pbXBvcnQgeyBDYWxlbmRhckRhdGFNYW5hZ2VyIH0gZnJvbSAnLi9yZWR1Y2Vycy9DYWxlbmRhckRhdGFNYW5hZ2VyJ1xuaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSAnLi9yZWR1Y2Vycy9BY3Rpb24nXG5pbXBvcnQgeyBFdmVudFNvdXJjZSB9IGZyb20gJy4vc3RydWN0cy9ldmVudC1zb3VyY2UnXG5pbXBvcnQgeyBldmVudEFwaVRvU3RvcmUsIGJ1aWxkRXZlbnRBcGlzIH0gZnJvbSAnLi9hcGkvRXZlbnRBcGknXG5cbi8vIHB1YmxpY1xuaW1wb3J0IHtcbiAgQ2FsZW5kYXJPcHRpb25zLFxuICBDYWxlbmRhckxpc3RlbmVycyxcbiAgRGF0ZUlucHV0LFxuICBEdXJhdGlvbklucHV0LFxuICBEYXRlU3BhbklucHV0LFxuICBEYXRlUmFuZ2VJbnB1dCxcbiAgRXZlbnRTb3VyY2VJbnB1dCxcbiAgRXZlbnRJbnB1dCxcbiAgRXZlbnRTb3VyY2VBcGksXG4gIEV2ZW50QXBpLFxuICBWaWV3QXBpLFxufSBmcm9tICcuL2FwaS10eXBlLWRlcHMnXG5cblxuZXhwb3J0IGNsYXNzIENhbGVuZGFyQXBpIHtcblxuICBjdXJyZW50RGF0YU1hbmFnZXI/OiBDYWxlbmRhckRhdGFNYW5hZ2VyIC8vIHdpbGwgYmUgc2V0IGJ5IENhbGVuZGFyRGF0YU1hbmFnZXJcblxuICBnZXRDdXJyZW50RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50RGF0YU1hbmFnZXIhLmdldEN1cnJlbnREYXRhKClcbiAgfVxuXG4gIGRpc3BhdGNoKGFjdGlvbjogQWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyIS5kaXNwYXRjaChhY3Rpb24pXG4gIH1cblxuICBnZXQgdmlldygpOiBWaWV3QXBpIHsgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudERhdGEoKS52aWV3QXBpIH0gLy8gZm9yIHB1YmxpYyBBUElcblxuXG4gIGJhdGNoUmVuZGVyaW5nKGNhbGxiYWNrOiAoKSA9PiB2b2lkKSB7IC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuICAgIGNhbGxiYWNrKClcbiAgfVxuXG5cbiAgdXBkYXRlU2l6ZSgpIHsgLy8gcHVibGljXG4gICAgdGhpcy50cmlnZ2VyKCdfcmVzaXplJywgdHJ1ZSlcbiAgfVxuXG5cbiAgLy8gT3B0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgc2V0T3B0aW9uPE9wdGlvbk5hbWUgZXh0ZW5kcyBrZXlvZiBDYWxlbmRhck9wdGlvbnM+KG5hbWU6IE9wdGlvbk5hbWUsIHZhbDogQ2FsZW5kYXJPcHRpb25zW09wdGlvbk5hbWVdKSB7XG4gICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiAnU0VUX09QVElPTicsXG4gICAgICBvcHRpb25OYW1lOiBuYW1lLFxuICAgICAgcmF3T3B0aW9uVmFsdWU6IHZhbFxuICAgIH0pXG4gIH1cblxuXG4gIGdldE9wdGlvbjxPcHRpb25OYW1lIGV4dGVuZHMga2V5b2YgQ2FsZW5kYXJPcHRpb25zPihuYW1lOiBPcHRpb25OYW1lKTogQ2FsZW5kYXJPcHRpb25zW09wdGlvbk5hbWVdIHsgLy8gZ2V0dGVyLCB1c2VkIGV4dGVybmFsbHkuIFdURiBUU1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnREYXRhTWFuYWdlciEuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0W25hbWVdXG4gIH1cblxuXG4gIGdldEF2YWlsYWJsZUxvY2FsZUNvZGVzKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmdldEN1cnJlbnREYXRhKCkuYXZhaWxhYmxlUmF3TG9jYWxlcylcbiAgfVxuXG5cbiAgLy8gVHJpZ2dlclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgb248TGlzdGVuZXJOYW1lIGV4dGVuZHMga2V5b2YgQ2FsZW5kYXJMaXN0ZW5lcnM+KGhhbmRsZXJOYW1lOiBMaXN0ZW5lck5hbWUsIGhhbmRsZXI6IENhbGVuZGFyTGlzdGVuZXJzW0xpc3RlbmVyTmFtZV0pIHtcbiAgICBsZXQgeyBjdXJyZW50RGF0YU1hbmFnZXIgfSA9IHRoaXNcblxuICAgIGlmIChjdXJyZW50RGF0YU1hbmFnZXIuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZXJzW2hhbmRsZXJOYW1lXSkge1xuICAgICAgY3VycmVudERhdGFNYW5hZ2VyLmVtaXR0ZXIub24oaGFuZGxlck5hbWUsIGhhbmRsZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihgVW5rbm93biBsaXN0ZW5lciBuYW1lICcke2hhbmRsZXJOYW1lfSdgKVxuICAgIH1cbiAgfVxuXG5cbiAgb2ZmPExpc3RlbmVyTmFtZSBleHRlbmRzIGtleW9mIENhbGVuZGFyTGlzdGVuZXJzPihoYW5kbGVyTmFtZTogTGlzdGVuZXJOYW1lLCBoYW5kbGVyOiBDYWxlbmRhckxpc3RlbmVyc1tMaXN0ZW5lck5hbWVdKSB7XG4gICAgdGhpcy5jdXJyZW50RGF0YU1hbmFnZXIhLmVtaXR0ZXIub2ZmKGhhbmRsZXJOYW1lLCBoYW5kbGVyKVxuICB9XG5cblxuICBwcm90ZWN0ZWQgdHJpZ2dlcjxMaXN0ZW5lck5hbWUgZXh0ZW5kcyBrZXlvZiBDYWxlbmRhckxpc3RlbmVycz4oaGFuZGxlck5hbWU6IExpc3RlbmVyTmFtZSwgLi4uYXJnczogUGFyYW1ldGVyczxDYWxlbmRhckxpc3RlbmVyc1tMaXN0ZW5lck5hbWVdPikge1xuICAgIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyIS5lbWl0dGVyLnRyaWdnZXIoaGFuZGxlck5hbWUsIC4uLmFyZ3MpXG4gIH1cblxuXG4gIC8vIFZpZXdcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gIGNoYW5nZVZpZXcodmlld1R5cGU6IHN0cmluZywgZGF0ZU9yUmFuZ2U/OiBEYXRlUmFuZ2VJbnB1dCB8IERhdGVJbnB1dCkge1xuICAgIHRoaXMuYmF0Y2hSZW5kZXJpbmcoKCkgPT4ge1xuICAgICAgdGhpcy51bnNlbGVjdCgpXG5cbiAgICAgIGlmIChkYXRlT3JSYW5nZSkge1xuXG4gICAgICAgIGlmICgoZGF0ZU9yUmFuZ2UgYXMgRGF0ZVJhbmdlSW5wdXQpLnN0YXJ0ICYmIChkYXRlT3JSYW5nZSBhcyBEYXRlUmFuZ2VJbnB1dCkuZW5kKSB7IC8vIGEgcmFuZ2VcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfVklFV19UWVBFJyxcbiAgICAgICAgICAgIHZpZXdUeXBlLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IC8vIG5vdCB2ZXJ5IGVmZmljaWVudCB0byBkbyB0d28gZGlzcGF0Y2hlc1xuICAgICAgICAgICAgdHlwZTogJ1NFVF9PUFRJT04nLFxuICAgICAgICAgICAgb3B0aW9uTmFtZTogJ3Zpc2libGVSYW5nZScsXG4gICAgICAgICAgICByYXdPcHRpb25WYWx1ZTogZGF0ZU9yUmFuZ2VcbiAgICAgICAgICB9KVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpXG5cbiAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfVklFV19UWVBFJyxcbiAgICAgICAgICAgIHZpZXdUeXBlLFxuICAgICAgICAgICAgZGF0ZU1hcmtlcjogZGF0ZUVudi5jcmVhdGVNYXJrZXIoZGF0ZU9yUmFuZ2UgYXMgRGF0ZUlucHV0KVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogJ0NIQU5HRV9WSUVXX1RZUEUnLFxuICAgICAgICAgIHZpZXdUeXBlXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG5cbiAgLy8gRm9yY2VzIG5hdmlnYXRpb24gdG8gYSB2aWV3IGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAgLy8gYHZpZXdUeXBlYCBjYW4gYmUgYSBzcGVjaWZpYyB2aWV3IG5hbWUgb3IgYSBnZW5lcmljIG9uZSBsaWtlIFwid2Vla1wiIG9yIFwiZGF5XCIuXG4gIC8vIG5lZWRzIHRvIGNoYW5nZVxuICB6b29tVG8oZGF0ZU1hcmtlcjogRGF0ZU1hcmtlciwgdmlld1R5cGU/OiBzdHJpbmcpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKClcbiAgICBsZXQgc3BlY1xuXG4gICAgdmlld1R5cGUgPSB2aWV3VHlwZSB8fCAnZGF5JyAvLyBkYXkgaXMgZGVmYXVsdCB6b29tXG4gICAgc3BlYyA9IHN0YXRlLnZpZXdTcGVjc1t2aWV3VHlwZV0gfHwgdGhpcy5nZXRVbml0Vmlld1NwZWModmlld1R5cGUpXG5cbiAgICB0aGlzLnVuc2VsZWN0KClcblxuICAgIGlmIChzcGVjKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogJ0NIQU5HRV9WSUVXX1RZUEUnLFxuICAgICAgICB2aWV3VHlwZTogc3BlYy50eXBlLFxuICAgICAgICBkYXRlTWFya2VyXG4gICAgICB9KVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICBkYXRlTWFya2VyXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG5cbiAgLy8gR2l2ZW4gYSBkdXJhdGlvbiBzaW5ndWxhciB1bml0LCBsaWtlIFwid2Vla1wiIG9yIFwiZGF5XCIsIGZpbmRzIGEgbWF0Y2hpbmcgdmlldyBzcGVjLlxuICAvLyBQcmVmZXJlbmNlIGlzIGdpdmVuIHRvIHZpZXdzIHRoYXQgaGF2ZSBjb3JyZXNwb25kaW5nIGJ1dHRvbnMuXG4gIHByaXZhdGUgZ2V0VW5pdFZpZXdTcGVjKHVuaXQ6IHN0cmluZyk6IFZpZXdTcGVjIHwgbnVsbCB7XG4gICAgbGV0IHsgdmlld1NwZWNzLCB0b29sYmFyQ29uZmlnIH0gPSB0aGlzLmdldEN1cnJlbnREYXRhKClcbiAgICBsZXQgdmlld1R5cGVzID0gW10uY29uY2F0KHRvb2xiYXJDb25maWcudmlld3NXaXRoQnV0dG9ucylcbiAgICBsZXQgaVxuICAgIGxldCBzcGVjXG5cbiAgICBmb3IgKGxldCB2aWV3VHlwZSBpbiB2aWV3U3BlY3MpIHtcbiAgICAgIHZpZXdUeXBlcy5wdXNoKHZpZXdUeXBlKVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCB2aWV3VHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNwZWMgPSB2aWV3U3BlY3Nbdmlld1R5cGVzW2ldXVxuICAgICAgaWYgKHNwZWMpIHtcbiAgICAgICAgaWYgKHNwZWMuc2luZ2xlVW5pdCA9PT0gdW5pdCkge1xuICAgICAgICAgIHJldHVybiBzcGVjXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIC8vIEN1cnJlbnQgRGF0ZVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgcHJldigpIHtcbiAgICB0aGlzLnVuc2VsZWN0KClcbiAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ1BSRVYnIH0pXG4gIH1cblxuXG4gIG5leHQoKSB7XG4gICAgdGhpcy51bnNlbGVjdCgpXG4gICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdORVhUJyB9KVxuICB9XG5cblxuICBwcmV2WWVhcigpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKClcbiAgICB0aGlzLnVuc2VsZWN0KClcbiAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICBkYXRlTWFya2VyOiBzdGF0ZS5kYXRlRW52LmFkZFllYXJzKHN0YXRlLmN1cnJlbnREYXRlLCAtMSlcbiAgICB9KVxuICB9XG5cblxuICBuZXh0WWVhcigpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKClcblxuICAgIHRoaXMudW5zZWxlY3QoKVxuICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogJ0NIQU5HRV9EQVRFJyxcbiAgICAgIGRhdGVNYXJrZXI6IHN0YXRlLmRhdGVFbnYuYWRkWWVhcnMoc3RhdGUuY3VycmVudERhdGUsIDEpXG4gICAgfSlcbiAgfVxuXG5cbiAgdG9kYXkoKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpXG5cbiAgICB0aGlzLnVuc2VsZWN0KClcbiAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICBkYXRlTWFya2VyOiBnZXROb3coc3RhdGUuY2FsZW5kYXJPcHRpb25zLm5vdywgc3RhdGUuZGF0ZUVudilcbiAgICB9KVxuICB9XG5cblxuICBnb3RvRGF0ZSh6b25lZERhdGVJbnB1dCkge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKVxuXG4gICAgdGhpcy51bnNlbGVjdCgpXG4gICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgZGF0ZU1hcmtlcjogc3RhdGUuZGF0ZUVudi5jcmVhdGVNYXJrZXIoem9uZWREYXRlSW5wdXQpXG4gICAgfSlcbiAgfVxuXG5cbiAgaW5jcmVtZW50RGF0ZShkZWx0YUlucHV0KSB7IC8vIGlzIHB1YmxpYyBmYWNpbmdcbiAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKClcbiAgICBsZXQgZGVsdGEgPSBjcmVhdGVEdXJhdGlvbihkZWx0YUlucHV0KVxuXG4gICAgaWYgKGRlbHRhKSB7IC8vIGVsc2UsIHdhcm4gYWJvdXQgaW52YWxpZCBpbnB1dD9cbiAgICAgIHRoaXMudW5zZWxlY3QoKVxuICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICAgIGRhdGVNYXJrZXI6IHN0YXRlLmRhdGVFbnYuYWRkKHN0YXRlLmN1cnJlbnREYXRlLCBkZWx0YSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cblxuICAvLyBmb3IgZXh0ZXJuYWwgQVBJXG4gIGdldERhdGUoKTogRGF0ZSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpXG4gICAgcmV0dXJuIHN0YXRlLmRhdGVFbnYudG9EYXRlKHN0YXRlLmN1cnJlbnREYXRlKVxuICB9XG5cblxuICAvLyBEYXRlIEZvcm1hdHRpbmcgVXRpbHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gIGZvcm1hdERhdGUoZDogRGF0ZUlucHV0LCBmb3JtYXR0ZXIpOiBzdHJpbmcge1xuICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKVxuXG4gICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0KFxuICAgICAgZGF0ZUVudi5jcmVhdGVNYXJrZXIoZCksXG4gICAgICBjcmVhdGVGb3JtYXR0ZXIoZm9ybWF0dGVyKVxuICAgIClcbiAgfVxuXG5cbiAgLy8gYHNldHRpbmdzYCBpcyBmb3IgZm9ybWF0dGVyIEFORCBpc0VuZEV4Y2x1c2l2ZVxuICBmb3JtYXRSYW5nZShkMDogRGF0ZUlucHV0LCBkMTogRGF0ZUlucHV0LCBzZXR0aW5ncykge1xuICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMgfSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKVxuXG4gICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0UmFuZ2UoXG4gICAgICBkYXRlRW52LmNyZWF0ZU1hcmtlcihkMCksXG4gICAgICBkYXRlRW52LmNyZWF0ZU1hcmtlcihkMSksXG4gICAgICBjcmVhdGVGb3JtYXR0ZXIoc2V0dGluZ3MsIG9wdGlvbnMuZGVmYXVsdFJhbmdlU2VwYXJhdG9yKSxcbiAgICAgIHNldHRpbmdzXG4gICAgKVxuICB9XG5cblxuICBmb3JtYXRJc28oZDogRGF0ZUlucHV0LCBvbWl0VGltZT86IGJvb2xlYW4pIHtcbiAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLmdldEN1cnJlbnREYXRhKClcblxuICAgIHJldHVybiBkYXRlRW52LmZvcm1hdElzbyhkYXRlRW52LmNyZWF0ZU1hcmtlcihkKSwgeyBvbWl0VGltZSB9KVxuICB9XG5cblxuICAvLyBEYXRlIFNlbGVjdGlvbiAvIEV2ZW50IFNlbGVjdGlvbiAvIERheUNsaWNrXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAvLyB0aGlzIHB1YmxpYyBtZXRob2QgcmVjZWl2ZXMgc3RhcnQvZW5kIGRhdGVzIGluIGFueSBmb3JtYXQsIHdpdGggYW55IHRpbWV6b25lXG4gIC8vIE5PVEU6IGFyZ3Mgd2VyZSBjaGFuZ2VkIGZyb20gdjNcbiAgc2VsZWN0KGRhdGVPck9iajogRGF0ZUlucHV0IHwgYW55LCBlbmREYXRlPzogRGF0ZUlucHV0KSB7XG4gICAgbGV0IHNlbGVjdGlvbklucHV0OiBEYXRlU3BhbklucHV0XG5cbiAgICBpZiAoZW5kRGF0ZSA9PSBudWxsKSB7XG4gICAgICBpZiAoZGF0ZU9yT2JqLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgc2VsZWN0aW9uSW5wdXQgPSBkYXRlT3JPYmogYXMgRGF0ZVNwYW5JbnB1dFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0aW9uSW5wdXQgPSB7XG4gICAgICAgICAgc3RhcnQ6IGRhdGVPck9iaixcbiAgICAgICAgICBlbmQ6IG51bGxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3Rpb25JbnB1dCA9IHtcbiAgICAgICAgc3RhcnQ6IGRhdGVPck9iaixcbiAgICAgICAgZW5kOiBlbmREYXRlXG4gICAgICB9IGFzIERhdGVTcGFuSW5wdXRcbiAgICB9XG5cbiAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKClcbiAgICBsZXQgc2VsZWN0aW9uID0gcGFyc2VEYXRlU3BhbihcbiAgICAgIHNlbGVjdGlvbklucHV0LFxuICAgICAgc3RhdGUuZGF0ZUVudixcbiAgICAgIGNyZWF0ZUR1cmF0aW9uKHsgZGF5czogMSB9KSAvLyBUT0RPOiBjYWNoZSB0aGlzP1xuICAgIClcblxuICAgIGlmIChzZWxlY3Rpb24pIHsgLy8gdGhyb3cgcGFyc2UgZXJyb3Igb3RoZXJ3aXNlP1xuICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdTRUxFQ1RfREFURVMnLCBzZWxlY3Rpb24gfSlcbiAgICAgIHRyaWdnZXJEYXRlU2VsZWN0KHNlbGVjdGlvbiwgbnVsbCwgc3RhdGUpXG4gICAgfVxuICB9XG5cblxuICAvLyBwdWJsaWMgbWV0aG9kXG4gIHVuc2VsZWN0KHBldj86IFBvaW50ZXJEcmFnRXZlbnQpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKClcblxuICAgIGlmIChzdGF0ZS5kYXRlU2VsZWN0aW9uKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VMRUNUX0RBVEVTJyB9KVxuICAgICAgdHJpZ2dlckRhdGVVbnNlbGVjdChwZXYsIHN0YXRlKVxuICAgIH1cbiAgfVxuXG5cbiAgLy8gUHVibGljIEV2ZW50cyBBUElcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gIGFkZEV2ZW50KGV2ZW50SW5wdXQ6IEV2ZW50SW5wdXQsIHNvdXJjZUlucHV0PzogRXZlbnRTb3VyY2VBcGkgfCBzdHJpbmcgfCBib29sZWFuKTogRXZlbnRBcGkgfCBudWxsIHtcblxuICAgIGlmIChldmVudElucHV0IGluc3RhbmNlb2YgRXZlbnRBcGkpIHtcbiAgICAgIGxldCBkZWYgPSBldmVudElucHV0Ll9kZWZcbiAgICAgIGxldCBpbnN0YW5jZSA9IGV2ZW50SW5wdXQuX2luc3RhbmNlXG4gICAgICBsZXQgY3VycmVudERhdGEgPSB0aGlzLmdldEN1cnJlbnREYXRhKClcblxuICAgICAgLy8gbm90IGFscmVhZHkgcHJlc2VudD8gZG9uJ3Qgd2FudCB0byBhZGQgYW4gb2xkIHNuYXBzaG90XG4gICAgICBpZiAoIWN1cnJlbnREYXRhLmV2ZW50U3RvcmUuZGVmc1tkZWYuZGVmSWRdKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6ICdBRERfRVZFTlRTJyxcbiAgICAgICAgICBldmVudFN0b3JlOiBldmVudFR1cGxlVG9TdG9yZSh7IGRlZiwgaW5zdGFuY2UgfSkgLy8gVE9ETzogYmV0dGVyIHV0aWwgZm9yIHR3byBhcmdzP1xuICAgICAgICB9KVxuICAgICAgICB0aGlzLnRyaWdnZXJFdmVudEFkZChldmVudElucHV0KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXZlbnRJbnB1dFxuICAgIH1cblxuICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKVxuICAgIGxldCBldmVudFNvdXJjZTogRXZlbnRTb3VyY2U8YW55PlxuXG4gICAgaWYgKHNvdXJjZUlucHV0IGluc3RhbmNlb2YgRXZlbnRTb3VyY2VBcGkpIHtcbiAgICAgIGV2ZW50U291cmNlID0gc291cmNlSW5wdXQuaW50ZXJuYWxFdmVudFNvdXJjZVxuXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc291cmNlSW5wdXQgPT09ICdib29sZWFuJykge1xuICAgICAgaWYgKHNvdXJjZUlucHV0KSB7IC8vIHRydWUuIHBhcnQgb2YgdGhlIGZpcnN0IGV2ZW50IHNvdXJjZVxuICAgICAgICBldmVudFNvdXJjZSA9IGhhc2hWYWx1ZXNUb0FycmF5KHN0YXRlLmV2ZW50U291cmNlcylbMF1cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoc291cmNlSW5wdXQgIT0gbnVsbCkgeyAvLyBhbiBJRC4gYWNjZXB0cyBhIG51bWJlciB0b29cbiAgICAgIGxldCBzb3VyY2VBcGkgPSB0aGlzLmdldEV2ZW50U291cmNlQnlJZChzb3VyY2VJbnB1dCkgLy8gVE9ETzogdXNlIGFuIGludGVybmFsIGZ1bmN0aW9uXG5cbiAgICAgIGlmICghc291cmNlQXBpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGZpbmQgYW4gZXZlbnQgc291cmNlIHdpdGggSUQgXCInICsgc291cmNlSW5wdXQgKyAnXCInKSAvLyBUT0RPOiB0ZXN0XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldmVudFNvdXJjZSA9IHNvdXJjZUFwaS5pbnRlcm5hbEV2ZW50U291cmNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHR1cGxlID0gcGFyc2VFdmVudChldmVudElucHV0LCBldmVudFNvdXJjZSwgc3RhdGUsIGZhbHNlKVxuXG4gICAgaWYgKHR1cGxlKSB7XG4gICAgICBsZXQgbmV3RXZlbnRBcGkgPSBuZXcgRXZlbnRBcGkoXG4gICAgICAgIHN0YXRlLFxuICAgICAgICB0dXBsZS5kZWYsXG4gICAgICAgIHR1cGxlLmRlZi5yZWN1cnJpbmdEZWYgPyBudWxsIDogdHVwbGUuaW5zdGFuY2VcbiAgICAgIClcbiAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiAnQUREX0VWRU5UUycsXG4gICAgICAgIGV2ZW50U3RvcmU6IGV2ZW50VHVwbGVUb1N0b3JlKHR1cGxlKVxuICAgICAgfSlcbiAgICAgIHRoaXMudHJpZ2dlckV2ZW50QWRkKG5ld0V2ZW50QXBpKVxuXG4gICAgICByZXR1cm4gbmV3RXZlbnRBcGlcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cblxuICBwcml2YXRlIHRyaWdnZXJFdmVudEFkZChldmVudEFwaTogRXZlbnRBcGkpIHtcbiAgICBsZXQgeyBlbWl0dGVyIH0gPSB0aGlzLmdldEN1cnJlbnREYXRhKClcblxuICAgIGVtaXR0ZXIudHJpZ2dlcignZXZlbnRBZGQnLCB7XG4gICAgICBldmVudDogZXZlbnRBcGksXG4gICAgICByZWxhdGVkRXZlbnRzOiBbXSxcbiAgICAgIHJldmVydDogKCkgPT4ge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UUycsXG4gICAgICAgICAgZXZlbnRTdG9yZTogZXZlbnRBcGlUb1N0b3JlKGV2ZW50QXBpKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuXG4gIC8vIFRPRE86IG9wdGltaXplXG4gIGdldEV2ZW50QnlJZChpZDogc3RyaW5nKTogRXZlbnRBcGkgfCBudWxsIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKClcbiAgICBsZXQgeyBkZWZzLCBpbnN0YW5jZXMgfSA9IHN0YXRlLmV2ZW50U3RvcmVcblxuICAgIGlkID0gU3RyaW5nKGlkKVxuXG4gICAgZm9yIChsZXQgZGVmSWQgaW4gZGVmcykge1xuICAgICAgbGV0IGRlZiA9IGRlZnNbZGVmSWRdXG5cbiAgICAgIGlmIChkZWYucHVibGljSWQgPT09IGlkKSB7XG5cbiAgICAgICAgaWYgKGRlZi5yZWN1cnJpbmdEZWYpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50QXBpKHN0YXRlLCBkZWYsIG51bGwpXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICAgICAgbGV0IGluc3RhbmNlID0gaW5zdGFuY2VzW2luc3RhbmNlSWRdXG5cbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5kZWZJZCA9PT0gZGVmLmRlZklkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRBcGkoc3RhdGUsIGRlZiwgaW5zdGFuY2UpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG5cbiAgZ2V0RXZlbnRzKCk6IEV2ZW50QXBpW10ge1xuICAgIGxldCBjdXJyZW50RGF0YSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKVxuXG4gICAgcmV0dXJuIGJ1aWxkRXZlbnRBcGlzKGN1cnJlbnREYXRhLmV2ZW50U3RvcmUsIGN1cnJlbnREYXRhKVxuICB9XG5cblxuICByZW1vdmVBbGxFdmVudHMoKSB7XG4gICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdSRU1PVkVfQUxMX0VWRU5UUycgfSlcbiAgfVxuXG5cbiAgLy8gUHVibGljIEV2ZW50IFNvdXJjZXMgQVBJXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICBnZXRFdmVudFNvdXJjZXMoKTogRXZlbnRTb3VyY2VBcGlbXSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpXG4gICAgbGV0IHNvdXJjZUhhc2ggPSBzdGF0ZS5ldmVudFNvdXJjZXNcbiAgICBsZXQgc291cmNlQXBpczogRXZlbnRTb3VyY2VBcGlbXSA9IFtdXG5cbiAgICBmb3IgKGxldCBpbnRlcm5hbElkIGluIHNvdXJjZUhhc2gpIHtcbiAgICAgIHNvdXJjZUFwaXMucHVzaChuZXcgRXZlbnRTb3VyY2VBcGkoc3RhdGUsIHNvdXJjZUhhc2hbaW50ZXJuYWxJZF0pKVxuICAgIH1cblxuICAgIHJldHVybiBzb3VyY2VBcGlzXG4gIH1cblxuXG4gIGdldEV2ZW50U291cmNlQnlJZChpZDogc3RyaW5nKTogRXZlbnRTb3VyY2VBcGkgfCBudWxsIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKClcbiAgICBsZXQgc291cmNlSGFzaCA9IHN0YXRlLmV2ZW50U291cmNlc1xuXG4gICAgaWQgPSBTdHJpbmcoaWQpXG5cbiAgICBmb3IgKGxldCBzb3VyY2VJZCBpbiBzb3VyY2VIYXNoKSB7XG4gICAgICBpZiAoc291cmNlSGFzaFtzb3VyY2VJZF0ucHVibGljSWQgPT09IGlkKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXZlbnRTb3VyY2VBcGkoc3RhdGUsIHNvdXJjZUhhc2hbc291cmNlSWRdKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsXG4gIH1cblxuXG4gIGFkZEV2ZW50U291cmNlKHNvdXJjZUlucHV0OiBFdmVudFNvdXJjZUlucHV0KTogRXZlbnRTb3VyY2VBcGkge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKVxuXG4gICAgaWYgKHNvdXJjZUlucHV0IGluc3RhbmNlb2YgRXZlbnRTb3VyY2VBcGkpIHtcblxuICAgICAgLy8gbm90IGFscmVhZHkgcHJlc2VudD8gZG9uJ3Qgd2FudCB0byBhZGQgYW4gb2xkIHNuYXBzaG90XG4gICAgICBpZiAoIXN0YXRlLmV2ZW50U291cmNlc1tzb3VyY2VJbnB1dC5pbnRlcm5hbEV2ZW50U291cmNlLnNvdXJjZUlkXSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiAnQUREX0VWRU5UX1NPVVJDRVMnLFxuICAgICAgICAgIHNvdXJjZXM6IFsgc291cmNlSW5wdXQuaW50ZXJuYWxFdmVudFNvdXJjZSBdXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzb3VyY2VJbnB1dFxuICAgIH1cblxuICAgIGxldCBldmVudFNvdXJjZSA9IHBhcnNlRXZlbnRTb3VyY2Uoc291cmNlSW5wdXQsIHN0YXRlKVxuXG4gICAgaWYgKGV2ZW50U291cmNlKSB7IC8vIFRPRE86IGVycm9yIG90aGVyd2lzZT9cbiAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnQUREX0VWRU5UX1NPVVJDRVMnLCBzb3VyY2VzOiBbIGV2ZW50U291cmNlIF0gfSlcblxuICAgICAgcmV0dXJuIG5ldyBFdmVudFNvdXJjZUFwaShzdGF0ZSwgZXZlbnRTb3VyY2UpXG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG5cbiAgcmVtb3ZlQWxsRXZlbnRTb3VyY2VzKCkge1xuICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnUkVNT1ZFX0FMTF9FVkVOVF9TT1VSQ0VTJyB9KVxuICB9XG5cblxuICByZWZldGNoRXZlbnRzKCkge1xuICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnRkVUQ0hfRVZFTlRfU09VUkNFUycgfSlcbiAgfVxuXG5cbiAgLy8gU2Nyb2xsXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgc2Nyb2xsVG9UaW1lKHRpbWVJbnB1dDogRHVyYXRpb25JbnB1dCkge1xuICAgIGxldCB0aW1lID0gY3JlYXRlRHVyYXRpb24odGltZUlucHV0KVxuXG4gICAgaWYgKHRpbWUpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignX3Njcm9sbFJlcXVlc3QnLCB7IHRpbWUgfSlcbiAgICB9XG4gIH1cblxufVxuIiwiaW1wb3J0IHsgRXZlbnREZWYgfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LWRlZidcbmltcG9ydCB7IEVWRU5UX05PTl9EQVRFX1JFRklORVJTLCBFVkVOVF9EQVRFX1JFRklORVJTIH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1wYXJzZSdcbmltcG9ydCB7IEV2ZW50SW5zdGFuY2UgfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LWluc3RhbmNlJ1xuaW1wb3J0IHsgRVZFTlRfVUlfUkVGSU5FUlMsIEV2ZW50VWlIYXNoIH0gZnJvbSAnLi4vY29tcG9uZW50L2V2ZW50LXVpJ1xuaW1wb3J0IHsgRXZlbnRNdXRhdGlvbiwgYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZSB9IGZyb20gJy4uL3N0cnVjdHMvZXZlbnQtbXV0YXRpb24nXG5pbXBvcnQgeyBkaWZmRGF0ZXMsIGNvbXB1dGVBbGlnbmVkRGF5UmFuZ2UgfSBmcm9tICcuLi91dGlsL2RhdGUnXG5pbXBvcnQgeyBjcmVhdGVEdXJhdGlvbiwgZHVyYXRpb25zRXF1YWwgfSBmcm9tICcuLi9kYXRlbGliL2R1cmF0aW9uJ1xuaW1wb3J0IHsgY3JlYXRlRm9ybWF0dGVyIH0gZnJvbSAnLi4vZGF0ZWxpYi9mb3JtYXR0aW5nJ1xuaW1wb3J0IHsgQ2FsZW5kYXJDb250ZXh0IH0gZnJvbSAnLi4vQ2FsZW5kYXJDb250ZXh0J1xuaW1wb3J0IHsgZ2V0UmVsZXZhbnRFdmVudHMsIEV2ZW50U3RvcmUgfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LXN0b3JlJ1xuaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYidcbmltcG9ydCB7IERpY3Rpb25hcnkgfSBmcm9tICcuLi9vcHRpb25zJ1xuXG4vLyBwdWJsaWNcbmltcG9ydCB7XG4gIERhdGVJbnB1dCxcbiAgRHVyYXRpb25JbnB1dCxcbiAgRm9ybWF0dGVySW5wdXQsXG4gIEV2ZW50U291cmNlQXBpXG59IGZyb20gJy4uL2FwaS10eXBlLWRlcHMnXG5cblxuZXhwb3J0IGNsYXNzIEV2ZW50QXBpIHtcblxuICBfY29udGV4dDogQ2FsZW5kYXJDb250ZXh0XG4gIF9kZWY6IEV2ZW50RGVmXG4gIF9pbnN0YW5jZTogRXZlbnRJbnN0YW5jZSB8IG51bGxcbiAgICAvLyBpbnN0YW5jZSB3aWxsIGJlIG51bGwgaWYgZXhwcmVzc2luZyBhIHJlY3VycmluZyBldmVudCB0aGF0IGhhcyBubyBjdXJyZW50IGluc3RhbmNlcyxcbiAgICAvLyBPUiBpZiB0cnlpbmcgdG8gdmFsaWRhdGUgYW4gaW5jb21pbmcgZXh0ZXJuYWwgZXZlbnQgdGhhdCBoYXMgbm8gZGF0ZXMgYXNzaWduZWRcblxuICBjb25zdHJ1Y3Rvcihjb250ZXh0OiBDYWxlbmRhckNvbnRleHQsIGRlZjogRXZlbnREZWYsIGluc3RhbmNlPzogRXZlbnRJbnN0YW5jZSkge1xuICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0XG4gICAgdGhpcy5fZGVmID0gZGVmXG4gICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0YW5jZSB8fCBudWxsXG4gIH1cblxuICAvKlxuICBUT0RPOiBtYWtlIGV2ZW50IHN0cnVjdCBtb3JlIHJlc3BvbnNpYmxlIGZvciB0aGlzXG4gICovXG4gIHNldFByb3AobmFtZTogc3RyaW5nLCB2YWw6IHN0cmluZykge1xuXG4gICAgaWYgKG5hbWUgaW4gRVZFTlRfREFURV9SRUZJTkVSUykge1xuICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3Qgc2V0IGRhdGUtcmVsYXRlZCBwcm9wICduYW1lJy4gVXNlIG9uZSBvZiB0aGUgZGF0ZS1yZWxhdGVkIG1ldGhvZHMgaW5zdGVhZC5gKVxuXG4gICAgfSBlbHNlIGlmIChuYW1lIGluIEVWRU5UX05PTl9EQVRFX1JFRklORVJTKSB7XG4gICAgICB2YWwgPSBFVkVOVF9OT05fREFURV9SRUZJTkVSU1tuYW1lXSh2YWwpXG5cbiAgICAgIHRoaXMubXV0YXRlKHtcbiAgICAgICAgc3RhbmRhcmRQcm9wczogeyBbbmFtZV06IHZhbCB9XG4gICAgICB9KVxuXG4gICAgfSBlbHNlIGlmIChuYW1lIGluIEVWRU5UX1VJX1JFRklORVJTKSB7XG4gICAgICBsZXQgdWkgPSBFVkVOVF9VSV9SRUZJTkVSU1tuYW1lXSh2YWwpXG5cbiAgICAgIGlmIChuYW1lID09PSAnY29sb3InKSB7XG4gICAgICAgIHVpID0geyBiYWNrZ3JvdW5kQ29sb3I6IHZhbCwgYm9yZGVyQ29sb3I6IHZhbCB9XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdlZGl0YWJsZScpIHtcbiAgICAgICAgdWkgPSB7IHN0YXJ0RWRpdGFibGU6IHZhbCwgZHVyYXRpb25FZGl0YWJsZTogdmFsIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVpID0geyBbbmFtZV06IHZhbCB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubXV0YXRlKHtcbiAgICAgICAgc3RhbmRhcmRQcm9wczogeyB1aSB9XG4gICAgICB9KVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IHNldCBwcm9wICcke25hbWV9Jy4gVXNlIHNldEV4dGVuZGVkUHJvcCBpbnN0ZWFkLmApXG4gICAgfVxuICB9XG5cbiAgc2V0RXh0ZW5kZWRQcm9wKG5hbWU6IHN0cmluZywgdmFsOiBhbnkpIHtcbiAgICB0aGlzLm11dGF0ZSh7XG4gICAgICBleHRlbmRlZFByb3BzOiB7IFtuYW1lXTogdmFsIH1cbiAgICB9KVxuICB9XG5cbiAgc2V0U3RhcnQoc3RhcnRJbnB1dDogRGF0ZUlucHV0LCBvcHRpb25zOiB7IGdyYW51bGFyaXR5Pzogc3RyaW5nLCBtYWludGFpbkR1cmF0aW9uPzogYm9vbGVhbiB9ID0ge30pIHtcbiAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLl9jb250ZXh0XG4gICAgbGV0IHN0YXJ0ID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoc3RhcnRJbnB1dClcblxuICAgIGlmIChzdGFydCAmJiB0aGlzLl9pbnN0YW5jZSkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgIGxldCBpbnN0YW5jZVJhbmdlID0gdGhpcy5faW5zdGFuY2UucmFuZ2VcbiAgICAgIGxldCBzdGFydERlbHRhID0gZGlmZkRhdGVzKGluc3RhbmNlUmFuZ2Uuc3RhcnQsIHN0YXJ0LCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KSAvLyB3aGF0IGlmIHBhcnNlZCBiYWQhP1xuXG4gICAgICBpZiAob3B0aW9ucy5tYWludGFpbkR1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogc3RhcnREZWx0YSB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tdXRhdGUoeyBzdGFydERlbHRhIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2V0RW5kKGVuZElucHV0OiBEYXRlSW5wdXQgfCBudWxsLCBvcHRpb25zOiB7IGdyYW51bGFyaXR5Pzogc3RyaW5nIH0gPSB7fSkge1xuICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMuX2NvbnRleHRcbiAgICBsZXQgZW5kXG5cbiAgICBpZiAoZW5kSW5wdXQgIT0gbnVsbCkge1xuICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoZW5kSW5wdXQpXG5cbiAgICAgIGlmICghZW5kKSB7XG4gICAgICAgIHJldHVybiAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW5zdGFuY2UpIHtcbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgbGV0IGVuZERlbHRhID0gZGlmZkRhdGVzKHRoaXMuX2luc3RhbmNlLnJhbmdlLmVuZCwgZW5kLCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KVxuICAgICAgICB0aGlzLm11dGF0ZSh7IGVuZERlbHRhIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm11dGF0ZSh7IHN0YW5kYXJkUHJvcHM6IHsgaGFzRW5kOiBmYWxzZSB9IH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2V0RGF0ZXMoc3RhcnRJbnB1dDogRGF0ZUlucHV0LCBlbmRJbnB1dDogRGF0ZUlucHV0IHwgbnVsbCwgb3B0aW9uczogeyBhbGxEYXk/OiBib29sZWFuLCBncmFudWxhcml0eT86IHN0cmluZyB9ID0ge30pIHtcbiAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLl9jb250ZXh0XG4gICAgbGV0IHN0YW5kYXJkUHJvcHMgPSB7IGFsbERheTogb3B0aW9ucy5hbGxEYXkgfSBhcyBhbnlcbiAgICBsZXQgc3RhcnQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihzdGFydElucHV0KVxuICAgIGxldCBlbmRcblxuICAgIGlmICghc3RhcnQpIHtcbiAgICAgIHJldHVybiAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICB9XG5cbiAgICBpZiAoZW5kSW5wdXQgIT0gbnVsbCkge1xuICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoZW5kSW5wdXQpXG5cbiAgICAgIGlmICghZW5kKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW5zdGFuY2UpIHtcbiAgICAgIGxldCBpbnN0YW5jZVJhbmdlID0gdGhpcy5faW5zdGFuY2UucmFuZ2VcblxuICAgICAgLy8gd2hlbiBjb21wdXRpbmcgdGhlIGRpZmYgZm9yIGFuIGV2ZW50IGJlaW5nIGNvbnZlcnRlZCB0byBhbGwtZGF5LFxuICAgICAgLy8gY29tcHV0ZSBkaWZmIG9mZiBvZiB0aGUgYWxsLWRheSB2YWx1ZXMgdGhlIHdheSBldmVudC1tdXRhdGlvbiBkb2VzLlxuICAgICAgaWYgKG9wdGlvbnMuYWxsRGF5ID09PSB0cnVlKSB7XG4gICAgICAgIGluc3RhbmNlUmFuZ2UgPSBjb21wdXRlQWxpZ25lZERheVJhbmdlKGluc3RhbmNlUmFuZ2UpXG4gICAgICB9XG5cbiAgICAgIGxldCBzdGFydERlbHRhID0gZGlmZkRhdGVzKGluc3RhbmNlUmFuZ2Uuc3RhcnQsIHN0YXJ0LCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KVxuXG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIGxldCBlbmREZWx0YSA9IGRpZmZEYXRlcyhpbnN0YW5jZVJhbmdlLmVuZCwgZW5kLCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KVxuXG4gICAgICAgIGlmIChkdXJhdGlvbnNFcXVhbChzdGFydERlbHRhLCBlbmREZWx0YSkpIHtcbiAgICAgICAgICB0aGlzLm11dGF0ZSh7IGRhdGVzRGVsdGE6IHN0YXJ0RGVsdGEsIHN0YW5kYXJkUHJvcHMgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm11dGF0ZSh7IHN0YXJ0RGVsdGEsIGVuZERlbHRhLCBzdGFuZGFyZFByb3BzIH0pXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHsgLy8gbWVhbnMgXCJjbGVhciB0aGUgZW5kXCJcbiAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSBmYWxzZVxuICAgICAgICB0aGlzLm11dGF0ZSh7IGRhdGVzRGVsdGE6IHN0YXJ0RGVsdGEsIHN0YW5kYXJkUHJvcHMgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBtb3ZlU3RhcnQoZGVsdGFJbnB1dDogRHVyYXRpb25JbnB1dCkge1xuICAgIGxldCBkZWx0YSA9IGNyZWF0ZUR1cmF0aW9uKGRlbHRhSW5wdXQpXG5cbiAgICBpZiAoZGVsdGEpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICB0aGlzLm11dGF0ZSh7IHN0YXJ0RGVsdGE6IGRlbHRhIH0pXG4gICAgfVxuICB9XG5cbiAgbW92ZUVuZChkZWx0YUlucHV0OiBEdXJhdGlvbklucHV0KSB7XG4gICAgbGV0IGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dClcblxuICAgIGlmIChkZWx0YSkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgIHRoaXMubXV0YXRlKHsgZW5kRGVsdGE6IGRlbHRhIH0pXG4gICAgfVxuICB9XG5cbiAgbW92ZURhdGVzKGRlbHRhSW5wdXQ6IER1cmF0aW9uSW5wdXQpIHtcbiAgICBsZXQgZGVsdGEgPSBjcmVhdGVEdXJhdGlvbihkZWx0YUlucHV0KVxuXG4gICAgaWYgKGRlbHRhKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgdGhpcy5tdXRhdGUoeyBkYXRlc0RlbHRhOiBkZWx0YSB9KVxuICAgIH1cbiAgfVxuXG4gIHNldEFsbERheShhbGxEYXk6IGJvb2xlYW4sIG9wdGlvbnM6IHsgbWFpbnRhaW5EdXJhdGlvbj86IGJvb2xlYW4gfSA9IHt9KSB7XG4gICAgbGV0IHN0YW5kYXJkUHJvcHMgPSB7IGFsbERheSB9IGFzIGFueVxuICAgIGxldCBtYWludGFpbkR1cmF0aW9uID0gb3B0aW9ucy5tYWludGFpbkR1cmF0aW9uXG5cbiAgICBpZiAobWFpbnRhaW5EdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgICBtYWludGFpbkR1cmF0aW9uID0gdGhpcy5fY29udGV4dC5vcHRpb25zLmFsbERheU1haW50YWluRHVyYXRpb25cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGVmLmFsbERheSAhPT0gYWxsRGF5KSB7XG4gICAgICBzdGFuZGFyZFByb3BzLmhhc0VuZCA9IG1haW50YWluRHVyYXRpb25cbiAgICB9XG5cbiAgICB0aGlzLm11dGF0ZSh7IHN0YW5kYXJkUHJvcHMgfSlcbiAgfVxuXG4gIGZvcm1hdFJhbmdlKGZvcm1hdElucHV0OiBGb3JtYXR0ZXJJbnB1dCkge1xuICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMuX2NvbnRleHRcbiAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLl9pbnN0YW5jZVxuICAgIGxldCBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIoZm9ybWF0SW5wdXQsIHRoaXMuX2NvbnRleHQub3B0aW9ucy5kZWZhdWx0UmFuZ2VTZXBhcmF0b3IpXG5cbiAgICBpZiAodGhpcy5fZGVmLmhhc0VuZCkge1xuICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0UmFuZ2UoaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIGluc3RhbmNlLnJhbmdlLmVuZCwgZm9ybWF0dGVyLCB7XG4gICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBpbnN0YW5jZS5mb3JjZWRTdGFydFR6byxcbiAgICAgICAgZm9yY2VkRW5kVHpvOiBpbnN0YW5jZS5mb3JjZWRFbmRUem9cbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdChpbnN0YW5jZS5yYW5nZS5zdGFydCwgZm9ybWF0dGVyLCB7XG4gICAgICAgIGZvcmNlZFR6bzogaW5zdGFuY2UuZm9yY2VkU3RhcnRUem9cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgbXV0YXRlKG11dGF0aW9uOiBFdmVudE11dGF0aW9uKSB7IC8vIG1lYW50IHRvIGJlIHByaXZhdGUuIGJ1dCBwbHVnaW5zIG5lZWQgYWNjZXNzXG4gICAgbGV0IGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2VcblxuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgbGV0IGRlZiA9IHRoaXMuX2RlZlxuICAgICAgbGV0IGNvbnRleHQgPSB0aGlzLl9jb250ZXh0XG4gICAgICBsZXQgeyBldmVudFN0b3JlIH0gPSBjb250ZXh0LmdldEN1cnJlbnREYXRhKClcbiAgICAgIGxldCByZWxldmFudEV2ZW50cyA9IGdldFJlbGV2YW50RXZlbnRzKGV2ZW50U3RvcmUsIGluc3RhbmNlLmluc3RhbmNlSWQpXG4gICAgICBsZXQgZXZlbnRDb25maWdCYXNlID0ge1xuICAgICAgICAnJzogeyAvLyBIQUNLLiBhbHdheXMgYWxsb3cgQVBJIHRvIG11dGF0ZSBldmVudHNcbiAgICAgICAgICBkaXNwbGF5OiAnJyxcbiAgICAgICAgICBzdGFydEVkaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGR1cmF0aW9uRWRpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uc3RyYWludHM6IFtdLFxuICAgICAgICAgIG92ZXJsYXA6IG51bGwsXG4gICAgICAgICAgYWxsb3dzOiBbXSxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxuICAgICAgICAgIGJvcmRlckNvbG9yOiAnJyxcbiAgICAgICAgICB0ZXh0Q29sb3I6ICcnLFxuICAgICAgICAgIGNsYXNzTmFtZXM6IFtdXG4gICAgICAgIH1cbiAgICAgIH0gYXMgRXZlbnRVaUhhc2hcblxuICAgICAgcmVsZXZhbnRFdmVudHMgPSBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlKHJlbGV2YW50RXZlbnRzLCBldmVudENvbmZpZ0Jhc2UsIG11dGF0aW9uLCBjb250ZXh0KVxuXG4gICAgICBsZXQgb2xkRXZlbnQgPSBuZXcgRXZlbnRBcGkoY29udGV4dCwgZGVmLCBpbnN0YW5jZSkgLy8gc25hcHNob3RcbiAgICAgIHRoaXMuX2RlZiA9IHJlbGV2YW50RXZlbnRzLmRlZnNbZGVmLmRlZklkXVxuICAgICAgdGhpcy5faW5zdGFuY2UgPSByZWxldmFudEV2ZW50cy5pbnN0YW5jZXNbaW5zdGFuY2UuaW5zdGFuY2VJZF1cblxuICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICBldmVudFN0b3JlOiByZWxldmFudEV2ZW50c1xuICAgICAgfSlcblxuICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50Q2hhbmdlJywge1xuICAgICAgICBvbGRFdmVudCxcbiAgICAgICAgZXZlbnQ6IHRoaXMsXG4gICAgICAgIHJlbGF0ZWRFdmVudHM6IGJ1aWxkRXZlbnRBcGlzKHJlbGV2YW50RXZlbnRzLCBjb250ZXh0LCBpbnN0YW5jZSksXG4gICAgICAgIHJldmVydCgpIHtcbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRTJyxcbiAgICAgICAgICAgIGV2ZW50U3RvcmU6IHJlbGV2YW50RXZlbnRzXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZW1vdmUoKSB7XG4gICAgbGV0IGNvbnRleHQgPSB0aGlzLl9jb250ZXh0XG4gICAgbGV0IGFzU3RvcmUgPSBldmVudEFwaVRvU3RvcmUodGhpcylcblxuICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVFMnLFxuICAgICAgZXZlbnRTdG9yZTogYXNTdG9yZVxuICAgIH0pXG5cbiAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZW1vdmUnLCB7XG4gICAgICBldmVudDogdGhpcyxcbiAgICAgIHJlbGF0ZWRFdmVudHM6IFtdLFxuICAgICAgcmV2ZXJ0KCkge1xuICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICBldmVudFN0b3JlOiBhc1N0b3JlXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGdldCBzb3VyY2UoKTogRXZlbnRTb3VyY2VBcGkgfCBudWxsIHtcbiAgICBsZXQgc291cmNlSWQgPSB0aGlzLl9kZWYuc291cmNlSWRcblxuICAgIGlmIChzb3VyY2VJZCkge1xuICAgICAgcmV0dXJuIG5ldyBFdmVudFNvdXJjZUFwaShcbiAgICAgICAgdGhpcy5fY29udGV4dCxcbiAgICAgICAgdGhpcy5fY29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50U291cmNlc1tzb3VyY2VJZF1cbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGdldCBzdGFydCgpOiBEYXRlIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlID9cbiAgICAgIHRoaXMuX2NvbnRleHQuZGF0ZUVudi50b0RhdGUodGhpcy5faW5zdGFuY2UucmFuZ2Uuc3RhcnQpIDpcbiAgICAgIG51bGxcbiAgfVxuXG4gIGdldCBlbmQoKTogRGF0ZSB8IG51bGwge1xuICAgIHJldHVybiAodGhpcy5faW5zdGFuY2UgJiYgdGhpcy5fZGVmLmhhc0VuZCkgP1xuICAgICAgdGhpcy5fY29udGV4dC5kYXRlRW52LnRvRGF0ZSh0aGlzLl9pbnN0YW5jZS5yYW5nZS5lbmQpIDpcbiAgICAgIG51bGxcbiAgfVxuXG4gIGdldCBzdGFydFN0cigpOiBzdHJpbmcge1xuICAgIGxldCBpbnN0YW5jZSA9IHRoaXMuX2luc3RhbmNlXG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5kYXRlRW52LmZvcm1hdElzbyhpbnN0YW5jZS5yYW5nZS5zdGFydCwge1xuICAgICAgICBvbWl0VGltZTogdGhpcy5fZGVmLmFsbERheSxcbiAgICAgICAgZm9yY2VkVHpvOiBpbnN0YW5jZS5mb3JjZWRTdGFydFR6b1xuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBnZXQgZW5kU3RyKCk6IHN0cmluZyB7XG4gICAgbGV0IGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2VcbiAgICBpZiAoaW5zdGFuY2UgJiYgdGhpcy5fZGVmLmhhc0VuZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZGF0ZUVudi5mb3JtYXRJc28oaW5zdGFuY2UucmFuZ2UuZW5kLCB7XG4gICAgICAgIG9taXRUaW1lOiB0aGlzLl9kZWYuYWxsRGF5LFxuICAgICAgICBmb3JjZWRUem86IGluc3RhbmNlLmZvcmNlZEVuZFR6b1xuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBjb21wdXRhYmxlIHByb3BzIHRoYXQgYWxsIGFjY2VzcyB0aGUgZGVmXG4gIC8vIFRPRE86IGZpbmQgYSBUeXBlU2NyaXB0LWNvbXBhdGlibGUgd2F5IHRvIGRvIHRoaXMgYXQgc2NhbGVcbiAgZ2V0IGlkKCkgeyByZXR1cm4gdGhpcy5fZGVmLnB1YmxpY0lkIH1cbiAgZ2V0IGdyb3VwSWQoKSB7IHJldHVybiB0aGlzLl9kZWYuZ3JvdXBJZCB9XG4gIGdldCBhbGxEYXkoKSB7IHJldHVybiB0aGlzLl9kZWYuYWxsRGF5IH1cbiAgZ2V0IHRpdGxlKCkgeyByZXR1cm4gdGhpcy5fZGVmLnRpdGxlIH1cbiAgZ2V0IHVybCgpIHsgcmV0dXJuIHRoaXMuX2RlZi51cmwgfVxuICBnZXQgZGlzcGxheSgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5kaXNwbGF5IHx8ICdhdXRvJyB9IC8vIGJhZC4ganVzdCBub3JtYWxpemUgdGhlIHR5cGUgZWFybGllclxuICBnZXQgc3RhcnRFZGl0YWJsZSgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5zdGFydEVkaXRhYmxlIH1cbiAgZ2V0IGR1cmF0aW9uRWRpdGFibGUoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuZHVyYXRpb25FZGl0YWJsZSB9XG4gIGdldCBjb25zdHJhaW50KCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmNvbnN0cmFpbnRzWzBdIHx8IG51bGwgfVxuICBnZXQgb3ZlcmxhcCgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5vdmVybGFwIH1cbiAgZ2V0IGFsbG93KCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmFsbG93c1swXSB8fCBudWxsIH1cbiAgZ2V0IGJhY2tncm91bmRDb2xvcigpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5iYWNrZ3JvdW5kQ29sb3IgfVxuICBnZXQgYm9yZGVyQ29sb3IoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuYm9yZGVyQ29sb3IgfVxuICBnZXQgdGV4dENvbG9yKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLnRleHRDb2xvciB9XG5cbiAgLy8gTk9URTogdXNlciBjYW4ndCBtb2RpZnkgdGhlc2UgYmVjYXVzZSBPYmplY3QuZnJlZXplIHdhcyBjYWxsZWQgaW4gZXZlbnQtZGVmIHBhcnNpbmdcbiAgZ2V0IGNsYXNzTmFtZXMoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuY2xhc3NOYW1lcyB9XG4gIGdldCBleHRlbmRlZFByb3BzKCkgeyByZXR1cm4gdGhpcy5fZGVmLmV4dGVuZGVkUHJvcHMgfVxuXG5cbiAgdG9QbGFpbk9iamVjdChzZXR0aW5nczogeyBjb2xsYXBzZUV4dGVuZGVkUHJvcHM/OiBib29sZWFuLCBjb2xsYXBzZUNvbG9yPzogYm9vbGVhbiB9ID0ge30pOiBEaWN0aW9uYXJ5IHtcbiAgICBsZXQgZGVmID0gdGhpcy5fZGVmXG4gICAgbGV0IHsgdWkgfSA9IGRlZlxuICAgIGxldCB7IHN0YXJ0U3RyLCBlbmRTdHIgfSA9IHRoaXNcbiAgICBsZXQgcmVzOiBEaWN0aW9uYXJ5ID0ge31cblxuICAgIGlmIChkZWYudGl0bGUpIHtcbiAgICAgIHJlcy50aXRsZSA9IGRlZi50aXRsZVxuICAgIH1cblxuICAgIGlmIChzdGFydFN0cikge1xuICAgICAgcmVzLnN0YXJ0ID0gc3RhcnRTdHJcbiAgICB9XG5cbiAgICBpZiAoZW5kU3RyKSB7XG4gICAgICByZXMuZW5kID0gZW5kU3RyXG4gICAgfVxuXG4gICAgaWYgKGRlZi5wdWJsaWNJZCkge1xuICAgICAgcmVzLmlkID0gZGVmLnB1YmxpY0lkXG4gICAgfVxuXG4gICAgaWYgKGRlZi5ncm91cElkKSB7XG4gICAgICByZXMuZ3JvdXBJZCA9IGRlZi5ncm91cElkXG4gICAgfVxuXG4gICAgaWYgKGRlZi51cmwpIHtcbiAgICAgIHJlcy51cmwgPSBkZWYudXJsXG4gICAgfVxuXG4gICAgaWYgKHVpLmRpc3BsYXkgJiYgdWkuZGlzcGxheSAhPT0gJ2F1dG8nKSB7XG4gICAgICByZXMuZGlzcGxheSA9IHVpLmRpc3BsYXlcbiAgICB9XG5cbiAgICAvLyBUT0RPOiB3aGF0IGFib3V0IHJlY3VycmluZy1ldmVudCBwcm9wZXJ0aWVzPz8/XG4gICAgLy8gVE9ETzogaW5jbHVkZSBzdGFydEVkaXRhYmxlL2R1cmF0aW9uRWRpdGFibGUvY29uc3RyYWludC9vdmVybGFwL2FsbG93XG5cbiAgICBpZiAoc2V0dGluZ3MuY29sbGFwc2VDb2xvciAmJiB1aS5iYWNrZ3JvdW5kQ29sb3IgJiYgdWkuYmFja2dyb3VuZENvbG9yID09PSB1aS5ib3JkZXJDb2xvcikge1xuICAgICAgcmVzLmNvbG9yID0gdWkuYmFja2dyb3VuZENvbG9yXG5cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHVpLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICByZXMuYmFja2dyb3VuZENvbG9yID0gdWkuYmFja2dyb3VuZENvbG9yXG4gICAgICB9XG4gICAgICBpZiAodWkuYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgcmVzLmJvcmRlckNvbG9yID0gdWkuYm9yZGVyQ29sb3JcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodWkudGV4dENvbG9yKSB7XG4gICAgICByZXMudGV4dENvbG9yID0gdWkudGV4dENvbG9yXG4gICAgfVxuXG4gICAgaWYgKHVpLmNsYXNzTmFtZXMubGVuZ3RoKSB7XG4gICAgICByZXMuY2xhc3NOYW1lcyA9IHVpLmNsYXNzTmFtZXNcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmtleXMoZGVmLmV4dGVuZGVkUHJvcHMpLmxlbmd0aCkge1xuICAgICAgaWYgKHNldHRpbmdzLmNvbGxhcHNlRXh0ZW5kZWRQcm9wcykge1xuICAgICAgICBfX2Fzc2lnbihyZXMsIGRlZi5leHRlbmRlZFByb3BzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzLmV4dGVuZGVkUHJvcHMgPSBkZWYuZXh0ZW5kZWRQcm9wc1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXNcbiAgfVxuXG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvUGxhaW5PYmplY3QoKVxuICB9XG5cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZXZlbnRBcGlUb1N0b3JlKGV2ZW50QXBpOiBFdmVudEFwaSk6IEV2ZW50U3RvcmUge1xuICBsZXQgZGVmID0gZXZlbnRBcGkuX2RlZlxuICBsZXQgaW5zdGFuY2UgPSBldmVudEFwaS5faW5zdGFuY2VcblxuICByZXR1cm4ge1xuICAgIGRlZnM6IHsgW2RlZi5kZWZJZF06IGRlZiB9LFxuICAgIGluc3RhbmNlczogaW5zdGFuY2VcbiAgICAgID8geyBbaW5zdGFuY2UuaW5zdGFuY2VJZF06IGluc3RhbmNlIH1cbiAgICAgIDoge31cbiAgfVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEV2ZW50QXBpcyhldmVudFN0b3JlOiBFdmVudFN0b3JlLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQsIGV4Y2x1ZGVJbnN0YW5jZT86IEV2ZW50SW5zdGFuY2UpOiBFdmVudEFwaVtdIHtcbiAgbGV0IHsgZGVmcywgaW5zdGFuY2VzIH0gPSBldmVudFN0b3JlXG4gIGxldCBldmVudEFwaXM6IEV2ZW50QXBpW10gPSBbXVxuICBsZXQgZXhjbHVkZUluc3RhbmNlSWQgPSBleGNsdWRlSW5zdGFuY2UgPyBleGNsdWRlSW5zdGFuY2UuaW5zdGFuY2VJZCA6ICcnXG5cbiAgZm9yIChsZXQgaWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgbGV0IGluc3RhbmNlID0gaW5zdGFuY2VzW2lkXVxuICAgIGxldCBkZWYgPSBkZWZzW2luc3RhbmNlLmRlZklkXVxuXG4gICAgaWYgKGluc3RhbmNlLmluc3RhbmNlSWQgIT09IGV4Y2x1ZGVJbnN0YW5jZUlkKSB7XG4gICAgICBldmVudEFwaXMucHVzaChuZXcgRXZlbnRBcGkoY29udGV4dCwgZGVmLCBpbnN0YW5jZSkpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50QXBpc1xufVxuIiwiaW1wb3J0IHsgRGF0ZU1hcmtlciwgYXJyYXlUb1V0Y0RhdGUsIGRhdGVUb1V0Y0FycmF5IH0gZnJvbSAnLi9tYXJrZXInXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsZW5kYXJTeXN0ZW0ge1xuICBnZXRNYXJrZXJZZWFyKGQ6IERhdGVNYXJrZXIpOiBudW1iZXJcbiAgZ2V0TWFya2VyTW9udGgoZDogRGF0ZU1hcmtlcik6IG51bWJlclxuICBnZXRNYXJrZXJEYXkoZDogRGF0ZU1hcmtlcik6IG51bWJlclxuICBhcnJheVRvTWFya2VyKGFycjogbnVtYmVyW10pOiBEYXRlTWFya2VyXG4gIG1hcmtlclRvQXJyYXkoZDogRGF0ZU1hcmtlcik6IG51bWJlcltdXG59XG5cblxubGV0IGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXAgPSB7fVxuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJDYWxlbmRhclN5c3RlbShuYW1lLCB0aGVDbGFzcykge1xuICBjYWxlbmRhclN5c3RlbUNsYXNzTWFwW25hbWVdID0gdGhlQ2xhc3Ncbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNhbGVuZGFyU3lzdGVtKG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBjYWxlbmRhclN5c3RlbUNsYXNzTWFwW25hbWVdKClcbn1cblxuXG5jbGFzcyBHcmVnb3JpYW5DYWxlbmRhclN5c3RlbSBpbXBsZW1lbnRzIENhbGVuZGFyU3lzdGVtIHtcblxuICBnZXRNYXJrZXJZZWFyKGQ6IERhdGVNYXJrZXIpIHtcbiAgICByZXR1cm4gZC5nZXRVVENGdWxsWWVhcigpXG4gIH1cblxuICBnZXRNYXJrZXJNb250aChkOiBEYXRlTWFya2VyKSB7XG4gICAgcmV0dXJuIGQuZ2V0VVRDTW9udGgoKVxuICB9XG5cbiAgZ2V0TWFya2VyRGF5KGQ6IERhdGVNYXJrZXIpIHtcbiAgICByZXR1cm4gZC5nZXRVVENEYXRlKClcbiAgfVxuXG4gIGFycmF5VG9NYXJrZXIoYXJyKSB7XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGFycilcbiAgfVxuXG4gIG1hcmtlclRvQXJyYXkobWFya2VyKSB7XG4gICAgcmV0dXJuIGRhdGVUb1V0Y0FycmF5KG1hcmtlcilcbiAgfVxuXG59XG5cbnJlZ2lzdGVyQ2FsZW5kYXJTeXN0ZW0oJ2dyZWdvcnknLCBHcmVnb3JpYW5DYWxlbmRhclN5c3RlbSlcbiIsImltcG9ydCB7IGlzVmFsaWREYXRlIH0gZnJvbSAnLi9tYXJrZXInXG5cblxuY29uc3QgSVNPX1JFID0gL15cXHMqKFxcZHs0fSkoLShcXGR7Mn0pKC0oXFxkezJ9KShbVCBdKFxcZHsyfSk6KFxcZHsyfSkoOihcXGR7Mn0pKFxcLihcXGQrKSk/KT8oWnwoKFstK10pKFxcZHsyfSkoOj8oXFxkezJ9KSk/KSk/KT8pPyk/JC9cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBsZXQgbSA9IElTT19SRS5leGVjKHN0cilcblxuICBpZiAobSkge1xuICAgIGxldCBtYXJrZXIgPSBuZXcgRGF0ZShEYXRlLlVUQyhcbiAgICAgIE51bWJlcihtWzFdKSxcbiAgICAgIG1bM10gPyBOdW1iZXIobVszXSkgLSAxIDogMCxcbiAgICAgIE51bWJlcihtWzVdIHx8IDEpLFxuICAgICAgTnVtYmVyKG1bN10gfHwgMCksXG4gICAgICBOdW1iZXIobVs4XSB8fCAwKSxcbiAgICAgIE51bWJlcihtWzEwXSB8fCAwKSxcbiAgICAgIG1bMTJdID8gTnVtYmVyKCcwLicgKyBtWzEyXSkgKiAxMDAwIDogMFxuICAgICkpXG5cbiAgICBpZiAoaXNWYWxpZERhdGUobWFya2VyKSkge1xuICAgICAgbGV0IHRpbWVab25lT2Zmc2V0ID0gbnVsbFxuXG4gICAgICBpZiAobVsxM10pIHtcbiAgICAgICAgdGltZVpvbmVPZmZzZXQgPSAobVsxNV0gPT09ICctJyA/IC0xIDogMSkgKiAoXG4gICAgICAgICAgTnVtYmVyKG1bMTZdIHx8IDApICogNjAgK1xuICAgICAgICAgIE51bWJlcihtWzE4XSB8fCAwKVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hcmtlcixcbiAgICAgICAgaXNUaW1lVW5zcGVjaWZpZWQ6ICFtWzZdLFxuICAgICAgICB0aW1lWm9uZU9mZnNldFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG4iLCJpbXBvcnQge1xuICBEYXRlTWFya2VyLCBhZGRNcyxcbiAgZGlmZkhvdXJzLCBkaWZmTWludXRlcywgZGlmZlNlY29uZHMsIGRpZmZXaG9sZVdlZWtzLCBkaWZmV2hvbGVEYXlzLFxuICBzdGFydE9mRGF5LCBzdGFydE9mSG91ciwgc3RhcnRPZk1pbnV0ZSwgc3RhcnRPZlNlY29uZCxcbiAgd2Vla09mWWVhciwgYXJyYXlUb1V0Y0RhdGUsIGRhdGVUb1V0Y0FycmF5LCBkYXRlVG9Mb2NhbEFycmF5LCBhcnJheVRvTG9jYWxEYXRlLCB0aW1lQXNNcywgaXNWYWxpZERhdGVcbn0gZnJvbSAnLi9tYXJrZXInXG5pbXBvcnQgeyBDYWxlbmRhclN5c3RlbSwgY3JlYXRlQ2FsZW5kYXJTeXN0ZW0gfSBmcm9tICcuL2NhbGVuZGFyLXN5c3RlbSdcbmltcG9ydCB7IExvY2FsZSB9IGZyb20gJy4vbG9jYWxlJ1xuaW1wb3J0IHsgTmFtZWRUaW1lWm9uZUltcGwsIE5hbWVkVGltZVpvbmVJbXBsQ2xhc3MgfSBmcm9tICcuL3RpbWV6b25lJ1xuaW1wb3J0IHsgRHVyYXRpb24sIGFzUm91Z2hZZWFycywgYXNSb3VnaE1vbnRocywgYXNSb3VnaERheXMsIGFzUm91Z2hNcyB9IGZyb20gJy4vZHVyYXRpb24nXG5pbXBvcnQgeyBEYXRlRm9ybWF0dGVyLCBDbWRGb3JtYXR0ZXJGdW5jIH0gZnJvbSAnLi9EYXRlRm9ybWF0dGVyJ1xuaW1wb3J0IHsgYnVpbGRJc29TdHJpbmcgfSBmcm9tICcuL2Zvcm1hdHRpbmctdXRpbHMnXG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gJy4vcGFyc2luZydcbmltcG9ydCB7IGlzSW50IH0gZnJvbSAnLi4vdXRpbC9taXNjJ1xuXG5cbmV4cG9ydCB0eXBlIFdlZWtOdW1iZXJDYWxjdWxhdGlvbiA9ICdsb2NhbCcgfCAnSVNPJyB8ICgobTogRGF0ZSkgPT4gbnVtYmVyKVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVFbnZTZXR0aW5ncyB7XG4gIHRpbWVab25lOiBzdHJpbmdcbiAgbmFtZWRUaW1lWm9uZUltcGw/OiBOYW1lZFRpbWVab25lSW1wbENsYXNzXG4gIGNhbGVuZGFyU3lzdGVtOiBzdHJpbmdcbiAgbG9jYWxlOiBMb2NhbGVcbiAgd2Vla051bWJlckNhbGN1bGF0aW9uPzogV2Vla051bWJlckNhbGN1bGF0aW9uXG4gIGZpcnN0RGF5PzogbnVtYmVyLCAvLyB3aWxsIG92ZXJyaWRlIHdoYXQgdGhlIGxvY2FsZSB3YW50c1xuICB3ZWVrVGV4dD86IHN0cmluZyxcbiAgY21kRm9ybWF0dGVyPzogQ21kRm9ybWF0dGVyRnVuY1xuICBkZWZhdWx0U2VwYXJhdG9yPzogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIERhdGVJbnB1dCA9IERhdGUgfCBzdHJpbmcgfCBudW1iZXIgfCBudW1iZXJbXVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVNYXJrZXJNZXRhIHtcbiAgbWFya2VyOiBEYXRlTWFya2VyXG4gIGlzVGltZVVuc3BlY2lmaWVkOiBib29sZWFuXG4gIGZvcmNlZFR6bzogbnVtYmVyIHwgbnVsbFxufVxuXG5cbmV4cG9ydCBjbGFzcyBEYXRlRW52IHtcblxuICB0aW1lWm9uZTogc3RyaW5nXG4gIG5hbWVkVGltZVpvbmVJbXBsOiBOYW1lZFRpbWVab25lSW1wbFxuICBjYW5Db21wdXRlT2Zmc2V0OiBib29sZWFuXG5cbiAgY2FsZW5kYXJTeXN0ZW06IENhbGVuZGFyU3lzdGVtXG4gIGxvY2FsZTogTG9jYWxlXG4gIHdlZWtEb3c6IG51bWJlciAvLyB3aGljaCBkYXkgYmVnaW5zIHRoZSB3ZWVrXG4gIHdlZWtEb3k6IG51bWJlciAvLyB3aGljaCBkYXkgbXVzdCBiZSB3aXRoaW4gdGhlIHllYXIsIGZvciBjb21wdXRpbmcgdGhlIGZpcnN0IHdlZWsgbnVtYmVyXG4gIHdlZWtOdW1iZXJGdW5jOiBhbnlcbiAgd2Vla1RleHQ6IHN0cmluZyAvLyBET04nVCBMSUtFIGhvdyBvcHRpb25zIGFyZSBjb25mdXNlZCB3aXRoIGxvY2FsXG4gIGNtZEZvcm1hdHRlcj86IENtZEZvcm1hdHRlckZ1bmNcbiAgZGVmYXVsdFNlcGFyYXRvcjogc3RyaW5nXG5cblxuICBjb25zdHJ1Y3RvcihzZXR0aW5nczogRGF0ZUVudlNldHRpbmdzKSB7XG4gICAgbGV0IHRpbWVab25lID0gdGhpcy50aW1lWm9uZSA9IHNldHRpbmdzLnRpbWVab25lXG4gICAgbGV0IGlzTmFtZWRUaW1lWm9uZSA9IHRpbWVab25lICE9PSAnbG9jYWwnICYmIHRpbWVab25lICE9PSAnVVRDJ1xuXG4gICAgaWYgKHNldHRpbmdzLm5hbWVkVGltZVpvbmVJbXBsICYmIGlzTmFtZWRUaW1lWm9uZSkge1xuICAgICAgdGhpcy5uYW1lZFRpbWVab25lSW1wbCA9IG5ldyBzZXR0aW5ncy5uYW1lZFRpbWVab25lSW1wbCh0aW1lWm9uZSlcbiAgICB9XG5cbiAgICB0aGlzLmNhbkNvbXB1dGVPZmZzZXQgPSBCb29sZWFuKCFpc05hbWVkVGltZVpvbmUgfHwgdGhpcy5uYW1lZFRpbWVab25lSW1wbClcblxuICAgIHRoaXMuY2FsZW5kYXJTeXN0ZW0gPSBjcmVhdGVDYWxlbmRhclN5c3RlbShzZXR0aW5ncy5jYWxlbmRhclN5c3RlbSlcbiAgICB0aGlzLmxvY2FsZSA9IHNldHRpbmdzLmxvY2FsZVxuICAgIHRoaXMud2Vla0RvdyA9IHNldHRpbmdzLmxvY2FsZS53ZWVrLmRvd1xuICAgIHRoaXMud2Vla0RveSA9IHNldHRpbmdzLmxvY2FsZS53ZWVrLmRveVxuXG4gICAgaWYgKHNldHRpbmdzLndlZWtOdW1iZXJDYWxjdWxhdGlvbiA9PT0gJ0lTTycpIHtcbiAgICAgIHRoaXMud2Vla0RvdyA9IDFcbiAgICAgIHRoaXMud2Vla0RveSA9IDRcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNldHRpbmdzLmZpcnN0RGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy53ZWVrRG93ID0gc2V0dGluZ3MuZmlyc3REYXlcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNldHRpbmdzLndlZWtOdW1iZXJDYWxjdWxhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy53ZWVrTnVtYmVyRnVuYyA9IHNldHRpbmdzLndlZWtOdW1iZXJDYWxjdWxhdGlvblxuICAgIH1cblxuICAgIHRoaXMud2Vla1RleHQgPSBzZXR0aW5ncy53ZWVrVGV4dCAhPSBudWxsID8gc2V0dGluZ3Mud2Vla1RleHQgOiBzZXR0aW5ncy5sb2NhbGUub3B0aW9ucy53ZWVrVGV4dFxuXG4gICAgdGhpcy5jbWRGb3JtYXR0ZXIgPSBzZXR0aW5ncy5jbWRGb3JtYXR0ZXJcbiAgICB0aGlzLmRlZmF1bHRTZXBhcmF0b3IgPSBzZXR0aW5ncy5kZWZhdWx0U2VwYXJhdG9yXG4gIH1cblxuXG4gIC8vIENyZWF0aW5nIC8gUGFyc2luZ1xuXG4gIGNyZWF0ZU1hcmtlcihpbnB1dDogRGF0ZUlucHV0KTogRGF0ZU1hcmtlciB7XG4gICAgbGV0IG1ldGEgPSB0aGlzLmNyZWF0ZU1hcmtlck1ldGEoaW5wdXQpXG4gICAgaWYgKG1ldGEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHJldHVybiBtZXRhLm1hcmtlclxuICB9XG5cbiAgY3JlYXRlTm93TWFya2VyKCk6IERhdGVNYXJrZXIge1xuICAgIGlmICh0aGlzLmNhbkNvbXB1dGVPZmZzZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpbWVzdGFtcFRvTWFya2VyKG5ldyBEYXRlKCkudmFsdWVPZigpKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiB3ZSBjYW4ndCBjb21wdXRlIHRoZSBjdXJyZW50IGRhdGUgdmFsIGZvciBhIHRpbWV6b25lLFxuICAgICAgLy8gYmV0dGVyIHRvIGdpdmUgdGhlIGN1cnJlbnQgbG9jYWwgZGF0ZSB2YWxzIHRoYW4gVVRDXG4gICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoZGF0ZVRvTG9jYWxBcnJheShuZXcgRGF0ZSgpKSlcbiAgICB9XG4gIH1cblxuICBjcmVhdGVNYXJrZXJNZXRhKGlucHV0OiBEYXRlSW5wdXQpOiBEYXRlTWFya2VyTWV0YSB7XG5cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2UoaW5wdXQpXG4gICAgfVxuXG4gICAgbGV0IG1hcmtlciA9IG51bGxcblxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICBtYXJrZXIgPSB0aGlzLnRpbWVzdGFtcFRvTWFya2VyKGlucHV0KVxuXG4gICAgfSBlbHNlIGlmIChpbnB1dCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIGlucHV0ID0gaW5wdXQudmFsdWVPZigpXG5cbiAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgIG1hcmtlciA9IHRoaXMudGltZXN0YW1wVG9NYXJrZXIoaW5wdXQpXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICBtYXJrZXIgPSBhcnJheVRvVXRjRGF0ZShpbnB1dClcbiAgICB9XG5cbiAgICBpZiAobWFya2VyID09PSBudWxsIHx8ICFpc1ZhbGlkRGF0ZShtYXJrZXIpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiB7IG1hcmtlciwgaXNUaW1lVW5zcGVjaWZpZWQ6IGZhbHNlLCBmb3JjZWRUem86IG51bGwgfVxuICB9XG5cbiAgcGFyc2Uoczogc3RyaW5nKSB7XG4gICAgbGV0IHBhcnRzID0gcGFyc2UocylcbiAgICBpZiAocGFydHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgbGV0IG1hcmtlciA9IHBhcnRzLm1hcmtlclxuICAgIGxldCBmb3JjZWRUem8gPSBudWxsXG5cbiAgICBpZiAocGFydHMudGltZVpvbmVPZmZzZXQgIT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLmNhbkNvbXB1dGVPZmZzZXQpIHtcbiAgICAgICAgbWFya2VyID0gdGhpcy50aW1lc3RhbXBUb01hcmtlcihtYXJrZXIudmFsdWVPZigpIC0gcGFydHMudGltZVpvbmVPZmZzZXQgKiA2MCAqIDEwMDApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JjZWRUem8gPSBwYXJ0cy50aW1lWm9uZU9mZnNldFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IG1hcmtlciwgaXNUaW1lVW5zcGVjaWZpZWQ6IHBhcnRzLmlzVGltZVVuc3BlY2lmaWVkLCBmb3JjZWRUem8gfVxuICB9XG5cblxuICAvLyBBY2Nlc3NvcnNcblxuICBnZXRZZWFyKG1hcmtlcjogRGF0ZU1hcmtlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtYXJrZXIpXG4gIH1cblxuICBnZXRNb250aChtYXJrZXI6IERhdGVNYXJrZXIpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG1hcmtlcilcbiAgfVxuXG5cbiAgLy8gQWRkaW5nIC8gU3VidHJhY3RpbmdcblxuICBhZGQobWFya2VyOiBEYXRlTWFya2VyLCBkdXI6IER1cmF0aW9uKTogRGF0ZU1hcmtlciB7XG4gICAgbGV0IGEgPSB0aGlzLmNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkobWFya2VyKVxuICAgIGFbMF0gKz0gZHVyLnllYXJzXG4gICAgYVsxXSArPSBkdXIubW9udGhzXG4gICAgYVsyXSArPSBkdXIuZGF5c1xuICAgIGFbNl0gKz0gZHVyLm1pbGxpc2Vjb25kc1xuICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoYSlcbiAgfVxuXG4gIHN1YnRyYWN0KG1hcmtlcjogRGF0ZU1hcmtlciwgZHVyOiBEdXJhdGlvbik6IERhdGVNYXJrZXIge1xuICAgIGxldCBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcilcbiAgICBhWzBdIC09IGR1ci55ZWFyc1xuICAgIGFbMV0gLT0gZHVyLm1vbnRoc1xuICAgIGFbMl0gLT0gZHVyLmRheXNcbiAgICBhWzZdIC09IGR1ci5taWxsaXNlY29uZHNcbiAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKGEpXG4gIH1cblxuICBhZGRZZWFycyhtYXJrZXI6IERhdGVNYXJrZXIsIG46IG51bWJlcikge1xuICAgIGxldCBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcilcbiAgICBhWzBdICs9IG5cbiAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKGEpXG4gIH1cblxuICBhZGRNb250aHMobWFya2VyOiBEYXRlTWFya2VyLCBuOiBudW1iZXIpIHtcbiAgICBsZXQgYSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShtYXJrZXIpXG4gICAgYVsxXSArPSBuXG4gICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKVxuICB9XG5cblxuICAvLyBEaWZmaW5nIFdob2xlIFVuaXRzXG5cbiAgZGlmZldob2xlWWVhcnMobTA6IERhdGVNYXJrZXIsIG0xOiBEYXRlTWFya2VyKTogbnVtYmVyIHtcbiAgICBsZXQgeyBjYWxlbmRhclN5c3RlbSB9ID0gdGhpc1xuXG4gICAgaWYgKFxuICAgICAgdGltZUFzTXMobTApID09PSB0aW1lQXNNcyhtMSkgJiZcbiAgICAgIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlckRheShtMCkgPT09IGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlckRheShtMSkgJiZcbiAgICAgIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0wKSA9PT0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobTEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMSkgLSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0wKVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgZGlmZldob2xlTW9udGhzKG0wOiBEYXRlTWFya2VyLCBtMTogRGF0ZU1hcmtlcik6IG51bWJlciB7XG4gICAgbGV0IHsgY2FsZW5kYXJTeXN0ZW0gfSA9IHRoaXNcblxuICAgIGlmIChcbiAgICAgIHRpbWVBc01zKG0wKSA9PT0gdGltZUFzTXMobTEpICYmXG4gICAgICBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobTApID09PSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobTEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gKGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0xKSAtIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0wKSkgK1xuICAgICAgICAgIChjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0xKSAtIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobTApKSAqIDEyXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuXG4gIC8vIFJhbmdlIC8gRHVyYXRpb25cblxuICBncmVhdGVzdFdob2xlVW5pdChtMDogRGF0ZU1hcmtlciwgbTE6IERhdGVNYXJrZXIpIHtcbiAgICBsZXQgbiA9IHRoaXMuZGlmZldob2xlWWVhcnMobTAsIG0xKVxuXG4gICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IHVuaXQ6ICd5ZWFyJywgdmFsdWU6IG4gfVxuICAgIH1cblxuICAgIG4gPSB0aGlzLmRpZmZXaG9sZU1vbnRocyhtMCwgbTEpXG5cbiAgICBpZiAobiAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHsgdW5pdDogJ21vbnRoJywgdmFsdWU6IG4gfVxuICAgIH1cblxuICAgIG4gPSBkaWZmV2hvbGVXZWVrcyhtMCwgbTEpXG5cbiAgICBpZiAobiAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHsgdW5pdDogJ3dlZWsnLCB2YWx1ZTogbiB9XG4gICAgfVxuXG4gICAgbiA9IGRpZmZXaG9sZURheXMobTAsIG0xKVxuXG4gICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IHVuaXQ6ICdkYXknLCB2YWx1ZTogbiB9XG4gICAgfVxuXG4gICAgbiA9IGRpZmZIb3VycyhtMCwgbTEpXG5cbiAgICBpZiAoaXNJbnQobikpIHtcbiAgICAgIHJldHVybiB7IHVuaXQ6ICdob3VyJywgdmFsdWU6IG4gfVxuICAgIH1cblxuICAgIG4gPSBkaWZmTWludXRlcyhtMCwgbTEpXG5cbiAgICBpZiAoaXNJbnQobikpIHtcbiAgICAgIHJldHVybiB7IHVuaXQ6ICdtaW51dGUnLCB2YWx1ZTogbiB9XG4gICAgfVxuXG4gICAgbiA9IGRpZmZTZWNvbmRzKG0wLCBtMSlcblxuICAgIGlmIChpc0ludChuKSkge1xuICAgICAgcmV0dXJuIHsgdW5pdDogJ3NlY29uZCcsIHZhbHVlOiBuIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogbTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpIH1cbiAgfVxuXG4gIGNvdW50RHVyYXRpb25zQmV0d2VlbihtMDogRGF0ZU1hcmtlciwgbTE6IERhdGVNYXJrZXIsIGQ6IER1cmF0aW9uKSB7XG4gICAgLy8gVE9ETzogY2FuIHVzZSBncmVhdGVzdFdob2xlVW5pdFxuICAgIGxldCBkaWZmXG5cbiAgICBpZiAoZC55ZWFycykge1xuICAgICAgZGlmZiA9IHRoaXMuZGlmZldob2xlWWVhcnMobTAsIG0xKVxuICAgICAgaWYgKGRpZmYgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRpZmYgLyBhc1JvdWdoWWVhcnMoZClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZC5tb250aHMpIHtcbiAgICAgIGRpZmYgPSB0aGlzLmRpZmZXaG9sZU1vbnRocyhtMCwgbTEpXG4gICAgICBpZiAoZGlmZiAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hNb250aHMoZClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZC5kYXlzKSB7XG4gICAgICBkaWZmID0gZGlmZldob2xlRGF5cyhtMCwgbTEpXG4gICAgICBpZiAoZGlmZiAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hEYXlzKGQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkpIC8gYXNSb3VnaE1zKGQpXG4gIH1cblxuICAvLyBTdGFydC1PZlxuICAvLyB0aGVzZSBET04nVCByZXR1cm4gem9uZWQtZGF0ZXMuIG9ubHkgVVRDIHN0YXJ0LW9mIGRhdGVzXG5cbiAgc3RhcnRPZihtOiBEYXRlTWFya2VyLCB1bml0OiBzdHJpbmcpIHtcbiAgICBpZiAodW5pdCA9PT0gJ3llYXInKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGFydE9mWWVhcihtKVxuICAgIH0gZWxzZSBpZiAodW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZk1vbnRoKG0pXG4gICAgfSBlbHNlIGlmICh1bml0ID09PSAnd2VlaycpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2ZXZWVrKG0pXG4gICAgfSBlbHNlIGlmICh1bml0ID09PSAnZGF5Jykge1xuICAgICAgcmV0dXJuIHN0YXJ0T2ZEYXkobSlcbiAgICB9IGVsc2UgaWYgKHVuaXQgPT09ICdob3VyJykge1xuICAgICAgcmV0dXJuIHN0YXJ0T2ZIb3VyKG0pXG4gICAgfSBlbHNlIGlmICh1bml0ID09PSAnbWludXRlJykge1xuICAgICAgcmV0dXJuIHN0YXJ0T2ZNaW51dGUobSlcbiAgICB9IGVsc2UgaWYgKHVuaXQgPT09ICdzZWNvbmQnKSB7XG4gICAgICByZXR1cm4gc3RhcnRPZlNlY29uZChtKVxuICAgIH1cbiAgfVxuXG4gIHN0YXJ0T2ZZZWFyKG06IERhdGVNYXJrZXIpOiBEYXRlTWFya2VyIHtcbiAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKFtcbiAgICAgIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtKVxuICAgIF0pXG4gIH1cblxuICBzdGFydE9mTW9udGgobTogRGF0ZU1hcmtlcik6IERhdGVNYXJrZXIge1xuICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoW1xuICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0pLFxuICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtKVxuICAgIF0pXG4gIH1cblxuICBzdGFydE9mV2VlayhtOiBEYXRlTWFya2VyKTogRGF0ZU1hcmtlciB7XG4gICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihbXG4gICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobSksXG4gICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0pLFxuICAgICAgbS5nZXRVVENEYXRlKCkgLSAoKG0uZ2V0VVRDRGF5KCkgLSB0aGlzLndlZWtEb3cgKyA3KSAlIDcpXG4gICAgXSlcbiAgfVxuXG5cbiAgLy8gV2VlayBOdW1iZXJcblxuICBjb21wdXRlV2Vla051bWJlcihtYXJrZXI6IERhdGVNYXJrZXIpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLndlZWtOdW1iZXJGdW5jKSB7XG4gICAgICByZXR1cm4gdGhpcy53ZWVrTnVtYmVyRnVuYyh0aGlzLnRvRGF0ZShtYXJrZXIpKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd2Vla09mWWVhcihtYXJrZXIsIHRoaXMud2Vla0RvdywgdGhpcy53ZWVrRG95KVxuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IGNob2tlIG9uIHRpbWVab25lTmFtZTogbG9uZ1xuICBmb3JtYXQobWFya2VyOiBEYXRlTWFya2VyLCBmb3JtYXR0ZXI6IERhdGVGb3JtYXR0ZXIsIGRhdGVPcHRpb25zOiB7IGZvcmNlZFR6bz86IG51bWJlciB9ID0ge30pIHtcbiAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdChcbiAgICAgIHtcbiAgICAgICAgbWFya2VyOiBtYXJrZXIsXG4gICAgICAgIHRpbWVab25lT2Zmc2V0OiBkYXRlT3B0aW9ucy5mb3JjZWRUem8gIT0gbnVsbCA/XG4gICAgICAgICAgZGF0ZU9wdGlvbnMuZm9yY2VkVHpvIDpcbiAgICAgICAgICB0aGlzLm9mZnNldEZvck1hcmtlcihtYXJrZXIpXG4gICAgICB9LFxuICAgICAgdGhpc1xuICAgIClcbiAgfVxuXG4gIGZvcm1hdFJhbmdlKFxuICAgIHN0YXJ0OiBEYXRlTWFya2VyLFxuICAgIGVuZDogRGF0ZU1hcmtlcixcbiAgICBmb3JtYXR0ZXI6IERhdGVGb3JtYXR0ZXIsXG4gICAgZGF0ZU9wdGlvbnM6IHsgZm9yY2VkU3RhcnRUem8/OiBudW1iZXIsIGZvcmNlZEVuZFR6bz86IG51bWJlciwgaXNFbmRFeGNsdXNpdmU/OiBib29sZWFuIH0gPSB7fVxuICApIHtcblxuICAgIGlmIChkYXRlT3B0aW9ucy5pc0VuZEV4Y2x1c2l2ZSkge1xuICAgICAgZW5kID0gYWRkTXMoZW5kLCAtMSlcbiAgICB9XG5cbiAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdFJhbmdlKFxuICAgICAge1xuICAgICAgICBtYXJrZXI6IHN0YXJ0LFxuICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZU9wdGlvbnMuZm9yY2VkU3RhcnRUem8gIT0gbnVsbCA/XG4gICAgICAgICAgZGF0ZU9wdGlvbnMuZm9yY2VkU3RhcnRUem8gOlxuICAgICAgICAgIHRoaXMub2Zmc2V0Rm9yTWFya2VyKHN0YXJ0KVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbWFya2VyOiBlbmQsXG4gICAgICAgIHRpbWVab25lT2Zmc2V0OiBkYXRlT3B0aW9ucy5mb3JjZWRFbmRUem8gIT0gbnVsbCA/XG4gICAgICAgICAgZGF0ZU9wdGlvbnMuZm9yY2VkRW5kVHpvIDpcbiAgICAgICAgICB0aGlzLm9mZnNldEZvck1hcmtlcihlbmQpXG4gICAgICB9LFxuICAgICAgdGhpc1xuICAgIClcbiAgfVxuXG4gIC8qXG4gIERVTUI6IHRoZSBvbWl0VGltZSBhcmcgaXMgZHVtYi4gaWYgd2Ugb21pdCB0aGUgdGltZSwgd2Ugd2FudCB0byBvbWl0IHRoZSB0aW1lem9uZSBvZmZzZXQuIGFuZCBpZiB3ZSBkbyB0aGF0LFxuICBtaWdodCBhcyB3ZWxsIHVzZSBidWlsZElzb1N0cmluZyBvciBzb21lIG90aGVyIHV0aWwgZGlyZWN0bHlcbiAgKi9cbiAgZm9ybWF0SXNvKG1hcmtlcjogRGF0ZU1hcmtlciwgZXh0cmFPcHRpb25zOiBhbnkgPSB7fSkge1xuICAgIGxldCB0aW1lWm9uZU9mZnNldCA9IG51bGxcblxuICAgIGlmICghZXh0cmFPcHRpb25zLm9taXRUaW1lWm9uZU9mZnNldCkge1xuICAgICAgaWYgKGV4dHJhT3B0aW9ucy5mb3JjZWRUem8gIT0gbnVsbCkge1xuICAgICAgICB0aW1lWm9uZU9mZnNldCA9IGV4dHJhT3B0aW9ucy5mb3JjZWRUem9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVab25lT2Zmc2V0ID0gdGhpcy5vZmZzZXRGb3JNYXJrZXIobWFya2VyKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBidWlsZElzb1N0cmluZyhtYXJrZXIsIHRpbWVab25lT2Zmc2V0LCBleHRyYU9wdGlvbnMub21pdFRpbWUpXG4gIH1cblxuXG4gIC8vIFRpbWVab25lXG5cbiAgdGltZXN0YW1wVG9NYXJrZXIobXM6IG51bWJlcikge1xuICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnbG9jYWwnKSB7XG4gICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoZGF0ZVRvTG9jYWxBcnJheShuZXcgRGF0ZShtcykpKVxuICAgIH0gZWxzZSBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ1VUQycgfHwgIXRoaXMubmFtZWRUaW1lWm9uZUltcGwpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShtcylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKHRoaXMubmFtZWRUaW1lWm9uZUltcGwudGltZXN0YW1wVG9BcnJheShtcykpXG4gICAgfVxuICB9XG5cbiAgb2Zmc2V0Rm9yTWFya2VyKG06IERhdGVNYXJrZXIpIHtcbiAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ2xvY2FsJykge1xuICAgICAgcmV0dXJuIC1hcnJheVRvTG9jYWxEYXRlKGRhdGVUb1V0Y0FycmF5KG0pKS5nZXRUaW1lem9uZU9mZnNldCgpIC8vIGNvbnZlcnQgXCJpbnZlcnNlXCIgb2Zmc2V0IHRvIFwibm9ybWFsXCIgb2Zmc2V0XG4gICAgfSBlbHNlIGlmICh0aGlzLnRpbWVab25lID09PSAnVVRDJykge1xuICAgICAgcmV0dXJuIDBcbiAgICB9IGVsc2UgaWYgKHRoaXMubmFtZWRUaW1lWm9uZUltcGwpIHtcbiAgICAgIHJldHVybiB0aGlzLm5hbWVkVGltZVpvbmVJbXBsLm9mZnNldEZvckFycmF5KGRhdGVUb1V0Y0FycmF5KG0pKVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cblxuICAvLyBDb252ZXJzaW9uXG5cbiAgdG9EYXRlKG06IERhdGVNYXJrZXIsIGZvcmNlZFR6bz86IG51bWJlcik6IERhdGUge1xuICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnbG9jYWwnKSB7XG4gICAgICByZXR1cm4gYXJyYXlUb0xvY2FsRGF0ZShkYXRlVG9VdGNBcnJheShtKSlcbiAgICB9IGVsc2UgaWYgKHRoaXMudGltZVpvbmUgPT09ICdVVEMnKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUobS52YWx1ZU9mKCkpIC8vIG1ha2Ugc3VyZSBpdCdzIGEgY29weVxuICAgIH0gZWxzZSBpZiAoIXRoaXMubmFtZWRUaW1lWm9uZUltcGwpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShtLnZhbHVlT2YoKSAtIChmb3JjZWRUem8gfHwgMCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShcbiAgICAgICAgbS52YWx1ZU9mKCkgLVxuICAgICAgICB0aGlzLm5hbWVkVGltZVpvbmVJbXBsLm9mZnNldEZvckFycmF5KGRhdGVUb1V0Y0FycmF5KG0pKSAqIDEwMDAgKiA2MCAvLyBjb252ZXJ0IG1pbnV0ZXMgLT4gbXNcbiAgICAgIClcbiAgICB9XG4gIH1cblxufVxuIiwiaW1wb3J0IHsgTG9jYWxlSW5wdXQgfSBmcm9tICcuL2RhdGVsaWIvbG9jYWxlJ1xuXG5leHBvcnQgY29uc3QgZ2xvYmFsTG9jYWxlczogTG9jYWxlSW5wdXRbXSA9IFtdXG4iLCJpbXBvcnQgeyBtZXJnZVByb3BzIH0gZnJvbSAnLi4vdXRpbC9vYmplY3QnXG5pbXBvcnQgeyBnbG9iYWxMb2NhbGVzIH0gZnJvbSAnLi4vZ2xvYmFsLWxvY2FsZXMnIC8vIHdlaXJkIHRvIGJlIGltcG9ydGluZyB0aGlzXG5pbXBvcnQgeyBDYWxlbmRhck9wdGlvbnMsIENhbGVuZGFyT3B0aW9uc1JlZmluZWQgfSBmcm9tICcuLi9vcHRpb25zJ1xuXG5leHBvcnQgdHlwZSBMb2NhbGVDb2RlQXJnID0gc3RyaW5nIHwgc3RyaW5nW11cbmV4cG9ydCB0eXBlIExvY2FsZVNpbmd1bGFyQXJnID0gTG9jYWxlQ29kZUFyZyB8IExvY2FsZUlucHV0XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9jYWxlIHtcbiAgY29kZUFyZzogTG9jYWxlQ29kZUFyZ1xuICBjb2Rlczogc3RyaW5nW11cbiAgd2VlazogeyBkb3c6IG51bWJlciwgZG95OiBudW1iZXIgfVxuICBzaW1wbGVOdW1iZXJGb3JtYXQ6IEludGwuTnVtYmVyRm9ybWF0XG4gIG9wdGlvbnM6IENhbGVuZGFyT3B0aW9uc1JlZmluZWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2NhbGVJbnB1dCBleHRlbmRzIENhbGVuZGFyT3B0aW9ucyB7XG4gIGNvZGU6IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBMb2NhbGVJbnB1dE1hcCA9IHsgW2NvZGU6IHN0cmluZ106IExvY2FsZUlucHV0IH1cblxuZXhwb3J0IGludGVyZmFjZSBSYXdMb2NhbGVJbmZvIHtcbiAgbWFwOiBMb2NhbGVJbnB1dE1hcFxuICBkZWZhdWx0Q29kZTogc3RyaW5nXG59XG5cbmNvbnN0IFJBV19FTl9MT0NBTEUgPSB7XG4gIGNvZGU6ICdlbicsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrXG4gICAgZG95OiA0IC8vIDQgZGF5cyBuZWVkIHRvIGJlIHdpdGhpbiB0aGUgeWVhciB0byBiZSBjb25zaWRlcmVkIHRoZSBmaXJzdCB3ZWVrXG4gIH0sXG4gIGRpcmVjdGlvbjogJ2x0cicgYXMgKCdsdHInIHwgJ3J0bCcpLCAvLyBUT0RPOiBtYWtlIGEgcmVhbCB0eXBlIGZvciB0aGlzXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAncHJldicsXG4gICAgbmV4dDogJ25leHQnLFxuICAgIHByZXZZZWFyOiAncHJldiB5ZWFyJyxcbiAgICBuZXh0WWVhcjogJ25leHQgeWVhcicsXG4gICAgeWVhcjogJ3llYXInLFxuICAgIHRvZGF5OiAndG9kYXknLFxuICAgIG1vbnRoOiAnbW9udGgnLFxuICAgIHdlZWs6ICd3ZWVrJyxcbiAgICBkYXk6ICdkYXknLFxuICAgIGxpc3Q6ICdsaXN0J1xuICB9LFxuICB3ZWVrVGV4dDogJ1cnLFxuICBhbGxEYXlUZXh0OiAnYWxsLWRheScsXG4gIG1vcmVMaW5rVGV4dDogJ21vcmUnLFxuICBub0V2ZW50c1RleHQ6ICdObyBldmVudHMgdG8gZGlzcGxheSdcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gb3JnYW5pemVSYXdMb2NhbGVzKGV4cGxpY2l0UmF3TG9jYWxlczogTG9jYWxlSW5wdXRbXSk6IFJhd0xvY2FsZUluZm8ge1xuICBsZXQgZGVmYXVsdENvZGUgPSBleHBsaWNpdFJhd0xvY2FsZXMubGVuZ3RoID4gMCA/IGV4cGxpY2l0UmF3TG9jYWxlc1swXS5jb2RlIDogJ2VuJ1xuICBsZXQgYWxsUmF3TG9jYWxlcyA9IGdsb2JhbExvY2FsZXMuY29uY2F0KGV4cGxpY2l0UmF3TG9jYWxlcylcbiAgbGV0IHJhd0xvY2FsZU1hcDogTG9jYWxlSW5wdXRNYXAgPSB7XG4gICAgZW46IFJBV19FTl9MT0NBTEUgLy8gbmVjZXNzYXJ5P1xuICB9XG5cbiAgZm9yIChsZXQgcmF3TG9jYWxlIG9mIGFsbFJhd0xvY2FsZXMpIHtcbiAgICByYXdMb2NhbGVNYXBbcmF3TG9jYWxlLmNvZGVdID0gcmF3TG9jYWxlXG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1hcDogcmF3TG9jYWxlTWFwLFxuICAgIGRlZmF1bHRDb2RlXG4gIH1cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRMb2NhbGUoaW5wdXRTaW5ndWxhcjogTG9jYWxlU2luZ3VsYXJBcmcsIGF2YWlsYWJsZTogTG9jYWxlSW5wdXRNYXApIHtcbiAgaWYgKHR5cGVvZiBpbnB1dFNpbmd1bGFyID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpbnB1dFNpbmd1bGFyKSkge1xuICAgIHJldHVybiBwYXJzZUxvY2FsZShcbiAgICAgIGlucHV0U2luZ3VsYXIuY29kZSxcbiAgICAgIFsgaW5wdXRTaW5ndWxhci5jb2RlIF0sXG4gICAgICBpbnB1dFNpbmd1bGFyXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBxdWVyeUxvY2FsZShpbnB1dFNpbmd1bGFyLCBhdmFpbGFibGUpXG4gIH1cbn1cblxuXG5mdW5jdGlvbiBxdWVyeUxvY2FsZShjb2RlQXJnOiBMb2NhbGVDb2RlQXJnLCBhdmFpbGFibGU6IExvY2FsZUlucHV0TWFwKTogTG9jYWxlIHtcbiAgbGV0IGNvZGVzID0gW10uY29uY2F0KGNvZGVBcmcgfHwgW10pIC8vIHdpbGwgY29udmVydCB0byBhcnJheVxuICBsZXQgcmF3ID0gcXVlcnlSYXdMb2NhbGUoY29kZXMsIGF2YWlsYWJsZSkgfHwgUkFXX0VOX0xPQ0FMRVxuXG4gIHJldHVybiBwYXJzZUxvY2FsZShjb2RlQXJnLCBjb2RlcywgcmF3KVxufVxuXG5cbmZ1bmN0aW9uIHF1ZXJ5UmF3TG9jYWxlKGNvZGVzOiBzdHJpbmdbXSwgYXZhaWxhYmxlOiBMb2NhbGVJbnB1dE1hcCk6IExvY2FsZUlucHV0IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBwYXJ0cyA9IGNvZGVzW2ldLnRvTG9jYWxlTG93ZXJDYXNlKCkuc3BsaXQoJy0nKVxuXG4gICAgZm9yIChsZXQgaiA9IHBhcnRzLmxlbmd0aDsgaiA+IDA7IGotLSkge1xuICAgICAgbGV0IHNpbXBsZUlkID0gcGFydHMuc2xpY2UoMCwgaikuam9pbignLScpXG5cbiAgICAgIGlmIChhdmFpbGFibGVbc2ltcGxlSWRdKSB7XG4gICAgICAgIHJldHVybiBhdmFpbGFibGVbc2ltcGxlSWRdXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cblxuZnVuY3Rpb24gcGFyc2VMb2NhbGUoY29kZUFyZzogTG9jYWxlQ29kZUFyZywgY29kZXM6IHN0cmluZ1tdLCByYXc6IExvY2FsZUlucHV0KTogTG9jYWxlIHtcbiAgbGV0IG1lcmdlZCA9IG1lcmdlUHJvcHMoWyBSQVdfRU5fTE9DQUxFLCByYXcgXSwgWyAnYnV0dG9uVGV4dCcgXSlcblxuICBkZWxldGUgbWVyZ2VkLmNvZGUgLy8gZG9uJ3Qgd2FudCB0aGlzIHBhcnQgb2YgdGhlIG9wdGlvbnNcbiAgbGV0IHdlZWsgPSBtZXJnZWQud2Vla1xuICBkZWxldGUgbWVyZ2VkLndlZWtcblxuICByZXR1cm4ge1xuICAgIGNvZGVBcmcsXG4gICAgY29kZXMsXG4gICAgd2VlayxcbiAgICBzaW1wbGVOdW1iZXJGb3JtYXQ6IG5ldyBJbnRsLk51bWJlckZvcm1hdChjb2RlQXJnKSxcbiAgICBvcHRpb25zOiBtZXJnZWRcbiAgfVxufVxuIiwiaW1wb3J0IHsgRGF0ZUVudiB9IGZyb20gJy4vZGF0ZWxpYi9lbnYnXG5pbXBvcnQgeyBjcmVhdGVGb3JtYXR0ZXIgfSBmcm9tICcuL2RhdGVsaWIvZm9ybWF0dGluZydcbmltcG9ydCB7IG9yZ2FuaXplUmF3TG9jYWxlcywgYnVpbGRMb2NhbGUgfSBmcm9tICcuL2RhdGVsaWIvbG9jYWxlJ1xuaW1wb3J0IHsgQkFTRV9PUFRJT05fREVGQVVMVFMgfSBmcm9tICcuL29wdGlvbnMnXG5cbi8vIHB1YmxpY1xuaW1wb3J0IHtcbiAgRGF0ZUlucHV0XG59IGZyb20gJy4vYXBpLXR5cGUtZGVwcydcblxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlSW5wdXQ6IERhdGVJbnB1dCwgc2V0dGluZ3MgPSB7fSkge1xuICBsZXQgZGF0ZUVudiA9IGJ1aWxkRGF0ZUVudihzZXR0aW5ncylcbiAgbGV0IGZvcm1hdHRlciA9IGNyZWF0ZUZvcm1hdHRlcihzZXR0aW5ncylcbiAgbGV0IGRhdGVNZXRhID0gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKGRhdGVJbnB1dClcblxuICBpZiAoIWRhdGVNZXRhKSB7IC8vIFRPRE86IHdhcm5pbmc/XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoZGF0ZU1ldGEubWFya2VyLCBmb3JtYXR0ZXIsIHtcbiAgICBmb3JjZWRUem86IGRhdGVNZXRhLmZvcmNlZFR6b1xuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0UmFuZ2UoXG4gIHN0YXJ0SW5wdXQ6IERhdGVJbnB1dCxcbiAgZW5kSW5wdXQ6IERhdGVJbnB1dCxcbiAgc2V0dGluZ3MgLy8gbWl4dHVyZSBvZiBlbnYgYW5kIGZvcm1hdHRlciBzZXR0aW5nc1xuKSB7XG4gIGxldCBkYXRlRW52ID0gYnVpbGREYXRlRW52KHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcgJiYgc2V0dGluZ3MgPyBzZXR0aW5ncyA6IHt9KSAvLyBwYXNzIGluIGlmIG5vbi1udWxsIG9iamVjdFxuICBsZXQgZm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyKHNldHRpbmdzLCBCQVNFX09QVElPTl9ERUZBVUxUUy5kZWZhdWx0UmFuZ2VTZXBhcmF0b3IpXG4gIGxldCBzdGFydE1ldGEgPSBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoc3RhcnRJbnB1dClcbiAgbGV0IGVuZE1ldGEgPSBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoZW5kSW5wdXQpXG5cbiAgaWYgKCFzdGFydE1ldGEgfHwgIWVuZE1ldGEpIHsgLy8gVE9ETzogd2FybmluZz9cbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKHN0YXJ0TWV0YS5tYXJrZXIsIGVuZE1ldGEubWFya2VyLCBmb3JtYXR0ZXIsIHtcbiAgICBmb3JjZWRTdGFydFR6bzogc3RhcnRNZXRhLmZvcmNlZFR6byxcbiAgICBmb3JjZWRFbmRUem86IGVuZE1ldGEuZm9yY2VkVHpvLFxuICAgIGlzRW5kRXhjbHVzaXZlOiBzZXR0aW5ncy5pc0VuZEV4Y2x1c2l2ZVxuICB9KVxufVxuXG4vLyBUT0RPOiBtb3JlIERSWSBhbmQgb3B0aW1pemVkXG5mdW5jdGlvbiBidWlsZERhdGVFbnYoc2V0dGluZ3MpIHtcbiAgbGV0IGxvY2FsZSA9IGJ1aWxkTG9jYWxlKHNldHRpbmdzLmxvY2FsZSB8fCAnZW4nLCBvcmdhbml6ZVJhd0xvY2FsZXMoW10pLm1hcCkgLy8gVE9ETzogZG9uJ3QgaGFyZGNvZGUgJ2VuJyBldmVyeXdoZXJlXG5cbiAgLy8gZW5zdXJlIHJlcXVpcmVkIHNldHRpbmdzXG4gIHNldHRpbmdzID0ge1xuICAgIHRpbWVab25lOiBCQVNFX09QVElPTl9ERUZBVUxUUy50aW1lWm9uZSxcbiAgICBjYWxlbmRhclN5c3RlbTogJ2dyZWdvcnknLFxuICAgIC4uLnNldHRpbmdzLFxuICAgIGxvY2FsZVxuICB9XG5cbiAgcmV0dXJuIG5ldyBEYXRlRW52KHNldHRpbmdzKVxufVxuIiwiaW1wb3J0IHsgRXZlbnRJbnB1dCB9IGZyb20gJy4vZXZlbnQtcGFyc2UnXG5pbXBvcnQgeyBFdmVudFN0b3JlLCBwYXJzZUV2ZW50cyB9IGZyb20gJy4vZXZlbnQtc3RvcmUnXG5pbXBvcnQgeyBDYWxlbmRhckNvbnRleHQgfSBmcm9tICcuLi9DYWxlbmRhckNvbnRleHQnXG5cbi8qXG5VdGlscyBmb3IgY29udmVydGluZyByYXcgYnVzaW5lc3MgaG91ciBpbnB1dCBpbnRvIGFuIEV2ZW50U3RvcmUsXG5mb3IgYm90aCByZW5kZXJpbmcgYW5kIHRoZSBjb25zdHJhaW50IHN5c3RlbS5cbiovXG5cbmV4cG9ydCB0eXBlIEJ1c2luZXNzSG91cnNJbnB1dCA9IGJvb2xlYW4gfCBFdmVudElucHV0IHwgRXZlbnRJbnB1dFtdXG5cbmNvbnN0IERFRl9ERUZBVUxUUyA9IHtcbiAgc3RhcnRUaW1lOiAnMDk6MDAnLFxuICBlbmRUaW1lOiAnMTc6MDAnLFxuICBkYXlzT2ZXZWVrOiBbIDEsIDIsIDMsIDQsIDUgXSwgLy8gbW9uZGF5IC0gZnJpZGF5XG4gIGRpc3BsYXk6ICdpbnZlcnNlLWJhY2tncm91bmQnLFxuICBjbGFzc05hbWVzOiAnZmMtbm9uLWJ1c2luZXNzJyxcbiAgZ3JvdXBJZDogJ19idXNpbmVzc0hvdXJzJyAvLyBzbyBtdWx0aXBsZSBkZWZzIGdldCBncm91cGVkXG59XG5cbi8qXG5UT0RPOiBwYXNzIGFyb3VuZCBhcyBFdmVudERlZkhhc2ghISFcbiovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VCdXNpbmVzc0hvdXJzKGlucHV0OiBCdXNpbmVzc0hvdXJzSW5wdXQsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCk6IEV2ZW50U3RvcmUge1xuICByZXR1cm4gcGFyc2VFdmVudHMoXG4gICAgcmVmaW5lSW5wdXRzKGlucHV0KSxcbiAgICBudWxsLFxuICAgIGNvbnRleHRcbiAgKVxufVxuXG5mdW5jdGlvbiByZWZpbmVJbnB1dHMoaW5wdXQ6IEJ1c2luZXNzSG91cnNJbnB1dCkge1xuICBsZXQgcmF3RGVmc1xuXG4gIGlmIChpbnB1dCA9PT0gdHJ1ZSkge1xuICAgIHJhd0RlZnMgPSBbIHt9IF0gLy8gd2lsbCBnZXQgREVGX0RFRkFVTFRTIHZlcmJhdGltXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAvLyBpZiBzcGVjaWZ5aW5nIGFuIGFycmF5LCBldmVyeSBzdWItZGVmaW5pdGlvbiBORUVEUyBhIGRheS1vZi13ZWVrXG4gICAgcmF3RGVmcyA9IGlucHV0LmZpbHRlcihmdW5jdGlvbihyYXdEZWYpIHtcbiAgICAgIHJldHVybiByYXdEZWYuZGF5c09mV2Vla1xuICAgIH0pXG4gIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICByYXdEZWZzID0gWyBpbnB1dCBdXG4gIH0gZWxzZSB7IC8vIGlzIHByb2JhYmx5IGZhbHNlXG4gICAgcmF3RGVmcyA9IFtdXG4gIH1cblxuICByYXdEZWZzID0gcmF3RGVmcy5tYXAoZnVuY3Rpb24ocmF3RGVmKSB7XG4gICAgcmV0dXJuIHsgLi4uREVGX0RFRkFVTFRTLCAuLi5yYXdEZWYgfVxuICB9KVxuXG4gIHJldHVybiByYXdEZWZzXG59XG4iLCJcbmV4cG9ydCBpbnRlcmZhY2UgUG9pbnQge1xuICBsZWZ0OiBudW1iZXJcbiAgdG9wOiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWN0IHtcbiAgbGVmdDogbnVtYmVyXG4gIHJpZ2h0OiBudW1iZXJcbiAgdG9wOiBudW1iZXJcbiAgYm90dG9tOiBudW1iZXJcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRJbnNpZGVSZWN0KHBvaW50OiBQb2ludCwgcmVjdDogUmVjdCk6IGJvb2xlYW4ge1xuICByZXR1cm4gcG9pbnQubGVmdCA+PSByZWN0LmxlZnQgJiZcbiAgICBwb2ludC5sZWZ0IDwgcmVjdC5yaWdodCAmJlxuICAgIHBvaW50LnRvcCA+PSByZWN0LnRvcCAmJlxuICAgIHBvaW50LnRvcCA8IHJlY3QuYm90dG9tXG59XG5cblxuLy8gUmV0dXJucyBhIG5ldyByZWN0YW5nbGUgdGhhdCBpcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gcmVjdGFuZ2xlcy4gSWYgdGhleSBkb24ndCBpbnRlcnNlY3QsIHJldHVybnMgZmFsc2VcbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3RSZWN0cyhyZWN0MTogUmVjdCwgcmVjdDI6IFJlY3QpOiBSZWN0IHwgZmFsc2Uge1xuICBsZXQgcmVzID0ge1xuICAgIGxlZnQ6IE1hdGgubWF4KHJlY3QxLmxlZnQsIHJlY3QyLmxlZnQpLFxuICAgIHJpZ2h0OiBNYXRoLm1pbihyZWN0MS5yaWdodCwgcmVjdDIucmlnaHQpLFxuICAgIHRvcDogTWF0aC5tYXgocmVjdDEudG9wLCByZWN0Mi50b3ApLFxuICAgIGJvdHRvbTogTWF0aC5taW4ocmVjdDEuYm90dG9tLCByZWN0Mi5ib3R0b20pXG4gIH1cblxuICBpZiAocmVzLmxlZnQgPCByZXMucmlnaHQgJiYgcmVzLnRvcCA8IHJlcy5ib3R0b20pIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlUmVjdChyZWN0OiBSZWN0LCBkZWx0YVg6IG51bWJlciwgZGVsdGFZOiBudW1iZXIpOiBSZWN0IHtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiByZWN0LmxlZnQgKyBkZWx0YVgsXG4gICAgcmlnaHQ6IHJlY3QucmlnaHQgKyBkZWx0YVgsXG4gICAgdG9wOiByZWN0LnRvcCArIGRlbHRhWSxcbiAgICBib3R0b206IHJlY3QuYm90dG9tICsgZGVsdGFZXG4gIH1cbn1cblxuXG4vLyBSZXR1cm5zIGEgbmV3IHBvaW50IHRoYXQgd2lsbCBoYXZlIGJlZW4gbW92ZWQgdG8gcmVzaWRlIHdpdGhpbiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlXG5leHBvcnQgZnVuY3Rpb24gY29uc3RyYWluUG9pbnQocG9pbnQ6IFBvaW50LCByZWN0OiBSZWN0KTogUG9pbnQge1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IE1hdGgubWluKE1hdGgubWF4KHBvaW50LmxlZnQsIHJlY3QubGVmdCksIHJlY3QucmlnaHQpLFxuICAgIHRvcDogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQudG9wLCByZWN0LnRvcCksIHJlY3QuYm90dG9tKVxuICB9XG59XG5cblxuLy8gUmV0dXJucyBhIHBvaW50IHRoYXQgaXMgdGhlIGNlbnRlciBvZiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVjdENlbnRlcihyZWN0OiBSZWN0KTogUG9pbnQge1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIsXG4gICAgdG9wOiAocmVjdC50b3AgKyByZWN0LmJvdHRvbSkgLyAyXG4gIH1cbn1cblxuXG4vLyBTdWJ0cmFjdHMgcG9pbnQyJ3MgY29vcmRpbmF0ZXMgZnJvbSBwb2ludDEncyBjb29yZGluYXRlcywgcmV0dXJuaW5nIGEgZGVsdGFcbmV4cG9ydCBmdW5jdGlvbiBkaWZmUG9pbnRzKHBvaW50MTogUG9pbnQsIHBvaW50MjogUG9pbnQpOiBQb2ludCB7XG4gIHJldHVybiB7XG4gICAgbGVmdDogcG9pbnQxLmxlZnQgLSBwb2ludDIubGVmdCxcbiAgICB0b3A6IHBvaW50MS50b3AgLSBwb2ludDIudG9wXG4gIH1cbn1cbiIsImltcG9ydCB7IEV2ZW50U3RvcmUsIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSB9IGZyb20gJy4uL3N0cnVjdHMvZXZlbnQtc3RvcmUnXG5pbXBvcnQgeyBFdmVudERlZiB9IGZyb20gJy4uL3N0cnVjdHMvZXZlbnQtZGVmJ1xuaW1wb3J0IHsgRXZlbnRJbnRlcmFjdGlvblN0YXRlIH0gZnJvbSAnLi4vaW50ZXJhY3Rpb25zL2V2ZW50LWludGVyYWN0aW9uLXN0YXRlJ1xuaW1wb3J0IHsgbWFwSGFzaCB9IGZyb20gJy4uL3V0aWwvb2JqZWN0J1xuaW1wb3J0IHsgbWVtb2l6ZSB9IGZyb20gJy4uL3V0aWwvbWVtb2l6ZSdcbmltcG9ydCB7IEV2ZW50VWlIYXNoLCBFdmVudFVpLCBjb21iaW5lRXZlbnRVaXMgfSBmcm9tICcuL2V2ZW50LXVpJ1xuaW1wb3J0IHsgRGF0ZVNwYW4gfSBmcm9tICcuLi9zdHJ1Y3RzL2RhdGUtc3BhbidcbmltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSAndHNsaWInXG5cbmV4cG9ydCBpbnRlcmZhY2UgU3BsaXR0YWJsZVByb3BzIHtcbiAgYnVzaW5lc3NIb3VyczogRXZlbnRTdG9yZSB8IG51bGwgLy8gaXMgdGhpcyByZWFsbHkgYWxsb3dlZCB0byBiZSBudWxsP1xuICBkYXRlU2VsZWN0aW9uOiBEYXRlU3BhbiB8IG51bGxcbiAgZXZlbnRTdG9yZTogRXZlbnRTdG9yZVxuICBldmVudFVpQmFzZXM6IEV2ZW50VWlIYXNoXG4gIGV2ZW50U2VsZWN0aW9uOiBzdHJpbmdcbiAgZXZlbnREcmFnOiBFdmVudEludGVyYWN0aW9uU3RhdGUgfCBudWxsXG4gIGV2ZW50UmVzaXplOiBFdmVudEludGVyYWN0aW9uU3RhdGUgfCBudWxsXG59XG5cbmNvbnN0IEVNUFRZX0VWRU5UX1NUT1JFID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCkgLy8gZm9yIHB1cmVjb21wb25lbnRzLiBUT0RPOiBrZWVwIGVsc2V3aGVyZVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU3BsaXR0ZXI8UHJvcHNUeXBlIGV4dGVuZHMgU3BsaXR0YWJsZVByb3BzID0gU3BsaXR0YWJsZVByb3BzPiB7XG5cbiAgcHJpdmF0ZSBnZXRLZXlzRm9yRXZlbnREZWZzID0gbWVtb2l6ZSh0aGlzLl9nZXRLZXlzRm9yRXZlbnREZWZzKVxuICBwcml2YXRlIHNwbGl0RGF0ZVNlbGVjdGlvbiA9IG1lbW9pemUodGhpcy5fc3BsaXREYXRlU3BhbilcbiAgcHJpdmF0ZSBzcGxpdEV2ZW50U3RvcmUgPSBtZW1vaXplKHRoaXMuX3NwbGl0RXZlbnRTdG9yZSlcbiAgcHJpdmF0ZSBzcGxpdEluZGl2aWR1YWxVaSA9IG1lbW9pemUodGhpcy5fc3BsaXRJbmRpdmlkdWFsVWkpXG4gIHByaXZhdGUgc3BsaXRFdmVudERyYWcgPSBtZW1vaXplKHRoaXMuX3NwbGl0SW50ZXJhY3Rpb24pXG4gIHByaXZhdGUgc3BsaXRFdmVudFJlc2l6ZSA9IG1lbW9pemUodGhpcy5fc3BsaXRJbnRlcmFjdGlvbilcbiAgcHJpdmF0ZSBldmVudFVpQnVpbGRlcnMgPSB7fSAvLyBUT0RPOiB0eXBlc2NyaXB0IHByb3RlY3Rpb25cblxuICBhYnN0cmFjdCBnZXRLZXlJbmZvKHByb3BzOiBQcm9wc1R5cGUpOiB7IFtrZXk6IHN0cmluZ106IHsgdWk/OiBFdmVudFVpLCBidXNpbmVzc0hvdXJzPzogRXZlbnRTdG9yZSB9IH1cbiAgYWJzdHJhY3QgZ2V0S2V5c0ZvckRhdGVTcGFuKGRhdGVTcGFuOiBEYXRlU3Bhbik6IHN0cmluZ1tdXG4gIGFic3RyYWN0IGdldEtleXNGb3JFdmVudERlZihldmVudERlZjogRXZlbnREZWYpOiBzdHJpbmdbXVxuXG4gIHNwbGl0UHJvcHMocHJvcHM6IFByb3BzVHlwZSk6IHsgW2tleTogc3RyaW5nXTogU3BsaXR0YWJsZVByb3BzIH0ge1xuXG4gICAgbGV0IGtleUluZm9zID0gdGhpcy5nZXRLZXlJbmZvKHByb3BzKVxuICAgIGxldCBkZWZLZXlzID0gdGhpcy5nZXRLZXlzRm9yRXZlbnREZWZzKHByb3BzLmV2ZW50U3RvcmUpXG4gICAgbGV0IGRhdGVTZWxlY3Rpb25zID0gdGhpcy5zcGxpdERhdGVTZWxlY3Rpb24ocHJvcHMuZGF0ZVNlbGVjdGlvbilcbiAgICBsZXQgaW5kaXZpZHVhbFVpID0gdGhpcy5zcGxpdEluZGl2aWR1YWxVaShwcm9wcy5ldmVudFVpQmFzZXMsIGRlZktleXMpIC8vIHRoZSBpbmRpdmlkdWFsICpiYXNlcypcbiAgICBsZXQgZXZlbnRTdG9yZXMgPSB0aGlzLnNwbGl0RXZlbnRTdG9yZShwcm9wcy5ldmVudFN0b3JlLCBkZWZLZXlzKVxuICAgIGxldCBldmVudERyYWdzID0gdGhpcy5zcGxpdEV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcpXG4gICAgbGV0IGV2ZW50UmVzaXplcyA9IHRoaXMuc3BsaXRFdmVudFJlc2l6ZShwcm9wcy5ldmVudFJlc2l6ZSlcbiAgICBsZXQgc3BsaXRQcm9wczogeyBba2V5OiBzdHJpbmddOiBTcGxpdHRhYmxlUHJvcHMgfSA9IHt9XG5cbiAgICB0aGlzLmV2ZW50VWlCdWlsZGVycyA9IG1hcEhhc2goa2V5SW5mb3MsIChpbmZvLCBrZXkpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmV2ZW50VWlCdWlsZGVyc1trZXldIHx8IG1lbW9pemUoYnVpbGRFdmVudFVpRm9yS2V5KVxuICAgIH0pXG5cbiAgICBmb3IgKGxldCBrZXkgaW4ga2V5SW5mb3MpIHtcbiAgICAgIGxldCBrZXlJbmZvID0ga2V5SW5mb3Nba2V5XVxuICAgICAgbGV0IGV2ZW50U3RvcmUgPSBldmVudFN0b3Jlc1trZXldIHx8IEVNUFRZX0VWRU5UX1NUT1JFXG4gICAgICBsZXQgYnVpbGRFdmVudFVpID0gdGhpcy5ldmVudFVpQnVpbGRlcnNba2V5XVxuXG4gICAgICBzcGxpdFByb3BzW2tleV0gPSB7XG4gICAgICAgIGJ1c2luZXNzSG91cnM6IGtleUluZm8uYnVzaW5lc3NIb3VycyB8fCBwcm9wcy5idXNpbmVzc0hvdXJzLFxuICAgICAgICBkYXRlU2VsZWN0aW9uOiBkYXRlU2VsZWN0aW9uc1trZXldIHx8IG51bGwsXG4gICAgICAgIGV2ZW50U3RvcmUsXG4gICAgICAgIGV2ZW50VWlCYXNlczogYnVpbGRFdmVudFVpKHByb3BzLmV2ZW50VWlCYXNlc1snJ10sIGtleUluZm8udWksIGluZGl2aWR1YWxVaVtrZXldKSxcbiAgICAgICAgZXZlbnRTZWxlY3Rpb246IGV2ZW50U3RvcmUuaW5zdGFuY2VzW3Byb3BzLmV2ZW50U2VsZWN0aW9uXSA/IHByb3BzLmV2ZW50U2VsZWN0aW9uIDogJycsXG4gICAgICAgIGV2ZW50RHJhZzogZXZlbnREcmFnc1trZXldIHx8IG51bGwsXG4gICAgICAgIGV2ZW50UmVzaXplOiBldmVudFJlc2l6ZXNba2V5XSB8fCBudWxsXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNwbGl0UHJvcHNcbiAgfVxuXG4gIHByaXZhdGUgX3NwbGl0RGF0ZVNwYW4oZGF0ZVNwYW46IERhdGVTcGFuIHwgbnVsbCkge1xuICAgIGxldCBkYXRlU3BhbnMgPSB7fVxuXG4gICAgaWYgKGRhdGVTcGFuKSB7XG4gICAgICBsZXQga2V5cyA9IHRoaXMuZ2V0S2V5c0ZvckRhdGVTcGFuKGRhdGVTcGFuKVxuXG4gICAgICBmb3IgKGxldCBrZXkgb2Yga2V5cykge1xuICAgICAgICBkYXRlU3BhbnNba2V5XSA9IGRhdGVTcGFuXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGVTcGFuc1xuICB9XG5cbiAgcHJpdmF0ZSBfZ2V0S2V5c0ZvckV2ZW50RGVmcyhldmVudFN0b3JlOiBFdmVudFN0b3JlKSB7XG4gICAgcmV0dXJuIG1hcEhhc2goZXZlbnRTdG9yZS5kZWZzLCAoZXZlbnREZWY6IEV2ZW50RGVmKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRLZXlzRm9yRXZlbnREZWYoZXZlbnREZWYpXG4gICAgfSlcbiAgfVxuXG4gIHByaXZhdGUgX3NwbGl0RXZlbnRTdG9yZShldmVudFN0b3JlOiBFdmVudFN0b3JlLCBkZWZLZXlzKTogeyBba2V5OiBzdHJpbmddOiBFdmVudFN0b3JlIH0ge1xuICAgIGxldCB7IGRlZnMsIGluc3RhbmNlcyB9ID0gZXZlbnRTdG9yZVxuICAgIGxldCBzcGxpdFN0b3JlcyA9IHt9XG5cbiAgICBmb3IgKGxldCBkZWZJZCBpbiBkZWZzKSB7XG4gICAgICBmb3IgKGxldCBrZXkgb2YgZGVmS2V5c1tkZWZJZF0pIHtcblxuICAgICAgICBpZiAoIXNwbGl0U3RvcmVzW2tleV0pIHtcbiAgICAgICAgICBzcGxpdFN0b3Jlc1trZXldID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKClcbiAgICAgICAgfVxuXG4gICAgICAgIHNwbGl0U3RvcmVzW2tleV0uZGVmc1tkZWZJZF0gPSBkZWZzW2RlZklkXVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICBsZXQgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaW5zdGFuY2VJZF1cblxuICAgICAgZm9yIChsZXQga2V5IG9mIGRlZktleXNbaW5zdGFuY2UuZGVmSWRdKSB7XG5cbiAgICAgICAgaWYgKHNwbGl0U3RvcmVzW2tleV0pIHsgLy8gbXVzdCBoYXZlIGFscmVhZHkgYmVlbiBjcmVhdGVkXG4gICAgICAgICAgc3BsaXRTdG9yZXNba2V5XS5pbnN0YW5jZXNbaW5zdGFuY2VJZF0gPSBpbnN0YW5jZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNwbGl0U3RvcmVzXG4gIH1cblxuICBwcml2YXRlIF9zcGxpdEluZGl2aWR1YWxVaShldmVudFVpQmFzZXM6IEV2ZW50VWlIYXNoLCBkZWZLZXlzKTogeyBba2V5OiBzdHJpbmddOiBFdmVudFVpSGFzaCB9IHtcbiAgICBsZXQgc3BsaXRIYXNoZXM6IHsgW2tleTogc3RyaW5nXTogRXZlbnRVaUhhc2ggfSA9IHt9XG5cbiAgICBmb3IgKGxldCBkZWZJZCBpbiBldmVudFVpQmFzZXMpIHtcbiAgICAgIGlmIChkZWZJZCkgeyAvLyBub3QgdGhlICcnIGtleVxuICAgICAgICBmb3IgKGxldCBrZXkgb2YgZGVmS2V5c1tkZWZJZF0pIHtcblxuICAgICAgICAgIGlmICghc3BsaXRIYXNoZXNba2V5XSkge1xuICAgICAgICAgICAgc3BsaXRIYXNoZXNba2V5XSA9IHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3BsaXRIYXNoZXNba2V5XVtkZWZJZF0gPSBldmVudFVpQmFzZXNbZGVmSWRdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3BsaXRIYXNoZXNcbiAgfVxuXG4gIHByaXZhdGUgX3NwbGl0SW50ZXJhY3Rpb24oaW50ZXJhY3Rpb246IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSB8IG51bGwpOiB7IFtrZXk6IHN0cmluZ106IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSB9IHtcbiAgICBsZXQgc3BsaXRTdGF0ZXM6IHsgW2tleTogc3RyaW5nXTogRXZlbnRJbnRlcmFjdGlvblN0YXRlIH0gPSB7fVxuXG4gICAgaWYgKGludGVyYWN0aW9uKSB7XG4gICAgICBsZXQgYWZmZWN0ZWRTdG9yZXMgPSB0aGlzLl9zcGxpdEV2ZW50U3RvcmUoXG4gICAgICAgIGludGVyYWN0aW9uLmFmZmVjdGVkRXZlbnRzLFxuICAgICAgICB0aGlzLl9nZXRLZXlzRm9yRXZlbnREZWZzKGludGVyYWN0aW9uLmFmZmVjdGVkRXZlbnRzKSAvLyBjYW4ndCB1c2UgY2FjaGVkLiBtaWdodCBiZSBldmVudHMgZnJvbSBvdGhlciBjYWxlbmRhclxuICAgICAgKVxuXG4gICAgICAvLyBjYW4ndCByZWx5IG9uIGRlZktleXMgYmVjYXVzZSBldmVudCBkYXRhIGlzIG11dGF0ZWRcbiAgICAgIGxldCBtdXRhdGVkS2V5c0J5RGVmSWQgPSB0aGlzLl9nZXRLZXlzRm9yRXZlbnREZWZzKGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMpXG4gICAgICBsZXQgbXV0YXRlZFN0b3JlcyA9IHRoaXMuX3NwbGl0RXZlbnRTdG9yZShpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzLCBtdXRhdGVkS2V5c0J5RGVmSWQpXG5cbiAgICAgIGxldCBwb3B1bGF0ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAoIXNwbGl0U3RhdGVzW2tleV0pIHtcbiAgICAgICAgICBzcGxpdFN0YXRlc1trZXldID0ge1xuICAgICAgICAgICAgYWZmZWN0ZWRFdmVudHM6IGFmZmVjdGVkU3RvcmVzW2tleV0gfHwgRU1QVFlfRVZFTlRfU1RPUkUsXG4gICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBtdXRhdGVkU3RvcmVzW2tleV0gfHwgRU1QVFlfRVZFTlRfU1RPUkUsXG4gICAgICAgICAgICBpc0V2ZW50OiBpbnRlcmFjdGlvbi5pc0V2ZW50XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGtleSBpbiBhZmZlY3RlZFN0b3Jlcykge1xuICAgICAgICBwb3B1bGF0ZShrZXkpXG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGtleSBpbiBtdXRhdGVkU3RvcmVzKSB7XG4gICAgICAgIHBvcHVsYXRlKGtleSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3BsaXRTdGF0ZXNcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRVaUZvcktleShhbGxVaTogRXZlbnRVaSB8IG51bGwsIGV2ZW50VWlGb3JLZXk6IEV2ZW50VWkgfCBudWxsLCBpbmRpdmlkdWFsVWk6IEV2ZW50VWlIYXNoIHwgbnVsbCkge1xuICBsZXQgYmFzZVBhcnRzID0gW11cblxuICBpZiAoYWxsVWkpIHtcbiAgICBiYXNlUGFydHMucHVzaChhbGxVaSlcbiAgfVxuXG4gIGlmIChldmVudFVpRm9yS2V5KSB7XG4gICAgYmFzZVBhcnRzLnB1c2goZXZlbnRVaUZvcktleSlcbiAgfVxuXG4gIGxldCBzdHVmZiA9IHtcbiAgICAnJzogY29tYmluZUV2ZW50VWlzKGJhc2VQYXJ0cylcbiAgfVxuXG4gIGlmIChpbmRpdmlkdWFsVWkpIHtcbiAgICBfX2Fzc2lnbihzdHVmZiwgaW5kaXZpZHVhbFVpKVxuICB9XG5cbiAgcmV0dXJuIHN0dWZmXG59XG4iLCJpbXBvcnQgeyBEYXRlTWFya2VyLCBEQVlfSURTIH0gZnJvbSAnLi4vZGF0ZWxpYi9tYXJrZXInXG5pbXBvcnQgeyByYW5nZUNvbnRhaW5zTWFya2VyLCBEYXRlUmFuZ2UgfSBmcm9tICcuLi9kYXRlbGliL2RhdGUtcmFuZ2UnXG5pbXBvcnQgeyBEYXRlUHJvZmlsZSB9IGZyb20gJy4uL0RhdGVQcm9maWxlR2VuZXJhdG9yJ1xuaW1wb3J0IHsgVGhlbWUgfSBmcm9tICcuLi90aGVtZS9UaGVtZSdcblxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVNZXRhIHtcbiAgZG93OiBudW1iZXJcbiAgaXNEaXNhYmxlZDogYm9vbGVhblxuICBpc090aGVyOiBib29sZWFuIC8vIGxpa2UsIGlzIGl0IGluIHRoZSBub24tY3VycmVudCBcIm90aGVyXCIgbW9udGhcbiAgaXNUb2RheTogYm9vbGVhblxuICBpc1Bhc3Q6IGJvb2xlYW5cbiAgaXNGdXR1cmU6IGJvb2xlYW5cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGF0ZU1ldGEoZGF0ZTogRGF0ZU1hcmtlciwgdG9kYXlSYW5nZT86IERhdGVSYW5nZSwgbm93RGF0ZT86IERhdGVNYXJrZXIsIGRhdGVQcm9maWxlPzogRGF0ZVByb2ZpbGUpOiBEYXRlTWV0YSB7XG4gIHJldHVybiB7XG4gICAgZG93OiBkYXRlLmdldFVUQ0RheSgpLFxuICAgIGlzRGlzYWJsZWQ6IEJvb2xlYW4oZGF0ZVByb2ZpbGUgJiYgIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGRhdGUpKSxcbiAgICBpc090aGVyOiBCb29sZWFuKGRhdGVQcm9maWxlICYmICFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZSwgZGF0ZSkpLFxuICAgIGlzVG9kYXk6IEJvb2xlYW4odG9kYXlSYW5nZSAmJiByYW5nZUNvbnRhaW5zTWFya2VyKHRvZGF5UmFuZ2UsIGRhdGUpKSxcbiAgICBpc1Bhc3Q6IEJvb2xlYW4obm93RGF0ZSA/IChkYXRlIDwgbm93RGF0ZSkgOiB0b2RheVJhbmdlID8gKGRhdGUgPCB0b2RheVJhbmdlLnN0YXJ0KSA6IGZhbHNlKSxcbiAgICBpc0Z1dHVyZTogQm9vbGVhbihub3dEYXRlID8gKGRhdGUgPiBub3dEYXRlKSA6IHRvZGF5UmFuZ2UgPyAoZGF0ZSA+PSB0b2RheVJhbmdlLmVuZCkgOiBmYWxzZSlcbiAgfVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREYXlDbGFzc05hbWVzKG1ldGE6IERhdGVNZXRhLCB0aGVtZTogVGhlbWUpIHtcbiAgbGV0IGNsYXNzTmFtZXM6IHN0cmluZ1tdID0gW1xuICAgICdmYy1kYXknLFxuICAgICdmYy1kYXktJyArIERBWV9JRFNbbWV0YS5kb3ddXG4gIF1cblxuICBpZiAobWV0YS5pc0Rpc2FibGVkKSB7XG4gICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1kYXktZGlzYWJsZWQnKVxuXG4gIH0gZWxzZSB7XG5cbiAgICBpZiAobWV0YS5pc1RvZGF5KSB7XG4gICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS10b2RheScpXG4gICAgICBjbGFzc05hbWVzLnB1c2godGhlbWUuZ2V0Q2xhc3MoJ3RvZGF5JykpXG4gICAgfVxuXG4gICAgaWYgKG1ldGEuaXNQYXN0KSB7XG4gICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1wYXN0JylcbiAgICB9XG5cbiAgICBpZiAobWV0YS5pc0Z1dHVyZSkge1xuICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1kYXktZnV0dXJlJylcbiAgICB9XG5cbiAgICBpZiAobWV0YS5pc090aGVyKSB7XG4gICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1vdGhlcicpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNsYXNzTmFtZXNcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2xvdENsYXNzTmFtZXMobWV0YTogRGF0ZU1ldGEsIHRoZW1lOiBUaGVtZSkge1xuICBsZXQgY2xhc3NOYW1lczogc3RyaW5nW10gPSBbXG4gICAgJ2ZjLXNsb3QnLFxuICAgICdmYy1zbG90LScgKyBEQVlfSURTW21ldGEuZG93XVxuICBdXG5cbiAgaWYgKG1ldGEuaXNEaXNhYmxlZCkge1xuICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2xvdC1kaXNhYmxlZCcpXG5cbiAgfSBlbHNlIHtcblxuICAgIGlmIChtZXRhLmlzVG9kYXkpIHtcbiAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2xvdC10b2RheScpXG4gICAgICBjbGFzc05hbWVzLnB1c2godGhlbWUuZ2V0Q2xhc3MoJ3RvZGF5JykpXG4gICAgfVxuXG4gICAgaWYgKG1ldGEuaXNQYXN0KSB7XG4gICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtcGFzdCcpXG4gICAgfVxuXG4gICAgaWYgKG1ldGEuaXNGdXR1cmUpIHtcbiAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2xvdC1mdXR1cmUnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjbGFzc05hbWVzXG59XG4iLCJpbXBvcnQgeyBmb3JtYXREYXlTdHJpbmcgfSBmcm9tICcuLi9kYXRlbGliL2Zvcm1hdHRpbmctdXRpbHMnXG5pbXBvcnQgeyBEYXRlTWFya2VyIH0gZnJvbSAnLi4vZGF0ZWxpYi9tYXJrZXInXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkTmF2TGlua0RhdGEoZGF0ZTogRGF0ZU1hcmtlciwgdHlwZSA9ICdkYXknKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgZGF0ZTogZm9ybWF0RGF5U3RyaW5nKGRhdGUpLFxuICAgIHR5cGVcbiAgfSlcbn1cbiIsImltcG9ydCB7IHJlbW92ZUVsZW1lbnQsIGFwcGx5U3R5bGUgfSBmcm9tICcuLi91dGlsL2RvbS1tYW5pcCdcblxuXG5sZXQgX2lzUnRsU2Nyb2xsYmFyT25MZWZ0OiBib29sZWFuIHwgbnVsbCA9IG51bGxcblxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SXNSdGxTY3JvbGxiYXJPbkxlZnQoKSB7IC8vIHJlc3BvbnNpYmxlIGZvciBjYWNoaW5nIHRoZSBjb21wdXRhdGlvblxuICBpZiAoX2lzUnRsU2Nyb2xsYmFyT25MZWZ0ID09PSBudWxsKSB7XG4gICAgX2lzUnRsU2Nyb2xsYmFyT25MZWZ0ID0gY29tcHV0ZUlzUnRsU2Nyb2xsYmFyT25MZWZ0KClcbiAgfVxuICByZXR1cm4gX2lzUnRsU2Nyb2xsYmFyT25MZWZ0XG59XG5cblxuZnVuY3Rpb24gY29tcHV0ZUlzUnRsU2Nyb2xsYmFyT25MZWZ0KCkgeyAvLyBjcmVhdGVzIGFuIG9mZnNjcmVlbiB0ZXN0IGVsZW1lbnQsIHRoZW4gcmVtb3ZlcyBpdFxuXG4gIC8vIFRPRE86IHVzZSBodG1sVG9FbGVtZW50XG4gIGxldCBvdXRlckVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgYXBwbHlTdHlsZShvdXRlckVsLCB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgdG9wOiAtMTAwMCxcbiAgICBsZWZ0OiAwLFxuICAgIGJvcmRlcjogMCxcbiAgICBwYWRkaW5nOiAwLFxuICAgIG92ZXJmbG93OiAnc2Nyb2xsJyxcbiAgICBkaXJlY3Rpb246ICdydGwnXG4gIH0pXG4gIG91dGVyRWwuaW5uZXJIVE1MID0gJzxkaXY+PC9kaXY+J1xuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3V0ZXJFbClcbiAgbGV0IGlubmVyRWwgPSBvdXRlckVsLmZpcnN0Q2hpbGQgYXMgSFRNTEVsZW1lbnRcbiAgbGV0IHJlcyA9IGlubmVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCA+IG91dGVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdFxuXG4gIHJlbW92ZUVsZW1lbnQob3V0ZXJFbClcbiAgcmV0dXJuIHJlc1xufVxuIiwiXG5leHBvcnQgaW50ZXJmYWNlIFNjcm9sbGJhcldpZHRocyB7XG4gIHg6IG51bWJlclxuICB5OiBudW1iZXIgLy8gVE9ETzogcmVuYW1lIHRvIHZlcnRpY2FsLiBsZXNzIGNvbmZ1c2luZyB3aGVuIGRlYWxpbmcgd2l0aCB3aWR0aC9oZWlnaHQgdmVyYmFnZVxufVxuXG5sZXQgX3Njcm9sbGJhcldpZHRoczogU2Nyb2xsYmFyV2lkdGhzIHwgdW5kZWZpbmVkXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjcm9sbGJhcldpZHRocygpIHsgLy8gVE9ETzogd2F5IHRvIGZvcmNlIHJlY29tcHV0ZT9cbiAgaWYgKCFfc2Nyb2xsYmFyV2lkdGhzKSB7XG4gICAgX3Njcm9sbGJhcldpZHRocyA9IGNvbXB1dGVTY3JvbGxiYXJXaWR0aHMoKVxuICB9XG5cbiAgcmV0dXJuIF9zY3JvbGxiYXJXaWR0aHNcbn1cblxuXG5mdW5jdGlvbiBjb21wdXRlU2Nyb2xsYmFyV2lkdGhzKCk6IFNjcm9sbGJhcldpZHRocyB7XG4gIGxldCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIGVsLnN0eWxlLm92ZXJmbG93ID0gJ3Njcm9sbCdcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbClcbiAgbGV0IHJlcyA9IGNvbXB1dGVTY3JvbGxiYXJXaWR0aHNGb3JFbChlbClcbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbClcbiAgcmV0dXJuIHJlc1xufVxuXG5cbi8vIFdBUk5JTkc6IHdpbGwgaW5jbHVkZSBib3JkZXJcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlU2Nyb2xsYmFyV2lkdGhzRm9yRWwoZWw6IEhUTUxFbGVtZW50KTogU2Nyb2xsYmFyV2lkdGhzIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBlbC5vZmZzZXRIZWlnaHQgLSBlbC5jbGllbnRIZWlnaHQsXG4gICAgeTogZWwub2Zmc2V0V2lkdGggLSBlbC5jbGllbnRXaWR0aFxuICB9XG59XG4iLCJpbXBvcnQgeyBSZWN0IH0gZnJvbSAnLi9nZW9tJ1xuaW1wb3J0IHsgZ2V0SXNSdGxTY3JvbGxiYXJPbkxlZnQgfSBmcm9tICcuL3Njcm9sbGJhci1zaWRlJ1xuaW1wb3J0IHsgY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsIH0gZnJvbSAnLi9zY3JvbGxiYXItd2lkdGgnXG5cbmV4cG9ydCBpbnRlcmZhY2UgRWRnZUluZm8ge1xuICBib3JkZXJMZWZ0OiBudW1iZXJcbiAgYm9yZGVyUmlnaHQ6IG51bWJlclxuICBib3JkZXJUb3A6IG51bWJlclxuICBib3JkZXJCb3R0b206IG51bWJlclxuICBzY3JvbGxiYXJMZWZ0OiBudW1iZXJcbiAgc2Nyb2xsYmFyUmlnaHQ6IG51bWJlclxuICBzY3JvbGxiYXJCb3R0b206IG51bWJlclxuICBwYWRkaW5nTGVmdD86IG51bWJlclxuICBwYWRkaW5nUmlnaHQ/OiBudW1iZXJcbiAgcGFkZGluZ1RvcD86IG51bWJlclxuICBwYWRkaW5nQm90dG9tPzogbnVtYmVyXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVFZGdlcyhlbDogSFRNTEVsZW1lbnQsIGdldFBhZGRpbmcgPSBmYWxzZSk6IEVkZ2VJbmZvIHsgLy8gY2FjaGUgc29tZWhvdz9cbiAgbGV0IGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbClcbiAgbGV0IGJvcmRlckxlZnQgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlckxlZnRXaWR0aCwgMTApIHx8IDBcbiAgbGV0IGJvcmRlclJpZ2h0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJSaWdodFdpZHRoLCAxMCkgfHwgMFxuICBsZXQgYm9yZGVyVG9wID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJUb3BXaWR0aCwgMTApIHx8IDBcbiAgbGV0IGJvcmRlckJvdHRvbSA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyQm90dG9tV2lkdGgsIDEwKSB8fCAwXG4gIGxldCBiYWRTY3JvbGxiYXJXaWR0aHMgPSBjb21wdXRlU2Nyb2xsYmFyV2lkdGhzRm9yRWwoZWwpIC8vIGluY2x1ZGVzIGJvcmRlciFcbiAgbGV0IHNjcm9sbGJhckxlZnRSaWdodCA9IGJhZFNjcm9sbGJhcldpZHRocy55IC0gYm9yZGVyTGVmdCAtIGJvcmRlclJpZ2h0XG4gIGxldCBzY3JvbGxiYXJCb3R0b20gPSBiYWRTY3JvbGxiYXJXaWR0aHMueCAtIGJvcmRlclRvcCAtIGJvcmRlckJvdHRvbVxuXG4gIGxldCByZXM6IEVkZ2VJbmZvID0ge1xuICAgIGJvcmRlckxlZnQsXG4gICAgYm9yZGVyUmlnaHQsXG4gICAgYm9yZGVyVG9wLFxuICAgIGJvcmRlckJvdHRvbSxcbiAgICBzY3JvbGxiYXJCb3R0b20sXG4gICAgc2Nyb2xsYmFyTGVmdDogMCxcbiAgICBzY3JvbGxiYXJSaWdodDogMFxuICB9XG5cbiAgaWYgKGdldElzUnRsU2Nyb2xsYmFyT25MZWZ0KCkgJiYgY29tcHV0ZWRTdHlsZS5kaXJlY3Rpb24gPT09ICdydGwnKSB7IC8vIGlzIHRoZSBzY3JvbGxiYXIgb24gdGhlIGxlZnQgc2lkZT9cbiAgICByZXMuc2Nyb2xsYmFyTGVmdCA9IHNjcm9sbGJhckxlZnRSaWdodFxuICB9IGVsc2Uge1xuICAgIHJlcy5zY3JvbGxiYXJSaWdodCA9IHNjcm9sbGJhckxlZnRSaWdodFxuICB9XG5cbiAgaWYgKGdldFBhZGRpbmcpIHtcbiAgICByZXMucGFkZGluZ0xlZnQgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLnBhZGRpbmdMZWZ0LCAxMCkgfHwgMFxuICAgIHJlcy5wYWRkaW5nUmlnaHQgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLnBhZGRpbmdSaWdodCwgMTApIHx8IDBcbiAgICByZXMucGFkZGluZ1RvcCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ1RvcCwgMTApIHx8IDBcbiAgICByZXMucGFkZGluZ0JvdHRvbSA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ0JvdHRvbSwgMTApIHx8IDBcbiAgfVxuXG4gIHJldHVybiByZXNcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUlubmVyUmVjdChlbCwgZ29XaXRoaW5QYWRkaW5nID0gZmFsc2UsIGRvRnJvbVdpbmRvd1ZpZXdwb3J0PzogYm9vbGVhbikge1xuICBsZXQgb3V0ZXJSZWN0ID0gZG9Gcm9tV2luZG93Vmlld3BvcnQgPyBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IGNvbXB1dGVSZWN0KGVsKVxuICBsZXQgZWRnZXMgPSBjb21wdXRlRWRnZXMoZWwsIGdvV2l0aGluUGFkZGluZylcbiAgbGV0IHJlcyA9IHtcbiAgICBsZWZ0OiBvdXRlclJlY3QubGVmdCArIGVkZ2VzLmJvcmRlckxlZnQgKyBlZGdlcy5zY3JvbGxiYXJMZWZ0LFxuICAgIHJpZ2h0OiBvdXRlclJlY3QucmlnaHQgLSBlZGdlcy5ib3JkZXJSaWdodCAtIGVkZ2VzLnNjcm9sbGJhclJpZ2h0LFxuICAgIHRvcDogb3V0ZXJSZWN0LnRvcCArIGVkZ2VzLmJvcmRlclRvcCxcbiAgICBib3R0b206IG91dGVyUmVjdC5ib3R0b20gLSBlZGdlcy5ib3JkZXJCb3R0b20gLSBlZGdlcy5zY3JvbGxiYXJCb3R0b21cbiAgfVxuXG4gIGlmIChnb1dpdGhpblBhZGRpbmcpIHtcbiAgICByZXMubGVmdCArPSBlZGdlcy5wYWRkaW5nTGVmdFxuICAgIHJlcy5yaWdodCAtPSBlZGdlcy5wYWRkaW5nUmlnaHRcbiAgICByZXMudG9wICs9IGVkZ2VzLnBhZGRpbmdUb3BcbiAgICByZXMuYm90dG9tIC09IGVkZ2VzLnBhZGRpbmdCb3R0b21cbiAgfVxuXG4gIHJldHVybiByZXNcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVJlY3QoZWwpOiBSZWN0IHtcbiAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG4gIHJldHVybiB7XG4gICAgbGVmdDogcmVjdC5sZWZ0ICsgd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgIHRvcDogcmVjdC50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQsXG4gICAgcmlnaHQ6IHJlY3QucmlnaHQgKyB3aW5kb3cucGFnZVhPZmZzZXQsXG4gICAgYm90dG9tOiByZWN0LmJvdHRvbSArIHdpbmRvdy5wYWdlWU9mZnNldFxuICB9XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVIZWlnaHRBbmRNYXJnaW5zKGVsOiBIVE1MRWxlbWVudCkge1xuICByZXR1cm4gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0ICsgY29tcHV0ZVZNYXJnaW5zKGVsKVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlVk1hcmdpbnMoZWw6IEhUTUxFbGVtZW50KSB7XG4gIGxldCBjb21wdXRlZCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKVxuXG4gIHJldHVybiBwYXJzZUludChjb21wdXRlZC5tYXJnaW5Ub3AsIDEwKSArXG4gICAgcGFyc2VJbnQoY29tcHV0ZWQubWFyZ2luQm90dG9tLCAxMClcbn1cblxuXG4vLyBkb2VzIG5vdCByZXR1cm4gd2luZG93XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsOiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50W10ge1xuICBsZXQgcGFyZW50czogSFRNTEVsZW1lbnRbXSA9IFtdXG5cbiAgd2hpbGUgKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHsgLy8gd2lsbCBzdG9wIHdoZW4gZ2V0cyB0byBkb2N1bWVudCBvciBudWxsXG4gICAgbGV0IGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbClcblxuICAgIGlmIChjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGlmICgoLyhhdXRvfHNjcm9sbCkvKS50ZXN0KGNvbXB1dGVkU3R5bGUub3ZlcmZsb3cgKyBjb21wdXRlZFN0eWxlLm92ZXJmbG93WSArIGNvbXB1dGVkU3R5bGUub3ZlcmZsb3dYKSkge1xuICAgICAgcGFyZW50cy5wdXNoKGVsKVxuICAgIH1cblxuICAgIGVsID0gZWwucGFyZW50Tm9kZSBhcyBIVE1MRWxlbWVudFxuICB9XG5cbiAgcmV0dXJuIHBhcmVudHNcbn1cbiIsIlxuLy8gZ2l2ZW4gYSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIGEgcmVzdWx0IGFzeW5jaHJvbm91c2x5LlxuLy8gdGhlIGZ1bmN0aW9uIGNhbiBlaXRoZXIgY2FsbCBwYXNzZWQtaW4gc3VjY2VzcyBhbmQgZmFpbHVyZSBjYWxsYmFja3MsXG4vLyBvciBpdCBjYW4gcmV0dXJuIGEgcHJvbWlzZS5cbi8vIGlmIHlvdSBuZWVkIHRvIHBhc3MgYWRkaXRpb25hbCBwYXJhbXMgdG8gZnVuYywgYmluZCB0aGVtIGZpcnN0LlxuZXhwb3J0IGZ1bmN0aW9uIHVucHJvbWlzaWZ5KGZ1bmMsIHN1Y2Nlc3MsIGZhaWx1cmU/KSB7XG5cbiAgLy8gZ3VhcmQgYWdhaW5zdCBzdWNjZXNzL2ZhaWx1cmUgY2FsbGJhY2tzIGJlaW5nIGNhbGxlZCBtb3JlIHRoYW4gb25jZVxuICAvLyBhbmQgZ3VhcmQgYWdhaW5zdCBhIHByb21pc2UgQU5EIGNhbGxiYWNrIGJlaW5nIHVzZWQgdG9nZXRoZXIuXG4gIGxldCBpc1Jlc29sdmVkID0gZmFsc2VcbiAgbGV0IHdyYXBwZWRTdWNjZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFpc1Jlc29sdmVkKSB7XG4gICAgICBpc1Jlc29sdmVkID0gdHJ1ZVxuICAgICAgc3VjY2Vzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG4gIGxldCB3cmFwcGVkRmFpbHVyZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghaXNSZXNvbHZlZCkge1xuICAgICAgaXNSZXNvbHZlZCA9IHRydWVcbiAgICAgIGlmIChmYWlsdXJlKSB7XG4gICAgICAgIGZhaWx1cmUuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCByZXMgPSBmdW5jKHdyYXBwZWRTdWNjZXNzLCB3cmFwcGVkRmFpbHVyZSlcbiAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXMudGhlbih3cmFwcGVkU3VjY2Vzcywgd3JhcHBlZEZhaWx1cmUpXG4gIH1cbn1cbiIsIlxuZXhwb3J0IGludGVyZmFjZSBIYW5kbGVyRnVuY1R5cGVIYXNoIHtcbiAgW2V2ZW50TmFtZTogc3RyaW5nXTogKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkgLy8gd2l0aCBhbGwgcHJvcGVydGllcyByZXF1aXJlZFxufVxuXG5leHBvcnQgY2xhc3MgRW1pdHRlcjxIYW5kbGVyRnVuY3MgZXh0ZW5kcyBIYW5kbGVyRnVuY1R5cGVIYXNoPiB7XG5cbiAgcHJpdmF0ZSBoYW5kbGVyczogeyBbUHJvcCBpbiBrZXlvZiBIYW5kbGVyRnVuY3NdPzogSGFuZGxlckZ1bmNzW1Byb3BdW10gfSA9IHt9XG4gIHByaXZhdGUgb3B0aW9uczogUGFydGlhbDxIYW5kbGVyRnVuY3M+XG4gIHByaXZhdGUgdGhpc0NvbnRleHQ6IGFueSA9IG51bGxcblxuXG4gIHNldFRoaXNDb250ZXh0KHRoaXNDb250ZXh0KSB7XG4gICAgdGhpcy50aGlzQ29udGV4dCA9IHRoaXNDb250ZXh0XG4gIH1cblxuXG4gIHNldE9wdGlvbnMob3B0aW9uczogUGFydGlhbDxIYW5kbGVyRnVuY3M+KSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICB9XG5cblxuICBvbjxQcm9wIGV4dGVuZHMga2V5b2YgSGFuZGxlckZ1bmNzPih0eXBlOiBQcm9wLCBoYW5kbGVyOiBIYW5kbGVyRnVuY3NbUHJvcF0pIHtcbiAgICBhZGRUb0hhc2godGhpcy5oYW5kbGVycywgdHlwZSwgaGFuZGxlcilcbiAgfVxuXG5cbiAgb2ZmPFByb3AgZXh0ZW5kcyBrZXlvZiBIYW5kbGVyRnVuY3M+KHR5cGU6IFByb3AsIGhhbmRsZXI/OiBIYW5kbGVyRnVuY3NbUHJvcF0pIHtcbiAgICByZW1vdmVGcm9tSGFzaCh0aGlzLmhhbmRsZXJzLCB0eXBlLCBoYW5kbGVyKVxuICB9XG5cblxuICB0cmlnZ2VyPFByb3AgZXh0ZW5kcyBrZXlvZiBIYW5kbGVyRnVuY3M+KHR5cGU6IFByb3AsIC4uLmFyZ3M6IFBhcmFtZXRlcnM8SGFuZGxlckZ1bmNzW1Byb3BdPikge1xuICAgIGxldCBhdHRhY2hlZEhhbmRsZXJzID0gdGhpcy5oYW5kbGVyc1t0eXBlXSB8fCBbXVxuICAgIGxldCBvcHRpb25IYW5kbGVyID0gdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9uc1t0eXBlXVxuICAgIGxldCBoYW5kbGVycyA9IFtdLmNvbmNhdChvcHRpb25IYW5kbGVyIHx8IFtdLCBhdHRhY2hlZEhhbmRsZXJzKVxuXG4gICAgZm9yIChsZXQgaGFuZGxlciBvZiBoYW5kbGVycykge1xuICAgICAgaGFuZGxlci5hcHBseSh0aGlzLnRoaXNDb250ZXh0LCBhcmdzKVxuICAgIH1cbiAgfVxuXG5cbiAgaGFzSGFuZGxlcnModHlwZToga2V5b2YgSGFuZGxlckZ1bmNzKSB7XG4gICAgcmV0dXJuICh0aGlzLmhhbmRsZXJzW3R5cGVdICYmIHRoaXMuaGFuZGxlcnNbdHlwZV0ubGVuZ3RoKSB8fFxuICAgICAgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnNbdHlwZV0pXG4gIH1cblxufVxuXG5cbmZ1bmN0aW9uIGFkZFRvSGFzaChoYXNoLCB0eXBlLCBoYW5kbGVyKSB7XG4gIChoYXNoW3R5cGVdIHx8IChoYXNoW3R5cGVdID0gW10pKVxuICAgIC5wdXNoKGhhbmRsZXIpXG59XG5cblxuZnVuY3Rpb24gcmVtb3ZlRnJvbUhhc2goaGFzaCwgdHlwZSwgaGFuZGxlcj8pIHtcbiAgaWYgKGhhbmRsZXIpIHtcbiAgICBpZiAoaGFzaFt0eXBlXSkge1xuICAgICAgaGFzaFt0eXBlXSA9IGhhc2hbdHlwZV0uZmlsdGVyKGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMgIT09IGhhbmRsZXJcbiAgICAgIH0pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlbGV0ZSBoYXNoW3R5cGVdIC8vIHJlbW92ZSBhbGwgaGFuZGxlciBmdW5jcyBmb3IgdGhpcyB0eXBlXG4gIH1cbn1cbiIsIlxuLypcblJlY29yZHMgb2Zmc2V0IGluZm9ybWF0aW9uIGZvciBhIHNldCBvZiBlbGVtZW50cywgcmVsYXRpdmUgdG8gYW4gb3JpZ2luIGVsZW1lbnQuXG5DYW4gcmVjb3JkIHRoZSBsZWZ0L3JpZ2h0IE9SIHRoZSB0b3AvYm90dG9tIE9SIGJvdGguXG5Qcm92aWRlcyBtZXRob2RzIGZvciBxdWVyeWluZyB0aGUgY2FjaGUgYnkgcG9zaXRpb24uXG4qL1xuZXhwb3J0IGNsYXNzIFBvc2l0aW9uQ2FjaGUge1xuXG4gIGVsczogSFRNTEVsZW1lbnRbXSAvLyBhc3N1bWVkIHRvIGJlIHNpYmxpbmdzXG4gIG9yaWdpbkNsaWVudFJlY3Q6IENsaWVudFJlY3RcblxuICAvLyBhcnJheXMgb2YgY29vcmRpbmF0ZXMgKGZyb20gdG9wbGVmdCBvZiBvcmlnaW5FbClcbiAgLy8gY2FsbGVyIGNhbiBhY2Nlc3MgdGhlc2UgZGlyZWN0bHlcbiAgbGVmdHM6IGFueVxuICByaWdodHM6IGFueVxuICB0b3BzOiBhbnlcbiAgYm90dG9tczogYW55XG5cblxuICBjb25zdHJ1Y3RvcihvcmlnaW5FbDogSFRNTEVsZW1lbnQsIGVsczogSFRNTEVsZW1lbnRbXSwgaXNIb3Jpem9udGFsOiBib29sZWFuLCBpc1ZlcnRpY2FsOiBib29sZWFuKSB7XG4gICAgdGhpcy5lbHMgPSBlbHNcblxuICAgIGxldCBvcmlnaW5DbGllbnRSZWN0ID0gdGhpcy5vcmlnaW5DbGllbnRSZWN0ID0gb3JpZ2luRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgLy8gcmVsYXRpdmUgdG8gdmlld3BvcnQgdG9wLWxlZnRcblxuICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgIHRoaXMuYnVpbGRFbEhvcml6b250YWxzKG9yaWdpbkNsaWVudFJlY3QubGVmdClcbiAgICB9XG5cbiAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgdGhpcy5idWlsZEVsVmVydGljYWxzKG9yaWdpbkNsaWVudFJlY3QudG9wKVxuICAgIH1cbiAgfVxuXG5cbiAgLy8gUG9wdWxhdGVzIHRoZSBsZWZ0L3JpZ2h0IGludGVybmFsIGNvb3JkaW5hdGUgYXJyYXlzXG4gIGJ1aWxkRWxIb3Jpem9udGFscyhvcmlnaW5DbGllbnRMZWZ0OiBudW1iZXIpIHtcbiAgICBsZXQgbGVmdHMgPSBbXVxuICAgIGxldCByaWdodHMgPSBbXVxuXG4gICAgZm9yIChsZXQgZWwgb2YgdGhpcy5lbHMpIHtcbiAgICAgIGxldCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIGxlZnRzLnB1c2gocmVjdC5sZWZ0IC0gb3JpZ2luQ2xpZW50TGVmdClcbiAgICAgIHJpZ2h0cy5wdXNoKHJlY3QucmlnaHQgLSBvcmlnaW5DbGllbnRMZWZ0KVxuICAgIH1cblxuICAgIHRoaXMubGVmdHMgPSBsZWZ0c1xuICAgIHRoaXMucmlnaHRzID0gcmlnaHRzXG4gIH1cblxuXG4gIC8vIFBvcHVsYXRlcyB0aGUgdG9wL2JvdHRvbSBpbnRlcm5hbCBjb29yZGluYXRlIGFycmF5c1xuICBidWlsZEVsVmVydGljYWxzKG9yaWdpbkNsaWVudFRvcDogbnVtYmVyKSB7XG4gICAgbGV0IHRvcHMgPSBbXVxuICAgIGxldCBib3R0b21zID0gW11cblxuICAgIGZvciAobGV0IGVsIG9mIHRoaXMuZWxzKSB7XG4gICAgICBsZXQgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICB0b3BzLnB1c2gocmVjdC50b3AgLSBvcmlnaW5DbGllbnRUb3ApXG4gICAgICBib3R0b21zLnB1c2gocmVjdC5ib3R0b20gLSBvcmlnaW5DbGllbnRUb3ApXG4gICAgfVxuXG4gICAgdGhpcy50b3BzID0gdG9wc1xuICAgIHRoaXMuYm90dG9tcyA9IGJvdHRvbXNcbiAgfVxuXG5cbiAgLy8gR2l2ZW4gYSBsZWZ0IG9mZnNldCAoZnJvbSBkb2N1bWVudCBsZWZ0KSwgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsIHRoYXQgaXQgaG9yaXpvbnRhbGx5IGludGVyc2VjdHMuXG4gIC8vIElmIG5vIGludGVyc2VjdGlvbiBpcyBtYWRlLCByZXR1cm5zIHVuZGVmaW5lZC5cbiAgbGVmdFRvSW5kZXgobGVmdFBvc2l0aW9uOiBudW1iZXIpIHtcbiAgICBsZXQgbGVmdHMgPSB0aGlzLmxlZnRzXG4gICAgbGV0IHJpZ2h0cyA9IHRoaXMucmlnaHRzXG4gICAgbGV0IGxlbiA9IGxlZnRzLmxlbmd0aFxuICAgIGxldCBpXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChsZWZ0UG9zaXRpb24gPj0gbGVmdHNbaV0gJiYgbGVmdFBvc2l0aW9uIDwgcmlnaHRzW2ldKSB7XG4gICAgICAgIHJldHVybiBpXG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICAvLyBHaXZlbiBhIHRvcCBvZmZzZXQgKGZyb20gZG9jdW1lbnQgdG9wKSwgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsIHRoYXQgaXQgdmVydGljYWxseSBpbnRlcnNlY3RzLlxuICAvLyBJZiBubyBpbnRlcnNlY3Rpb24gaXMgbWFkZSwgcmV0dXJucyB1bmRlZmluZWQuXG4gIHRvcFRvSW5kZXgodG9wUG9zaXRpb246IG51bWJlcikge1xuICAgIGxldCB0b3BzID0gdGhpcy50b3BzXG4gICAgbGV0IGJvdHRvbXMgPSB0aGlzLmJvdHRvbXNcbiAgICBsZXQgbGVuID0gdG9wcy5sZW5ndGhcbiAgICBsZXQgaVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAodG9wUG9zaXRpb24gPj0gdG9wc1tpXSAmJiB0b3BQb3NpdGlvbiA8IGJvdHRvbXNbaV0pIHtcbiAgICAgICAgcmV0dXJuIGlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIC8vIEdldHMgdGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxuICBnZXRXaWR0aChsZWZ0SW5kZXg6IG51bWJlcikge1xuICAgIHJldHVybiB0aGlzLnJpZ2h0c1tsZWZ0SW5kZXhdIC0gdGhpcy5sZWZ0c1tsZWZ0SW5kZXhdXG4gIH1cblxuXG4gIC8vIEdldHMgdGhlIGhlaWdodCBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgZ2V0SGVpZ2h0KHRvcEluZGV4OiBudW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5ib3R0b21zW3RvcEluZGV4XSAtIHRoaXMudG9wc1t0b3BJbmRleF1cbiAgfVxuXG59XG4iLCJcbi8qXG5BbiBvYmplY3QgZm9yIGdldHRpbmcvc2V0dGluZyBzY3JvbGwtcmVsYXRlZCBpbmZvcm1hdGlvbiBmb3IgYW4gZWxlbWVudC5cbkludGVybmFsbHksIHRoaXMgaXMgZG9uZSB2ZXJ5IGRpZmZlcmVudGx5IGZvciB3aW5kb3cgdmVyc3VzIERPTSBlbGVtZW50LFxuc28gdGhpcyBvYmplY3Qgc2VydmVzIGFzIGEgY29tbW9uIGludGVyZmFjZS5cbiovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2Nyb2xsQ29udHJvbGxlciB7XG5cbiAgYWJzdHJhY3QgZ2V0U2Nyb2xsVG9wKCk6IG51bWJlclxuICBhYnN0cmFjdCBnZXRTY3JvbGxMZWZ0KCk6IG51bWJlclxuICBhYnN0cmFjdCBzZXRTY3JvbGxUb3AodG9wOiBudW1iZXIpOiB2b2lkXG4gIGFic3RyYWN0IHNldFNjcm9sbExlZnQobGVmdDogbnVtYmVyKTogdm9pZFxuICBhYnN0cmFjdCBnZXRDbGllbnRXaWR0aCgpOiBudW1iZXJcbiAgYWJzdHJhY3QgZ2V0Q2xpZW50SGVpZ2h0KCk6IG51bWJlclxuICBhYnN0cmFjdCBnZXRTY3JvbGxXaWR0aCgpOiBudW1iZXJcbiAgYWJzdHJhY3QgZ2V0U2Nyb2xsSGVpZ2h0KCk6IG51bWJlclxuXG4gIGdldE1heFNjcm9sbFRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxIZWlnaHQoKSAtIHRoaXMuZ2V0Q2xpZW50SGVpZ2h0KClcbiAgfVxuXG4gIGdldE1heFNjcm9sbExlZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsV2lkdGgoKSAtIHRoaXMuZ2V0Q2xpZW50V2lkdGgoKVxuICB9XG5cbiAgY2FuU2Nyb2xsVmVydGljYWxseSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNYXhTY3JvbGxUb3AoKSA+IDBcbiAgfVxuXG4gIGNhblNjcm9sbEhvcml6b250YWxseSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNYXhTY3JvbGxMZWZ0KCkgPiAwXG4gIH1cblxuICBjYW5TY3JvbGxVcCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxUb3AoKSA+IDBcbiAgfVxuXG4gIGNhblNjcm9sbERvd24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsVG9wKCkgPCB0aGlzLmdldE1heFNjcm9sbFRvcCgpXG4gIH1cblxuICBjYW5TY3JvbGxMZWZ0KCkge1xuICAgIHJldHVybiB0aGlzLmdldFNjcm9sbExlZnQoKSA+IDBcbiAgfVxuXG4gIGNhblNjcm9sbFJpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmdldFNjcm9sbExlZnQoKSA8IHRoaXMuZ2V0TWF4U2Nyb2xsTGVmdCgpXG4gIH1cblxufVxuXG5leHBvcnQgY2xhc3MgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIgZXh0ZW5kcyBTY3JvbGxDb250cm9sbGVyIHtcblxuICBlbDogSFRNTEVsZW1lbnRcblxuICBjb25zdHJ1Y3RvcihlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5lbCA9IGVsXG4gIH1cblxuICBnZXRTY3JvbGxUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWwuc2Nyb2xsVG9wXG4gIH1cblxuICBnZXRTY3JvbGxMZWZ0KCkge1xuICAgIHJldHVybiB0aGlzLmVsLnNjcm9sbExlZnRcbiAgfVxuXG4gIHNldFNjcm9sbFRvcCh0b3A6IG51bWJlcikge1xuICAgIHRoaXMuZWwuc2Nyb2xsVG9wID0gdG9wXG4gIH1cblxuICBzZXRTY3JvbGxMZWZ0KGxlZnQ6IG51bWJlcikge1xuICAgIHRoaXMuZWwuc2Nyb2xsTGVmdCA9IGxlZnRcbiAgfVxuXG4gIGdldFNjcm9sbFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmVsLnNjcm9sbFdpZHRoXG4gIH1cblxuICBnZXRTY3JvbGxIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWwuc2Nyb2xsSGVpZ2h0XG4gIH1cblxuICBnZXRDbGllbnRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWwuY2xpZW50SGVpZ2h0XG4gIH1cblxuICBnZXRDbGllbnRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbC5jbGllbnRXaWR0aFxuICB9XG5cbn1cblxuZXhwb3J0IGNsYXNzIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIgZXh0ZW5kcyBTY3JvbGxDb250cm9sbGVyIHtcblxuICBnZXRTY3JvbGxUb3AoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5wYWdlWU9mZnNldFxuICB9XG5cbiAgZ2V0U2Nyb2xsTGVmdCgpIHtcbiAgICByZXR1cm4gd2luZG93LnBhZ2VYT2Zmc2V0XG4gIH1cblxuICBzZXRTY3JvbGxUb3AobjogbnVtYmVyKSB7XG4gICAgd2luZG93LnNjcm9sbCh3aW5kb3cucGFnZVhPZmZzZXQsIG4pXG4gIH1cblxuICBzZXRTY3JvbGxMZWZ0KG46IG51bWJlcikge1xuICAgIHdpbmRvdy5zY3JvbGwobiwgd2luZG93LnBhZ2VZT2Zmc2V0KVxuICB9XG5cbiAgZ2V0U2Nyb2xsV2lkdGgoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aFxuICB9XG5cbiAgZ2V0U2Nyb2xsSGVpZ2h0KCkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0XG4gIH1cblxuICBnZXRDbGllbnRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcbiAgfVxuXG4gIGdldENsaWVudFdpZHRoKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGhcbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBDYWxlbmRhck9wdGlvbnNSZWZpbmVkIH0gZnJvbSAnLi4vb3B0aW9ucydcblxuZXhwb3J0IGNsYXNzIFRoZW1lIHtcblxuICAvLyBzZXR0aW5ncy4gZGVmYXVsdCB2YWx1ZXMgYXJlIHNldCBhZnRlciB0aGUgY2xhc3NcbiAgY2xhc3NlczogYW55XG4gIGljb25DbGFzc2VzOiBhbnlcbiAgcnRsSWNvbkNsYXNzZXM6IGFueVxuICBiYXNlSWNvbkNsYXNzOiBzdHJpbmcgLy8gY2xhc3NOYW1lIHRoYXQgQUxMIGljb24gZWxlbWVudHMgZm9yIHRoaXMgdGhlbWUgc2hvdWxkIGhhdmVcbiAgaWNvbk92ZXJyaWRlT3B0aW9uOiBhbnkgLy8gdGhlIG5hbWUgb2YgdGhlIHNldHRpbmcgdG8gdXNlIGZvciBpY29ucy4gdGhlIHN1YmNsYXNzIG11c3Qgc2V0IHRoaXMuXG4gIGljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbjogYW55IC8vIHRoZSBuYW1lIG9mIHRoZSBzZXR0aW5nLCAqd2l0aGluKiBlYWNoIGN1c3RvbUJ1dHRvbnMgb2JqZWN0LCB0byB1c2UgZm9yIGljb25zXG4gIGljb25PdmVycmlkZVByZWZpeDogc3RyaW5nXG5cblxuICBjb25zdHJ1Y3RvcihjYWxlbmRhck9wdGlvbnM6IENhbGVuZGFyT3B0aW9uc1JlZmluZWQpIHtcbiAgICBpZiAodGhpcy5pY29uT3ZlcnJpZGVPcHRpb24pIHtcbiAgICAgIHRoaXMuc2V0SWNvbk92ZXJyaWRlKFxuICAgICAgICBjYWxlbmRhck9wdGlvbnNbdGhpcy5pY29uT3ZlcnJpZGVPcHRpb25dXG4gICAgICApXG4gICAgfVxuICB9XG5cblxuICBzZXRJY29uT3ZlcnJpZGUoaWNvbk92ZXJyaWRlSGFzaCkge1xuICAgIGxldCBpY29uQ2xhc3Nlc0NvcHlcbiAgICBsZXQgYnV0dG9uTmFtZVxuXG4gICAgaWYgKHR5cGVvZiBpY29uT3ZlcnJpZGVIYXNoID09PSAnb2JqZWN0JyAmJiBpY29uT3ZlcnJpZGVIYXNoKSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgaWNvbkNsYXNzZXNDb3B5ID0geyAuLi50aGlzLmljb25DbGFzc2VzIH1cblxuICAgICAgZm9yIChidXR0b25OYW1lIGluIGljb25PdmVycmlkZUhhc2gpIHtcbiAgICAgICAgaWNvbkNsYXNzZXNDb3B5W2J1dHRvbk5hbWVdID0gdGhpcy5hcHBseUljb25PdmVycmlkZVByZWZpeChcbiAgICAgICAgICBpY29uT3ZlcnJpZGVIYXNoW2J1dHRvbk5hbWVdXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgdGhpcy5pY29uQ2xhc3NlcyA9IGljb25DbGFzc2VzQ29weVxuXG4gICAgfSBlbHNlIGlmIChpY29uT3ZlcnJpZGVIYXNoID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5pY29uQ2xhc3NlcyA9IHt9XG4gICAgfVxuICB9XG5cblxuICBhcHBseUljb25PdmVycmlkZVByZWZpeChjbGFzc05hbWUpIHtcbiAgICBsZXQgcHJlZml4ID0gdGhpcy5pY29uT3ZlcnJpZGVQcmVmaXhcblxuICAgIGlmIChwcmVmaXggJiYgY2xhc3NOYW1lLmluZGV4T2YocHJlZml4KSAhPT0gMCkgeyAvLyBpZiBub3QgYWxyZWFkeSBwcmVzZW50XG4gICAgICBjbGFzc05hbWUgPSBwcmVmaXggKyBjbGFzc05hbWVcbiAgICB9XG5cbiAgICByZXR1cm4gY2xhc3NOYW1lXG4gIH1cblxuXG4gIGdldENsYXNzKGtleSkge1xuICAgIHJldHVybiB0aGlzLmNsYXNzZXNba2V5XSB8fCAnJ1xuICB9XG5cblxuICBnZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSwgaXNSdGw/OiBib29sZWFuKSB7XG4gICAgbGV0IGNsYXNzTmFtZVxuXG4gICAgaWYgKGlzUnRsICYmIHRoaXMucnRsSWNvbkNsYXNzZXMpIHtcbiAgICAgIGNsYXNzTmFtZSA9IHRoaXMucnRsSWNvbkNsYXNzZXNbYnV0dG9uTmFtZV0gfHwgdGhpcy5pY29uQ2xhc3Nlc1tidXR0b25OYW1lXVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGNsYXNzTmFtZSA9IHRoaXMuaWNvbkNsYXNzZXNbYnV0dG9uTmFtZV1cbiAgICB9XG5cbiAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5iYXNlSWNvbkNsYXNzICsgJyAnICsgY2xhc3NOYW1lXG4gICAgfVxuXG4gICAgcmV0dXJuICcnXG4gIH1cblxuXG4gIGdldEN1c3RvbUJ1dHRvbkljb25DbGFzcyhjdXN0b21CdXR0b25Qcm9wcykge1xuICAgIGxldCBjbGFzc05hbWVcblxuICAgIGlmICh0aGlzLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbikge1xuICAgICAgY2xhc3NOYW1lID0gY3VzdG9tQnV0dG9uUHJvcHNbdGhpcy5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb25dXG5cbiAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUljb25DbGFzcyArICcgJyArIHRoaXMuYXBwbHlJY29uT3ZlcnJpZGVQcmVmaXgoY2xhc3NOYW1lKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJ1xuICB9XG5cbn1cblxuVGhlbWUucHJvdG90eXBlLmNsYXNzZXMgPSB7fVxuVGhlbWUucHJvdG90eXBlLmljb25DbGFzc2VzID0ge31cblRoZW1lLnByb3RvdHlwZS5iYXNlSWNvbkNsYXNzID0gJydcblRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVQcmVmaXggPSAnJ1xuXG5leHBvcnQgdHlwZSBUaGVtZUNsYXNzID0geyBuZXcoY2FsZW5kYXJPcHRpb25zOiBhbnkpOiBUaGVtZSB9XG4iLCJpbXBvcnQgeyBEdXJhdGlvbiB9IGZyb20gJy4vZGF0ZWxpYi9kdXJhdGlvbidcbmltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSAndHNsaWInXG5pbXBvcnQgeyBFbWl0dGVyIH0gZnJvbSAnLi9jb21tb24vRW1pdHRlcidcbmltcG9ydCB7IENhbGVuZGFyTGlzdGVuZXJzIH0gZnJvbSAnLi9vcHRpb25zJ1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgU2Nyb2xsUmVxdWVzdCB7XG4gIHRpbWU/OiBEdXJhdGlvblxuICBbb3RoZXJQcm9wOiBzdHJpbmddOiBhbnlcbn1cblxuZXhwb3J0IHR5cGUgU2Nyb2xsUmVxdWVzdEhhbmRsZXIgPSAocmVxdWVzdDogU2Nyb2xsUmVxdWVzdCkgPT4gYm9vbGVhblxuXG5cbmV4cG9ydCBjbGFzcyBTY3JvbGxSZXNwb25kZXIge1xuXG4gIHF1ZXVlZFJlcXVlc3Q6IFNjcm9sbFJlcXVlc3RcblxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZXhlY0Z1bmM6IFNjcm9sbFJlcXVlc3RIYW5kbGVyLFxuICAgIHByaXZhdGUgZW1pdHRlcjogRW1pdHRlcjxDYWxlbmRhckxpc3RlbmVycz4sXG4gICAgcHJpdmF0ZSBzY3JvbGxUaW1lOiBEdXJhdGlvblxuICApIHtcbiAgICBlbWl0dGVyLm9uKCdfc2Nyb2xsUmVxdWVzdCcsIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdClcbiAgICB0aGlzLmZpcmVJbml0aWFsU2Nyb2xsKClcbiAgfVxuXG5cbiAgZGV0YWNoKCkge1xuICAgIHRoaXMuZW1pdHRlci5vZmYoJ19zY3JvbGxSZXF1ZXN0JywgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0KVxuICB9XG5cblxuICB1cGRhdGUoaXNEYXRlc05ldzogYm9vbGVhbikge1xuICAgIGlmIChpc0RhdGVzTmV3KSB7XG4gICAgICB0aGlzLmZpcmVJbml0aWFsU2Nyb2xsKCkgLy8gd2lsbCBkcmFpblxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRyYWluKClcbiAgICB9XG4gIH1cblxuXG4gIHByaXZhdGUgZmlyZUluaXRpYWxTY3JvbGwoKSB7XG4gICAgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0KHtcbiAgICAgIHRpbWU6IHRoaXMuc2Nyb2xsVGltZVxuICAgIH0pXG4gIH1cblxuXG4gIHByaXZhdGUgaGFuZGxlU2Nyb2xsUmVxdWVzdCA9IChyZXF1ZXN0OiBTY3JvbGxSZXF1ZXN0KSA9PiB7XG4gICAgdGhpcy5xdWV1ZWRSZXF1ZXN0ID0gX19hc3NpZ24oe30sIHRoaXMucXVldWVkUmVxdWVzdCB8fCB7fSwgcmVxdWVzdClcbiAgICB0aGlzLmRyYWluKClcbiAgfVxuXG5cbiAgcHJpdmF0ZSBkcmFpbigpIHtcbiAgICBpZiAodGhpcy5xdWV1ZWRSZXF1ZXN0ICYmIHRoaXMuZXhlY0Z1bmModGhpcy5xdWV1ZWRSZXF1ZXN0KSkge1xuICAgICAgdGhpcy5xdWV1ZWRSZXF1ZXN0ID0gbnVsbFxuICAgIH1cbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBDYWxlbmRhckFwaSB9IGZyb20gJy4vQ2FsZW5kYXJBcGknXG5pbXBvcnQgeyBWaWV3QXBpIH0gZnJvbSAnLi9WaWV3QXBpJ1xuaW1wb3J0IHsgVGhlbWUgfSBmcm9tICcuL3RoZW1lL1RoZW1lJ1xuaW1wb3J0IHsgRGF0ZUVudiB9IGZyb20gJy4vZGF0ZWxpYi9lbnYnXG5pbXBvcnQgeyBQbHVnaW5Ib29rcyB9IGZyb20gJy4vcGx1Z2luLXN5c3RlbS1zdHJ1Y3QnXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSAnLi92ZG9tJ1xuaW1wb3J0IHsgU2Nyb2xsUmVzcG9uZGVyLCBTY3JvbGxSZXF1ZXN0SGFuZGxlciB9IGZyb20gJy4vU2Nyb2xsUmVzcG9uZGVyJ1xuaW1wb3J0IHsgRGF0ZVByb2ZpbGVHZW5lcmF0b3IgfSBmcm9tICcuL0RhdGVQcm9maWxlR2VuZXJhdG9yJ1xuaW1wb3J0IHsgVmlld1NwZWMgfSBmcm9tICcuL3N0cnVjdHMvdmlldy1zcGVjJ1xuaW1wb3J0IHsgQ2FsZW5kYXJEYXRhIH0gZnJvbSAnLi9yZWR1Y2Vycy9kYXRhLXR5cGVzJ1xuaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSAnLi9yZWR1Y2Vycy9BY3Rpb24nXG5pbXBvcnQgeyBFbWl0dGVyIH0gZnJvbSAnLi9jb21tb24vRW1pdHRlcidcbmltcG9ydCB7IEludGVyYWN0aW9uU2V0dGluZ3NJbnB1dCB9IGZyb20gJy4vaW50ZXJhY3Rpb25zL2ludGVyYWN0aW9uJ1xuaW1wb3J0IHsgRGF0ZUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50L0RhdGVDb21wb25lbnQnXG5pbXBvcnQgeyBDYWxlbmRhckNvbnRleHQgfSBmcm9tICcuL0NhbGVuZGFyQ29udGV4dCdcbmltcG9ydCB7IGNyZWF0ZUR1cmF0aW9uIH0gZnJvbSAnLi9kYXRlbGliL2R1cmF0aW9uJ1xuaW1wb3J0IHsgVmlld09wdGlvbnNSZWZpbmVkLCBDYWxlbmRhckxpc3RlbmVycyB9IGZyb20gJy4vb3B0aW9ucydcblxuZXhwb3J0IGNvbnN0IFZpZXdDb250ZXh0VHlwZSA9IGNyZWF0ZUNvbnRleHQ8Vmlld0NvbnRleHQ+KHt9IGFzIGFueSkgLy8gZm9yIENvbXBvbmVudHNcbmV4cG9ydCB0eXBlIFJlc2l6ZUhhbmRsZXIgPSAoZm9yY2U6IGJvb2xlYW4pID0+IHZvaWRcblxuLypcbml0J3MgaW1wb3J0YW50IHRoYXQgVmlld0NvbnRleHQgZXh0ZW5kcyBDYWxlbmRhckNvbnRleHQgc28gdGhhdCBjb21wb25lbnRzIHRoYXQgc3Vic2NyaWJlIHRvIFZpZXdDb250ZXh0XG5jYW4gcGFzcyBpbiB0aGVpciBWaWV3Q29udGV4dCB0byB1dGlsIGZ1bmN0aW9ucyB0aGF0IGFjY2VwdCBDYWxlbmRhckNvbnRleHQuXG4qL1xuZXhwb3J0IGludGVyZmFjZSBWaWV3Q29udGV4dCBleHRlbmRzIENhbGVuZGFyQ29udGV4dCB7XG4gIG9wdGlvbnM6IFZpZXdPcHRpb25zUmVmaW5lZCAvLyBtb3JlIHNwZWNpZmljIHRoYW4gQmFzZU9wdGlvbnNSZWZpbmVkXG4gIHRoZW1lOiBUaGVtZVxuICBpc1J0bDogYm9vbGVhblxuICBkYXRlUHJvZmlsZUdlbmVyYXRvcjogRGF0ZVByb2ZpbGVHZW5lcmF0b3JcbiAgdmlld1NwZWM6IFZpZXdTcGVjXG4gIHZpZXdBcGk6IFZpZXdBcGlcbiAgYWRkUmVzaXplSGFuZGxlcjogKGhhbmRsZXI6IFJlc2l6ZUhhbmRsZXIpID0+IHZvaWRcbiAgcmVtb3ZlUmVzaXplSGFuZGxlcjogKGhhbmRsZXI6IFJlc2l6ZUhhbmRsZXIpID0+IHZvaWRcbiAgY3JlYXRlU2Nyb2xsUmVzcG9uZGVyOiAoZXhlY0Z1bmM6IFNjcm9sbFJlcXVlc3RIYW5kbGVyKSA9PiBTY3JvbGxSZXNwb25kZXJcbiAgcmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudDogKGNvbXBvbmVudDogRGF0ZUNvbXBvbmVudDxhbnk+LCBzZXR0aW5nc0lucHV0OiBJbnRlcmFjdGlvblNldHRpbmdzSW5wdXQpID0+IHZvaWRcbiAgdW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50OiAoY29tcG9uZW50OiBEYXRlQ29tcG9uZW50PGFueT4pID0+IHZvaWRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkVmlld0NvbnRleHQoXG4gIHZpZXdTcGVjOiBWaWV3U3BlYyxcbiAgdmlld0FwaTogVmlld0FwaSxcbiAgdmlld09wdGlvbnM6IFZpZXdPcHRpb25zUmVmaW5lZCxcbiAgZGF0ZVByb2ZpbGVHZW5lcmF0b3I6IERhdGVQcm9maWxlR2VuZXJhdG9yLFxuICBkYXRlRW52OiBEYXRlRW52LFxuICB0aGVtZTogVGhlbWUsXG4gIHBsdWdpbkhvb2tzOiBQbHVnaW5Ib29rcyxcbiAgZGlzcGF0Y2g6IChhY3Rpb246IEFjdGlvbikgPT4gdm9pZCxcbiAgZ2V0Q3VycmVudERhdGE6ICgpID0+IENhbGVuZGFyRGF0YSxcbiAgZW1pdHRlcjogRW1pdHRlcjxDYWxlbmRhckxpc3RlbmVycz4sXG4gIGNhbGVuZGFyQXBpOiBDYWxlbmRhckFwaSxcbiAgcmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudDogKGNvbXBvbmVudDogRGF0ZUNvbXBvbmVudDxhbnk+LCBzZXR0aW5nc0lucHV0OiBJbnRlcmFjdGlvblNldHRpbmdzSW5wdXQpID0+IHZvaWQsXG4gIHVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudDogKGNvbXBvbmVudDogRGF0ZUNvbXBvbmVudDxhbnk+KSA9PiB2b2lkXG4pOiBWaWV3Q29udGV4dCB7XG4gIHJldHVybiB7XG4gICAgZGF0ZUVudixcbiAgICBvcHRpb25zOiB2aWV3T3B0aW9ucyxcbiAgICBwbHVnaW5Ib29rcyxcbiAgICBlbWl0dGVyLFxuICAgIGRpc3BhdGNoLFxuICAgIGdldEN1cnJlbnREYXRhLFxuICAgIGNhbGVuZGFyQXBpLFxuICAgIHZpZXdTcGVjLFxuICAgIHZpZXdBcGksXG4gICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3IsXG4gICAgdGhlbWUsXG4gICAgaXNSdGw6IHZpZXdPcHRpb25zLmRpcmVjdGlvbiA9PT0gJ3J0bCcsXG4gICAgYWRkUmVzaXplSGFuZGxlcihoYW5kbGVyOiBSZXNpemVIYW5kbGVyKSB7XG4gICAgICBlbWl0dGVyLm9uKCdfcmVzaXplJywgaGFuZGxlcilcbiAgICB9LFxuICAgIHJlbW92ZVJlc2l6ZUhhbmRsZXIoaGFuZGxlcjogUmVzaXplSGFuZGxlcikge1xuICAgICAgZW1pdHRlci5vZmYoJ19yZXNpemUnLCBoYW5kbGVyKVxuICAgIH0sXG4gICAgY3JlYXRlU2Nyb2xsUmVzcG9uZGVyKGV4ZWNGdW5jOiBTY3JvbGxSZXF1ZXN0SGFuZGxlcikge1xuICAgICAgcmV0dXJuIG5ldyBTY3JvbGxSZXNwb25kZXIoXG4gICAgICAgIGV4ZWNGdW5jLFxuICAgICAgICBlbWl0dGVyLFxuICAgICAgICBjcmVhdGVEdXJhdGlvbih2aWV3T3B0aW9ucy5zY3JvbGxUaW1lKVxuICAgICAgKVxuICAgIH0sXG4gICAgcmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCxcbiAgICB1bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnRcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBSZWYgfSBmcm9tICcuL3Zkb20nXG5pbXBvcnQgeyBWaWV3Q29udGV4dFR5cGUsIFZpZXdDb250ZXh0IH0gZnJvbSAnLi9WaWV3Q29udGV4dCdcbmltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSAndHNsaWInXG5pbXBvcnQgeyBjb21wYXJlT2JqcywgRXF1YWxpdHlGdW5jcywgZ2V0VW5lcXVhbFByb3BzIH0gZnJvbSAnLi91dGlsL29iamVjdCdcbmltcG9ydCB7IERpY3Rpb25hcnkgfSBmcm9tICcuL29wdGlvbnMnXG5cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFB1cmVDb21wb25lbnQ8UHJvcHM9RGljdGlvbmFyeSwgU3RhdGU9RGljdGlvbmFyeT4gZXh0ZW5kcyBDb21wb25lbnQ8UHJvcHMsIFN0YXRlPiB7XG5cbiAgc3RhdGljIGFkZFByb3BzRXF1YWxpdHkgPSBhZGRQcm9wc0VxdWFsaXR5XG4gIHN0YXRpYyBhZGRTdGF0ZUVxdWFsaXR5ID0gYWRkU3RhdGVFcXVhbGl0eVxuICBzdGF0aWMgY29udGV4dFR5cGUgPSBWaWV3Q29udGV4dFR5cGVcblxuICBjb250ZXh0OiBWaWV3Q29udGV4dFxuICBwcm9wRXF1YWxpdHk6IEVxdWFsaXR5RnVuY3M8UHJvcHM+XG4gIHN0YXRlRXF1YWxpdHk6IEVxdWFsaXR5RnVuY3M8U3RhdGU+XG4gIGRlYnVnOiBib29sZWFuXG5cblxuICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzOiBQcm9wcywgbmV4dFN0YXRlOiBTdGF0ZSkge1xuXG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKGdldFVuZXF1YWxQcm9wcyhuZXh0UHJvcHMsIHRoaXMucHJvcHMpLCBnZXRVbmVxdWFsUHJvcHMobmV4dFN0YXRlLCB0aGlzLnN0YXRlKSlcbiAgICB9XG5cbiAgICByZXR1cm4gIWNvbXBhcmVPYmpzKHRoaXMucHJvcHMsIG5leHRQcm9wcywgdGhpcy5wcm9wRXF1YWxpdHkpIHx8XG4gICAgICAhY29tcGFyZU9ianModGhpcy5zdGF0ZSwgbmV4dFN0YXRlLCB0aGlzLnN0YXRlRXF1YWxpdHkpXG4gIH1cblxufVxuXG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZS5wcm9wRXF1YWxpdHkgPSB7fVxuUHVyZUNvbXBvbmVudC5wcm90b3R5cGUuc3RhdGVFcXVhbGl0eSA9IHt9XG5cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VDb21wb25lbnQ8UHJvcHM9RGljdGlvbmFyeSwgU3RhdGU9RGljdGlvbmFyeT4gZXh0ZW5kcyBQdXJlQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuXG4gIHN0YXRpYyBjb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZVxuICBjb250ZXh0OiBWaWV3Q29udGV4dFxuXG59XG5cblxuZnVuY3Rpb24gYWRkUHJvcHNFcXVhbGl0eSh0aGlzOiB7IHByb3RvdHlwZTogeyBwcm9wRXF1YWxpdHk6IGFueSB9IH0sIHByb3BFcXVhbGl0eSkge1xuICBsZXQgaGFzaCA9IE9iamVjdC5jcmVhdGUodGhpcy5wcm90b3R5cGUucHJvcEVxdWFsaXR5KVxuICBfX2Fzc2lnbihoYXNoLCBwcm9wRXF1YWxpdHkpXG4gIHRoaXMucHJvdG90eXBlLnByb3BFcXVhbGl0eSA9IGhhc2hcbn1cblxuXG5mdW5jdGlvbiBhZGRTdGF0ZUVxdWFsaXR5KHRoaXM6IHsgcHJvdG90eXBlOiB7IHN0YXRlRXF1YWxpdHk6IGFueSB9IH0sIHN0YXRlRXF1YWxpdHkpIHtcbiAgbGV0IGhhc2ggPSBPYmplY3QuY3JlYXRlKHRoaXMucHJvdG90eXBlLnN0YXRlRXF1YWxpdHkpXG4gIF9fYXNzaWduKGhhc2gsIHN0YXRlRXF1YWxpdHkpXG4gIHRoaXMucHJvdG90eXBlLnN0YXRlRXF1YWxpdHkgPSBoYXNoXG59XG5cblxuLy8gdXNlIG90aGVyIG9uZVxuZXhwb3J0IGZ1bmN0aW9uIHNldFJlZjxSZWZUeXBlPihyZWY6IFJlZjxSZWZUeXBlPiB8IHZvaWQsIGN1cnJlbnQ6IFJlZlR5cGUpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZWYoY3VycmVudClcbiAgfSBlbHNlIGlmIChyZWYpIHtcbiAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzAyOVxuICAgIChyZWYgYXMgYW55KS5jdXJyZW50ID0gY3VycmVudFxuICB9XG59XG4iLCJpbXBvcnQgeyBmaWx0ZXJIYXNoLCBtYXBIYXNoIH0gZnJvbSAnLi4vdXRpbC9vYmplY3QnXG5pbXBvcnQgeyBFdmVudERlZiB9IGZyb20gJy4uL3N0cnVjdHMvZXZlbnQtZGVmJ1xuaW1wb3J0IHsgRXZlbnRJbnN0YW5jZSwgRXZlbnRJbnN0YW5jZUhhc2ggfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LWluc3RhbmNlJ1xuaW1wb3J0IHsgRXZlbnRJbnB1dCB9IGZyb20gJy4uL3N0cnVjdHMvZXZlbnQtcGFyc2UnXG5pbXBvcnQge1xuICBFdmVudFN0b3JlLFxuICBtZXJnZUV2ZW50U3RvcmVzLFxuICBjcmVhdGVFbXB0eUV2ZW50U3RvcmUsXG4gIGZpbHRlckV2ZW50U3RvcmVEZWZzLFxuICBleGNsdWRlU3ViRXZlbnRTdG9yZSxcbiAgcGFyc2VFdmVudHNcbn0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1zdG9yZSdcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gJy4vQWN0aW9uJ1xuaW1wb3J0IHsgRXZlbnRTb3VyY2VIYXNoLCBFdmVudFNvdXJjZSB9IGZyb20gJy4uL3N0cnVjdHMvZXZlbnQtc291cmNlJ1xuaW1wb3J0IHsgRGF0ZVJhbmdlIH0gZnJvbSAnLi4vZGF0ZWxpYi9kYXRlLXJhbmdlJ1xuaW1wb3J0IHsgRGF0ZVByb2ZpbGUgfSBmcm9tICcuLi9EYXRlUHJvZmlsZUdlbmVyYXRvcidcbmltcG9ydCB7IERhdGVFbnYgfSBmcm9tICcuLi9kYXRlbGliL2VudidcbmltcG9ydCB7IENhbGVuZGFyQ29udGV4dCB9IGZyb20gJy4uL0NhbGVuZGFyQ29udGV4dCdcbmltcG9ydCB7IGV4cGFuZFJlY3VycmluZyB9IGZyb20gJy4uL3N0cnVjdHMvcmVjdXJyaW5nLWV2ZW50J1xuXG5cbmV4cG9ydCBmdW5jdGlvbiByZWR1Y2VFdmVudFN0b3JlKGV2ZW50U3RvcmU6IEV2ZW50U3RvcmUsIGFjdGlvbjogQWN0aW9uLCBldmVudFNvdXJjZXM6IEV2ZW50U291cmNlSGFzaCwgZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpOiBFdmVudFN0b3JlIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuXG4gICAgY2FzZSAnUkVDRUlWRV9FVkVOVFMnOiAvLyByYXdcbiAgICAgIHJldHVybiByZWNlaXZlUmF3RXZlbnRzKFxuICAgICAgICBldmVudFN0b3JlLFxuICAgICAgICBldmVudFNvdXJjZXNbYWN0aW9uLnNvdXJjZUlkXSxcbiAgICAgICAgYWN0aW9uLmZldGNoSWQsXG4gICAgICAgIGFjdGlvbi5mZXRjaFJhbmdlLFxuICAgICAgICBhY3Rpb24ucmF3RXZlbnRzLFxuICAgICAgICBjb250ZXh0XG4gICAgICApXG5cbiAgICBjYXNlICdBRERfRVZFTlRTJzogLy8gYWxyZWFkeSBwYXJzZWQsIGJ1dCBub3QgZXhwYW5kZWRcbiAgICAgIHJldHVybiBhZGRFdmVudChcbiAgICAgICAgZXZlbnRTdG9yZSxcbiAgICAgICAgYWN0aW9uLmV2ZW50U3RvcmUsIC8vIG5ldyBvbmVzXG4gICAgICAgIGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsLFxuICAgICAgICBjb250ZXh0XG4gICAgICApXG5cbiAgICBjYXNlICdNRVJHRV9FVkVOVFMnOiAvLyBhbHJlYWR5IHBhcnNlZCBhbmQgZXhwYW5kZWRcbiAgICAgIHJldHVybiBtZXJnZUV2ZW50U3RvcmVzKGV2ZW50U3RvcmUsIGFjdGlvbi5ldmVudFN0b3JlKVxuXG4gICAgY2FzZSAnUFJFVic6IC8vIFRPRE86IGhvdyBkbyB3ZSB0cmFjayBhbGwgYWN0aW9ucyB0aGF0IGFmZmVjdCBkYXRlUHJvZmlsZSA6KFxuICAgIGNhc2UgJ05FWFQnOlxuICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcbiAgICBjYXNlICdDSEFOR0VfVklFV19UWVBFJzpcbiAgICAgIGlmIChkYXRlUHJvZmlsZSkge1xuICAgICAgICByZXR1cm4gZXhwYW5kUmVjdXJyaW5nKGV2ZW50U3RvcmUsIGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBjb250ZXh0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmVcbiAgICAgIH1cblxuICAgIGNhc2UgJ1JFTU9WRV9FVkVOVFMnOlxuICAgICAgcmV0dXJuIGV4Y2x1ZGVTdWJFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGFjdGlvbi5ldmVudFN0b3JlKVxuXG4gICAgY2FzZSAnUkVNT1ZFX0VWRU5UX1NPVVJDRSc6XG4gICAgICByZXR1cm4gZXhjbHVkZUV2ZW50c0J5U291cmNlSWQoZXZlbnRTdG9yZSwgYWN0aW9uLnNvdXJjZUlkKVxuXG4gICAgY2FzZSAnUkVNT1ZFX0FMTF9FVkVOVF9TT1VSQ0VTJzpcbiAgICAgIHJldHVybiBmaWx0ZXJFdmVudFN0b3JlRGVmcyhldmVudFN0b3JlLCBmdW5jdGlvbihldmVudERlZjogRXZlbnREZWYpIHtcbiAgICAgICAgcmV0dXJuICFldmVudERlZi5zb3VyY2VJZCAvLyBvbmx5IGtlZXAgZXZlbnRzIHdpdGggbm8gc291cmNlIGlkXG4gICAgICB9KVxuXG4gICAgY2FzZSAnUkVNT1ZFX0FMTF9FVkVOVFMnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpXG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGV2ZW50U3RvcmVcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHJlY2VpdmVSYXdFdmVudHMoXG4gIGV2ZW50U3RvcmU6IEV2ZW50U3RvcmUsXG4gIGV2ZW50U291cmNlOiBFdmVudFNvdXJjZTxhbnk+LFxuICBmZXRjaElkOiBzdHJpbmcsXG4gIGZldGNoUmFuZ2U6IERhdGVSYW5nZSB8IG51bGwsXG4gIHJhd0V2ZW50czogRXZlbnRJbnB1dFtdLFxuICBjb250ZXh0OiBDYWxlbmRhckNvbnRleHRcbik6IEV2ZW50U3RvcmUge1xuXG4gIGlmIChcbiAgICBldmVudFNvdXJjZSAmJiAvLyBub3QgYWxyZWFkeSByZW1vdmVkXG4gICAgZmV0Y2hJZCA9PT0gZXZlbnRTb3VyY2UubGF0ZXN0RmV0Y2hJZCAvLyBUT0RPOiB3aXNoIHRoaXMgbG9naWMgd2FzIGFsd2F5cyBpbiBldmVudC1zb3VyY2VzXG4gICkge1xuXG4gICAgbGV0IHN1YnNldCA9IHBhcnNlRXZlbnRzKFxuICAgICAgdHJhbnNmb3JtUmF3RXZlbnRzKHJhd0V2ZW50cywgZXZlbnRTb3VyY2UsIGNvbnRleHQpLFxuICAgICAgZXZlbnRTb3VyY2UsXG4gICAgICBjb250ZXh0XG4gICAgKVxuXG4gICAgaWYgKGZldGNoUmFuZ2UpIHtcbiAgICAgIHN1YnNldCA9IGV4cGFuZFJlY3VycmluZyhzdWJzZXQsIGZldGNoUmFuZ2UsIGNvbnRleHQpXG4gICAgfVxuXG4gICAgcmV0dXJuIG1lcmdlRXZlbnRTdG9yZXMoXG4gICAgICBleGNsdWRlRXZlbnRzQnlTb3VyY2VJZChldmVudFN0b3JlLCBldmVudFNvdXJjZS5zb3VyY2VJZCksXG4gICAgICBzdWJzZXRcbiAgICApXG4gIH1cblxuICByZXR1cm4gZXZlbnRTdG9yZVxufVxuXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVJhd0V2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlOiBFdmVudFNvdXJjZTxhbnk+LCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpIHtcbiAgbGV0IGNhbEVhY2hUcmFuc2Zvcm0gPSBjb250ZXh0Lm9wdGlvbnMuZXZlbnREYXRhVHJhbnNmb3JtXG4gIGxldCBzb3VyY2VFYWNoVHJhbnNmb3JtID0gZXZlbnRTb3VyY2UgPyBldmVudFNvdXJjZS5ldmVudERhdGFUcmFuc2Zvcm0gOiBudWxsXG5cbiAgaWYgKHNvdXJjZUVhY2hUcmFuc2Zvcm0pIHtcbiAgICByYXdFdmVudHMgPSB0cmFuc2Zvcm1FYWNoUmF3RXZlbnQocmF3RXZlbnRzLCBzb3VyY2VFYWNoVHJhbnNmb3JtKVxuICB9XG5cbiAgaWYgKGNhbEVhY2hUcmFuc2Zvcm0pIHtcbiAgICByYXdFdmVudHMgPSB0cmFuc2Zvcm1FYWNoUmF3RXZlbnQocmF3RXZlbnRzLCBjYWxFYWNoVHJhbnNmb3JtKVxuICB9XG5cbiAgcmV0dXJuIHJhd0V2ZW50c1xufVxuXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUVhY2hSYXdFdmVudChyYXdFdmVudHMsIGZ1bmMpIHtcbiAgbGV0IHJlZmluZWRFdmVudHNcblxuICBpZiAoIWZ1bmMpIHtcbiAgICByZWZpbmVkRXZlbnRzID0gcmF3RXZlbnRzXG4gIH0gZWxzZSB7XG4gICAgcmVmaW5lZEV2ZW50cyA9IFtdXG5cbiAgICBmb3IgKGxldCByYXdFdmVudCBvZiByYXdFdmVudHMpIHtcbiAgICAgIGxldCByZWZpbmVkRXZlbnQgPSBmdW5jKHJhd0V2ZW50KVxuXG4gICAgICBpZiAocmVmaW5lZEV2ZW50KSB7XG4gICAgICAgIHJlZmluZWRFdmVudHMucHVzaChyZWZpbmVkRXZlbnQpXG4gICAgICB9IGVsc2UgaWYgKHJlZmluZWRFdmVudCA9PSBudWxsKSB7XG4gICAgICAgIHJlZmluZWRFdmVudHMucHVzaChyYXdFdmVudClcbiAgICAgIH0gLy8gaWYgYSBkaWZmZXJlbnQgZmFsc3kgdmFsdWUsIGRvIG5vdGhpbmdcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVmaW5lZEV2ZW50c1xufVxuXG5cbmZ1bmN0aW9uIGFkZEV2ZW50KGV2ZW50U3RvcmU6IEV2ZW50U3RvcmUsIHN1YnNldDogRXZlbnRTdG9yZSwgZXhwYW5kUmFuZ2U6IERhdGVSYW5nZSB8IG51bGwsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCk6IEV2ZW50U3RvcmUge1xuXG4gIGlmIChleHBhbmRSYW5nZSkge1xuICAgIHN1YnNldCA9IGV4cGFuZFJlY3VycmluZyhzdWJzZXQsIGV4cGFuZFJhbmdlLCBjb250ZXh0KVxuICB9XG5cbiAgcmV0dXJuIG1lcmdlRXZlbnRTdG9yZXMoZXZlbnRTdG9yZSwgc3Vic2V0KVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiByZXpvbmVFdmVudFN0b3JlRGF0ZXMoZXZlbnRTdG9yZTogRXZlbnRTdG9yZSwgb2xkRGF0ZUVudjogRGF0ZUVudiwgbmV3RGF0ZUVudjogRGF0ZUVudik6IEV2ZW50U3RvcmUge1xuICBsZXQgZGVmcyA9IGV2ZW50U3RvcmUuZGVmc1xuXG4gIGxldCBpbnN0YW5jZXMgPSBtYXBIYXNoKGV2ZW50U3RvcmUuaW5zdGFuY2VzLCBmdW5jdGlvbihpbnN0YW5jZTogRXZlbnRJbnN0YW5jZSk6IEV2ZW50SW5zdGFuY2Uge1xuICAgIGxldCBkZWYgPSBkZWZzW2luc3RhbmNlLmRlZklkXVxuXG4gICAgaWYgKGRlZi5hbGxEYXkgfHwgZGVmLnJlY3VycmluZ0RlZikge1xuICAgICAgcmV0dXJuIGluc3RhbmNlIC8vIGlzbid0IGRlcGVuZGVudCBvbiB0aW1lem9uZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5pbnN0YW5jZSxcbiAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICBzdGFydDogbmV3RGF0ZUVudi5jcmVhdGVNYXJrZXIob2xkRGF0ZUVudi50b0RhdGUoaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvKSksXG4gICAgICAgICAgZW5kOiBuZXdEYXRlRW52LmNyZWF0ZU1hcmtlcihvbGREYXRlRW52LnRvRGF0ZShpbnN0YW5jZS5yYW5nZS5lbmQsIGluc3RhbmNlLmZvcmNlZEVuZFR6bykpXG4gICAgICAgIH0sXG4gICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBuZXdEYXRlRW52LmNhbkNvbXB1dGVPZmZzZXQgPyBudWxsIDogaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sXG4gICAgICAgIGZvcmNlZEVuZFR6bzogbmV3RGF0ZUVudi5jYW5Db21wdXRlT2Zmc2V0ID8gbnVsbCA6IGluc3RhbmNlLmZvcmNlZEVuZFR6b1xuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4geyBkZWZzLCBpbnN0YW5jZXMgfVxufVxuXG5cbmZ1bmN0aW9uIGV4Y2x1ZGVFdmVudHNCeVNvdXJjZUlkKGV2ZW50U3RvcmU6IEV2ZW50U3RvcmUsIHNvdXJjZUlkOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIGZ1bmN0aW9uKGV2ZW50RGVmOiBFdmVudERlZikge1xuICAgIHJldHVybiBldmVudERlZi5zb3VyY2VJZCAhPT0gc291cmNlSWRcbiAgfSlcbn1cblxuXG4vLyBRVUVTVElPTjogd2h5IG5vdCBqdXN0IHJldHVybiBpbnN0YW5jZXM/IGRvIGEgZ2VuZXJhbCBvYmplY3QtcHJvcGVydHktZXhjbHVzaW9uIHV0aWxcbmV4cG9ydCBmdW5jdGlvbiBleGNsdWRlSW5zdGFuY2VzKGV2ZW50U3RvcmU6IEV2ZW50U3RvcmUsIHJlbW92YWxzOiBFdmVudEluc3RhbmNlSGFzaCk6IEV2ZW50U3RvcmUge1xuICByZXR1cm4ge1xuICAgIGRlZnM6IGV2ZW50U3RvcmUuZGVmcyxcbiAgICBpbnN0YW5jZXM6IGZpbHRlckhhc2goZXZlbnRTdG9yZS5pbnN0YW5jZXMsIGZ1bmN0aW9uKGluc3RhbmNlOiBFdmVudEluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gIXJlbW92YWxzW2luc3RhbmNlLmluc3RhbmNlSWRdXG4gICAgfSlcbiAgfVxufVxuIiwiaW1wb3J0IHsgRXZlbnRTdG9yZSwgZmlsdGVyRXZlbnRTdG9yZURlZnMgfSBmcm9tICcuL3N0cnVjdHMvZXZlbnQtc3RvcmUnXG5pbXBvcnQgeyBEYXRlU3BhbiB9IGZyb20gJy4vc3RydWN0cy9kYXRlLXNwYW4nXG5pbXBvcnQgeyByYW5nZUNvbnRhaW5zUmFuZ2UsIHJhbmdlc0ludGVyc2VjdCwgRGF0ZVJhbmdlLCBPcGVuRGF0ZVJhbmdlIH0gZnJvbSAnLi9kYXRlbGliL2RhdGUtcmFuZ2UnXG5pbXBvcnQgeyBFdmVudEFwaSB9IGZyb20gJy4vYXBpL0V2ZW50QXBpJ1xuaW1wb3J0IHsgY29tcGlsZUV2ZW50VWlzIH0gZnJvbSAnLi9jb21wb25lbnQvZXZlbnQtcmVuZGVyaW5nJ1xuaW1wb3J0IHsgZXhjbHVkZUluc3RhbmNlcyB9IGZyb20gJy4vcmVkdWNlcnMvZXZlbnRTdG9yZSdcbmltcG9ydCB7IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSB9IGZyb20gJy4vaW50ZXJhY3Rpb25zL2V2ZW50LWludGVyYWN0aW9uLXN0YXRlJ1xuaW1wb3J0IHsgU3BsaXR0YWJsZVByb3BzIH0gZnJvbSAnLi9jb21wb25lbnQvZXZlbnQtc3BsaXR0aW5nJ1xuaW1wb3J0IHsgbWFwSGFzaCB9IGZyb20gJy4vdXRpbC9vYmplY3QnXG5pbXBvcnQgeyBDYWxlbmRhckNvbnRleHQgfSBmcm9tICcuL0NhbGVuZGFyQ29udGV4dCdcbmltcG9ydCB7IGJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dCB9IGZyb20gJy4vY2FsZW5kYXItdXRpbHMnXG5pbXBvcnQgeyBDb25zdHJhaW50IH0gZnJvbSAnLi9zdHJ1Y3RzL2NvbnN0cmFpbnQnXG5pbXBvcnQgeyBleHBhbmRSZWN1cnJpbmcgfSBmcm9tICcuL3N0cnVjdHMvcmVjdXJyaW5nLWV2ZW50J1xuXG5cbi8vIGhpZ2gtbGV2ZWwgc2VnbWVudGluZy1hd2FyZSB0ZXN0ZXIgZnVuY3Rpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5leHBvcnQgZnVuY3Rpb24gaXNJbnRlcmFjdGlvblZhbGlkKGludGVyYWN0aW9uOiBFdmVudEludGVyYWN0aW9uU3RhdGUsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCkge1xuICByZXR1cm4gaXNOZXdQcm9wc1ZhbGlkKHsgZXZlbnREcmFnOiBpbnRlcmFjdGlvbiB9LCBjb250ZXh0KSAvLyBIQUNLOiB0aGUgZXZlbnREcmFnIHByb3BzIGlzIHVzZWQgZm9yIEFMTCBpbnRlcmFjdGlvbnNcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gaXNEYXRlU2VsZWN0aW9uVmFsaWQoZGF0ZVNlbGVjdGlvbjogRGF0ZVNwYW4sIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCkge1xuICByZXR1cm4gaXNOZXdQcm9wc1ZhbGlkKHsgZGF0ZVNlbGVjdGlvbiB9LCBjb250ZXh0KVxufVxuXG5cbmZ1bmN0aW9uIGlzTmV3UHJvcHNWYWxpZChuZXdQcm9wcywgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KSB7XG4gIGxldCBjYWxlbmRhclN0YXRlID0gY29udGV4dC5nZXRDdXJyZW50RGF0YSgpXG5cbiAgbGV0IHByb3BzID0ge1xuICAgIGJ1c2luZXNzSG91cnM6IGNhbGVuZGFyU3RhdGUuYnVzaW5lc3NIb3VycyxcbiAgICBkYXRlU2VsZWN0aW9uOiAnJyxcbiAgICBldmVudFN0b3JlOiBjYWxlbmRhclN0YXRlLmV2ZW50U3RvcmUsXG4gICAgZXZlbnRVaUJhc2VzOiBjYWxlbmRhclN0YXRlLmV2ZW50VWlCYXNlcyxcbiAgICBldmVudFNlbGVjdGlvbjogJycsXG4gICAgZXZlbnREcmFnOiBudWxsLFxuICAgIGV2ZW50UmVzaXplOiBudWxsLFxuICAgIC4uLm5ld1Byb3BzXG4gIH1cblxuICByZXR1cm4gKGNvbnRleHQucGx1Z2luSG9va3MuaXNQcm9wc1ZhbGlkIHx8IGlzUHJvcHNWYWxpZCkocHJvcHMsIGNvbnRleHQpXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUHJvcHNWYWxpZChzdGF0ZTogU3BsaXR0YWJsZVByb3BzLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQsIGRhdGVTcGFuTWV0YSA9IHt9LCBmaWx0ZXJDb25maWc/KTogYm9vbGVhbiB7XG5cbiAgaWYgKHN0YXRlLmV2ZW50RHJhZyAmJiAhaXNJbnRlcmFjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKHN0YXRlLmRhdGVTZWxlY3Rpb24gJiYgIWlzRGF0ZVNlbGVjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuXG4vLyBNb3ZpbmcgRXZlbnQgVmFsaWRhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGlzSW50ZXJhY3Rpb25Qcm9wc1ZhbGlkKHN0YXRlOiBTcGxpdHRhYmxlUHJvcHMsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCwgZGF0ZVNwYW5NZXRhOiBhbnksIGZpbHRlckNvbmZpZyk6IGJvb2xlYW4ge1xuICBsZXQgY3VycmVudFN0YXRlID0gY29udGV4dC5nZXRDdXJyZW50RGF0YSgpXG4gIGxldCBpbnRlcmFjdGlvbiA9IHN0YXRlLmV2ZW50RHJhZyAvLyBIQUNLOiB0aGUgZXZlbnREcmFnIHByb3BzIGlzIHVzZWQgZm9yIEFMTCBpbnRlcmFjdGlvbnNcblxuICBsZXQgc3ViamVjdEV2ZW50U3RvcmUgPSBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzXG4gIGxldCBzdWJqZWN0RGVmcyA9IHN1YmplY3RFdmVudFN0b3JlLmRlZnNcbiAgbGV0IHN1YmplY3RJbnN0YW5jZXMgPSBzdWJqZWN0RXZlbnRTdG9yZS5pbnN0YW5jZXNcbiAgbGV0IHN1YmplY3RDb25maWdzID0gY29tcGlsZUV2ZW50VWlzKFxuICAgIHN1YmplY3REZWZzLFxuICAgIGludGVyYWN0aW9uLmlzRXZlbnQgP1xuICAgICAgc3RhdGUuZXZlbnRVaUJhc2VzIDpcbiAgICAgIHsgJyc6IGN1cnJlbnRTdGF0ZS5zZWxlY3Rpb25Db25maWcgfSAvLyBpZiBub3QgYSByZWFsIGV2ZW50LCB2YWxpZGF0ZSBhcyBhIHNlbGVjdGlvblxuICApXG5cbiAgaWYgKGZpbHRlckNvbmZpZykge1xuICAgIHN1YmplY3RDb25maWdzID0gbWFwSGFzaChzdWJqZWN0Q29uZmlncywgZmlsdGVyQ29uZmlnKVxuICB9XG5cbiAgbGV0IG90aGVyRXZlbnRTdG9yZSA9IGV4Y2x1ZGVJbnN0YW5jZXMoc3RhdGUuZXZlbnRTdG9yZSwgaW50ZXJhY3Rpb24uYWZmZWN0ZWRFdmVudHMuaW5zdGFuY2VzKSAvLyBleGNsdWRlIHRoZSBzdWJqZWN0IGV2ZW50cy4gVE9ETzogZXhjbHVkZSBkZWZzIHRvbz9cbiAgbGV0IG90aGVyRGVmcyA9IG90aGVyRXZlbnRTdG9yZS5kZWZzXG4gIGxldCBvdGhlckluc3RhbmNlcyA9IG90aGVyRXZlbnRTdG9yZS5pbnN0YW5jZXNcbiAgbGV0IG90aGVyQ29uZmlncyA9IGNvbXBpbGVFdmVudFVpcyhvdGhlckRlZnMsIHN0YXRlLmV2ZW50VWlCYXNlcylcblxuICBmb3IgKGxldCBzdWJqZWN0SW5zdGFuY2VJZCBpbiBzdWJqZWN0SW5zdGFuY2VzKSB7XG4gICAgbGV0IHN1YmplY3RJbnN0YW5jZSA9IHN1YmplY3RJbnN0YW5jZXNbc3ViamVjdEluc3RhbmNlSWRdXG4gICAgbGV0IHN1YmplY3RSYW5nZSA9IHN1YmplY3RJbnN0YW5jZS5yYW5nZVxuICAgIGxldCBzdWJqZWN0Q29uZmlnID0gc3ViamVjdENvbmZpZ3Nbc3ViamVjdEluc3RhbmNlLmRlZklkXVxuICAgIGxldCBzdWJqZWN0RGVmID0gc3ViamVjdERlZnNbc3ViamVjdEluc3RhbmNlLmRlZklkXVxuXG4gICAgLy8gY29uc3RyYWludFxuICAgIGlmICghYWxsQ29uc3RyYWludHNQYXNzKHN1YmplY3RDb25maWcuY29uc3RyYWludHMsIHN1YmplY3RSYW5nZSwgb3RoZXJFdmVudFN0b3JlLCBzdGF0ZS5idXNpbmVzc0hvdXJzLCBjb250ZXh0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gb3ZlcmxhcFxuXG4gICAgbGV0IHsgZXZlbnRPdmVybGFwIH0gPSBjb250ZXh0Lm9wdGlvbnNcbiAgICBsZXQgZXZlbnRPdmVybGFwRnVuYyA9IHR5cGVvZiBldmVudE92ZXJsYXAgPT09ICdmdW5jdGlvbicgPyBldmVudE92ZXJsYXAgOiBudWxsXG5cbiAgICBmb3IgKGxldCBvdGhlckluc3RhbmNlSWQgaW4gb3RoZXJJbnN0YW5jZXMpIHtcbiAgICAgIGxldCBvdGhlckluc3RhbmNlID0gb3RoZXJJbnN0YW5jZXNbb3RoZXJJbnN0YW5jZUlkXVxuXG4gICAgICAvLyBpbnRlcnNlY3QhIGV2YWx1YXRlXG4gICAgICBpZiAocmFuZ2VzSW50ZXJzZWN0KHN1YmplY3RSYW5nZSwgb3RoZXJJbnN0YW5jZS5yYW5nZSkpIHtcbiAgICAgICAgbGV0IG90aGVyT3ZlcmxhcCA9IG90aGVyQ29uZmlnc1tvdGhlckluc3RhbmNlLmRlZklkXS5vdmVybGFwXG5cbiAgICAgICAgLy8gY29uc2lkZXIgdGhlIG90aGVyIGV2ZW50J3Mgb3ZlcmxhcC4gb25seSBkbyB0aGlzIGlmIHRoZSBzdWJqZWN0IGV2ZW50IGlzIGEgXCJyZWFsXCIgZXZlbnRcbiAgICAgICAgaWYgKG90aGVyT3ZlcmxhcCA9PT0gZmFsc2UgJiYgaW50ZXJhY3Rpb24uaXNFdmVudCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN1YmplY3RDb25maWcub3ZlcmxhcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudE92ZXJsYXBGdW5jICYmICFldmVudE92ZXJsYXBGdW5jKFxuICAgICAgICAgIG5ldyBFdmVudEFwaShjb250ZXh0LCBvdGhlckRlZnNbb3RoZXJJbnN0YW5jZS5kZWZJZF0sIG90aGVySW5zdGFuY2UpLCAvLyBzdGlsbCBldmVudFxuICAgICAgICAgIG5ldyBFdmVudEFwaShjb250ZXh0LCBzdWJqZWN0RGVmLCBzdWJqZWN0SW5zdGFuY2UpIC8vIG1vdmluZyBldmVudFxuICAgICAgICApKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbGxvdyAoYSBmdW5jdGlvbilcblxuICAgIGxldCBjYWxlbmRhckV2ZW50U3RvcmUgPSBjdXJyZW50U3RhdGUuZXZlbnRTdG9yZSAvLyBuZWVkIGdsb2JhbC10by1jYWxlbmRhciwgbm90IGxvY2FsIHRvIGNvbXBvbmVudCAoc3BsaXR0YWJsZSlzdGF0ZVxuXG4gICAgZm9yIChsZXQgc3ViamVjdEFsbG93IG9mIHN1YmplY3RDb25maWcuYWxsb3dzKSB7XG5cbiAgICAgIGxldCBzdWJqZWN0RGF0ZVNwYW46IERhdGVTcGFuID0ge1xuICAgICAgICAuLi5kYXRlU3Bhbk1ldGEsXG4gICAgICAgIHJhbmdlOiBzdWJqZWN0SW5zdGFuY2UucmFuZ2UsXG4gICAgICAgIGFsbERheTogc3ViamVjdERlZi5hbGxEYXlcbiAgICAgIH1cblxuICAgICAgbGV0IG9yaWdEZWYgPSBjYWxlbmRhckV2ZW50U3RvcmUuZGVmc1tzdWJqZWN0RGVmLmRlZklkXVxuICAgICAgbGV0IG9yaWdJbnN0YW5jZSA9IGNhbGVuZGFyRXZlbnRTdG9yZS5pbnN0YW5jZXNbc3ViamVjdEluc3RhbmNlSWRdXG4gICAgICBsZXQgZXZlbnRBcGlcblxuICAgICAgaWYgKG9yaWdEZWYpIHsgLy8gd2FzIHByZXZpb3VzbHkgaW4gdGhlIGNhbGVuZGFyXG4gICAgICAgIGV2ZW50QXBpID0gbmV3IEV2ZW50QXBpKGNvbnRleHQsIG9yaWdEZWYsIG9yaWdJbnN0YW5jZSlcblxuICAgICAgfSBlbHNlIHsgLy8gd2FzIGFuIGV4dGVybmFsIGV2ZW50XG4gICAgICAgIGV2ZW50QXBpID0gbmV3IEV2ZW50QXBpKGNvbnRleHQsIHN1YmplY3REZWYpIC8vIG5vIGluc3RhbmNlLCBiZWNhdXNlIGhhZCBubyBkYXRlc1xuICAgICAgfVxuXG4gICAgICBpZiAoIXN1YmplY3RBbGxvdyhcbiAgICAgICAgYnVpbGREYXRlU3BhbkFwaVdpdGhDb250ZXh0KHN1YmplY3REYXRlU3BhbiwgY29udGV4dCksXG4gICAgICAgIGV2ZW50QXBpXG4gICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuXG4vLyBEYXRlIFNlbGVjdGlvbiBWYWxpZGF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gaXNEYXRlU2VsZWN0aW9uUHJvcHNWYWxpZChzdGF0ZTogU3BsaXR0YWJsZVByb3BzLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQsIGRhdGVTcGFuTWV0YTogYW55LCBmaWx0ZXJDb25maWcpOiBib29sZWFuIHtcbiAgbGV0IHJlbGV2YW50RXZlbnRTdG9yZSA9IHN0YXRlLmV2ZW50U3RvcmVcbiAgbGV0IHJlbGV2YW50RGVmcyA9IHJlbGV2YW50RXZlbnRTdG9yZS5kZWZzXG4gIGxldCByZWxldmFudEluc3RhbmNlcyA9IHJlbGV2YW50RXZlbnRTdG9yZS5pbnN0YW5jZXNcblxuICBsZXQgc2VsZWN0aW9uID0gc3RhdGUuZGF0ZVNlbGVjdGlvblxuICBsZXQgc2VsZWN0aW9uUmFuZ2UgPSBzZWxlY3Rpb24ucmFuZ2VcbiAgbGV0IHsgc2VsZWN0aW9uQ29uZmlnIH0gPSBjb250ZXh0LmdldEN1cnJlbnREYXRhKClcblxuICBpZiAoZmlsdGVyQ29uZmlnKSB7XG4gICAgc2VsZWN0aW9uQ29uZmlnID0gZmlsdGVyQ29uZmlnKHNlbGVjdGlvbkNvbmZpZylcbiAgfVxuXG4gIC8vIGNvbnN0cmFpbnRcbiAgaWYgKCFhbGxDb25zdHJhaW50c1Bhc3Moc2VsZWN0aW9uQ29uZmlnLmNvbnN0cmFpbnRzLCBzZWxlY3Rpb25SYW5nZSwgcmVsZXZhbnRFdmVudFN0b3JlLCBzdGF0ZS5idXNpbmVzc0hvdXJzLCBjb250ZXh0KSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gb3ZlcmxhcFxuXG4gIGxldCB7IHNlbGVjdE92ZXJsYXAgfSA9IGNvbnRleHQub3B0aW9uc1xuICBsZXQgc2VsZWN0T3ZlcmxhcEZ1bmMgPSB0eXBlb2Ygc2VsZWN0T3ZlcmxhcCA9PT0gJ2Z1bmN0aW9uJyA/IHNlbGVjdE92ZXJsYXAgOiBudWxsXG5cbiAgZm9yIChsZXQgcmVsZXZhbnRJbnN0YW5jZUlkIGluIHJlbGV2YW50SW5zdGFuY2VzKSB7XG4gICAgbGV0IHJlbGV2YW50SW5zdGFuY2UgPSByZWxldmFudEluc3RhbmNlc1tyZWxldmFudEluc3RhbmNlSWRdXG5cbiAgICAvLyBpbnRlcnNlY3QhIGV2YWx1YXRlXG4gICAgaWYgKHJhbmdlc0ludGVyc2VjdChzZWxlY3Rpb25SYW5nZSwgcmVsZXZhbnRJbnN0YW5jZS5yYW5nZSkpIHtcblxuICAgICAgaWYgKHNlbGVjdGlvbkNvbmZpZy5vdmVybGFwID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdE92ZXJsYXBGdW5jICYmICFzZWxlY3RPdmVybGFwRnVuYyhcbiAgICAgICAgbmV3IEV2ZW50QXBpKGNvbnRleHQsIHJlbGV2YW50RGVmc1tyZWxldmFudEluc3RhbmNlLmRlZklkXSwgcmVsZXZhbnRJbnN0YW5jZSksXG4gICAgICAgIG51bGxcbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gYWxsb3cgKGEgZnVuY3Rpb24pXG4gIGZvciAobGV0IHNlbGVjdGlvbkFsbG93IG9mIHNlbGVjdGlvbkNvbmZpZy5hbGxvd3MpIHtcblxuICAgIGxldCBmdWxsRGF0ZVNwYW4gPSB7IC4uLmRhdGVTcGFuTWV0YSwgLi4uc2VsZWN0aW9uIH1cblxuICAgIGlmICghc2VsZWN0aW9uQWxsb3coXG4gICAgICBidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQoZnVsbERhdGVTcGFuLCBjb250ZXh0KSxcbiAgICAgIG51bGxcbiAgICApKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5cbi8vIENvbnN0cmFpbnQgVXRpbHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBhbGxDb25zdHJhaW50c1Bhc3MoXG4gIGNvbnN0cmFpbnRzOiBDb25zdHJhaW50W10sXG4gIHN1YmplY3RSYW5nZTogRGF0ZVJhbmdlLFxuICBvdGhlckV2ZW50U3RvcmU6IEV2ZW50U3RvcmUsXG4gIGJ1c2luZXNzSG91cnNVbmV4cGFuZGVkOiBFdmVudFN0b3JlLFxuICBjb250ZXh0OiBDYWxlbmRhckNvbnRleHRcbik6IGJvb2xlYW4ge1xuICBmb3IgKGxldCBjb25zdHJhaW50IG9mIGNvbnN0cmFpbnRzKSB7XG4gICAgaWYgKCFhbnlSYW5nZXNDb250YWluUmFuZ2UoXG4gICAgICBjb25zdHJhaW50VG9SYW5nZXMoY29uc3RyYWludCwgc3ViamVjdFJhbmdlLCBvdGhlckV2ZW50U3RvcmUsIGJ1c2luZXNzSG91cnNVbmV4cGFuZGVkLCBjb250ZXh0KSxcbiAgICAgIHN1YmplY3RSYW5nZVxuICAgICkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGNvbnN0cmFpbnRUb1JhbmdlcyhcbiAgY29uc3RyYWludDogQ29uc3RyYWludCxcbiAgc3ViamVjdFJhbmdlOiBEYXRlUmFuZ2UsIC8vIGZvciBleHBhbmRpbmcgYSByZWN1cnJpbmcgY29uc3RyYWludCwgb3IgZXhwYW5kaW5nIGJ1c2luZXNzIGhvdXJzXG4gIG90aGVyRXZlbnRTdG9yZTogRXZlbnRTdG9yZSwgLy8gZm9yIGlmIGNvbnN0cmFpbnQgaXMgYW4gZXZlbiBncm91cCBJRFxuICBidXNpbmVzc0hvdXJzVW5leHBhbmRlZDogRXZlbnRTdG9yZSwgLy8gZm9yIGlmIGNvbnN0cmFpbnQgaXMgJ2J1c2luZXNzSG91cnMnXG4gIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCAvLyBmb3IgZXhwYW5kaW5nIGJ1c2luZXNzaG91cnNcbik6IE9wZW5EYXRlUmFuZ2VbXSB7XG5cbiAgaWYgKGNvbnN0cmFpbnQgPT09ICdidXNpbmVzc0hvdXJzJykge1xuICAgIHJldHVybiBldmVudFN0b3JlVG9SYW5nZXMoXG4gICAgICBleHBhbmRSZWN1cnJpbmcoYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQsIHN1YmplY3RSYW5nZSwgY29udGV4dClcbiAgICApXG5cbiAgfSBlbHNlIGlmICh0eXBlb2YgY29uc3RyYWludCA9PT0gJ3N0cmluZycpIHsgLy8gYW4gZ3JvdXAgSURcbiAgICByZXR1cm4gZXZlbnRTdG9yZVRvUmFuZ2VzKFxuICAgICAgZmlsdGVyRXZlbnRTdG9yZURlZnMob3RoZXJFdmVudFN0b3JlLCBmdW5jdGlvbihldmVudERlZikge1xuICAgICAgICByZXR1cm4gZXZlbnREZWYuZ3JvdXBJZCA9PT0gY29uc3RyYWludFxuICAgICAgfSlcbiAgICApXG5cbiAgfSBlbHNlIGlmICh0eXBlb2YgY29uc3RyYWludCA9PT0gJ29iamVjdCcgJiYgY29uc3RyYWludCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICByZXR1cm4gZXZlbnRTdG9yZVRvUmFuZ2VzKFxuICAgICAgZXhwYW5kUmVjdXJyaW5nKGNvbnN0cmFpbnQsIHN1YmplY3RSYW5nZSwgY29udGV4dClcbiAgICApXG4gIH1cblxuICByZXR1cm4gW10gLy8gaWYgaXQncyBmYWxzZVxufVxuXG4vLyBUT0RPOiBtb3ZlIHRvIGV2ZW50LXN0b3JlIGZpbGU/XG5mdW5jdGlvbiBldmVudFN0b3JlVG9SYW5nZXMoZXZlbnRTdG9yZTogRXZlbnRTdG9yZSk6IERhdGVSYW5nZVtdIHtcbiAgbGV0IHsgaW5zdGFuY2VzIH0gPSBldmVudFN0b3JlXG4gIGxldCByYW5nZXM6IERhdGVSYW5nZVtdID0gW11cblxuICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgIHJhbmdlcy5wdXNoKGluc3RhbmNlc1tpbnN0YW5jZUlkXS5yYW5nZSlcbiAgfVxuXG4gIHJldHVybiByYW5nZXNcbn1cblxuLy8gVE9ETzogbW92ZSB0byBnZW9tIGZpbGU/XG5mdW5jdGlvbiBhbnlSYW5nZXNDb250YWluUmFuZ2Uob3V0ZXJSYW5nZXM6IERhdGVSYW5nZVtdLCBpbm5lclJhbmdlOiBEYXRlUmFuZ2UpOiBib29sZWFuIHtcblxuICBmb3IgKGxldCBvdXRlclJhbmdlIG9mIG91dGVyUmFuZ2VzKSB7XG4gICAgaWYgKHJhbmdlQ29udGFpbnNSYW5nZShvdXRlclJhbmdlLCBpbm5lclJhbmdlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cbiIsImltcG9ydCB7IEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi92ZG9tLXV0aWwnXG5pbXBvcnQgeyBFdmVudFJlbmRlclJhbmdlIH0gZnJvbSAnLi9ldmVudC1yZW5kZXJpbmcnXG5pbXBvcnQgeyBEYXRlU3BhbiB9IGZyb20gJy4uL3N0cnVjdHMvZGF0ZS1zcGFuJ1xuaW1wb3J0IHsgRXZlbnRJbnN0YW5jZUhhc2ggfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LWluc3RhbmNlJ1xuaW1wb3J0IHsgcmFuZ2VDb250YWluc1JhbmdlIH0gZnJvbSAnLi4vZGF0ZWxpYi9kYXRlLXJhbmdlJ1xuaW1wb3J0IHsgSGl0IH0gZnJvbSAnLi4vaW50ZXJhY3Rpb25zL2hpdCdcbmltcG9ydCB7IGVsZW1lbnRDbG9zZXN0IH0gZnJvbSAnLi4vdXRpbC9kb20tbWFuaXAnXG5pbXBvcnQgeyBpc0RhdGVTZWxlY3Rpb25WYWxpZCwgaXNJbnRlcmFjdGlvblZhbGlkIH0gZnJvbSAnLi4vdmFsaWRhdGlvbidcbmltcG9ydCB7IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSB9IGZyb20gJy4uL2ludGVyYWN0aW9ucy9ldmVudC1pbnRlcmFjdGlvbi1zdGF0ZSdcbmltcG9ydCB7IGd1aWQgfSBmcm9tICcuLi91dGlsL21pc2MnXG5pbXBvcnQgeyBEaWN0aW9uYXJ5IH0gZnJvbSAnLi4vb3B0aW9ucydcblxuZXhwb3J0IHR5cGUgRGF0ZUNvbXBvbmVudEhhc2ggPSB7IFt1aWQ6IHN0cmluZ106IERhdGVDb21wb25lbnQ8YW55LCBhbnk+IH1cblxuLy8gTk9URTogZm9yIGZnLWV2ZW50cywgZXZlbnRSYW5nZS5yYW5nZSBpcyBOT1Qgc2xpY2VkLFxuLy8gdGh1cywgd2UgbmVlZCBpc1N0YXJ0L2lzRW5kXG5leHBvcnQgaW50ZXJmYWNlIFNlZyB7XG4gIGNvbXBvbmVudD86IERhdGVDb21wb25lbnQ8YW55LCBhbnk+XG4gIGlzU3RhcnQ6IGJvb2xlYW5cbiAgaXNFbmQ6IGJvb2xlYW5cbiAgZXZlbnRSYW5nZT86IEV2ZW50UmVuZGVyUmFuZ2VcbiAgW290aGVyUHJvcDogc3RyaW5nXTogYW55IC8vIFRPRE86IHJlbW92ZSB0aGlzLiBleHRlbmRpbmcgU2VnIHdpbGwgaGFuZGxlIHRoaXNcbiAgZWw/OiBuZXZlclxuICAvLyBOT1RFOiBjYW4gc29tZXRpbWVzIGhhdmUgc3RhcnQvZW5kLCB3aGljaCBhcmUgaW1wb3J0YW50IHZhbHVlcyA6KFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV2ZW50U2VnVWlJbnRlcmFjdGlvblN0YXRlIHtcbiAgYWZmZWN0ZWRJbnN0YW5jZXM6IEV2ZW50SW5zdGFuY2VIYXNoXG4gIHNlZ3M6IFNlZ1tdXG4gIGlzRXZlbnQ6IGJvb2xlYW5cbn1cblxuLypcbmFuIElOVEVSQUNUQUJMRSBkYXRlIGNvbXBvbmVudFxuXG5QVVJQT1NFUzpcbi0gaG9vayB1cCB0byBmZywgZmlsbCwgYW5kIG1pcnJvciByZW5kZXJlcnNcbi0gaW50ZXJmYWNlIGZvciBkcmFnZ2luZyBhbmQgaGl0c1xuKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBEYXRlQ29tcG9uZW50PFByb3BzPURpY3Rpb25hcnksIFN0YXRlPURpY3Rpb25hcnk+IGV4dGVuZHMgQmFzZUNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcblxuICB1aWQgPSBndWlkKClcblxuICAvLyBJTiBTQ0hFRFVMRVI6IGFsbG93QWNyb3NzUmVzb3VyY2VzXG5cbiAgLy8gaWYgZGVmaW5lZCwgaG9sZHMgdGhlIHVuaXQgaWRlbnRpZmllZCAoZXg6IFwieWVhclwiIG9yIFwibW9udGhcIikgdGhhdCBkZXRlcm1pbmVzIHRoZSBsZXZlbCBvZiBncmFudWxhcml0eVxuICAvLyBvZiB0aGUgZGF0ZSBhcmVhcy4gaWYgbm90IGRlZmluZWQsIGFzc3VtZXMgdG8gYmUgZGF5IGFuZCB0aW1lIGdyYW51bGFyaXR5LlxuICAvLyBUT0RPOiBwb3J0IGlzVGltZVNjYWxlIGludG8gc2FtZSBzeXN0ZW0/XG4gIGxhcmdlVW5pdDogYW55XG5cblxuICAvLyBIaXQgU3lzdGVtXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICBwcmVwYXJlSGl0cygpIHtcbiAgfVxuXG5cbiAgcXVlcnlIaXQocG9zaXRpb25MZWZ0OiBudW1iZXIsIHBvc2l0aW9uVG9wOiBudW1iZXIsIGVsV2lkdGg6IG51bWJlciwgZWxIZWlnaHQ6IG51bWJlcik6IEhpdCB8IG51bGwge1xuICAgIHJldHVybiBudWxsIC8vIHRoaXMgc2hvdWxkIGJlIGFic3RyYWN0XG4gIH1cblxuXG4gIC8vIFZhbGlkYXRpb25cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBpc0ludGVyYWN0aW9uVmFsaWQoaW50ZXJhY3Rpb246IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSkge1xuICAgIGxldCBkYXRlUHJvZmlsZSA9ICh0aGlzLnByb3BzIGFzIGFueSkuZGF0ZVByb2ZpbGUgLy8gSEFDS1xuICAgIGxldCBpbnN0YW5jZXMgPSBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzLmluc3RhbmNlc1xuXG4gICAgaWYgKGRhdGVQcm9maWxlKSB7IC8vIEhBQ0sgZm9yIE1vcmVQb3BvdmVyXG4gICAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICBpZiAoIXJhbmdlQ29udGFpbnNSYW5nZShkYXRlUHJvZmlsZS52YWxpZFJhbmdlLCBpbnN0YW5jZXNbaW5zdGFuY2VJZF0ucmFuZ2UpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaXNJbnRlcmFjdGlvblZhbGlkKGludGVyYWN0aW9uLCB0aGlzLmNvbnRleHQpXG4gIH1cblxuICBpc0RhdGVTZWxlY3Rpb25WYWxpZChzZWxlY3Rpb246IERhdGVTcGFuKTogYm9vbGVhbiB7XG4gICAgbGV0IGRhdGVQcm9maWxlID0gKHRoaXMucHJvcHMgYXMgYW55KS5kYXRlUHJvZmlsZSAvLyBIQUNLXG5cbiAgICBpZiAoXG4gICAgICBkYXRlUHJvZmlsZSAmJiAvLyBIQUNLIGZvciBNb3JlUG9wb3ZlclxuICAgICAgIXJhbmdlQ29udGFpbnNSYW5nZShkYXRlUHJvZmlsZS52YWxpZFJhbmdlLCBzZWxlY3Rpb24ucmFuZ2UpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gaXNEYXRlU2VsZWN0aW9uVmFsaWQoc2VsZWN0aW9uLCB0aGlzLmNvbnRleHQpXG4gIH1cblxuXG4gIC8vIFBvaW50ZXIgSW50ZXJhY3Rpb24gVXRpbHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBpc1ZhbGlkU2VnRG93bkVsKGVsOiBIVE1MRWxlbWVudCkge1xuICAgIHJldHVybiAhKHRoaXMucHJvcHMgYXMgYW55KS5ldmVudERyYWcgJiYgLy8gSEFDS1xuICAgICAgISh0aGlzLnByb3BzIGFzIGFueSkuZXZlbnRSZXNpemUgJiYgLy8gSEFDS1xuICAgICAgIWVsZW1lbnRDbG9zZXN0KGVsLCAnLmZjLWV2ZW50LW1pcnJvcicpICYmXG4gICAgICAodGhpcy5pc1BvcG92ZXIoKSB8fCAhdGhpcy5pc0luUG9wb3ZlcihlbCkpXG4gICAgICAvLyBeYWJvdmUgbGluZSBlbnN1cmVzIHdlIGRvbid0IGRldGVjdCBhIHNlZyBpbnRlcmFjdGlvbiB3aXRoaW4gYSBuZXN0ZWQgY29tcG9uZW50LlxuICAgICAgLy8gaXQncyBhIEhBQ0sgYmVjYXVzZSBpdCBvbmx5IHN1cHBvcnRzIGEgcG9wb3ZlciBhcyB0aGUgbmVzdGVkIGNvbXBvbmVudC5cbiAgfVxuXG5cbiAgaXNWYWxpZERhdGVEb3duRWwoZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgcmV0dXJuICFlbGVtZW50Q2xvc2VzdChlbCwgJy5mYy1ldmVudDpub3QoLmZjLWJnLWV2ZW50KScpICYmXG4gICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtZGF5Z3JpZC1tb3JlLWxpbmsnKSAmJiAvLyBhIFwibW9yZS4uXCIgbGlua1xuICAgICAgIWVsZW1lbnRDbG9zZXN0KGVsLCAnYVtkYXRhLW5hdmxpbmtdJykgJiYgLy8gYSBjbGlja2FibGUgbmF2IGxpbmtcbiAgICAgICF0aGlzLmlzSW5Qb3BvdmVyKGVsKVxuICB9XG5cblxuICBpc1BvcG92ZXIoKSB7IC8vIEhBQ0suIHNob3VsZCBiZSBvdmVycmlkZGVuIGJ5IGFueSBjb21wb25lbnRzIHRoYXQga25vdyB0aGF0IHRoZXkgbGl2ZSB3aXRoaW4gYSBwb3BvdmVyXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuXG4gIGlzSW5Qb3BvdmVyKGVsOiBIVE1MRWxlbWVudCkge1xuICAgIHJldHVybiBCb29sZWFuKGVsZW1lbnRDbG9zZXN0KGVsLCAnLmZjLXBvcG92ZXInKSlcbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBndWlkIH0gZnJvbSAnLi91dGlsL21pc2MnXG5pbXBvcnQgeyBQbHVnaW5EZWZJbnB1dCwgUGx1Z2luRGVmLCBQbHVnaW5Ib29rcyB9IGZyb20gJy4vcGx1Z2luLXN5c3RlbS1zdHJ1Y3QnXG5pbXBvcnQgeyBpc0FycmF5c0VxdWFsIH0gZnJvbSAnLi91dGlsL2FycmF5J1xuXG5cbi8vIFRPRE86IGVhc2llciB3YXkgdG8gYWRkIG5ldyBob29rcz8gbmVlZCB0byB1cGRhdGUgYSBtaWxsaW9uIHRoaW5nc1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQbHVnaW4oaW5wdXQ6IFBsdWdpbkRlZklucHV0KTogUGx1Z2luRGVmIHtcbiAgcmV0dXJuIHtcbiAgICBpZDogZ3VpZCgpLFxuICAgIGRlcHM6IGlucHV0LmRlcHMgfHwgW10sXG4gICAgcmVkdWNlcnM6IGlucHV0LnJlZHVjZXJzIHx8IFtdLFxuICAgIGNvbnRleHRJbml0OiBbXS5jb25jYXQoaW5wdXQuY29udGV4dEluaXQgfHwgW10pLFxuICAgIGV2ZW50UmVmaW5lcnM6IGlucHV0LmV2ZW50UmVmaW5lcnMgfHwge30sXG4gICAgZXZlbnREZWZNZW1iZXJBZGRlcnM6IGlucHV0LmV2ZW50RGVmTWVtYmVyQWRkZXJzIHx8IFtdLFxuICAgIGV2ZW50U291cmNlUmVmaW5lcnM6IGlucHV0LmV2ZW50U291cmNlUmVmaW5lcnMgfHwge30sXG4gICAgaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM6IGlucHV0LmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzIHx8IFtdLFxuICAgIGV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzOiBpbnB1dC5ldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VycyB8fCBbXSxcbiAgICBldmVudERlZk11dGF0aW9uQXBwbGllcnM6IGlucHV0LmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycyB8fCBbXSxcbiAgICBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzOiBpbnB1dC5kYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzIHx8IFtdLFxuICAgIGRhdGVQb2ludFRyYW5zZm9ybXM6IGlucHV0LmRhdGVQb2ludFRyYW5zZm9ybXMgfHwgW10sXG4gICAgZGF0ZVNwYW5UcmFuc2Zvcm1zOiBpbnB1dC5kYXRlU3BhblRyYW5zZm9ybXMgfHwgW10sXG4gICAgdmlld3M6IGlucHV0LnZpZXdzIHx8IHt9LFxuICAgIHZpZXdQcm9wc1RyYW5zZm9ybWVyczogaW5wdXQudmlld1Byb3BzVHJhbnNmb3JtZXJzIHx8IFtdLFxuICAgIGlzUHJvcHNWYWxpZDogaW5wdXQuaXNQcm9wc1ZhbGlkIHx8IG51bGwsXG4gICAgZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zOiBpbnB1dC5leHRlcm5hbERlZlRyYW5zZm9ybXMgfHwgW10sXG4gICAgZXZlbnRSZXNpemVKb2luVHJhbnNmb3JtczogaW5wdXQuZXZlbnRSZXNpemVKb2luVHJhbnNmb3JtcyB8fCBbXSxcbiAgICB2aWV3Q29udGFpbmVyQXBwZW5kczogaW5wdXQudmlld0NvbnRhaW5lckFwcGVuZHMgfHwgW10sXG4gICAgZXZlbnREcm9wVHJhbnNmb3JtZXJzOiBpbnB1dC5ldmVudERyb3BUcmFuc2Zvcm1lcnMgfHwgW10sXG4gICAgY29tcG9uZW50SW50ZXJhY3Rpb25zOiBpbnB1dC5jb21wb25lbnRJbnRlcmFjdGlvbnMgfHwgW10sXG4gICAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IGlucHV0LmNhbGVuZGFySW50ZXJhY3Rpb25zIHx8IFtdLFxuICAgIHRoZW1lQ2xhc3NlczogaW5wdXQudGhlbWVDbGFzc2VzIHx8IHt9LFxuICAgIGV2ZW50U291cmNlRGVmczogaW5wdXQuZXZlbnRTb3VyY2VEZWZzIHx8IFtdLFxuICAgIGNtZEZvcm1hdHRlcjogaW5wdXQuY21kRm9ybWF0dGVyLFxuICAgIHJlY3VycmluZ1R5cGVzOiBpbnB1dC5yZWN1cnJpbmdUeXBlcyB8fCBbXSxcbiAgICBuYW1lZFRpbWVab25lZEltcGw6IGlucHV0Lm5hbWVkVGltZVpvbmVkSW1wbCxcbiAgICBpbml0aWFsVmlldzogaW5wdXQuaW5pdGlhbFZpZXcgfHwgJycsXG4gICAgZWxlbWVudERyYWdnaW5nSW1wbDogaW5wdXQuZWxlbWVudERyYWdnaW5nSW1wbCxcbiAgICBvcHRpb25DaGFuZ2VIYW5kbGVyczogaW5wdXQub3B0aW9uQ2hhbmdlSGFuZGxlcnMgfHwge30sXG4gICAgc2Nyb2xsR3JpZEltcGw6IGlucHV0LnNjcm9sbEdyaWRJbXBsIHx8IG51bGwsXG4gICAgY29udGVudFR5cGVIYW5kbGVyczogaW5wdXQuY29udGVudFR5cGVIYW5kbGVycyB8fCB7fSxcbiAgICBsaXN0ZW5lclJlZmluZXJzOiBpbnB1dC5saXN0ZW5lclJlZmluZXJzIHx8IHt9LFxuICAgIG9wdGlvblJlZmluZXJzOiBpbnB1dC5vcHRpb25SZWZpbmVycyB8fCB7fSxcbiAgICBwcm9wU2V0SGFuZGxlcnM6IGlucHV0LnByb3BTZXRIYW5kbGVycyB8fCB7fVxuICB9XG59XG5cblxuZnVuY3Rpb24gYnVpbGRQbHVnaW5Ib29rcyhwbHVnaW5EZWZzOiBQbHVnaW5EZWZbXSwgZ2xvYmFsRGVmczogUGx1Z2luRGVmW10pOiBQbHVnaW5Ib29rcyB7XG4gIGxldCBpc0FkZGVkOiB7IFtwbHVnaW5JZDogc3RyaW5nXTogYm9vbGVhbiB9ID0ge31cbiAgbGV0IGhvb2tzOiBQbHVnaW5Ib29rcyA9IHtcbiAgICByZWR1Y2VyczogW10sXG4gICAgY29udGV4dEluaXQ6IFtdLFxuICAgIGV2ZW50UmVmaW5lcnM6IHt9LFxuICAgIGV2ZW50RGVmTWVtYmVyQWRkZXJzOiBbXSxcbiAgICBldmVudFNvdXJjZVJlZmluZXJzOiB7fSxcbiAgICBpc0RyYWdnYWJsZVRyYW5zZm9ybWVyczogW10sXG4gICAgZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnM6IFtdLFxuICAgIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyczogW10sXG4gICAgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyczogW10sXG4gICAgZGF0ZVBvaW50VHJhbnNmb3JtczogW10sXG4gICAgZGF0ZVNwYW5UcmFuc2Zvcm1zOiBbXSxcbiAgICB2aWV3czoge30sXG4gICAgdmlld1Byb3BzVHJhbnNmb3JtZXJzOiBbXSxcbiAgICBpc1Byb3BzVmFsaWQ6IG51bGwsXG4gICAgZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zOiBbXSxcbiAgICBldmVudFJlc2l6ZUpvaW5UcmFuc2Zvcm1zOiBbXSxcbiAgICB2aWV3Q29udGFpbmVyQXBwZW5kczogW10sXG4gICAgZXZlbnREcm9wVHJhbnNmb3JtZXJzOiBbXSxcbiAgICBjb21wb25lbnRJbnRlcmFjdGlvbnM6IFtdLFxuICAgIGNhbGVuZGFySW50ZXJhY3Rpb25zOiBbXSxcbiAgICB0aGVtZUNsYXNzZXM6IHt9LFxuICAgIGV2ZW50U291cmNlRGVmczogW10sXG4gICAgY21kRm9ybWF0dGVyOiBudWxsLFxuICAgIHJlY3VycmluZ1R5cGVzOiBbXSxcbiAgICBuYW1lZFRpbWVab25lZEltcGw6IG51bGwsXG4gICAgaW5pdGlhbFZpZXc6ICcnLFxuICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IG51bGwsXG4gICAgb3B0aW9uQ2hhbmdlSGFuZGxlcnM6IHt9LFxuICAgIHNjcm9sbEdyaWRJbXBsOiBudWxsLFxuICAgIGNvbnRlbnRUeXBlSGFuZGxlcnM6IHt9LFxuICAgIGxpc3RlbmVyUmVmaW5lcnM6IHt9LFxuICAgIG9wdGlvblJlZmluZXJzOiB7fSxcbiAgICBwcm9wU2V0SGFuZGxlcnM6IHt9XG4gIH1cblxuICBmdW5jdGlvbiBhZGREZWZzKGRlZnM6IFBsdWdpbkRlZltdKSB7XG4gICAgZm9yIChsZXQgZGVmIG9mIGRlZnMpIHtcbiAgICAgIGlmICghaXNBZGRlZFtkZWYuaWRdKSB7XG4gICAgICAgIGlzQWRkZWRbZGVmLmlkXSA9IHRydWVcbiAgICAgICAgYWRkRGVmcyhkZWYuZGVwcylcbiAgICAgICAgaG9va3MgPSBjb21iaW5lSG9va3MoaG9va3MsIGRlZilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAocGx1Z2luRGVmcykge1xuICAgIGFkZERlZnMocGx1Z2luRGVmcylcbiAgfVxuXG4gIGFkZERlZnMoZ2xvYmFsRGVmcylcblxuICByZXR1cm4gaG9va3Ncbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRCdWlsZFBsdWdpbkhvb2tzKCkgeyAvLyBtZW1vaXplc1xuICBsZXQgY3VycmVudE92ZXJyaWRlRGVmczogUGx1Z2luRGVmW10gPSBbXVxuICBsZXQgY3VycmVudEdsb2JhbERlZnM6IFBsdWdpbkRlZltdID0gW11cbiAgbGV0IGN1cnJlbnRIb29rczogUGx1Z2luSG9va3NcblxuICByZXR1cm4gZnVuY3Rpb24ob3ZlcnJpZGVEZWZzOiBQbHVnaW5EZWZbXSwgZ2xvYmFsRGVmczogUGx1Z2luRGVmW10pIHtcbiAgICBpZiAoIWN1cnJlbnRIb29rcyB8fCAhaXNBcnJheXNFcXVhbChvdmVycmlkZURlZnMsIGN1cnJlbnRPdmVycmlkZURlZnMpIHx8ICFpc0FycmF5c0VxdWFsKGdsb2JhbERlZnMsIGN1cnJlbnRHbG9iYWxEZWZzKSkge1xuICAgICAgY3VycmVudEhvb2tzID0gYnVpbGRQbHVnaW5Ib29rcyhvdmVycmlkZURlZnMsIGdsb2JhbERlZnMpXG4gICAgfVxuICAgIGN1cnJlbnRPdmVycmlkZURlZnMgPSBvdmVycmlkZURlZnNcbiAgICBjdXJyZW50R2xvYmFsRGVmcyA9IGdsb2JhbERlZnNcbiAgICByZXR1cm4gY3VycmVudEhvb2tzXG4gIH1cbn1cblxuXG5mdW5jdGlvbiBjb21iaW5lSG9va3MoaG9va3MwOiBQbHVnaW5Ib29rcywgaG9va3MxOiBQbHVnaW5Ib29rcyk6IFBsdWdpbkhvb2tzIHtcbiAgcmV0dXJuIHtcbiAgICByZWR1Y2VyczogaG9va3MwLnJlZHVjZXJzLmNvbmNhdChob29rczEucmVkdWNlcnMpLFxuICAgIGNvbnRleHRJbml0OiBob29rczAuY29udGV4dEluaXQuY29uY2F0KGhvb2tzMS5jb250ZXh0SW5pdCksXG4gICAgZXZlbnRSZWZpbmVyczogeyAuLi5ob29rczAuZXZlbnRSZWZpbmVycywgLi4uaG9va3MxLmV2ZW50UmVmaW5lcnMgfSxcbiAgICBldmVudERlZk1lbWJlckFkZGVyczogaG9va3MwLmV2ZW50RGVmTWVtYmVyQWRkZXJzLmNvbmNhdChob29rczEuZXZlbnREZWZNZW1iZXJBZGRlcnMpLFxuICAgIGV2ZW50U291cmNlUmVmaW5lcnM6IHsgLi4uaG9va3MwLmV2ZW50U291cmNlUmVmaW5lcnMsIC4uLmhvb2tzMS5ldmVudFNvdXJjZVJlZmluZXJzIH0sXG4gICAgaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM6IGhvb2tzMC5pc0RyYWdnYWJsZVRyYW5zZm9ybWVycy5jb25jYXQoaG9va3MxLmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzKSxcbiAgICBldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VyczogaG9va3MwLmV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzLmNvbmNhdChob29rczEuZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnMpLFxuICAgIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyczogaG9va3MwLmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycy5jb25jYXQoaG9va3MxLmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycyksXG4gICAgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyczogaG9va3MwLmRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMuY29uY2F0KGhvb2tzMS5kYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzKSxcbiAgICBkYXRlUG9pbnRUcmFuc2Zvcm1zOiBob29rczAuZGF0ZVBvaW50VHJhbnNmb3Jtcy5jb25jYXQoaG9va3MxLmRhdGVQb2ludFRyYW5zZm9ybXMpLFxuICAgIGRhdGVTcGFuVHJhbnNmb3JtczogaG9va3MwLmRhdGVTcGFuVHJhbnNmb3Jtcy5jb25jYXQoaG9va3MxLmRhdGVTcGFuVHJhbnNmb3JtcyksXG4gICAgdmlld3M6IHsgLi4uaG9va3MwLnZpZXdzLCAuLi5ob29rczEudmlld3MgfSxcbiAgICB2aWV3UHJvcHNUcmFuc2Zvcm1lcnM6IGhvb2tzMC52aWV3UHJvcHNUcmFuc2Zvcm1lcnMuY29uY2F0KGhvb2tzMS52aWV3UHJvcHNUcmFuc2Zvcm1lcnMpLFxuICAgIGlzUHJvcHNWYWxpZDogaG9va3MxLmlzUHJvcHNWYWxpZCB8fCBob29rczAuaXNQcm9wc1ZhbGlkLFxuICAgIGV4dGVybmFsRGVmVHJhbnNmb3JtczogaG9va3MwLmV4dGVybmFsRGVmVHJhbnNmb3Jtcy5jb25jYXQoaG9va3MxLmV4dGVybmFsRGVmVHJhbnNmb3JtcyksXG4gICAgZXZlbnRSZXNpemVKb2luVHJhbnNmb3JtczogaG9va3MwLmV2ZW50UmVzaXplSm9pblRyYW5zZm9ybXMuY29uY2F0KGhvb2tzMS5ldmVudFJlc2l6ZUpvaW5UcmFuc2Zvcm1zKSxcbiAgICB2aWV3Q29udGFpbmVyQXBwZW5kczogaG9va3MwLnZpZXdDb250YWluZXJBcHBlbmRzLmNvbmNhdChob29rczEudmlld0NvbnRhaW5lckFwcGVuZHMpLFxuICAgIGV2ZW50RHJvcFRyYW5zZm9ybWVyczogaG9va3MwLmV2ZW50RHJvcFRyYW5zZm9ybWVycy5jb25jYXQoaG9va3MxLmV2ZW50RHJvcFRyYW5zZm9ybWVycyksXG4gICAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IGhvb2tzMC5jYWxlbmRhckludGVyYWN0aW9ucy5jb25jYXQoaG9va3MxLmNhbGVuZGFySW50ZXJhY3Rpb25zKSxcbiAgICBjb21wb25lbnRJbnRlcmFjdGlvbnM6IGhvb2tzMC5jb21wb25lbnRJbnRlcmFjdGlvbnMuY29uY2F0KGhvb2tzMS5jb21wb25lbnRJbnRlcmFjdGlvbnMpLFxuICAgIHRoZW1lQ2xhc3NlczogeyAuLi5ob29rczAudGhlbWVDbGFzc2VzLCAuLi5ob29rczEudGhlbWVDbGFzc2VzIH0sXG4gICAgZXZlbnRTb3VyY2VEZWZzOiBob29rczAuZXZlbnRTb3VyY2VEZWZzLmNvbmNhdChob29rczEuZXZlbnRTb3VyY2VEZWZzKSxcbiAgICBjbWRGb3JtYXR0ZXI6IGhvb2tzMS5jbWRGb3JtYXR0ZXIgfHwgaG9va3MwLmNtZEZvcm1hdHRlcixcbiAgICByZWN1cnJpbmdUeXBlczogaG9va3MwLnJlY3VycmluZ1R5cGVzLmNvbmNhdChob29rczEucmVjdXJyaW5nVHlwZXMpLFxuICAgIG5hbWVkVGltZVpvbmVkSW1wbDogaG9va3MxLm5hbWVkVGltZVpvbmVkSW1wbCB8fCBob29rczAubmFtZWRUaW1lWm9uZWRJbXBsLFxuICAgIGluaXRpYWxWaWV3OiBob29rczAuaW5pdGlhbFZpZXcgfHwgaG9va3MxLmluaXRpYWxWaWV3LCAvLyBwdXQgZWFybGllciBwbHVnaW5zIEZJUlNUXG4gICAgZWxlbWVudERyYWdnaW5nSW1wbDogaG9va3MwLmVsZW1lbnREcmFnZ2luZ0ltcGwgfHwgaG9va3MxLmVsZW1lbnREcmFnZ2luZ0ltcGwsIC8vIFwiXG4gICAgb3B0aW9uQ2hhbmdlSGFuZGxlcnM6IHsgLi4uaG9va3MwLm9wdGlvbkNoYW5nZUhhbmRsZXJzLCAuLi5ob29rczEub3B0aW9uQ2hhbmdlSGFuZGxlcnMgfSxcbiAgICBzY3JvbGxHcmlkSW1wbDogaG9va3MxLnNjcm9sbEdyaWRJbXBsIHx8IGhvb2tzMC5zY3JvbGxHcmlkSW1wbCxcbiAgICBjb250ZW50VHlwZUhhbmRsZXJzOiB7IC4uLmhvb2tzMC5jb250ZW50VHlwZUhhbmRsZXJzLCAuLi5ob29rczEuY29udGVudFR5cGVIYW5kbGVycyB9LFxuICAgIGxpc3RlbmVyUmVmaW5lcnM6IHsgLi4uaG9va3MwLmxpc3RlbmVyUmVmaW5lcnMsIC4uLmhvb2tzMS5saXN0ZW5lclJlZmluZXJzIH0sXG4gICAgb3B0aW9uUmVmaW5lcnM6IHsgLi4uaG9va3MwLm9wdGlvblJlZmluZXJzLCAuLi5ob29rczEub3B0aW9uUmVmaW5lcnMgfSxcbiAgICBwcm9wU2V0SGFuZGxlcnM6IHsgLi4uaG9va3MwLnByb3BTZXRIYW5kbGVycywgLi4uaG9va3MxLnByb3BTZXRIYW5kbGVycyB9XG4gIH1cbn1cbiIsImltcG9ydCB7IFRoZW1lIH0gZnJvbSAnLi9UaGVtZSdcblxuZXhwb3J0IGNsYXNzIFN0YW5kYXJkVGhlbWUgZXh0ZW5kcyBUaGVtZSB7XG59XG5cblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmNsYXNzZXMgPSB7XG4gIHJvb3Q6ICdmYy10aGVtZS1zdGFuZGFyZCcsIC8vIFRPRE86IGNvbXB1dGUgdGhpcyBvZmYgb2YgcmVnaXN0ZXJlZCB0aGVtZSBuYW1lXG4gIHRhYmxlQ2VsbFNoYWRlZDogJ2ZjLWNlbGwtc2hhZGVkJyxcbiAgYnV0dG9uR3JvdXA6ICdmYy1idXR0b24tZ3JvdXAnLFxuICBidXR0b246ICdmYy1idXR0b24gZmMtYnV0dG9uLXByaW1hcnknLFxuICBidXR0b25BY3RpdmU6ICdmYy1idXR0b24tYWN0aXZlJ1xufVxuXG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5iYXNlSWNvbkNsYXNzID0gJ2ZjLWljb24nXG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uQ2xhc3NlcyA9IHtcbiAgY2xvc2U6ICdmYy1pY29uLXgnLFxuICBwcmV2OiAnZmMtaWNvbi1jaGV2cm9uLWxlZnQnLFxuICBuZXh0OiAnZmMtaWNvbi1jaGV2cm9uLXJpZ2h0JyxcbiAgcHJldlllYXI6ICdmYy1pY29uLWNoZXZyb25zLWxlZnQnLFxuICBuZXh0WWVhcjogJ2ZjLWljb24tY2hldnJvbnMtcmlnaHQnXG59XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5ydGxJY29uQ2xhc3NlcyA9IHtcbiAgcHJldjogJ2ZjLWljb24tY2hldnJvbi1yaWdodCcsXG4gIG5leHQ6ICdmYy1pY29uLWNoZXZyb24tbGVmdCcsXG4gIHByZXZZZWFyOiAnZmMtaWNvbi1jaGV2cm9ucy1yaWdodCcsXG4gIG5leHRZZWFyOiAnZmMtaWNvbi1jaGV2cm9ucy1sZWZ0J1xufVxuXG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVPcHRpb24gPSAnYnV0dG9uSWNvbnMnIC8vIFRPRE86IG1ha2UgVFMtZnJpZW5kbHlcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbiA9ICdpY29uJ1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlUHJlZml4ID0gJ2ZjLWljb24tJ1xuIiwiaW1wb3J0IHsgVmlld0NvbmZpZ0hhc2gsIFZpZXdDb21wb25lbnRUeXBlIH0gZnJvbSAnLi92aWV3LWNvbmZpZydcbmltcG9ydCB7IFZpZXdPcHRpb25zIH0gZnJvbSAnLi4vb3B0aW9ucydcblxuLypcblJlcHJlc2VudHMgaW5mb3JtYXRpb24gZm9yIGFuIGluc3RhbnRpYXRhYmxlIFZpZXcgY2xhc3MgYWxvbmcgd2l0aCBzZXR0aW5nc1xudGhhdCBhcmUgc3BlY2lmaWMgdG8gdGhhdCB2aWV3LiBObyBvdGhlciBzZXR0aW5ncywgbGlrZSBjYWxlbmRhci13aWRlIHNldHRpbmdzLCBhcmUgc3RvcmVkLlxuKi9cbmV4cG9ydCBpbnRlcmZhY2UgVmlld0RlZiB7XG4gIHR5cGU6IHN0cmluZ1xuICBjb21wb25lbnQ6IFZpZXdDb21wb25lbnRUeXBlXG4gIG92ZXJyaWRlczogVmlld09wdGlvbnNcbiAgZGVmYXVsdHM6IFZpZXdPcHRpb25zXG59XG5cbmV4cG9ydCB0eXBlIFZpZXdEZWZIYXNoID0geyBbdmlld1R5cGU6IHN0cmluZ106IFZpZXdEZWYgfVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGlsZVZpZXdEZWZzKGRlZmF1bHRDb25maWdzOiBWaWV3Q29uZmlnSGFzaCwgb3ZlcnJpZGVDb25maWdzOiBWaWV3Q29uZmlnSGFzaCk6IFZpZXdEZWZIYXNoIHtcbiAgbGV0IGhhc2g6IFZpZXdEZWZIYXNoID0ge31cbiAgbGV0IHZpZXdUeXBlOiBzdHJpbmdcblxuICBmb3IgKHZpZXdUeXBlIGluIGRlZmF1bHRDb25maWdzKSB7XG4gICAgZW5zdXJlVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncylcbiAgfVxuXG4gIGZvciAodmlld1R5cGUgaW4gb3ZlcnJpZGVDb25maWdzKSB7XG4gICAgZW5zdXJlVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncylcbiAgfVxuXG4gIHJldHVybiBoYXNoXG59XG5cbmZ1bmN0aW9uIGVuc3VyZVZpZXdEZWYodmlld1R5cGU6IHN0cmluZywgaGFzaDogVmlld0RlZkhhc2gsIGRlZmF1bHRDb25maWdzOiBWaWV3Q29uZmlnSGFzaCwgb3ZlcnJpZGVDb25maWdzOiBWaWV3Q29uZmlnSGFzaCk6IFZpZXdEZWYgfCBudWxsIHtcbiAgaWYgKGhhc2hbdmlld1R5cGVdKSB7XG4gICAgcmV0dXJuIGhhc2hbdmlld1R5cGVdXG4gIH1cblxuICBsZXQgdmlld0RlZiA9IGJ1aWxkVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncylcblxuICBpZiAodmlld0RlZikge1xuICAgIGhhc2hbdmlld1R5cGVdID0gdmlld0RlZlxuICB9XG5cbiAgcmV0dXJuIHZpZXdEZWZcbn1cblxuZnVuY3Rpb24gYnVpbGRWaWV3RGVmKHZpZXdUeXBlOiBzdHJpbmcsIGhhc2g6IFZpZXdEZWZIYXNoLCBkZWZhdWx0Q29uZmlnczogVmlld0NvbmZpZ0hhc2gsIG92ZXJyaWRlQ29uZmlnczogVmlld0NvbmZpZ0hhc2gpOiBWaWV3RGVmIHwgbnVsbCB7XG4gIGxldCBkZWZhdWx0Q29uZmlnID0gZGVmYXVsdENvbmZpZ3Nbdmlld1R5cGVdXG4gIGxldCBvdmVycmlkZUNvbmZpZyA9IG92ZXJyaWRlQ29uZmlnc1t2aWV3VHlwZV1cblxuICBsZXQgcXVlcnlQcm9wID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiAoZGVmYXVsdENvbmZpZyAmJiBkZWZhdWx0Q29uZmlnW25hbWVdICE9PSBudWxsKSA/IGRlZmF1bHRDb25maWdbbmFtZV0gOlxuICAgICAgKChvdmVycmlkZUNvbmZpZyAmJiBvdmVycmlkZUNvbmZpZ1tuYW1lXSAhPT0gbnVsbCkgPyBvdmVycmlkZUNvbmZpZ1tuYW1lXSA6IG51bGwpXG4gIH1cblxuICBsZXQgdGhlQ29tcG9uZW50ID0gcXVlcnlQcm9wKCdjb21wb25lbnQnKSBhcyBWaWV3Q29tcG9uZW50VHlwZVxuICBsZXQgc3VwZXJUeXBlID0gcXVlcnlQcm9wKCdzdXBlclR5cGUnKSBhcyBzdHJpbmdcbiAgbGV0IHN1cGVyRGVmOiBWaWV3RGVmIHwgbnVsbCA9IG51bGxcblxuICBpZiAoc3VwZXJUeXBlKSB7XG5cbiAgICBpZiAoc3VwZXJUeXBlID09PSB2aWV3VHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGhhdmUgYSBjdXN0b20gdmlldyB0eXBlIHRoYXQgcmVmZXJlbmNlcyBpdHNlbGYnKVxuICAgIH1cblxuICAgIHN1cGVyRGVmID0gZW5zdXJlVmlld0RlZihzdXBlclR5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpXG4gIH1cblxuICBpZiAoIXRoZUNvbXBvbmVudCAmJiBzdXBlckRlZikge1xuICAgIHRoZUNvbXBvbmVudCA9IHN1cGVyRGVmLmNvbXBvbmVudFxuICB9XG5cbiAgaWYgKCF0aGVDb21wb25lbnQpIHtcbiAgICByZXR1cm4gbnVsbCAvLyBkb24ndCB0aHJvdyBhIHdhcm5pbmcsIG1pZ2h0IGJlIHNldHRpbmdzIGZvciBhIHNpbmdsZS11bml0IHZpZXdcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogdmlld1R5cGUsXG4gICAgY29tcG9uZW50OiB0aGVDb21wb25lbnQsXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgIC4uLihzdXBlckRlZiA/IHN1cGVyRGVmLmRlZmF1bHRzIDoge30pLFxuICAgICAgLi4uKGRlZmF1bHRDb25maWcgPyBkZWZhdWx0Q29uZmlnLnJhd09wdGlvbnMgOiB7fSlcbiAgICB9LFxuICAgIG92ZXJyaWRlczoge1xuICAgICAgLi4uKHN1cGVyRGVmID8gc3VwZXJEZWYub3ZlcnJpZGVzIDoge30pLFxuICAgICAgLi4uKG92ZXJyaWRlQ29uZmlnID8gb3ZlcnJpZGVDb25maWcucmF3T3B0aW9ucyA6IHt9KVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgUmVmLCBjcmVhdGVSZWYsIENvbXBvbmVudENoaWxkcmVuLCBjcmVhdGVFbGVtZW50LCBSZWZPYmplY3QsIGNyZWF0ZUNvbnRleHQgfSBmcm9tICcuLi92ZG9tJ1xuaW1wb3J0IHsgc2V0UmVmLCBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vdmRvbS11dGlsJ1xuaW1wb3J0IHsgaXNQcm9wc0VxdWFsIH0gZnJvbSAnLi4vdXRpbC9vYmplY3QnXG5pbXBvcnQgeyBwYXJzZUNsYXNzTmFtZXMsIENsYXNzTmFtZXNJbnB1dCB9IGZyb20gJy4uL3V0aWwvaHRtbCdcblxuXG5leHBvcnQgaW50ZXJmYWNlIFJlbmRlckhvb2tQcm9wczxDb250ZW50QXJnPiB7XG4gIGhvb2tQcm9wczogQ29udGVudEFyZ1xuICBjbGFzc05hbWVzOiBDbGFzc05hbWVzR2VuZXJhdG9yPENvbnRlbnRBcmc+XG4gIGNvbnRlbnQ6IEN1c3RvbUNvbnRlbnRHZW5lcmF0b3I8Q29udGVudEFyZz5cbiAgZGVmYXVsdENvbnRlbnQ/OiBEZWZhdWx0Q29udGVudEdlbmVyYXRvcjxDb250ZW50QXJnPlxuICBkaWRNb3VudDogRGlkTW91bnRIYW5kbGVyPE1vdW50QXJnPENvbnRlbnRBcmc+PlxuICB3aWxsVW5tb3VudDogV2lsbFVubW91bnRIYW5kbGVyPE1vdW50QXJnPENvbnRlbnRBcmc+PlxuICBjaGlsZHJlbjogUmVuZGVySG9va1Byb3BzQ2hpbGRyZW5cbiAgZWxSZWY/OiBSZWY8YW55PlxufVxuXG5leHBvcnQgdHlwZSBSZW5kZXJIb29rUHJvcHNDaGlsZHJlbiA9IChcbiAgcm9vdEVsUmVmOiBSZWY8YW55PixcbiAgY2xhc3NOYW1lczogc3RyaW5nW10sXG4gIGlubmVyRWxSZWY6IFJlZjxhbnk+LFxuICBpbm5lckNvbnRlbnQ6IENvbXBvbmVudENoaWxkcmVuIC8vIGlmIGZhbHN5LCBtZWFucyBpdCB3YXNuJ3Qgc3BlY2lmaWVkXG4pID0+IENvbXBvbmVudENoaWxkcmVuXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udGVudFR5cGVIYW5kbGVycyB7XG4gIFtjb250ZW50S2V5OiBzdHJpbmddOiAoKSA9PiAoZWw6IEhUTUxFbGVtZW50LCBjb250ZW50VmFsOiBhbnkpID0+IHZvaWRcbn1cblxuXG4vLyBOT1RFOiBpbiBKU1gsIHlvdSBzaG91bGQgYWx3YXlzIHVzZSB0aGlzIGNsYXNzIHdpdGggPEhvb2tQcm9wcz4gYXJnLiBvdGhlcndpc2UsIHdpbGwgZGVmYXVsdCB0byBhbnk/Pz9cbmV4cG9ydCBjbGFzcyBSZW5kZXJIb29rPEhvb2tQcm9wcz4gZXh0ZW5kcyBCYXNlQ29tcG9uZW50PFJlbmRlckhvb2tQcm9wczxIb29rUHJvcHM+PiB7XG5cbiAgcHJpdmF0ZSByb290RWxSZWYgPSBjcmVhdGVSZWYoKVxuXG5cbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IHByb3BzIH0gPSB0aGlzXG4gICAgbGV0IHsgaG9va1Byb3BzIH0gPSBwcm9wc1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxNb3VudEhvb2sgaG9va1Byb3BzPXtob29rUHJvcHN9IGRpZE1vdW50PXtwcm9wcy5kaWRNb3VudH0gd2lsbFVubW91bnQ9e3Byb3BzLndpbGxVbm1vdW50fSBlbFJlZj17dGhpcy5oYW5kbGVSb290RWx9PlxuICAgICAgICB7KHJvb3RFbFJlZikgPT4gKFxuICAgICAgICAgIDxDb250ZW50SG9vayBob29rUHJvcHM9e2hvb2tQcm9wc30gY29udGVudD17cHJvcHMuY29udGVudH0gZGVmYXVsdENvbnRlbnQ9e3Byb3BzLmRlZmF1bHRDb250ZW50fSBiYWNrdXBFbFJlZj17dGhpcy5yb290RWxSZWZ9PlxuICAgICAgICAgICAgeyhpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpID0+IHByb3BzLmNoaWxkcmVuKFxuICAgICAgICAgICAgICByb290RWxSZWYsXG4gICAgICAgICAgICAgIG5vcm1hbGl6ZUNsYXNzTmFtZXMocHJvcHMuY2xhc3NOYW1lcywgaG9va1Byb3BzKSxcbiAgICAgICAgICAgICAgaW5uZXJFbFJlZixcbiAgICAgICAgICAgICAgaW5uZXJDb250ZW50XG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvQ29udGVudEhvb2s+XG4gICAgICAgICl9XG4gICAgICA8L01vdW50SG9vaz5cbiAgICApXG4gIH1cblxuXG4gIGhhbmRsZVJvb3RFbCA9IChlbDogSFRNTEVsZW1lbnQgfCBudWxsKSA9PiB7XG4gICAgc2V0UmVmKHRoaXMucm9vdEVsUmVmLCBlbClcblxuICAgIGlmICh0aGlzLnByb3BzLmVsUmVmKSB7XG4gICAgICBzZXRSZWYodGhpcy5wcm9wcy5lbFJlZiwgZWwpXG4gICAgfVxuICB9XG5cbn1cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgT2JqQ3VzdG9tQ29udGVudCB7XG4gIGh0bWw6IHN0cmluZ1xuICBkb21Ob2RlczogYW55W11cbiAgW2N1c3RvbTogc3RyaW5nXTogYW55IC8vIFRPRE86IGV4cG9zZSBob29rIGZvciBwbHVnaW5zIHRvIGFkZCFcbn1cblxuZXhwb3J0IHR5cGUgQ3VzdG9tQ29udGVudCA9IENvbXBvbmVudENoaWxkcmVuIHwgT2JqQ3VzdG9tQ29udGVudFxuZXhwb3J0IHR5cGUgQ3VzdG9tQ29udGVudEdlbmVyYXRvcjxIb29rUHJvcHM+ID0gQ3VzdG9tQ29udGVudCB8ICgoaG9va1Byb3BzOiBIb29rUHJvcHMpID0+IEN1c3RvbUNvbnRlbnQpXG5leHBvcnQgdHlwZSBEZWZhdWx0Q29udGVudEdlbmVyYXRvcjxIb29rUHJvcHM+ID0gKGhvb2tQcm9wczogSG9va1Byb3BzKSA9PiBDb21wb25lbnRDaGlsZHJlbiAvLyBUT0RPOiByZW5hbWUgdG8gYmUgYWJvdXQgZnVuY3Rpb24sIG5vdCBkZWZhdWx0LiB1c2UgaW4gYWJvdmUgdHlwZVxuXG4vLyBmb3IgZm9yY2luZyByZXJlbmRlciBvZiBjb21wb25lbnRzIHRoYXQgdXNlIHRoZSBDb250ZW50SG9va1xuZXhwb3J0IGNvbnN0IEN1c3RvbUNvbnRlbnRSZW5kZXJDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxudW1iZXI+KDApXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udGVudEhvb2tQcm9wczxIb29rUHJvcHM+IHtcbiAgaG9va1Byb3BzOiBIb29rUHJvcHNcbiAgY29udGVudDogQ3VzdG9tQ29udGVudEdlbmVyYXRvcjxIb29rUHJvcHM+XG4gIGRlZmF1bHRDb250ZW50PzogRGVmYXVsdENvbnRlbnRHZW5lcmF0b3I8SG9va1Byb3BzPlxuICBjaGlsZHJlbjogKFxuICAgIGlubmVyRWxSZWY6IFJlZjxhbnk+LFxuICAgIGlubmVyQ29udGVudDogQ29tcG9uZW50Q2hpbGRyZW4gLy8gaWYgZmFsc3ksIG1lYW5zIGl0IHdhc24ndCBzcGVjaWZpZWRcbiAgKSA9PiBDb21wb25lbnRDaGlsZHJlblxuICBiYWNrdXBFbFJlZj86IFJlZk9iamVjdDxhbnk+XG59XG5cbmV4cG9ydCBjbGFzcyBDb250ZW50SG9vazxIb29rUHJvcHM+IGV4dGVuZHMgQmFzZUNvbXBvbmVudDxDb250ZW50SG9va1Byb3BzPEhvb2tQcm9wcz4+IHsgLy8gVE9ETzogcmVuYW1lIHRvIEN1c3RvbUNvbnRlbnRIb29rP1xuXG4gIHByaXZhdGUgaW5uZXJFbFJlZiA9IGNyZWF0ZVJlZigpXG4gIHByaXZhdGUgY3VzdG9tQ29udGVudEluZm86IHtcbiAgICBjb250ZW50S2V5OiBzdHJpbmdcbiAgICBjb250ZW50VmFsOiBhbnlcbiAgICBoYW5kbGVyOiAoZWw6IEhUTUxFbGVtZW50LCBjb250ZW50VmFsOiBhbnkpID0+IHZvaWRcbiAgfVxuXG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8Q3VzdG9tQ29udGVudFJlbmRlckNvbnRleHQuQ29uc3VtZXI+XG4gICAgICAgIHsoKSA9PiAoXG4gICAgICAgICAgdGhpcy5wcm9wcy5jaGlsZHJlbih0aGlzLmlubmVyRWxSZWYsIHRoaXMucmVuZGVySW5uZXJDb250ZW50KCkpXG4gICAgICAgICl9XG4gICAgICA8L0N1c3RvbUNvbnRlbnRSZW5kZXJDb250ZXh0LkNvbnN1bWVyPlxuICAgIClcbiAgfVxuXG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy51cGRhdGVDdXN0b21Db250ZW50KClcbiAgfVxuXG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIHRoaXMudXBkYXRlQ3VzdG9tQ29udGVudCgpXG4gIH1cblxuXG4gIHByaXZhdGUgcmVuZGVySW5uZXJDb250ZW50KCkge1xuICAgIGxldCB7IGNvbnRlbnRUeXBlSGFuZGxlcnMgfSA9IHRoaXMuY29udGV4dC5wbHVnaW5Ib29rc1xuICAgIGxldCB7IHByb3BzLCBjdXN0b21Db250ZW50SW5mbyB9ID0gdGhpc1xuICAgIGxldCByYXdWYWwgPSBwcm9wcy5jb250ZW50XG4gICAgbGV0IGlubmVyQ29udGVudCA9IG5vcm1hbGl6ZUNvbnRlbnQocmF3VmFsLCBwcm9wcy5ob29rUHJvcHMpXG4gICAgbGV0IGlubmVyQ29udGVudFZEb206IENvbXBvbmVudENoaWxkcmVuID0gbnVsbFxuXG4gICAgaWYgKGlubmVyQ29udGVudCA9PT0gdW5kZWZpbmVkKSB7IC8vIHVzZSB0aGUgZGVmYXVsdFxuICAgICAgaW5uZXJDb250ZW50ID0gbm9ybWFsaXplQ29udGVudChwcm9wcy5kZWZhdWx0Q29udGVudCwgcHJvcHMuaG9va1Byb3BzKVxuICAgIH1cblxuICAgIGlmIChpbm5lckNvbnRlbnQgIT09IHVuZGVmaW5lZCkgeyAvLyB3ZSBhbGxvdyBjdXN0b20gY29udGVudCBoYW5kbGVycyB0byByZXR1cm4gbm90aGluZ1xuXG4gICAgICBpZiAoY3VzdG9tQ29udGVudEluZm8pIHtcbiAgICAgICAgY3VzdG9tQ29udGVudEluZm8uY29udGVudFZhbCA9IGlubmVyQ29udGVudFtjdXN0b21Db250ZW50SW5mby5jb250ZW50S2V5XVxuXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbm5lckNvbnRlbnQgPT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgLy8gbG9vayBmb3IgYSBwcm9wIHRoYXQgd291bGQgaW5kaWNhdGUgYSBjdXN0b20gY29udGVudCBoYW5kbGVyIGlzIG5lZWRlZFxuICAgICAgICBmb3IgKGxldCBjb250ZW50S2V5IGluIGNvbnRlbnRUeXBlSGFuZGxlcnMpIHtcblxuICAgICAgICAgIGlmIChpbm5lckNvbnRlbnRbY29udGVudEtleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY3VzdG9tQ29udGVudEluZm8gPSB0aGlzLmN1c3RvbUNvbnRlbnRJbmZvID0ge1xuICAgICAgICAgICAgICBjb250ZW50S2V5LFxuICAgICAgICAgICAgICBjb250ZW50VmFsOiBpbm5lckNvbnRlbnRbY29udGVudEtleV0sXG4gICAgICAgICAgICAgIGhhbmRsZXI6IGNvbnRlbnRUeXBlSGFuZGxlcnNbY29udGVudEtleV0oKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGN1c3RvbUNvbnRlbnRJbmZvKSB7XG4gICAgICAgIGlubmVyQ29udGVudFZEb20gPSBbXSAvLyBzaWduYWwgdGhhdCBzb21ldGhpbmcgd2FzIHNwZWNpZmllZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5uZXJDb250ZW50VkRvbSA9IGlubmVyQ29udGVudCAvLyBhc3N1bWUgYSBbcF1yZWFjdCB2ZG9tIG5vZGUuIHVzZSBpdFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbm5lckNvbnRlbnRWRG9tXG4gIH1cblxuXG4gIHByaXZhdGUgdXBkYXRlQ3VzdG9tQ29udGVudCgpIHtcbiAgICBpZiAodGhpcy5jdXN0b21Db250ZW50SW5mbykge1xuICAgICAgdGhpcy5jdXN0b21Db250ZW50SW5mby5oYW5kbGVyKFxuICAgICAgICB0aGlzLmlubmVyRWxSZWYuY3VycmVudCB8fCB0aGlzLnByb3BzLmJhY2t1cEVsUmVmLmN1cnJlbnQsIC8vIHRoZSBlbGVtZW50IHRvIHJlbmRlciBpbnRvXG4gICAgICAgIHRoaXMuY3VzdG9tQ29udGVudEluZm8uY29udGVudFZhbFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG59XG5cblxuXG5cbmV4cG9ydCB0eXBlIE1vdW50QXJnPENvbnRlbnRBcmc+ID0gQ29udGVudEFyZyAmIHsgZWw6IEhUTUxFbGVtZW50IH1cbmV4cG9ydCB0eXBlIERpZE1vdW50SGFuZGxlcjxNb3VudEFyZyBleHRlbmRzIHsgZWw6IEhUTUxFbGVtZW50IH0+ID0gKG1vdW50QXJnOiBNb3VudEFyZykgPT4gdm9pZFxuZXhwb3J0IHR5cGUgV2lsbFVubW91bnRIYW5kbGVyPE1vdW50QXJnIGV4dGVuZHMgeyBlbDogSFRNTEVsZW1lbnQgfT4gPSAobW91bnRBcmc6IE1vdW50QXJnKSA9PiB2b2lkXG5cbmV4cG9ydCBpbnRlcmZhY2UgTW91bnRIb29rUHJvcHM8Q29udGVudEFyZz4ge1xuICBob29rUHJvcHM6IENvbnRlbnRBcmdcbiAgZGlkTW91bnQ6IERpZE1vdW50SGFuZGxlcjxNb3VudEFyZzxDb250ZW50QXJnPj5cbiAgd2lsbFVubW91bnQ6IFdpbGxVbm1vdW50SGFuZGxlcjxNb3VudEFyZzxDb250ZW50QXJnPj5cbiAgY2hpbGRyZW46IChyb290RWxSZWY6IFJlZjxhbnk+KSA9PiBDb21wb25lbnRDaGlsZHJlblxuICBlbFJlZj86IFJlZjxhbnk+IC8vIG1heWJlIGdldCByaWQgb2Ygb25jZSB3ZSBoYXZlIGJldHRlciBBUEkgZm9yIGNhbGxlciB0byBjb21iaW5lIHJlZnNcbn1cblxuZXhwb3J0IGNsYXNzIE1vdW50SG9vazxDb250ZW50QXJnPiBleHRlbmRzIEJhc2VDb21wb25lbnQ8TW91bnRIb29rUHJvcHM8Q29udGVudEFyZz4+IHtcblxuICByb290RWw6IEhUTUxFbGVtZW50XG5cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW4odGhpcy5oYW5kbGVSb290RWwpXG4gIH1cblxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGxldCBjYWxsYmFjayA9IHRoaXMucHJvcHMuZGlkTW91bnRcbiAgICBjYWxsYmFjayAmJiBjYWxsYmFjayh7IC4uLnRoaXMucHJvcHMuaG9va1Byb3BzLCBlbDogdGhpcy5yb290RWwgfSlcbiAgfVxuXG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgbGV0IGNhbGxiYWNrID0gdGhpcy5wcm9wcy53aWxsVW5tb3VudFxuICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHsgLi4udGhpcy5wcm9wcy5ob29rUHJvcHMsIGVsOiB0aGlzLnJvb3RFbCB9KVxuICB9XG5cblxuICBwcml2YXRlIGhhbmRsZVJvb3RFbCA9IChyb290RWw6IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgdGhpcy5yb290RWwgPSByb290RWxcblxuICAgIGlmICh0aGlzLnByb3BzLmVsUmVmKSB7XG4gICAgICBzZXRSZWYodGhpcy5wcm9wcy5lbFJlZiwgcm9vdEVsKVxuICAgIH1cbiAgfVxuXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkQ2xhc3NOYW1lTm9ybWFsaXplcjxIb29rUHJvcHM+KCkgeyAvLyBUT0RPOiBnZW5lcmFsIGRlZXAtbWVtb2l6ZXI/XG4gIGxldCBjdXJyZW50R2VuZXJhdG9yOiBDbGFzc05hbWVzR2VuZXJhdG9yPEhvb2tQcm9wcz5cbiAgbGV0IGN1cnJlbnRIb29rUHJvcHM6IEhvb2tQcm9wc1xuICBsZXQgY3VycmVudENsYXNzTmFtZXM6IHN0cmluZ1tdID0gW11cblxuICByZXR1cm4gZnVuY3Rpb24oZ2VuZXJhdG9yOiBDbGFzc05hbWVzR2VuZXJhdG9yPEhvb2tQcm9wcz4sIGhvb2tQcm9wczogSG9va1Byb3BzKSB7XG4gICAgaWYgKCFjdXJyZW50SG9va1Byb3BzIHx8ICFpc1Byb3BzRXF1YWwoY3VycmVudEhvb2tQcm9wcywgaG9va1Byb3BzKSB8fCBnZW5lcmF0b3IgIT09IGN1cnJlbnRHZW5lcmF0b3IpIHtcbiAgICAgIGN1cnJlbnRHZW5lcmF0b3IgPSBnZW5lcmF0b3JcbiAgICAgIGN1cnJlbnRIb29rUHJvcHMgPSBob29rUHJvcHNcbiAgICAgIGN1cnJlbnRDbGFzc05hbWVzID0gbm9ybWFsaXplQ2xhc3NOYW1lcyhnZW5lcmF0b3IsIGhvb2tQcm9wcylcbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudENsYXNzTmFtZXNcbiAgfVxufVxuXG5cbmV4cG9ydCB0eXBlIENsYXNzTmFtZXNHZW5lcmF0b3I8SG9va1Byb3BzPiA9IENsYXNzTmFtZXNJbnB1dCB8ICgoaG9va1Byb3BzOiBIb29rUHJvcHMpID0+IENsYXNzTmFtZXNJbnB1dClcblxuXG5mdW5jdGlvbiBub3JtYWxpemVDbGFzc05hbWVzPEhvb2tQcm9wcz4oY2xhc3NOYW1lczogQ2xhc3NOYW1lc0dlbmVyYXRvcjxIb29rUHJvcHM+LCBob29rUHJvcHM6IEhvb2tQcm9wcyk6IHN0cmluZ1tdIHtcblxuICBpZiAodHlwZW9mIGNsYXNzTmFtZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjbGFzc05hbWVzID0gY2xhc3NOYW1lcyhob29rUHJvcHMpXG4gIH1cblxuICByZXR1cm4gcGFyc2VDbGFzc05hbWVzKGNsYXNzTmFtZXMpXG59XG5cblxuZnVuY3Rpb24gbm9ybWFsaXplQ29udGVudChpbnB1dCwgaG9va1Byb3BzKSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gaW5wdXQoaG9va1Byb3BzLCBjcmVhdGVFbGVtZW50KSAvLyBnaXZlIHRoZSBmdW5jdGlvbiB0aGUgdmRvbS1jcmVhdGlvbiBmdW5jXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGlucHV0XG4gIH1cbn1cbiIsImltcG9ydCB7IFZpZXdTcGVjIH0gZnJvbSAnLi4vc3RydWN0cy92aWV3LXNwZWMnXG5pbXBvcnQgeyBNb3VudEhvb2ssIGJ1aWxkQ2xhc3NOYW1lTm9ybWFsaXplciwgTW91bnRBcmcgfSBmcm9tICcuL3JlbmRlci1ob29rJ1xuaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGNyZWF0ZUVsZW1lbnQsIFJlZiB9IGZyb20gJy4uL3Zkb20nXG5pbXBvcnQgeyBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vdmRvbS11dGlsJ1xuaW1wb3J0IHsgVmlld0FwaSB9IGZyb20gJy4uL1ZpZXdBcGknXG5cblxuZXhwb3J0IGludGVyZmFjZSBWaWV3Um9vdFByb3BzIHtcbiAgdmlld1NwZWM6IFZpZXdTcGVjXG4gIGNoaWxkcmVuOiAocm9vdEVsUmVmOiBSZWY8YW55PiwgY2xhc3NOYW1lczogc3RyaW5nW10pID0+IENvbXBvbmVudENoaWxkcmVuXG4gIGVsUmVmPzogUmVmPGFueT5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBWaWV3Q29udGVudEFyZyB7XG4gIHZpZXc6IFZpZXdBcGlcbn1cblxuZXhwb3J0IHR5cGUgVmlld01vdW50QXJnID0gTW91bnRBcmc8Vmlld0NvbnRlbnRBcmc+XG5cblxuZXhwb3J0IGNsYXNzIFZpZXdSb290IGV4dGVuZHMgQmFzZUNvbXBvbmVudDxWaWV3Um9vdFByb3BzPiB7XG5cbiAgbm9ybWFsaXplQ2xhc3NOYW1lcyA9IGJ1aWxkQ2xhc3NOYW1lTm9ybWFsaXplcjxWaWV3Q29udGVudEFyZz4oKVxuXG5cbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzXG4gICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dFxuICAgIGxldCBob29rUHJvcHM6IFZpZXdDb250ZW50QXJnID0geyB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfVxuICAgIGxldCBjdXN0b21DbGFzc05hbWVzID0gdGhpcy5ub3JtYWxpemVDbGFzc05hbWVzKG9wdGlvbnMudmlld0NsYXNzTmFtZXMsIGhvb2tQcm9wcylcblxuICAgIHJldHVybiAoXG4gICAgICA8TW91bnRIb29rXG4gICAgICAgIGhvb2tQcm9wcz17aG9va1Byb3BzfVxuICAgICAgICBkaWRNb3VudD17b3B0aW9ucy52aWV3RGlkTW91bnR9XG4gICAgICAgIHdpbGxVbm1vdW50PXtvcHRpb25zLnZpZXdXaWxsVW5tb3VudH1cbiAgICAgICAgZWxSZWY9e3Byb3BzLmVsUmVmfVxuICAgICAgPlxuICAgICAgICB7KHJvb3RFbFJlZikgPT4gcHJvcHMuY2hpbGRyZW4oXG4gICAgICAgICAgcm9vdEVsUmVmLFxuICAgICAgICAgIFsgYGZjLSR7cHJvcHMudmlld1NwZWMudHlwZX0tdmlld2AsICdmYy12aWV3JyBdLmNvbmNhdChjdXN0b21DbGFzc05hbWVzKVxuICAgICAgICApfVxuICAgICAgPC9Nb3VudEhvb2s+XG4gICAgKVxuICB9XG5cbn1cbiIsImltcG9ydCB7IFZpZXdQcm9wcyB9IGZyb20gJy4uL1ZpZXcnXG5pbXBvcnQgeyBtYXBIYXNoIH0gZnJvbSAnLi4vdXRpbC9vYmplY3QnXG5pbXBvcnQgeyBDb21wb25lbnRUeXBlLCBDb21wb25lbnQsIGNyZWF0ZUVsZW1lbnQgfSBmcm9tICcuLi92ZG9tJ1xuaW1wb3J0IHsgVmlld1Jvb3QgfSBmcm9tICcuLi9jb21tb24vVmlld1Jvb3QnXG5pbXBvcnQgeyBSZW5kZXJIb29rLCBNb3VudEFyZyB9IGZyb20gJy4uL2NvbW1vbi9yZW5kZXItaG9vaydcbmltcG9ydCB7IFZpZXdDb250ZXh0LCBWaWV3Q29udGV4dFR5cGUgfSBmcm9tICcuLi9WaWV3Q29udGV4dCdcbmltcG9ydCB7IFZpZXdPcHRpb25zIH0gZnJvbSAnLi4vb3B0aW9ucydcbmltcG9ydCB7IER1cmF0aW9uIH0gZnJvbSAnLi4vZGF0ZWxpYi9kdXJhdGlvbidcblxuLypcbkEgdmlldy1jb25maWcgcmVwcmVzZW50cyBpbmZvcm1hdGlvbiBmb3IgZWl0aGVyOlxuQSkgY3JlYXRpbmcgYSBuZXcgaW5zdGFudGlhdGFibGUgdmlldyBjbGFzcy4gaW4gd2hpY2ggY2FzZSwgc3VwcGxpZWQgYSBjbGFzcy90eXBlIGluIGFkZGl0aW9uIHRvIG9wdGlvbnMsIE9SXG5CKSBvcHRpb25zIHRvIGN1c3RvbWl6ZSBhbiBleGlzdGluZyB2aWV3LCBpbiB3aGljaCBjYXNlIG9ubHkgcHJvdmlkZXMgb3B0aW9ucy5cbiovXG5cbmV4cG9ydCB0eXBlIFZpZXdDb21wb25lbnQgPSBDb21wb25lbnQ8Vmlld1Byb3BzPiAvLyBhbiBpbnN0YW5jZVxuZXhwb3J0IHR5cGUgVmlld0NvbXBvbmVudFR5cGUgPSBDb21wb25lbnRUeXBlPFZpZXdQcm9wcz5cblxuZXhwb3J0IHR5cGUgVmlld0NvbmZpZ0lucHV0ID0gVmlld0NvbXBvbmVudFR5cGUgfCBWaWV3T3B0aW9uc1xuZXhwb3J0IHR5cGUgVmlld0NvbmZpZ0lucHV0SGFzaCA9IHsgW3ZpZXdUeXBlOiBzdHJpbmddOiBWaWV3Q29uZmlnSW5wdXQgfVxuXG5leHBvcnQgaW50ZXJmYWNlIFZpZXdDb25maWcge1xuICBzdXBlclR5cGU6IHN0cmluZ1xuICBjb21wb25lbnQ6IFZpZXdDb21wb25lbnRUeXBlIHwgbnVsbFxuICByYXdPcHRpb25zOiBWaWV3T3B0aW9uc1xufVxuXG5leHBvcnQgdHlwZSBWaWV3Q29uZmlnSGFzaCA9IHsgW3ZpZXdUeXBlOiBzdHJpbmddOiBWaWV3Q29uZmlnIH1cblxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VWaWV3Q29uZmlncyhpbnB1dHM6IFZpZXdDb25maWdJbnB1dEhhc2gpOiBWaWV3Q29uZmlnSGFzaCB7XG4gIHJldHVybiBtYXBIYXNoKGlucHV0cywgcGFyc2VWaWV3Q29uZmlnKVxufVxuXG5cbmZ1bmN0aW9uIHBhcnNlVmlld0NvbmZpZyhpbnB1dDogVmlld0NvbmZpZ0lucHV0KTogVmlld0NvbmZpZyB7XG4gIGxldCByYXdPcHRpb25zOiBWaWV3T3B0aW9ucyA9IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgeyBjb21wb25lbnQ6IGlucHV0IH0gOlxuICAgIGlucHV0XG4gIGxldCBjb21wb25lbnQgPSByYXdPcHRpb25zLmNvbXBvbmVudFxuXG4gIGlmIChyYXdPcHRpb25zLmNvbnRlbnQpIHtcbiAgICBjb21wb25lbnQgPSBjcmVhdGVWaWV3SG9va0NvbXBvbmVudChyYXdPcHRpb25zKVxuICAgIC8vIFRPRE86IHJlbW92ZSBjb250ZW50L2NsYXNzTmFtZXMvZGlkTW91bnQvZXRjIGZyb20gb3B0aW9ucz9cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3VwZXJUeXBlOiByYXdPcHRpb25zLnR5cGUsXG4gICAgY29tcG9uZW50LFxuICAgIHJhd09wdGlvbnMgLy8gaW5jbHVkZXMgdHlwZSBhbmQgY29tcG9uZW50IHRvbyA6KFxuICB9XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBTcGVjaWZpY1ZpZXdDb250ZW50QXJnIGV4dGVuZHMgVmlld1Byb3BzIHtcbiAgbmV4dERheVRocmVzaG9sZDogRHVyYXRpb25cbn1cblxuZXhwb3J0IHR5cGUgU3BlY2lmaWNWaWV3TW91bnRBcmcgPSBNb3VudEFyZzxTcGVjaWZpY1ZpZXdDb250ZW50QXJnPlxuXG5cbmZ1bmN0aW9uIGNyZWF0ZVZpZXdIb29rQ29tcG9uZW50KG9wdGlvbnM6IFZpZXdPcHRpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbih2aWV3UHJvcHM6IFZpZXdQcm9wcykge1xuICAgIHJldHVybiAoXG4gICAgICA8Vmlld0NvbnRleHRUeXBlLkNvbnN1bWVyPlxuICAgICAgICB7KGNvbnRleHQ6IFZpZXdDb250ZXh0KSA9PiAoXG4gICAgICAgICAgPFZpZXdSb290IHZpZXdTcGVjPXtjb250ZXh0LnZpZXdTcGVjfT5cbiAgICAgICAgICAgIHsocm9vdEVsUmVmLCB2aWV3Q2xhc3NOYW1lcykgPT4ge1xuICAgICAgICAgICAgICBsZXQgaG9va1Byb3BzOiBTcGVjaWZpY1ZpZXdDb250ZW50QXJnID0ge1xuICAgICAgICAgICAgICAgIC4uLnZpZXdQcm9wcyxcbiAgICAgICAgICAgICAgICBuZXh0RGF5VGhyZXNob2xkOiBjb250ZXh0Lm9wdGlvbnMubmV4dERheVRocmVzaG9sZFxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8UmVuZGVySG9va1xuICAgICAgICAgICAgICAgICAgaG9va1Byb3BzPXtob29rUHJvcHN9XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWVzPXtvcHRpb25zLmNsYXNzTmFtZXN9XG4gICAgICAgICAgICAgICAgICBjb250ZW50PXtvcHRpb25zLmNvbnRlbnR9XG4gICAgICAgICAgICAgICAgICBkaWRNb3VudD17b3B0aW9ucy5kaWRNb3VudH1cbiAgICAgICAgICAgICAgICAgIHdpbGxVbm1vdW50PXtvcHRpb25zLndpbGxVbm1vdW50fVxuICAgICAgICAgICAgICAgICAgZWxSZWY9e3Jvb3RFbFJlZn1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICB7KHJvb3RFbFJlZiwgY3VzdG9tQ2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSA9PiAoXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXt2aWV3Q2xhc3NOYW1lcy5jb25jYXQoY3VzdG9tQ2xhc3NOYW1lcykuam9pbignICcpfSByZWY9e3Jvb3RFbFJlZn0+XG4gICAgICAgICAgICAgICAgICAgICAge2lubmVyQ29udGVudH1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgIDwvUmVuZGVySG9vaz5cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfX1cbiAgICAgICAgICA8L1ZpZXdSb290PlxuICAgICAgICApfVxuICAgICAgPC9WaWV3Q29udGV4dFR5cGUuQ29uc3VtZXI+XG4gICAgKVxuICB9XG59XG4iLCJpbXBvcnQgeyBWaWV3RGVmLCBjb21waWxlVmlld0RlZnMgfSBmcm9tICcuL3ZpZXctZGVmJ1xuaW1wb3J0IHsgRHVyYXRpb24sIGNyZWF0ZUR1cmF0aW9uLCBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IsIER1cmF0aW9uSW5wdXQgfSBmcm9tICcuLi9kYXRlbGliL2R1cmF0aW9uJ1xuaW1wb3J0IHsgbWFwSGFzaCB9IGZyb20gJy4uL3V0aWwvb2JqZWN0J1xuaW1wb3J0IHsgVmlld09wdGlvbnMsIENhbGVuZGFyT3B0aW9ucywgQkFTRV9PUFRJT05fREVGQVVMVFMgfSBmcm9tICcuLi9vcHRpb25zJ1xuaW1wb3J0IHsgVmlld0NvbmZpZ0lucHV0SGFzaCwgcGFyc2VWaWV3Q29uZmlncywgVmlld0NvbmZpZ0hhc2gsIFZpZXdDb21wb25lbnRUeXBlIH0gZnJvbSAnLi92aWV3LWNvbmZpZydcblxuLypcblJlcHJlc2VudHMgZXZlcnl0aGluZyBuZWVkZWQgdG8gaW5zdGFudGlhdGUgYSBuZXcgdmlldyBpbnN0YW5jZSxcbmluY2x1ZGluZyBvcHRpb25zIHRoYXQgaGF2ZSBiZWVuIGNvbXBpbGVkIGZyb20gdmlldy1zcGVjaWZpYyBhbmQgY2FsZW5kYXItd2lkZSBvcHRpb25zLFxuYXMgd2VsbCBhcyBkdXJhdGlvbiBpbmZvcm1hdGlvbi5cblxuT3ZlcmFsbCBmbG93OlxuVmlld0NvbmZpZyAtPiBWaWV3RGVmIC0+IFZpZXdTcGVjXG4qL1xuZXhwb3J0IGludGVyZmFjZSBWaWV3U3BlYyB7XG4gIHR5cGU6IHN0cmluZ1xuICBjb21wb25lbnQ6IFZpZXdDb21wb25lbnRUeXBlXG4gIGR1cmF0aW9uOiBEdXJhdGlvblxuICBkdXJhdGlvblVuaXQ6IHN0cmluZ1xuICBzaW5nbGVVbml0OiBzdHJpbmdcbiAgb3B0aW9uRGVmYXVsdHM6IFZpZXdPcHRpb25zXG4gIG9wdGlvbk92ZXJyaWRlczogVmlld09wdGlvbnNcbiAgYnV0dG9uVGV4dE92ZXJyaWRlOiBzdHJpbmdcbiAgYnV0dG9uVGV4dERlZmF1bHQ6IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBWaWV3U3BlY0hhc2ggPSB7IFt2aWV3VHlwZTogc3RyaW5nXTogVmlld1NwZWMgfVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFZpZXdTcGVjcyhkZWZhdWx0SW5wdXRzOiBWaWV3Q29uZmlnSW5wdXRIYXNoLCBvcHRpb25PdmVycmlkZXM6IENhbGVuZGFyT3B0aW9ucywgZHluYW1pY09wdGlvbk92ZXJyaWRlczogQ2FsZW5kYXJPcHRpb25zLCBsb2NhbGVEZWZhdWx0cyk6IFZpZXdTcGVjSGFzaCB7XG4gIGxldCBkZWZhdWx0Q29uZmlncyA9IHBhcnNlVmlld0NvbmZpZ3MoZGVmYXVsdElucHV0cylcbiAgbGV0IG92ZXJyaWRlQ29uZmlncyA9IHBhcnNlVmlld0NvbmZpZ3Mob3B0aW9uT3ZlcnJpZGVzLnZpZXdzKVxuICBsZXQgdmlld0RlZnMgPSBjb21waWxlVmlld0RlZnMoZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncylcblxuICByZXR1cm4gbWFwSGFzaCh2aWV3RGVmcywgZnVuY3Rpb24odmlld0RlZikge1xuICAgIHJldHVybiBidWlsZFZpZXdTcGVjKHZpZXdEZWYsIG92ZXJyaWRlQ29uZmlncywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBsb2NhbGVEZWZhdWx0cylcbiAgfSlcbn1cblxuXG5mdW5jdGlvbiBidWlsZFZpZXdTcGVjKHZpZXdEZWY6IFZpZXdEZWYsIG92ZXJyaWRlQ29uZmlnczogVmlld0NvbmZpZ0hhc2gsIG9wdGlvbk92ZXJyaWRlczogQ2FsZW5kYXJPcHRpb25zLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzOiBDYWxlbmRhck9wdGlvbnMsIGxvY2FsZURlZmF1bHRzKTogVmlld1NwZWMge1xuICBsZXQgZHVyYXRpb25JbnB1dCA9XG4gICAgdmlld0RlZi5vdmVycmlkZXMuZHVyYXRpb24gfHxcbiAgICB2aWV3RGVmLmRlZmF1bHRzLmR1cmF0aW9uIHx8XG4gICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcy5kdXJhdGlvbiB8fFxuICAgIG9wdGlvbk92ZXJyaWRlcy5kdXJhdGlvblxuXG4gIGxldCBkdXJhdGlvbiA9IG51bGxcbiAgbGV0IGR1cmF0aW9uVW5pdCA9ICcnXG4gIGxldCBzaW5nbGVVbml0ID0gJydcbiAgbGV0IHNpbmdsZVVuaXRPdmVycmlkZXM6IFZpZXdPcHRpb25zID0ge31cblxuICBpZiAoZHVyYXRpb25JbnB1dCkge1xuICAgIGR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb25DYWNoZWQoZHVyYXRpb25JbnB1dClcblxuICAgIGlmIChkdXJhdGlvbikgeyAvLyB2YWxpZD9cbiAgICAgIGxldCBkZW5vbSA9IGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXJhdGlvbilcbiAgICAgIGR1cmF0aW9uVW5pdCA9IGRlbm9tLnVuaXRcblxuICAgICAgaWYgKGRlbm9tLnZhbHVlID09PSAxKSB7XG4gICAgICAgIHNpbmdsZVVuaXQgPSBkdXJhdGlvblVuaXRcbiAgICAgICAgc2luZ2xlVW5pdE92ZXJyaWRlcyA9IG92ZXJyaWRlQ29uZmlnc1tkdXJhdGlvblVuaXRdID8gb3ZlcnJpZGVDb25maWdzW2R1cmF0aW9uVW5pdF0ucmF3T3B0aW9ucyA6IHt9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IHF1ZXJ5QnV0dG9uVGV4dCA9IGZ1bmN0aW9uKG9wdGlvbnNTdWJzZXQpIHtcbiAgICBsZXQgYnV0dG9uVGV4dE1hcCA9IG9wdGlvbnNTdWJzZXQuYnV0dG9uVGV4dCB8fCB7fVxuICAgIGxldCBidXR0b25UZXh0S2V5ID0gdmlld0RlZi5kZWZhdWx0cy5idXR0b25UZXh0S2V5XG5cbiAgICBpZiAoYnV0dG9uVGV4dEtleSAhPSBudWxsICYmIGJ1dHRvblRleHRNYXBbYnV0dG9uVGV4dEtleV0gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGJ1dHRvblRleHRNYXBbYnV0dG9uVGV4dEtleV1cbiAgICB9XG5cbiAgICBpZiAoYnV0dG9uVGV4dE1hcFt2aWV3RGVmLnR5cGVdICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBidXR0b25UZXh0TWFwW3ZpZXdEZWYudHlwZV1cbiAgICB9XG5cbiAgICBpZiAoYnV0dG9uVGV4dE1hcFtzaW5nbGVVbml0XSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gYnV0dG9uVGV4dE1hcFtzaW5nbGVVbml0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogdmlld0RlZi50eXBlLFxuICAgIGNvbXBvbmVudDogdmlld0RlZi5jb21wb25lbnQsXG4gICAgZHVyYXRpb24sXG4gICAgZHVyYXRpb25Vbml0LFxuICAgIHNpbmdsZVVuaXQsXG4gICAgb3B0aW9uRGVmYXVsdHM6IHZpZXdEZWYuZGVmYXVsdHMsXG4gICAgb3B0aW9uT3ZlcnJpZGVzOiB7IC4uLnNpbmdsZVVuaXRPdmVycmlkZXMsIC4uLnZpZXdEZWYub3ZlcnJpZGVzIH0sXG5cbiAgICBidXR0b25UZXh0T3ZlcnJpZGU6XG4gICAgICBxdWVyeUJ1dHRvblRleHQoZHluYW1pY09wdGlvbk92ZXJyaWRlcykgfHxcbiAgICAgIHF1ZXJ5QnV0dG9uVGV4dChvcHRpb25PdmVycmlkZXMpIHx8IC8vIGNvbnN0cnVjdG9yLXNwZWNpZmllZCBidXR0b25UZXh0IGxvb2t1cCBoYXNoIHRha2VzIHByZWNlZGVuY2VcbiAgICAgIHZpZXdEZWYub3ZlcnJpZGVzLmJ1dHRvblRleHQsIC8vIGBidXR0b25UZXh0YCBmb3Igdmlldy1zcGVjaWZpYyBvcHRpb25zIGlzIGEgc3RyaW5nXG5cbiAgICBidXR0b25UZXh0RGVmYXVsdDpcbiAgICAgIHF1ZXJ5QnV0dG9uVGV4dChsb2NhbGVEZWZhdWx0cykgfHxcbiAgICAgIHZpZXdEZWYuZGVmYXVsdHMuYnV0dG9uVGV4dCB8fFxuICAgICAgcXVlcnlCdXR0b25UZXh0KEJBU0VfT1BUSU9OX0RFRkFVTFRTKSB8fFxuICAgICAgdmlld0RlZi50eXBlIC8vIGZhbGwgYmFjayB0byBnaXZlbiB2aWV3IG5hbWVcbiAgfVxufVxuXG5cbi8vIGhhY2sgdG8gZ2V0IG1lbW9pemF0aW9uIHdvcmtpbmdcblxubGV0IGR1cmF0aW9uSW5wdXRNYXA6IHsgW2pzb246IHN0cmluZ106IER1cmF0aW9uIH0gPSB7fVxuXG5mdW5jdGlvbiBjcmVhdGVEdXJhdGlvbkNhY2hlZChkdXJhdGlvbklucHV0OiBEdXJhdGlvbklucHV0KSB7XG4gIGxldCBqc29uID0gSlNPTi5zdHJpbmdpZnkoZHVyYXRpb25JbnB1dClcbiAgbGV0IHJlcyA9IGR1cmF0aW9uSW5wdXRNYXBbanNvbl1cblxuICBpZiAocmVzID09PSB1bmRlZmluZWQpIHtcbiAgICByZXMgPSBjcmVhdGVEdXJhdGlvbihkdXJhdGlvbklucHV0KVxuICAgIGR1cmF0aW9uSW5wdXRNYXBbanNvbl0gPSByZXNcbiAgfVxuXG4gIHJldHVybiByZXNcbn1cbiIsImltcG9ydCB7IERhdGVNYXJrZXIsIHN0YXJ0T2ZEYXksIGFkZERheXMgfSBmcm9tICcuL2RhdGVsaWIvbWFya2VyJ1xuaW1wb3J0IHsgRHVyYXRpb24sIGNyZWF0ZUR1cmF0aW9uLCBhc1JvdWdoRGF5cywgYXNSb3VnaE1zLCBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IgfSBmcm9tICcuL2RhdGVsaWIvZHVyYXRpb24nXG5pbXBvcnQgeyBEYXRlUmFuZ2UsIE9wZW5EYXRlUmFuZ2UsIGNvbnN0cmFpbk1hcmtlclRvUmFuZ2UsIGludGVyc2VjdFJhbmdlcywgcmFuZ2VzSW50ZXJzZWN0LCBwYXJzZVJhbmdlLCBEYXRlUmFuZ2VJbnB1dCB9IGZyb20gJy4vZGF0ZWxpYi9kYXRlLXJhbmdlJ1xuaW1wb3J0IHsgRGF0ZUVudiwgRGF0ZUlucHV0IH0gZnJvbSAnLi9kYXRlbGliL2VudidcbmltcG9ydCB7IGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UgfSBmcm9tICcuL3V0aWwvZGF0ZSdcbmltcG9ydCB7IGdldE5vdyB9IGZyb20gJy4vcmVkdWNlcnMvY3VycmVudC1kYXRlJ1xuaW1wb3J0IHsgQ2FsZW5kYXJBcGkgfSBmcm9tICcuL0NhbGVuZGFyQXBpJ1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZVByb2ZpbGUge1xuICBjdXJyZW50UmFuZ2U6IERhdGVSYW5nZSAvLyBUT0RPOiBkb2VzIHRoaXMgaW5jbHVkZSBzbG90TWluVGltZS9zbG90TWF4VGltZT9cbiAgY3VycmVudFJhbmdlVW5pdDogc3RyaW5nXG4gIGlzUmFuZ2VBbGxEYXk6IGJvb2xlYW5cbiAgdmFsaWRSYW5nZTogT3BlbkRhdGVSYW5nZVxuICBhY3RpdmVSYW5nZTogRGF0ZVJhbmdlIHwgbnVsbFxuICByZW5kZXJSYW5nZTogRGF0ZVJhbmdlXG4gIHNsb3RNaW5UaW1lOiBEdXJhdGlvblxuICBzbG90TWF4VGltZTogRHVyYXRpb25cbiAgaXNWYWxpZDogYm9vbGVhblxuICBkYXRlSW5jcmVtZW50OiBEdXJhdGlvblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVQcm9maWxlR2VuZXJhdG9yUHJvcHMgZXh0ZW5kcyBEYXRlUHJvZmlsZU9wdGlvbnMge1xuICBkYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzOiBEYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzIC8vIG5vdCB1c2VkIGJ5IERhdGVQcm9maWxlR2VuZXJhdG9yIGl0c2VsZlxuICBkdXJhdGlvbjogRHVyYXRpb25cbiAgZHVyYXRpb25Vbml0OiBzdHJpbmdcbiAgdXNlc01pbk1heFRpbWU6IGJvb2xlYW5cbiAgZGF0ZUVudjogRGF0ZUVudlxuICBjYWxlbmRhckFwaTogQ2FsZW5kYXJBcGlcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXRlUHJvZmlsZU9wdGlvbnMge1xuICBzbG90TWluVGltZTogRHVyYXRpb25cbiAgc2xvdE1heFRpbWU6IER1cmF0aW9uXG4gIHNob3dOb25DdXJyZW50RGF0ZXM/OiBib29sZWFuXG4gIGRheUNvdW50PzogbnVtYmVyXG4gIGRhdGVBbGlnbm1lbnQ/OiBzdHJpbmdcbiAgZGF0ZUluY3JlbWVudD86IER1cmF0aW9uXG4gIGhpZGRlbkRheXM/OiBudW1iZXJbXVxuICB3ZWVrZW5kcz86IGJvb2xlYW5cbiAgbm93SW5wdXQ/OiBEYXRlSW5wdXQgfCAoKCkgPT4gRGF0ZUlucHV0KVxuICB2YWxpZFJhbmdlSW5wdXQ/OiBEYXRlUmFuZ2VJbnB1dCB8ICgodGhpczogQ2FsZW5kYXJBcGksIG5vd0RhdGU6IERhdGUpID0+IERhdGVSYW5nZUlucHV0KVxuICB2aXNpYmxlUmFuZ2VJbnB1dD86IERhdGVSYW5nZUlucHV0IHwgKCh0aGlzOiBDYWxlbmRhckFwaSwgbm93RGF0ZTogRGF0ZSkgPT4gRGF0ZVJhbmdlSW5wdXQpXG4gIG1vbnRoTW9kZT86IGJvb2xlYW5cbiAgZml4ZWRXZWVrQ291bnQ/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIERhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MgPSB7XG4gIG5ldyhwcm9wczogRGF0ZVByb2ZpbGVHZW5lcmF0b3JQcm9wcyk6IERhdGVQcm9maWxlR2VuZXJhdG9yXG59XG5cblxuZXhwb3J0IGNsYXNzIERhdGVQcm9maWxlR2VuZXJhdG9yIHsgLy8gb25seSBwdWJsaWNseSB1c2VkIGZvciBpc0hpZGRlbkRheSA6KFxuXG4gIG5vd0RhdGU6IERhdGVNYXJrZXJcbiAgaXNIaWRkZW5EYXlIYXNoOiBib29sZWFuW11cblxuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBwcm9wczogRGF0ZVByb2ZpbGVHZW5lcmF0b3JQcm9wcykge1xuICAgIHRoaXMubm93RGF0ZSA9IGdldE5vdyhwcm9wcy5ub3dJbnB1dCwgcHJvcHMuZGF0ZUVudilcbiAgICB0aGlzLmluaXRIaWRkZW5EYXlzKClcbiAgfVxuXG5cbiAgLyogRGF0ZSBSYW5nZSBDb21wdXRhdGlvblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cbiAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIHdpdGggaW5mbyBhYm91dCB3aGF0IHRoZSBkYXRlcy9yYW5nZXMgd2lsbCBiZSBmb3IgdGhlIFwicHJldlwiIHZpZXcuXG4gIGJ1aWxkUHJldihjdXJyZW50RGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZTogRGF0ZU1hcmtlciwgZm9yY2VUb1ZhbGlkPzogYm9vbGVhbik6IERhdGVQcm9maWxlIHtcbiAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLnByb3BzXG5cbiAgICBsZXQgcHJldkRhdGUgPSBkYXRlRW52LnN1YnRyYWN0KFxuICAgICAgZGF0ZUVudi5zdGFydE9mKGN1cnJlbnREYXRlLCBjdXJyZW50RGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCksIC8vIGltcG9ydGFudCBmb3Igc3RhcnQtb2YtbW9udGhcbiAgICAgIGN1cnJlbnREYXRlUHJvZmlsZS5kYXRlSW5jcmVtZW50XG4gICAgKVxuXG4gICAgcmV0dXJuIHRoaXMuYnVpbGQocHJldkRhdGUsIC0xLCBmb3JjZVRvVmFsaWQpXG4gIH1cblxuXG4gIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgd2hhdCB0aGUgZGF0ZXMvcmFuZ2VzIHdpbGwgYmUgZm9yIHRoZSBcIm5leHRcIiB2aWV3LlxuICBidWlsZE5leHQoY3VycmVudERhdGVQcm9maWxlOiBEYXRlUHJvZmlsZSwgY3VycmVudERhdGU6IERhdGVNYXJrZXIsIGZvcmNlVG9WYWxpZD86IGJvb2xlYW4pOiBEYXRlUHJvZmlsZSB7XG4gICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5wcm9wc1xuXG4gICAgbGV0IG5leHREYXRlID0gZGF0ZUVudi5hZGQoXG4gICAgICBkYXRlRW52LnN0YXJ0T2YoY3VycmVudERhdGUsIGN1cnJlbnREYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KSwgLy8gaW1wb3J0YW50IGZvciBzdGFydC1vZi1tb250aFxuICAgICAgY3VycmVudERhdGVQcm9maWxlLmRhdGVJbmNyZW1lbnRcbiAgICApXG5cbiAgICByZXR1cm4gdGhpcy5idWlsZChuZXh0RGF0ZSwgMSwgZm9yY2VUb1ZhbGlkKVxuICB9XG5cblxuICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgaG9sZGluZyBkYXRlcy9yYW5nZXMgZm9yIHJlbmRlcmluZyBhcm91bmQgdGhlIGdpdmVuIGRhdGUuXG4gIC8vIE9wdGlvbmFsIGRpcmVjdGlvbiBwYXJhbSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgZGF0ZSBpcyBiZWluZyBpbmNyZW1lbnRlZC9kZWNyZW1lbnRlZFxuICAvLyBmcm9tIGl0cyBwcmV2aW91cyB2YWx1ZS4gZGVjcmVtZW50ZWQgPSAtMSwgaW5jcmVtZW50ZWQgPSAxIChkZWZhdWx0KS5cbiAgYnVpbGQoY3VycmVudERhdGU6IERhdGVNYXJrZXIsIGRpcmVjdGlvbj8sIGZvcmNlVG9WYWxpZCA9IHRydWUpOiBEYXRlUHJvZmlsZSB7XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcbiAgICBsZXQgdmFsaWRSYW5nZTogRGF0ZVJhbmdlXG4gICAgbGV0IGN1cnJlbnRJbmZvXG4gICAgbGV0IGlzUmFuZ2VBbGxEYXlcbiAgICBsZXQgcmVuZGVyUmFuZ2U6IERhdGVSYW5nZVxuICAgIGxldCBhY3RpdmVSYW5nZTogRGF0ZVJhbmdlXG4gICAgbGV0IGlzVmFsaWRcblxuICAgIHZhbGlkUmFuZ2UgPSB0aGlzLmJ1aWxkVmFsaWRSYW5nZSgpXG4gICAgdmFsaWRSYW5nZSA9IHRoaXMudHJpbUhpZGRlbkRheXModmFsaWRSYW5nZSlcblxuICAgIGlmIChmb3JjZVRvVmFsaWQpIHtcbiAgICAgIGN1cnJlbnREYXRlID0gY29uc3RyYWluTWFya2VyVG9SYW5nZShjdXJyZW50RGF0ZSwgdmFsaWRSYW5nZSlcbiAgICB9XG5cbiAgICBjdXJyZW50SW5mbyA9IHRoaXMuYnVpbGRDdXJyZW50UmFuZ2VJbmZvKGN1cnJlbnREYXRlLCBkaXJlY3Rpb24pXG4gICAgaXNSYW5nZUFsbERheSA9IC9eKHllYXJ8bW9udGh8d2Vla3xkYXkpJC8udGVzdChjdXJyZW50SW5mby51bml0KVxuICAgIHJlbmRlclJhbmdlID0gdGhpcy5idWlsZFJlbmRlclJhbmdlKFxuICAgICAgdGhpcy50cmltSGlkZGVuRGF5cyhjdXJyZW50SW5mby5yYW5nZSksXG4gICAgICBjdXJyZW50SW5mby51bml0LFxuICAgICAgaXNSYW5nZUFsbERheVxuICAgIClcbiAgICByZW5kZXJSYW5nZSA9IHRoaXMudHJpbUhpZGRlbkRheXMocmVuZGVyUmFuZ2UpXG4gICAgYWN0aXZlUmFuZ2UgPSByZW5kZXJSYW5nZVxuXG4gICAgaWYgKCFwcm9wcy5zaG93Tm9uQ3VycmVudERhdGVzKSB7XG4gICAgICBhY3RpdmVSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhhY3RpdmVSYW5nZSwgY3VycmVudEluZm8ucmFuZ2UpXG4gICAgfVxuXG4gICAgYWN0aXZlUmFuZ2UgPSB0aGlzLmFkanVzdEFjdGl2ZVJhbmdlKGFjdGl2ZVJhbmdlKVxuICAgIGFjdGl2ZVJhbmdlID0gaW50ZXJzZWN0UmFuZ2VzKGFjdGl2ZVJhbmdlLCB2YWxpZFJhbmdlKSAvLyBtaWdodCByZXR1cm4gbnVsbFxuXG4gICAgLy8gaXQncyBpbnZhbGlkIGlmIHRoZSBvcmlnaW5hbGx5IHJlcXVlc3RlZCBkYXRlIGlzIG5vdCBjb250YWluZWQsXG4gICAgLy8gb3IgaWYgdGhlIHJhbmdlIGlzIGNvbXBsZXRlbHkgb3V0c2lkZSBvZiB0aGUgdmFsaWQgcmFuZ2UuXG4gICAgaXNWYWxpZCA9IHJhbmdlc0ludGVyc2VjdChjdXJyZW50SW5mby5yYW5nZSwgdmFsaWRSYW5nZSlcblxuICAgIHJldHVybiB7XG4gICAgICAvLyBjb25zdHJhaW50IGZvciB3aGVyZSBwcmV2L25leHQgb3BlcmF0aW9ucyBjYW4gZ28gYW5kIHdoZXJlIGV2ZW50cyBjYW4gYmUgZHJhZ2dlZC9yZXNpemVkIHRvLlxuICAgICAgLy8gYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3RhcnQgYW5kIGVuZCBwcm9wZXJ0aWVzLlxuICAgICAgdmFsaWRSYW5nZTogdmFsaWRSYW5nZSxcblxuICAgICAgLy8gcmFuZ2UgdGhlIHZpZXcgaXMgZm9ybWFsbHkgcmVzcG9uc2libGUgZm9yLlxuICAgICAgLy8gZm9yIGV4YW1wbGUsIGEgbW9udGggdmlldyBtaWdodCBoYXZlIDFzdC0zMXN0LCBleGNsdWRpbmcgcGFkZGVkIGRhdGVzXG4gICAgICBjdXJyZW50UmFuZ2U6IGN1cnJlbnRJbmZvLnJhbmdlLFxuXG4gICAgICAvLyBuYW1lIG9mIGxhcmdlc3QgdW5pdCBiZWluZyBkaXNwbGF5ZWQsIGxpa2UgXCJtb250aFwiIG9yIFwid2Vla1wiXG4gICAgICBjdXJyZW50UmFuZ2VVbml0OiBjdXJyZW50SW5mby51bml0LFxuXG4gICAgICBpc1JhbmdlQWxsRGF5LFxuXG4gICAgICAvLyBkYXRlcyB0aGF0IGRpc3BsYXkgZXZlbnRzIGFuZCBhY2NlcHQgZHJhZy1uLWRyb3BcbiAgICAgIC8vIHdpbGwgYmUgYG51bGxgIGlmIG5vIGRhdGVzIGFjY2VwdCBldmVudHNcbiAgICAgIGFjdGl2ZVJhbmdlLFxuXG4gICAgICAvLyBkYXRlIHJhbmdlIHdpdGggYSByZW5kZXJlZCBza2VsZXRvblxuICAgICAgLy8gaW5jbHVkZXMgbm90LWFjdGl2ZSBkYXlzIHRoYXQgbmVlZCBzb21lIHNvcnQgb2YgRE9NXG4gICAgICByZW5kZXJSYW5nZSxcblxuICAgICAgLy8gRHVyYXRpb24gb2JqZWN0IHRoYXQgZGVub3RlcyB0aGUgZmlyc3QgdmlzaWJsZSB0aW1lIG9mIGFueSBnaXZlbiBkYXlcbiAgICAgIHNsb3RNaW5UaW1lOiBwcm9wcy5zbG90TWluVGltZSxcblxuICAgICAgLy8gRHVyYXRpb24gb2JqZWN0IHRoYXQgZGVub3RlcyB0aGUgZXhjbHVzaXZlIHZpc2libGUgZW5kIHRpbWUgb2YgYW55IGdpdmVuIGRheVxuICAgICAgc2xvdE1heFRpbWU6IHByb3BzLnNsb3RNYXhUaW1lLFxuXG4gICAgICBpc1ZhbGlkLFxuXG4gICAgICAvLyBob3cgZmFyIHRoZSBjdXJyZW50IGRhdGUgd2lsbCBtb3ZlIGZvciBhIHByZXYvbmV4dCBvcGVyYXRpb25cbiAgICAgIGRhdGVJbmNyZW1lbnQ6IHRoaXMuYnVpbGREYXRlSW5jcmVtZW50KGN1cnJlbnRJbmZvLmR1cmF0aW9uKVxuICAgICAgICAvLyBwYXNzIGEgZmFsbGJhY2sgKG1pZ2h0IGJlIG51bGwpIF5cbiAgICB9XG4gIH1cblxuXG4gIC8vIEJ1aWxkcyBhbiBvYmplY3Qgd2l0aCBvcHRpb25hbCBzdGFydC9lbmQgcHJvcGVydGllcy5cbiAgLy8gSW5kaWNhdGVzIHRoZSBtaW5pbXVtL21heGltdW0gZGF0ZXMgdG8gZGlzcGxheS5cbiAgLy8gbm90IHJlc3BvbnNpYmxlIGZvciB0cmltbWluZyBoaWRkZW4gZGF5cy5cbiAgYnVpbGRWYWxpZFJhbmdlKCk6IE9wZW5EYXRlUmFuZ2Uge1xuICAgIGxldCBpbnB1dCA9IHRoaXMucHJvcHMudmFsaWRSYW5nZUlucHV0XG4gICAgbGV0IHNpbXBsZUlucHV0ID0gdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nXG4gICAgICA/IGlucHV0LmNhbGwodGhpcy5wcm9wcy5jYWxlbmRhckFwaSwgdGhpcy5ub3dEYXRlKVxuICAgICAgOiBpbnB1dFxuXG4gICAgcmV0dXJuIHRoaXMucmVmaW5lUmFuZ2Uoc2ltcGxlSW5wdXQpIHx8XG4gICAgICB7IHN0YXJ0OiBudWxsLCBlbmQ6IG51bGwgfSAvLyBjb21wbGV0ZWx5IG9wZW4tZW5kZWRcbiAgfVxuXG5cbiAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIHdpdGggaW5mbyBhYm91dCB0aGUgXCJjdXJyZW50XCIgcmFuZ2UsIHRoZSByYW5nZSB0aGF0IGlzXG4gIC8vIGhpZ2hsaWdodGVkIGFzIGJlaW5nIHRoZSBjdXJyZW50IG1vbnRoIGZvciBleGFtcGxlLlxuICAvLyBTZWUgYnVpbGQoKSBmb3IgYSBkZXNjcmlwdGlvbiBvZiBgZGlyZWN0aW9uYC5cbiAgLy8gR3VhcmFudGVlZCB0byBoYXZlIGByYW5nZWAgYW5kIGB1bml0YCBwcm9wZXJ0aWVzLiBgZHVyYXRpb25gIGlzIG9wdGlvbmFsLlxuICBidWlsZEN1cnJlbnRSYW5nZUluZm8oZGF0ZTogRGF0ZU1hcmtlciwgZGlyZWN0aW9uKSB7XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcbiAgICBsZXQgZHVyYXRpb24gPSBudWxsXG4gICAgbGV0IHVuaXQgPSBudWxsXG4gICAgbGV0IHJhbmdlID0gbnVsbFxuICAgIGxldCBkYXlDb3VudFxuXG4gICAgaWYgKHByb3BzLmR1cmF0aW9uKSB7XG4gICAgICBkdXJhdGlvbiA9IHByb3BzLmR1cmF0aW9uXG4gICAgICB1bml0ID0gcHJvcHMuZHVyYXRpb25Vbml0XG4gICAgICByYW5nZSA9IHRoaXMuYnVpbGRSYW5nZUZyb21EdXJhdGlvbihkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KVxuICAgIH0gZWxzZSBpZiAoKGRheUNvdW50ID0gdGhpcy5wcm9wcy5kYXlDb3VudCkpIHtcbiAgICAgIHVuaXQgPSAnZGF5J1xuICAgICAgcmFuZ2UgPSB0aGlzLmJ1aWxkUmFuZ2VGcm9tRGF5Q291bnQoZGF0ZSwgZGlyZWN0aW9uLCBkYXlDb3VudClcbiAgICB9IGVsc2UgaWYgKChyYW5nZSA9IHRoaXMuYnVpbGRDdXN0b21WaXNpYmxlUmFuZ2UoZGF0ZSkpKSB7XG4gICAgICB1bml0ID0gcHJvcHMuZGF0ZUVudi5ncmVhdGVzdFdob2xlVW5pdChyYW5nZS5zdGFydCwgcmFuZ2UuZW5kKS51bml0XG4gICAgfSBlbHNlIHtcbiAgICAgIGR1cmF0aW9uID0gdGhpcy5nZXRGYWxsYmFja0R1cmF0aW9uKClcbiAgICAgIHVuaXQgPSBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IoZHVyYXRpb24pLnVuaXRcbiAgICAgIHJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbUR1cmF0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgZHVyYXRpb246IGR1cmF0aW9uLCB1bml0OiB1bml0LCByYW5nZSB9XG4gIH1cblxuXG4gIGdldEZhbGxiYWNrRHVyYXRpb24oKTogRHVyYXRpb24ge1xuICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IGRheTogMSB9KVxuICB9XG5cblxuICAvLyBSZXR1cm5zIGEgbmV3IGFjdGl2ZVJhbmdlIHRvIGhhdmUgdGltZSB2YWx1ZXMgKHVuLWFtYmlndWF0ZSlcbiAgLy8gc2xvdE1pblRpbWUgb3Igc2xvdE1heFRpbWUgY2F1c2VzIHRoZSByYW5nZSB0byBleHBhbmQuXG4gIGFkanVzdEFjdGl2ZVJhbmdlKHJhbmdlOiBEYXRlUmFuZ2UpIHtcbiAgICBsZXQgeyBkYXRlRW52LCB1c2VzTWluTWF4VGltZSwgc2xvdE1pblRpbWUsIHNsb3RNYXhUaW1lIH0gPSB0aGlzLnByb3BzXG4gICAgbGV0IHN0YXJ0ID0gcmFuZ2Uuc3RhcnRcbiAgICBsZXQgZW5kID0gcmFuZ2UuZW5kXG5cbiAgICBpZiAodXNlc01pbk1heFRpbWUpIHtcblxuICAgICAgLy8gZXhwYW5kIGFjdGl2ZSByYW5nZSBpZiBzbG90TWluVGltZSBpcyBuZWdhdGl2ZSAod2h5IG5vdCB3aGVuIHBvc2l0aXZlPylcbiAgICAgIGlmIChhc1JvdWdoRGF5cyhzbG90TWluVGltZSkgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCkgLy8gbmVjZXNzYXJ5P1xuICAgICAgICBzdGFydCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBzbG90TWluVGltZSlcbiAgICAgIH1cblxuICAgICAgLy8gZXhwYW5kIGFjdGl2ZSByYW5nZSBpZiBzbG90TWF4VGltZSBpcyBiZXlvbmQgb25lIGRheSAod2h5IG5vdCB3aGVuIG5lZ2F0aXZlPylcbiAgICAgIGlmIChhc1JvdWdoRGF5cyhzbG90TWF4VGltZSkgPiAxKSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0T2ZEYXkoZW5kKSAvLyBuZWNlc3Nhcnk/XG4gICAgICAgIGVuZCA9IGFkZERheXMoZW5kLCAtMSlcbiAgICAgICAgZW5kID0gZGF0ZUVudi5hZGQoZW5kLCBzbG90TWF4VGltZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBzdGFydCwgZW5kIH1cbiAgfVxuXG5cbiAgLy8gQnVpbGRzIHRoZSBcImN1cnJlbnRcIiByYW5nZSB3aGVuIGl0IGlzIHNwZWNpZmllZCBhcyBhbiBleHBsaWNpdCBkdXJhdGlvbi5cbiAgLy8gYHVuaXRgIGlzIHRoZSBhbHJlYWR5LWNvbXB1dGVkIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvciB1bml0IG9mIGR1cmF0aW9uLlxuICBidWlsZFJhbmdlRnJvbUR1cmF0aW9uKGRhdGU6IERhdGVNYXJrZXIsIGRpcmVjdGlvbiwgZHVyYXRpb246IER1cmF0aW9uLCB1bml0KSB7XG4gICAgbGV0IHsgZGF0ZUVudiwgZGF0ZUFsaWdubWVudCB9ID0gdGhpcy5wcm9wc1xuICAgIGxldCBzdGFydDogRGF0ZU1hcmtlclxuICAgIGxldCBlbmQ6IERhdGVNYXJrZXJcbiAgICBsZXQgcmVzXG5cbiAgICAvLyBjb21wdXRlIHdoYXQgdGhlIGFsaWdubWVudCBzaG91bGQgYmVcbiAgICBpZiAoIWRhdGVBbGlnbm1lbnQpIHtcbiAgICAgIGxldCB7IGRhdGVJbmNyZW1lbnQgfSA9IHRoaXMucHJvcHNcblxuICAgICAgaWYgKGRhdGVJbmNyZW1lbnQpIHtcbiAgICAgICAgLy8gdXNlIHRoZSBzbWFsbGVyIG9mIHRoZSB0d28gdW5pdHNcbiAgICAgICAgaWYgKGFzUm91Z2hNcyhkYXRlSW5jcmVtZW50KSA8IGFzUm91Z2hNcyhkdXJhdGlvbikpIHtcbiAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yKGRhdGVJbmNyZW1lbnQpLnVuaXRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gdW5pdFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRlQWxpZ25tZW50ID0gdW5pdFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoZSB2aWV3IGRpc3BsYXlzIGEgc2luZ2xlIGRheSBvciBzbWFsbGVyXG4gICAgaWYgKGFzUm91Z2hEYXlzKGR1cmF0aW9uKSA8PSAxKSB7XG4gICAgICBpZiAodGhpcy5pc0hpZGRlbkRheShzdGFydCkpIHtcbiAgICAgICAgc3RhcnQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKHN0YXJ0LCBkaXJlY3Rpb24pXG4gICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlUmVzKCkge1xuICAgICAgc3RhcnQgPSBkYXRlRW52LnN0YXJ0T2YoZGF0ZSwgZGF0ZUFsaWdubWVudClcbiAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBkdXJhdGlvbilcbiAgICAgIHJlcyA9IHsgc3RhcnQsIGVuZCB9XG4gICAgfVxuXG4gICAgY29tcHV0ZVJlcygpXG5cbiAgICAvLyBpZiByYW5nZSBpcyBjb21wbGV0ZWx5IGVudmVsb3BlZCBieSBoaWRkZW4gZGF5cywgZ28gcGFzdCB0aGUgaGlkZGVuIGRheXNcbiAgICBpZiAoIXRoaXMudHJpbUhpZGRlbkRheXMocmVzKSkge1xuICAgICAgZGF0ZSA9IHRoaXMuc2tpcEhpZGRlbkRheXMoZGF0ZSwgZGlyZWN0aW9uKVxuICAgICAgY29tcHV0ZVJlcygpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc1xuICB9XG5cblxuICAvLyBCdWlsZHMgdGhlIFwiY3VycmVudFwiIHJhbmdlIHdoZW4gYSBkYXlDb3VudCBpcyBzcGVjaWZpZWQuXG4gIGJ1aWxkUmFuZ2VGcm9tRGF5Q291bnQoZGF0ZTogRGF0ZU1hcmtlciwgZGlyZWN0aW9uLCBkYXlDb3VudCkge1xuICAgIGxldCB7IGRhdGVFbnYsIGRhdGVBbGlnbm1lbnQgfSA9IHRoaXMucHJvcHNcbiAgICBsZXQgcnVubmluZ0NvdW50ID0gMFxuICAgIGxldCBzdGFydDogRGF0ZU1hcmtlciA9IGRhdGVcbiAgICBsZXQgZW5kOiBEYXRlTWFya2VyXG5cbiAgICBpZiAoZGF0ZUFsaWdubWVudCkge1xuICAgICAgc3RhcnQgPSBkYXRlRW52LnN0YXJ0T2Yoc3RhcnQsIGRhdGVBbGlnbm1lbnQpXG4gICAgfVxuXG4gICAgc3RhcnQgPSBzdGFydE9mRGF5KHN0YXJ0KVxuICAgIHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydCwgZGlyZWN0aW9uKVxuXG4gICAgZW5kID0gc3RhcnRcbiAgICBkbyB7XG4gICAgICBlbmQgPSBhZGREYXlzKGVuZCwgMSlcbiAgICAgIGlmICghdGhpcy5pc0hpZGRlbkRheShlbmQpKSB7XG4gICAgICAgIHJ1bm5pbmdDb3VudCsrXG4gICAgICB9XG4gICAgfSB3aGlsZSAocnVubmluZ0NvdW50IDwgZGF5Q291bnQpXG5cbiAgICByZXR1cm4geyBzdGFydCwgZW5kIH1cbiAgfVxuXG5cbiAgLy8gQnVpbGRzIGEgbm9ybWFsaXplZCByYW5nZSBvYmplY3QgZm9yIHRoZSBcInZpc2libGVcIiByYW5nZSxcbiAgLy8gd2hpY2ggaXMgYSB3YXkgdG8gZGVmaW5lIHRoZSBjdXJyZW50UmFuZ2UgYW5kIGFjdGl2ZVJhbmdlIGF0IHRoZSBzYW1lIHRpbWUuXG4gIGJ1aWxkQ3VzdG9tVmlzaWJsZVJhbmdlKGRhdGU6IERhdGVNYXJrZXIpIHtcbiAgICBsZXQgeyBwcm9wcyB9ID0gdGhpc1xuICAgIGxldCBpbnB1dCA9IHByb3BzLnZpc2libGVSYW5nZUlucHV0XG4gICAgbGV0IHNpbXBsZUlucHV0ID0gdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nXG4gICAgICA/IGlucHV0LmNhbGwocHJvcHMuY2FsZW5kYXJBcGksIHByb3BzLmRhdGVFbnYudG9EYXRlKGRhdGUpKVxuICAgICAgOiBpbnB1dFxuXG4gICAgbGV0IHJhbmdlID0gdGhpcy5yZWZpbmVSYW5nZShzaW1wbGVJbnB1dClcblxuICAgIGlmIChyYW5nZSAmJiAocmFuZ2Uuc3RhcnQgPT0gbnVsbCB8fCByYW5nZS5lbmQgPT0gbnVsbCkpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlXG4gIH1cblxuXG4gIC8vIENvbXB1dGVzIHRoZSByYW5nZSB0aGF0IHdpbGwgcmVwcmVzZW50IHRoZSBlbGVtZW50L2NlbGxzIGZvciAqcmVuZGVyaW5nKixcbiAgLy8gYnV0IHdoaWNoIG1heSBoYXZlIHZvaWRlZCBkYXlzL3RpbWVzLlxuICAvLyBub3QgcmVzcG9uc2libGUgZm9yIHRyaW1taW5nIGhpZGRlbiBkYXlzLlxuICBidWlsZFJlbmRlclJhbmdlKGN1cnJlbnRSYW5nZTogRGF0ZVJhbmdlLCBjdXJyZW50UmFuZ2VVbml0LCBpc1JhbmdlQWxsRGF5KSB7XG4gICAgcmV0dXJuIGN1cnJlbnRSYW5nZVxuICB9XG5cblxuICAvLyBDb21wdXRlIHRoZSBkdXJhdGlvbiB2YWx1ZSB0aGF0IHNob3VsZCBiZSBhZGRlZC9zdWJzdHJhY3RlZCB0byB0aGUgY3VycmVudCBkYXRlXG4gIC8vIHdoZW4gYSBwcmV2L25leHQgb3BlcmF0aW9uIGhhcHBlbnMuXG4gIGJ1aWxkRGF0ZUluY3JlbWVudChmYWxsYmFjayk6IER1cmF0aW9uIHtcbiAgICBsZXQgeyBkYXRlSW5jcmVtZW50IH0gPSB0aGlzLnByb3BzXG4gICAgbGV0IGN1c3RvbUFsaWdubWVudFxuXG4gICAgaWYgKGRhdGVJbmNyZW1lbnQpIHtcbiAgICAgIHJldHVybiBkYXRlSW5jcmVtZW50XG5cbiAgICB9IGVsc2UgaWYgKChjdXN0b21BbGlnbm1lbnQgPSB0aGlzLnByb3BzLmRhdGVBbGlnbm1lbnQpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oMSwgY3VzdG9tQWxpZ25tZW50KVxuXG4gICAgfSBlbHNlIGlmIChmYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGZhbGxiYWNrXG5cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHsgZGF5czogMSB9KVxuICAgIH1cbiAgfVxuXG5cbiAgcmVmaW5lUmFuZ2UocmFuZ2VJbnB1dDogRGF0ZVJhbmdlSW5wdXQgfCB1bmRlZmluZWQpOiBEYXRlUmFuZ2UgfCBudWxsIHtcbiAgICBpZiAocmFuZ2VJbnB1dCkge1xuICAgICAgbGV0IHJhbmdlID0gcGFyc2VSYW5nZShyYW5nZUlucHV0LCB0aGlzLnByb3BzLmRhdGVFbnYpXG5cbiAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICByYW5nZSA9IGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UocmFuZ2UpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByYW5nZVxuICAgIH1cblxuICAgIHJldHVybiBudWxsXG4gIH1cblxuXG4gIC8qIEhpZGRlbiBEYXlzXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuICAvLyBJbml0aWFsaXplcyBpbnRlcm5hbCB2YXJpYWJsZXMgcmVsYXRlZCB0byBjYWxjdWxhdGluZyBoaWRkZW4gZGF5cy1vZi13ZWVrXG4gIGluaXRIaWRkZW5EYXlzKCkge1xuICAgIGxldCBoaWRkZW5EYXlzID0gdGhpcy5wcm9wcy5oaWRkZW5EYXlzIHx8IFtdIC8vIGFycmF5IG9mIGRheS1vZi13ZWVrIGluZGljZXMgdGhhdCBhcmUgaGlkZGVuXG4gICAgbGV0IGlzSGlkZGVuRGF5SGFzaCA9IFtdIC8vIGlzIHRoZSBkYXktb2Ytd2VlayBoaWRkZW4/IChoYXNoIHdpdGggZGF5LW9mLXdlZWstaW5kZXggLT4gYm9vbClcbiAgICBsZXQgZGF5Q250ID0gMFxuICAgIGxldCBpXG5cbiAgICBpZiAodGhpcy5wcm9wcy53ZWVrZW5kcyA9PT0gZmFsc2UpIHtcbiAgICAgIGhpZGRlbkRheXMucHVzaCgwLCA2KSAvLyAwPXN1bmRheSwgNj1zYXR1cmRheVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgIGlmIChcbiAgICAgICAgIShpc0hpZGRlbkRheUhhc2hbaV0gPSBoaWRkZW5EYXlzLmluZGV4T2YoaSkgIT09IC0xKVxuICAgICAgKSB7XG4gICAgICAgIGRheUNudCsrXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFkYXlDbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBoaWRkZW5EYXlzJykgLy8gYWxsIGRheXMgd2VyZSBoaWRkZW4/IGJhZC5cbiAgICB9XG5cbiAgICB0aGlzLmlzSGlkZGVuRGF5SGFzaCA9IGlzSGlkZGVuRGF5SGFzaFxuICB9XG5cblxuICAvLyBSZW1vdmUgZGF5cyBmcm9tIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgcmFuZ2UgdGhhdCBhcmUgY29tcHV0ZWQgYXMgaGlkZGVuLlxuICAvLyBJZiB0aGUgd2hvbGUgcmFuZ2UgaXMgdHJpbW1lZCBvZmYsIHJldHVybnMgbnVsbFxuICB0cmltSGlkZGVuRGF5cyhyYW5nZTogRGF0ZVJhbmdlKTogRGF0ZVJhbmdlIHwgbnVsbCB7XG4gICAgbGV0IHN0YXJ0ID0gcmFuZ2Uuc3RhcnRcbiAgICBsZXQgZW5kID0gcmFuZ2UuZW5kXG5cbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydClcbiAgICB9XG5cbiAgICBpZiAoZW5kKSB7XG4gICAgICBlbmQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKGVuZCwgLTEsIHRydWUpXG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID09IG51bGwgfHwgZW5kID09IG51bGwgfHwgc3RhcnQgPCBlbmQpIHtcbiAgICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsXG4gIH1cblxuXG4gIC8vIElzIHRoZSBjdXJyZW50IGRheSBoaWRkZW4/XG4gIC8vIGBkYXlgIGlzIGEgZGF5LW9mLXdlZWsgaW5kZXggKDAtNiksIG9yIGEgRGF0ZSAodXNlZCBmb3IgVVRDKVxuICBpc0hpZGRlbkRheShkYXkpIHtcbiAgICBpZiAoZGF5IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgZGF5ID0gZGF5LmdldFVUQ0RheSgpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlzSGlkZGVuRGF5SGFzaFtkYXldXG4gIH1cblxuXG4gIC8vIEluY3JlbWVudGluZyB0aGUgY3VycmVudCBkYXkgdW50aWwgaXQgaXMgbm8gbG9uZ2VyIGEgaGlkZGVuIGRheSwgcmV0dXJuaW5nIGEgY29weS5cbiAgLy8gRE9FUyBOT1QgQ09OU0lERVIgdmFsaWRSYW5nZSFcbiAgLy8gSWYgdGhlIGluaXRpYWwgdmFsdWUgb2YgYGRhdGVgIGlzIG5vdCBhIGhpZGRlbiBkYXksIGRvbid0IGRvIGFueXRoaW5nLlxuICAvLyBQYXNzIGBpc0V4Y2x1c2l2ZWAgYXMgYHRydWVgIGlmIHlvdSBhcmUgZGVhbGluZyB3aXRoIGFuIGVuZCBkYXRlLlxuICAvLyBgaW5jYCBkZWZhdWx0cyB0byBgMWAgKGluY3JlbWVudCBvbmUgZGF5IGZvcndhcmQgZWFjaCB0aW1lKVxuICBza2lwSGlkZGVuRGF5cyhkYXRlOiBEYXRlTWFya2VyLCBpbmMgPSAxLCBpc0V4Y2x1c2l2ZSA9IGZhbHNlKSB7XG4gICAgd2hpbGUgKFxuICAgICAgdGhpcy5pc0hpZGRlbkRheUhhc2hbKGRhdGUuZ2V0VVRDRGF5KCkgKyAoaXNFeGNsdXNpdmUgPyBpbmMgOiAwKSArIDcpICUgN11cbiAgICApIHtcbiAgICAgIGRhdGUgPSBhZGREYXlzKGRhdGUsIGluYylcbiAgICB9XG4gICAgcmV0dXJuIGRhdGVcbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBBY3Rpb24gfSBmcm9tICcuL0FjdGlvbidcblxuXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlVmlld1R5cGUodmlld1R5cGU6IHN0cmluZywgYWN0aW9uOiBBY3Rpb24pOiBzdHJpbmcge1xuXG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlICdDSEFOR0VfVklFV19UWVBFJzpcbiAgICAgIHJldHVybiB2aWV3VHlwZSA9IGFjdGlvbi52aWV3VHlwZVxuICB9XG5cbiAgcmV0dXJuIHZpZXdUeXBlXG59XG4iLCJpbXBvcnQgeyBBY3Rpb24gfSBmcm9tICcuL0FjdGlvbidcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZHVjZUR5bmFtaWNPcHRpb25PdmVycmlkZXMoZHluYW1pY09wdGlvbk92ZXJyaWRlcywgYWN0aW9uOiBBY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgJ1NFVF9PUFRJT04nOlxuICAgICAgcmV0dXJuIHsgLi4uZHluYW1pY09wdGlvbk92ZXJyaWRlcywgW2FjdGlvbi5vcHRpb25OYW1lXTogYWN0aW9uLnJhd09wdGlvblZhbHVlIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGR5bmFtaWNPcHRpb25PdmVycmlkZXNcbiAgfVxufVxuIiwiaW1wb3J0IHsgRGF0ZVByb2ZpbGUsIERhdGVQcm9maWxlR2VuZXJhdG9yIH0gZnJvbSAnLi4vRGF0ZVByb2ZpbGVHZW5lcmF0b3InXG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tICcuL0FjdGlvbidcbmltcG9ydCB7IERhdGVNYXJrZXIgfSBmcm9tICcuLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IHJhbmdlQ29udGFpbnNNYXJrZXIgfSBmcm9tICcuLi9kYXRlbGliL2RhdGUtcmFuZ2UnXG5cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZHVjZURhdGVQcm9maWxlKGN1cnJlbnREYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGUgfCBudWxsLCBhY3Rpb246IEFjdGlvbiwgY3VycmVudERhdGU6IERhdGVNYXJrZXIsIGRhdGVQcm9maWxlR2VuZXJhdG9yOiBEYXRlUHJvZmlsZUdlbmVyYXRvcik6IERhdGVQcm9maWxlIHtcbiAgbGV0IGRwOiBEYXRlUHJvZmlsZVxuXG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcblxuICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxuICAgICAgcmV0dXJuIGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKGFjdGlvbi5kYXRlTWFya2VyIHx8IGN1cnJlbnREYXRlKVxuXG4gICAgY2FzZSAnQ0hBTkdFX0RBVEUnOlxuICAgICAgaWYgKFxuICAgICAgICAhY3VycmVudERhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIHx8XG4gICAgICAgICFyYW5nZUNvbnRhaW5zTWFya2VyKGN1cnJlbnREYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UsIGFjdGlvbi5kYXRlTWFya2VyKSAvLyBkb24ndCBtb3ZlIGlmIGRhdGUgYWxyZWFkeSBpbiB2aWV3XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKGFjdGlvbi5kYXRlTWFya2VyKVxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgJ1BSRVYnOlxuICAgICAgZHAgPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZFByZXYoY3VycmVudERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSlcbiAgICAgIGlmIChkcC5pc1ZhbGlkKSB7XG4gICAgICAgIHJldHVybiBkcFxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgJ05FWFQnOlxuICAgICAgZHAgPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZE5leHQoY3VycmVudERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSlcbiAgICAgIGlmIChkcC5pc1ZhbGlkKSB7XG4gICAgICAgIHJldHVybiBkcFxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgfVxuXG4gIHJldHVybiBjdXJyZW50RGF0ZVByb2ZpbGVcbn1cbiIsImltcG9ydCB7IEV2ZW50U291cmNlLCBFdmVudFNvdXJjZUhhc2ggfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LXNvdXJjZSdcbmltcG9ydCB7IHBhcnNlRXZlbnRTb3VyY2UsIGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyB9IGZyb20gJy4uL3N0cnVjdHMvZXZlbnQtc291cmNlLXBhcnNlJ1xuaW1wb3J0IHsgYXJyYXlUb0hhc2gsIGZpbHRlckhhc2ggfSBmcm9tICcuLi91dGlsL29iamVjdCdcbmltcG9ydCB7IERhdGVSYW5nZSB9IGZyb20gJy4uL2RhdGVsaWIvZGF0ZS1yYW5nZSdcbmltcG9ydCB7IERhdGVQcm9maWxlIH0gZnJvbSAnLi4vRGF0ZVByb2ZpbGVHZW5lcmF0b3InXG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tICcuL0FjdGlvbidcbmltcG9ydCB7IGd1aWQgfSBmcm9tICcuLi91dGlsL21pc2MnXG5pbXBvcnQgeyBDYWxlbmRhckNvbnRleHQgfSBmcm9tICcuLi9DYWxlbmRhckNvbnRleHQnXG5pbXBvcnQgeyBDYWxlbmRhck9wdGlvbnMgfSBmcm9tICcuLi9vcHRpb25zJ1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0RXZlbnRTb3VyY2VzKGNhbGVuZGFyT3B0aW9ucywgZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpIHtcbiAgbGV0IGFjdGl2ZVJhbmdlID0gZGF0ZVByb2ZpbGUgPyBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSA6IG51bGxcblxuICByZXR1cm4gYWRkU291cmNlcyhcbiAgICB7fSxcbiAgICBwYXJzZUluaXRpYWxTb3VyY2VzKGNhbGVuZGFyT3B0aW9ucywgY29udGV4dCksXG4gICAgYWN0aXZlUmFuZ2UsXG4gICAgY29udGV4dFxuICApXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZHVjZUV2ZW50U291cmNlcyhldmVudFNvdXJjZXM6IEV2ZW50U291cmNlSGFzaCwgYWN0aW9uOiBBY3Rpb24sIGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZSwgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KTogRXZlbnRTb3VyY2VIYXNoIHtcbiAgbGV0IGFjdGl2ZVJhbmdlID0gZGF0ZVByb2ZpbGUgPyBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSA6IG51bGwgLy8gbmVlZCB0aGlzIGNoZWNrP1xuXG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcblxuICAgIGNhc2UgJ0FERF9FVkVOVF9TT1VSQ0VTJzogLy8gYWxyZWFkeSBwYXJzZWRcbiAgICAgIHJldHVybiBhZGRTb3VyY2VzKGV2ZW50U291cmNlcywgYWN0aW9uLnNvdXJjZXMsIGFjdGl2ZVJhbmdlLCBjb250ZXh0KVxuXG4gICAgY2FzZSAnUkVNT1ZFX0VWRU5UX1NPVVJDRSc6XG4gICAgICByZXR1cm4gcmVtb3ZlU291cmNlKGV2ZW50U291cmNlcywgYWN0aW9uLnNvdXJjZUlkKVxuXG4gICAgY2FzZSAnUFJFVic6IC8vIFRPRE86IGhvdyBkbyB3ZSB0cmFjayBhbGwgYWN0aW9ucyB0aGF0IGFmZmVjdCBkYXRlUHJvZmlsZSA6KFxuICAgIGNhc2UgJ05FWFQnOlxuICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcbiAgICBjYXNlICdDSEFOR0VfVklFV19UWVBFJzpcbiAgICAgIGlmIChkYXRlUHJvZmlsZSkge1xuICAgICAgICByZXR1cm4gZmV0Y2hEaXJ0eVNvdXJjZXMoZXZlbnRTb3VyY2VzLCBhY3RpdmVSYW5nZSwgY29udGV4dClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBldmVudFNvdXJjZXNcbiAgICAgIH1cblxuICAgIGNhc2UgJ0ZFVENIX0VWRU5UX1NPVVJDRVMnOlxuICAgICAgcmV0dXJuIGZldGNoU291cmNlc0J5SWRzKFxuICAgICAgICBldmVudFNvdXJjZXMsXG4gICAgICAgIChhY3Rpb24gYXMgYW55KS5zb3VyY2VJZHMgPyAvLyB3aHkgbm8gdHlwZT9cbiAgICAgICAgICBhcnJheVRvSGFzaCgoYWN0aW9uIGFzIGFueSkuc291cmNlSWRzKSA6XG4gICAgICAgICAgZXhjbHVkZVN0YXRpY1NvdXJjZXMoZXZlbnRTb3VyY2VzLCBjb250ZXh0KSxcbiAgICAgICAgYWN0aXZlUmFuZ2UsXG4gICAgICAgIGNvbnRleHRcbiAgICAgIClcblxuICAgIGNhc2UgJ1JFQ0VJVkVfRVZFTlRTJzpcbiAgICBjYXNlICdSRUNFSVZFX0VWRU5UX0VSUk9SJzpcbiAgICAgIHJldHVybiByZWNlaXZlUmVzcG9uc2UoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlSWQsIGFjdGlvbi5mZXRjaElkLCBhY3Rpb24uZmV0Y2hSYW5nZSlcblxuICAgIGNhc2UgJ1JFTU9WRV9BTExfRVZFTlRfU09VUkNFUyc6XG4gICAgICByZXR1cm4ge31cblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZXZlbnRTb3VyY2VzXG4gIH1cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlRXZlbnRTb3VyY2VzTmV3VGltZVpvbmUoZXZlbnRTb3VyY2VzOiBFdmVudFNvdXJjZUhhc2gsIGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZSwgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KSB7XG4gIGxldCBhY3RpdmVSYW5nZSA9IGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsIC8vIG5lZWQgdGhpcyBjaGVjaz9cblxuICByZXR1cm4gZmV0Y2hTb3VyY2VzQnlJZHMoXG4gICAgZXZlbnRTb3VyY2VzLFxuICAgIGV4Y2x1ZGVTdGF0aWNTb3VyY2VzKGV2ZW50U291cmNlcywgY29udGV4dCksXG4gICAgYWN0aXZlUmFuZ2UsXG4gICAgY29udGV4dFxuICApXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVFdmVudFNvdXJjZUxvYWRpbmdMZXZlbChldmVudFNvdXJjZXM6IEV2ZW50U291cmNlSGFzaCk6IG51bWJlciB7XG4gIGxldCBjbnQgPSAwXG5cbiAgZm9yIChsZXQgc291cmNlSWQgaW4gZXZlbnRTb3VyY2VzKSB7XG4gICAgaWYgKGV2ZW50U291cmNlc1tzb3VyY2VJZF0uaXNGZXRjaGluZykge1xuICAgICAgY250KytcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY250XG59XG5cblxuZnVuY3Rpb24gYWRkU291cmNlcyhldmVudFNvdXJjZUhhc2g6IEV2ZW50U291cmNlSGFzaCwgc291cmNlczogRXZlbnRTb3VyY2U8YW55PltdLCBmZXRjaFJhbmdlOiBEYXRlUmFuZ2UgfCBudWxsLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpOiBFdmVudFNvdXJjZUhhc2gge1xuICBsZXQgaGFzaDogRXZlbnRTb3VyY2VIYXNoID0ge31cblxuICBmb3IgKGxldCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgIGhhc2hbc291cmNlLnNvdXJjZUlkXSA9IHNvdXJjZVxuICB9XG5cbiAgaWYgKGZldGNoUmFuZ2UpIHtcbiAgICBoYXNoID0gZmV0Y2hEaXJ0eVNvdXJjZXMoaGFzaCwgZmV0Y2hSYW5nZSwgY29udGV4dClcbiAgfVxuXG4gIHJldHVybiB7IC4uLmV2ZW50U291cmNlSGFzaCwgLi4uaGFzaCB9XG59XG5cblxuZnVuY3Rpb24gcmVtb3ZlU291cmNlKGV2ZW50U291cmNlSGFzaDogRXZlbnRTb3VyY2VIYXNoLCBzb3VyY2VJZDogc3RyaW5nKTogRXZlbnRTb3VyY2VIYXNoIHtcbiAgcmV0dXJuIGZpbHRlckhhc2goZXZlbnRTb3VyY2VIYXNoLCBmdW5jdGlvbihldmVudFNvdXJjZTogRXZlbnRTb3VyY2U8YW55Pikge1xuICAgIHJldHVybiBldmVudFNvdXJjZS5zb3VyY2VJZCAhPT0gc291cmNlSWRcbiAgfSlcbn1cblxuXG5mdW5jdGlvbiBmZXRjaERpcnR5U291cmNlcyhzb3VyY2VIYXNoOiBFdmVudFNvdXJjZUhhc2gsIGZldGNoUmFuZ2U6IERhdGVSYW5nZSwgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KTogRXZlbnRTb3VyY2VIYXNoIHtcbiAgcmV0dXJuIGZldGNoU291cmNlc0J5SWRzKFxuICAgIHNvdXJjZUhhc2gsXG4gICAgZmlsdGVySGFzaChzb3VyY2VIYXNoLCBmdW5jdGlvbihldmVudFNvdXJjZSkge1xuICAgICAgcmV0dXJuIGlzU291cmNlRGlydHkoZXZlbnRTb3VyY2UsIGZldGNoUmFuZ2UsIGNvbnRleHQpXG4gICAgfSksXG4gICAgZmV0Y2hSYW5nZSxcbiAgICBjb250ZXh0XG4gIClcbn1cblxuXG5mdW5jdGlvbiBpc1NvdXJjZURpcnR5KGV2ZW50U291cmNlOiBFdmVudFNvdXJjZTxhbnk+LCBmZXRjaFJhbmdlOiBEYXRlUmFuZ2UsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCkge1xuXG4gIGlmICghZG9lc1NvdXJjZU5lZWRSYW5nZShldmVudFNvdXJjZSwgY29udGV4dCkpIHtcbiAgICByZXR1cm4gIWV2ZW50U291cmNlLmxhdGVzdEZldGNoSWRcblxuICB9IGVsc2Uge1xuICAgIHJldHVybiAhY29udGV4dC5vcHRpb25zLmxhenlGZXRjaGluZyB8fFxuICAgICAgIWV2ZW50U291cmNlLmZldGNoUmFuZ2UgfHxcbiAgICAgIGV2ZW50U291cmNlLmlzRmV0Y2hpbmcgfHwgLy8gYWx3YXlzIGNhbmNlbCBvdXRkYXRlZCBpbi1wcm9ncmVzcyBmZXRjaGVzXG4gICAgICBmZXRjaFJhbmdlLnN0YXJ0IDwgZXZlbnRTb3VyY2UuZmV0Y2hSYW5nZS5zdGFydCB8fFxuICAgICAgZmV0Y2hSYW5nZS5lbmQgPiBldmVudFNvdXJjZS5mZXRjaFJhbmdlLmVuZFxuICB9XG59XG5cblxuZnVuY3Rpb24gZmV0Y2hTb3VyY2VzQnlJZHMoXG4gIHByZXZTb3VyY2VzOiBFdmVudFNvdXJjZUhhc2gsXG4gIHNvdXJjZUlkSGFzaDogeyBbc291cmNlSWQ6IHN0cmluZ106IGFueSB9LFxuICBmZXRjaFJhbmdlOiBEYXRlUmFuZ2UsXG4gIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dFxuKTogRXZlbnRTb3VyY2VIYXNoIHtcbiAgbGV0IG5leHRTb3VyY2VzOiBFdmVudFNvdXJjZUhhc2ggPSB7fVxuXG4gIGZvciAobGV0IHNvdXJjZUlkIGluIHByZXZTb3VyY2VzKSB7XG4gICAgbGV0IHNvdXJjZSA9IHByZXZTb3VyY2VzW3NvdXJjZUlkXVxuXG4gICAgaWYgKHNvdXJjZUlkSGFzaFtzb3VyY2VJZF0pIHtcbiAgICAgIG5leHRTb3VyY2VzW3NvdXJjZUlkXSA9IGZldGNoU291cmNlKHNvdXJjZSwgZmV0Y2hSYW5nZSwgY29udGV4dClcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dFNvdXJjZXNbc291cmNlSWRdID0gc291cmNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5leHRTb3VyY2VzXG59XG5cblxuZnVuY3Rpb24gZmV0Y2hTb3VyY2UoZXZlbnRTb3VyY2U6IEV2ZW50U291cmNlPGFueT4sIGZldGNoUmFuZ2U6IERhdGVSYW5nZSwgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KSB7XG4gIGxldCB7IG9wdGlvbnMsIGNhbGVuZGFyQXBpIH0gPSBjb250ZXh0XG4gIGxldCBzb3VyY2VEZWYgPSBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50U291cmNlRGVmc1tldmVudFNvdXJjZS5zb3VyY2VEZWZJZF1cbiAgbGV0IGZldGNoSWQgPSBndWlkKClcblxuICBzb3VyY2VEZWYuZmV0Y2goXG4gICAge1xuICAgICAgZXZlbnRTb3VyY2UsXG4gICAgICByYW5nZTogZmV0Y2hSYW5nZSxcbiAgICAgIGNvbnRleHRcbiAgICB9LFxuICAgIGZ1bmN0aW9uKHJlcykge1xuICAgICAgbGV0IHsgcmF3RXZlbnRzIH0gPSByZXNcblxuICAgICAgaWYgKG9wdGlvbnMuZXZlbnRTb3VyY2VTdWNjZXNzKSB7XG4gICAgICAgIHJhd0V2ZW50cyA9IG9wdGlvbnMuZXZlbnRTb3VyY2VTdWNjZXNzLmNhbGwoY2FsZW5kYXJBcGksIHJhd0V2ZW50cywgcmVzLnhocikgfHwgcmF3RXZlbnRzXG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudFNvdXJjZS5zdWNjZXNzKSB7XG4gICAgICAgIHJhd0V2ZW50cyA9IGV2ZW50U291cmNlLnN1Y2Nlc3MuY2FsbChjYWxlbmRhckFwaSwgcmF3RXZlbnRzLCByZXMueGhyKSB8fCByYXdFdmVudHNcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6ICdSRUNFSVZFX0VWRU5UUycsXG4gICAgICAgIHNvdXJjZUlkOiBldmVudFNvdXJjZS5zb3VyY2VJZCxcbiAgICAgICAgZmV0Y2hJZCxcbiAgICAgICAgZmV0Y2hSYW5nZSxcbiAgICAgICAgcmF3RXZlbnRzXG4gICAgICB9KVxuICAgIH0sXG4gICAgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihlcnJvci5tZXNzYWdlLCBlcnJvcilcblxuICAgICAgaWYgKG9wdGlvbnMuZXZlbnRTb3VyY2VGYWlsdXJlKSB7XG4gICAgICAgIG9wdGlvbnMuZXZlbnRTb3VyY2VGYWlsdXJlLmNhbGwoY2FsZW5kYXJBcGksIGVycm9yKVxuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnRTb3VyY2UuZmFpbHVyZSkge1xuICAgICAgICBldmVudFNvdXJjZS5mYWlsdXJlKGVycm9yKVxuICAgICAgfVxuXG4gICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogJ1JFQ0VJVkVfRVZFTlRfRVJST1InLFxuICAgICAgICBzb3VyY2VJZDogZXZlbnRTb3VyY2Uuc291cmNlSWQsXG4gICAgICAgIGZldGNoSWQsXG4gICAgICAgIGZldGNoUmFuZ2UsXG4gICAgICAgIGVycm9yXG4gICAgICB9KVxuICAgIH1cbiAgKVxuXG4gIHJldHVybiB7XG4gICAgLi4uZXZlbnRTb3VyY2UsXG4gICAgaXNGZXRjaGluZzogdHJ1ZSxcbiAgICBsYXRlc3RGZXRjaElkOiBmZXRjaElkXG4gIH1cbn1cblxuXG5mdW5jdGlvbiByZWNlaXZlUmVzcG9uc2Uoc291cmNlSGFzaDogRXZlbnRTb3VyY2VIYXNoLCBzb3VyY2VJZDogc3RyaW5nLCBmZXRjaElkOiBzdHJpbmcsIGZldGNoUmFuZ2U6IERhdGVSYW5nZSkge1xuICBsZXQgZXZlbnRTb3VyY2U6IEV2ZW50U291cmNlPGFueT4gPSBzb3VyY2VIYXNoW3NvdXJjZUlkXVxuXG4gIGlmIChcbiAgICBldmVudFNvdXJjZSAmJiAvLyBub3QgYWxyZWFkeSByZW1vdmVkXG4gICAgZmV0Y2hJZCA9PT0gZXZlbnRTb3VyY2UubGF0ZXN0RmV0Y2hJZFxuICApIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc291cmNlSGFzaCxcbiAgICAgIFtzb3VyY2VJZF06IHtcbiAgICAgICAgLi4uZXZlbnRTb3VyY2UsXG4gICAgICAgIGlzRmV0Y2hpbmc6IGZhbHNlLFxuICAgICAgICBmZXRjaFJhbmdlIC8vIGFsc28gc2VydmVzIGFzIGEgbWFya2VyIHRoYXQgYXQgbGVhc3Qgb25lIGZldGNoIGhhcyBjb21wbGV0ZWRcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc291cmNlSGFzaFxufVxuXG5cbmZ1bmN0aW9uIGV4Y2x1ZGVTdGF0aWNTb3VyY2VzKGV2ZW50U291cmNlczogRXZlbnRTb3VyY2VIYXNoLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpOiBFdmVudFNvdXJjZUhhc2gge1xuICByZXR1cm4gZmlsdGVySGFzaChldmVudFNvdXJjZXMsIGZ1bmN0aW9uKGV2ZW50U291cmNlKSB7XG4gICAgcmV0dXJuIGRvZXNTb3VyY2VOZWVkUmFuZ2UoZXZlbnRTb3VyY2UsIGNvbnRleHQpXG4gIH0pXG59XG5cblxuZnVuY3Rpb24gcGFyc2VJbml0aWFsU291cmNlcyhyYXdPcHRpb25zOiBDYWxlbmRhck9wdGlvbnMsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCkge1xuICBsZXQgcmVmaW5lcnMgPSBidWlsZEV2ZW50U291cmNlUmVmaW5lcnMoY29udGV4dClcbiAgbGV0IHJhd1NvdXJjZXMgPSBbXS5jb25jYXQocmF3T3B0aW9ucy5ldmVudFNvdXJjZXMgfHwgW10pXG4gIGxldCBzb3VyY2VzID0gW10gLy8gcGFyc2VkXG5cbiAgaWYgKHJhd09wdGlvbnMuaW5pdGlhbEV2ZW50cykge1xuICAgIHJhd1NvdXJjZXMudW5zaGlmdChyYXdPcHRpb25zLmluaXRpYWxFdmVudHMpXG4gIH1cblxuICBpZiAocmF3T3B0aW9ucy5ldmVudHMpIHtcbiAgICByYXdTb3VyY2VzLnVuc2hpZnQocmF3T3B0aW9ucy5ldmVudHMpXG4gIH1cblxuICBmb3IgKGxldCByYXdTb3VyY2Ugb2YgcmF3U291cmNlcykge1xuICAgIGxldCBzb3VyY2UgPSBwYXJzZUV2ZW50U291cmNlKHJhd1NvdXJjZSwgY29udGV4dCwgcmVmaW5lcnMpXG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgc291cmNlcy5wdXNoKHNvdXJjZSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc291cmNlc1xufVxuXG5cbmZ1bmN0aW9uIGRvZXNTb3VyY2VOZWVkUmFuZ2UoZXZlbnRTb3VyY2U6IEV2ZW50U291cmNlPGFueT4sIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCkge1xuICBsZXQgZGVmcyA9IGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnRTb3VyY2VEZWZzXG5cbiAgcmV0dXJuICFkZWZzW2V2ZW50U291cmNlLnNvdXJjZURlZklkXS5pZ25vcmVSYW5nZVxufVxuIiwiaW1wb3J0IHsgRGF0ZVNwYW4gfSBmcm9tICcuLi9zdHJ1Y3RzL2RhdGUtc3BhbidcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gJy4vQWN0aW9uJ1xuXG5cbmV4cG9ydCBmdW5jdGlvbiByZWR1Y2VEYXRlU2VsZWN0aW9uKGN1cnJlbnRTZWxlY3Rpb246IERhdGVTcGFuIHwgbnVsbCwgYWN0aW9uOiBBY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgJ1VOU0VMRUNUX0RBVEVTJzpcbiAgICAgIHJldHVybiBudWxsXG5cbiAgICBjYXNlICdTRUxFQ1RfREFURVMnOlxuICAgICAgcmV0dXJuIGFjdGlvbi5zZWxlY3Rpb25cblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gY3VycmVudFNlbGVjdGlvblxuICB9XG59XG4iLCJpbXBvcnQgeyBBY3Rpb24gfSBmcm9tICcuL0FjdGlvbidcblxuXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlU2VsZWN0ZWRFdmVudChjdXJyZW50SW5zdGFuY2VJZDogc3RyaW5nLCBhY3Rpb246IEFjdGlvbik6IHN0cmluZyB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlICdVTlNFTEVDVF9FVkVOVCc6XG4gICAgICByZXR1cm4gJydcblxuICAgIGNhc2UgJ1NFTEVDVF9FVkVOVCc6XG4gICAgICByZXR1cm4gYWN0aW9uLmV2ZW50SW5zdGFuY2VJZFxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjdXJyZW50SW5zdGFuY2VJZFxuICB9XG59XG4iLCJpbXBvcnQgeyBBY3Rpb24gfSBmcm9tICcuL0FjdGlvbidcbmltcG9ydCB7IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSB9IGZyb20gJy4uL2ludGVyYWN0aW9ucy9ldmVudC1pbnRlcmFjdGlvbi1zdGF0ZSdcblxuXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlRXZlbnREcmFnKGN1cnJlbnREcmFnOiBFdmVudEludGVyYWN0aW9uU3RhdGUgfCBudWxsLCBhY3Rpb246IEFjdGlvbik6IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSB8IG51bGwge1xuICBsZXQgbmV3RHJhZzogRXZlbnRJbnRlcmFjdGlvblN0YXRlXG5cbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgJ1VOU0VUX0VWRU5UX0RSQUcnOlxuICAgICAgcmV0dXJuIG51bGxcblxuICAgIGNhc2UgJ1NFVF9FVkVOVF9EUkFHJzpcbiAgICAgIG5ld0RyYWcgPSBhY3Rpb24uc3RhdGVcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWZmZWN0ZWRFdmVudHM6IG5ld0RyYWcuYWZmZWN0ZWRFdmVudHMsXG4gICAgICAgIG11dGF0ZWRFdmVudHM6IG5ld0RyYWcubXV0YXRlZEV2ZW50cyxcbiAgICAgICAgaXNFdmVudDogbmV3RHJhZy5pc0V2ZW50XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGN1cnJlbnREcmFnXG4gIH1cbn1cbiIsImltcG9ydCB7IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSB9IGZyb20gJy4uL2ludGVyYWN0aW9ucy9ldmVudC1pbnRlcmFjdGlvbi1zdGF0ZSdcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gJy4vQWN0aW9uJ1xuXG5cbmV4cG9ydCBmdW5jdGlvbiByZWR1Y2VFdmVudFJlc2l6ZShjdXJyZW50UmVzaXplOiBFdmVudEludGVyYWN0aW9uU3RhdGUgfCBudWxsLCBhY3Rpb246IEFjdGlvbik6IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSB8IG51bGwge1xuICBsZXQgbmV3UmVzaXplOiBFdmVudEludGVyYWN0aW9uU3RhdGVcblxuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSAnVU5TRVRfRVZFTlRfUkVTSVpFJzpcbiAgICAgIHJldHVybiBudWxsXG5cbiAgICBjYXNlICdTRVRfRVZFTlRfUkVTSVpFJzpcbiAgICAgIG5ld1Jlc2l6ZSA9IGFjdGlvbi5zdGF0ZVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZmZlY3RlZEV2ZW50czogbmV3UmVzaXplLmFmZmVjdGVkRXZlbnRzLFxuICAgICAgICBtdXRhdGVkRXZlbnRzOiBuZXdSZXNpemUubXV0YXRlZEV2ZW50cyxcbiAgICAgICAgaXNFdmVudDogbmV3UmVzaXplLmlzRXZlbnRcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gY3VycmVudFJlc2l6ZVxuICB9XG59XG4iLCJpbXBvcnQgeyBWaWV3U3BlYywgVmlld1NwZWNIYXNoIH0gZnJvbSAnLi9zdHJ1Y3RzL3ZpZXctc3BlYydcbmltcG9ydCB7IFRoZW1lIH0gZnJvbSAnLi90aGVtZS9UaGVtZSdcbmltcG9ydCB7IG1hcEhhc2ggfSBmcm9tICcuL3V0aWwvb2JqZWN0J1xuaW1wb3J0IHsgQ2FsZW5kYXJBcGkgfSBmcm9tICcuL0NhbGVuZGFyQXBpJ1xuaW1wb3J0IHsgQ2FsZW5kYXJPcHRpb25zUmVmaW5lZCwgQ2FsZW5kYXJPcHRpb25zIH0gZnJvbSAnLi9vcHRpb25zJ1xuaW1wb3J0IHsgVG9vbGJhcklucHV0LCBUb29sYmFyTW9kZWwsIFRvb2xiYXJXaWRnZXQgfSBmcm9tICcuL3Rvb2xiYXItc3RydWN0J1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVRvb2xiYXJzKFxuICBjYWxlbmRhck9wdGlvbnM6IENhbGVuZGFyT3B0aW9uc1JlZmluZWQsXG4gIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzOiBDYWxlbmRhck9wdGlvbnMsXG4gIHRoZW1lOiBUaGVtZSxcbiAgdmlld1NwZWNzOiBWaWV3U3BlY0hhc2gsXG4gIGNhbGVuZGFyQXBpOiBDYWxlbmRhckFwaVxuKSB7XG4gIGxldCB2aWV3c1dpdGhCdXR0b25zOiBzdHJpbmdbXSA9IFtdXG4gIGxldCBoZWFkZXJUb29sYmFyID0gY2FsZW5kYXJPcHRpb25zLmhlYWRlclRvb2xiYXIgPyBwYXJzZVRvb2xiYXIoY2FsZW5kYXJPcHRpb25zLmhlYWRlclRvb2xiYXIsIGNhbGVuZGFyT3B0aW9ucywgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpLCB2aWV3c1dpdGhCdXR0b25zKSA6IG51bGxcbiAgbGV0IGZvb3RlclRvb2xiYXIgPSBjYWxlbmRhck9wdGlvbnMuZm9vdGVyVG9vbGJhciA/IHBhcnNlVG9vbGJhcihjYWxlbmRhck9wdGlvbnMuZm9vdGVyVG9vbGJhciwgY2FsZW5kYXJPcHRpb25zLCBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGksIHZpZXdzV2l0aEJ1dHRvbnMpIDogbnVsbFxuXG4gIHJldHVybiB7IGhlYWRlclRvb2xiYXIsIGZvb3RlclRvb2xiYXIsIHZpZXdzV2l0aEJ1dHRvbnMgfVxufVxuXG5cbmZ1bmN0aW9uIHBhcnNlVG9vbGJhcihcbiAgc2VjdGlvblN0ckhhc2g6IFRvb2xiYXJJbnB1dCxcbiAgY2FsZW5kYXJPcHRpb25zOiBDYWxlbmRhck9wdGlvbnNSZWZpbmVkLFxuICBjYWxlbmRhck9wdGlvbk92ZXJyaWRlczogQ2FsZW5kYXJPcHRpb25zLFxuICB0aGVtZTogVGhlbWUsXG4gIHZpZXdTcGVjczogVmlld1NwZWNIYXNoLFxuICBjYWxlbmRhckFwaTogQ2FsZW5kYXJBcGksXG4gIHZpZXdzV2l0aEJ1dHRvbnM6IHN0cmluZ1tdIC8vIGR1bXAgc2lkZSBlZmZlY3RzXG4pIDogVG9vbGJhck1vZGVsIHtcbiAgcmV0dXJuIG1hcEhhc2goXG4gICAgc2VjdGlvblN0ckhhc2ggYXMgeyBbc2VjdGlvbjogc3RyaW5nXTogc3RyaW5nIH0sXG4gICAgKHNlY3Rpb25TdHIpID0+IHBhcnNlU2VjdGlvbihzZWN0aW9uU3RyLCBjYWxlbmRhck9wdGlvbnMsIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSwgdmlld3NXaXRoQnV0dG9ucylcbiAgKVxufVxuXG5cbi8qXG5CQUQ6IHF1ZXJ5aW5nIGljb25zIGFuZCB0ZXh0IGhlcmUuIHNob3VsZCBiZSBkb25lIGF0IHJlbmRlciB0aW1lXG4qL1xuZnVuY3Rpb24gcGFyc2VTZWN0aW9uKFxuICBzZWN0aW9uU3RyOiBzdHJpbmcsXG4gIGNhbGVuZGFyT3B0aW9uczogQ2FsZW5kYXJPcHRpb25zUmVmaW5lZCxcbiAgY2FsZW5kYXJPcHRpb25PdmVycmlkZXM6IENhbGVuZGFyT3B0aW9ucyxcbiAgdGhlbWU6IFRoZW1lLFxuICB2aWV3U3BlY3M6IFZpZXdTcGVjSGFzaCxcbiAgY2FsZW5kYXJBcGk6IENhbGVuZGFyQXBpLFxuICB2aWV3c1dpdGhCdXR0b25zOiBzdHJpbmdbXSAvLyBkdW1wIHNpZGUgZWZmZWN0c1xuKTogVG9vbGJhcldpZGdldFtdW10ge1xuICBsZXQgaXNSdGwgPSBjYWxlbmRhck9wdGlvbnMuZGlyZWN0aW9uID09PSAncnRsJ1xuICBsZXQgY2FsZW5kYXJDdXN0b21CdXR0b25zID0gY2FsZW5kYXJPcHRpb25zLmN1c3RvbUJ1dHRvbnMgfHwge31cbiAgbGV0IGNhbGVuZGFyQnV0dG9uVGV4dE92ZXJyaWRlcyA9IGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLmJ1dHRvblRleHQgfHwge31cbiAgbGV0IGNhbGVuZGFyQnV0dG9uVGV4dCA9IGNhbGVuZGFyT3B0aW9ucy5idXR0b25UZXh0IHx8IHt9XG4gIGxldCBzZWN0aW9uU3Vic3RycyA9IHNlY3Rpb25TdHIgPyBzZWN0aW9uU3RyLnNwbGl0KCcgJykgOiBbXVxuXG4gIHJldHVybiBzZWN0aW9uU3Vic3Rycy5tYXAoKGJ1dHRvbkdyb3VwU3RyKTogVG9vbGJhcldpZGdldFtdID0+IHtcbiAgICByZXR1cm4gYnV0dG9uR3JvdXBTdHIuc3BsaXQoJywnKS5tYXAoKGJ1dHRvbk5hbWUpOiBUb29sYmFyV2lkZ2V0ID0+IHtcblxuICAgICAgaWYgKGJ1dHRvbk5hbWUgPT09ICd0aXRsZScpIHtcbiAgICAgICAgcmV0dXJuIHsgYnV0dG9uTmFtZSB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBjdXN0b21CdXR0b25Qcm9wc1xuICAgICAgICBsZXQgdmlld1NwZWM6IFZpZXdTcGVjXG4gICAgICAgIGxldCBidXR0b25DbGlja1xuICAgICAgICBsZXQgYnV0dG9uSWNvbiAvLyBvbmx5IG9uZSBvZiB0aGVzZSB3aWxsIGJlIHNldFxuICAgICAgICBsZXQgYnV0dG9uVGV4dCAvLyBcIlxuXG4gICAgICAgIGlmICgoY3VzdG9tQnV0dG9uUHJvcHMgPSBjYWxlbmRhckN1c3RvbUJ1dHRvbnNbYnV0dG9uTmFtZV0pKSB7XG4gICAgICAgICAgYnV0dG9uQ2xpY2sgPSBmdW5jdGlvbihldjogVUlFdmVudCkge1xuICAgICAgICAgICAgaWYgKGN1c3RvbUJ1dHRvblByb3BzLmNsaWNrKSB7XG4gICAgICAgICAgICAgIGN1c3RvbUJ1dHRvblByb3BzLmNsaWNrLmNhbGwoZXYudGFyZ2V0LCBldikgLy8gVE9ETzogY29ycmVjdCB0byB1c2UgYHRhcmdldGA/XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEN1c3RvbUJ1dHRvbkljb25DbGFzcyhjdXN0b21CdXR0b25Qcm9wcykpIHx8XG4gICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSwgaXNSdGwpKSB8fFxuICAgICAgICAgIChidXR0b25UZXh0ID0gY3VzdG9tQnV0dG9uUHJvcHMudGV4dClcblxuICAgICAgICB9IGVsc2UgaWYgKCh2aWV3U3BlYyA9IHZpZXdTcGVjc1tidXR0b25OYW1lXSkpIHtcbiAgICAgICAgICB2aWV3c1dpdGhCdXR0b25zLnB1c2goYnV0dG9uTmFtZSlcblxuICAgICAgICAgIGJ1dHRvbkNsaWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjYWxlbmRhckFwaS5jaGFuZ2VWaWV3KGJ1dHRvbk5hbWUpXG4gICAgICAgICAgfTtcbiAgICAgICAgICAoYnV0dG9uVGV4dCA9IHZpZXdTcGVjLmJ1dHRvblRleHRPdmVycmlkZSkgfHxcbiAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEljb25DbGFzcyhidXR0b25OYW1lLCBpc1J0bCkpIHx8XG4gICAgICAgICAgKGJ1dHRvblRleHQgPSB2aWV3U3BlYy5idXR0b25UZXh0RGVmYXVsdClcblxuICAgICAgICB9IGVsc2UgaWYgKGNhbGVuZGFyQXBpW2J1dHRvbk5hbWVdKSB7IC8vIGEgY2FsZW5kYXJBcGkgbWV0aG9kXG4gICAgICAgICAgYnV0dG9uQ2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNhbGVuZGFyQXBpW2J1dHRvbk5hbWVdKClcbiAgICAgICAgICB9O1xuICAgICAgICAgIChidXR0b25UZXh0ID0gY2FsZW5kYXJCdXR0b25UZXh0T3ZlcnJpZGVzW2J1dHRvbk5hbWVdKSB8fFxuICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0SWNvbkNsYXNzKGJ1dHRvbk5hbWUsIGlzUnRsKSkgfHxcbiAgICAgICAgICAoYnV0dG9uVGV4dCA9IGNhbGVuZGFyQnV0dG9uVGV4dFtidXR0b25OYW1lXSlcbiAgICAgICAgICAvLyAgICAgICAgICAgIF4gZXZlcnl0aGluZyBlbHNlIGlzIGNvbnNpZGVyZWQgZGVmYXVsdFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgYnV0dG9uTmFtZSwgYnV0dG9uQ2xpY2ssIGJ1dHRvbkljb24sIGJ1dHRvblRleHQgfVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG59XG4iLCJpbXBvcnQgeyBjcmVhdGVQbHVnaW4gfSBmcm9tICcuLi9wbHVnaW4tc3lzdGVtJ1xuaW1wb3J0IHsgRXZlbnRTb3VyY2VEZWYgfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LXNvdXJjZS1kZWYnXG5pbXBvcnQgeyBFdmVudElucHV0IH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1wYXJzZSdcblxubGV0IGV2ZW50U291cmNlRGVmOiBFdmVudFNvdXJjZURlZjxFdmVudElucHV0W10+ID0ge1xuICBpZ25vcmVSYW5nZTogdHJ1ZSxcblxuICBwYXJzZU1ldGEocmVmaW5lZCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZmluZWQuZXZlbnRzKSkge1xuICAgICAgcmV0dXJuIHJlZmluZWQuZXZlbnRzXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH0sXG5cbiAgZmV0Y2goYXJnLCBzdWNjZXNzKSB7XG4gICAgc3VjY2Vzcyh7XG4gICAgICByYXdFdmVudHM6IGFyZy5ldmVudFNvdXJjZS5tZXRhXG4gICAgfSlcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgYXJyYXlFdmVudFNvdXJjZVBsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gIGV2ZW50U291cmNlRGVmczogWyBldmVudFNvdXJjZURlZiBdXG59KVxuIiwiaW1wb3J0IHsgdW5wcm9taXNpZnkgfSBmcm9tICcuLi91dGlsL3Byb21pc2UnXG5pbXBvcnQgeyBFdmVudFNvdXJjZURlZiB9IGZyb20gJy4uL3N0cnVjdHMvZXZlbnQtc291cmNlLWRlZidcbmltcG9ydCB7IEV2ZW50U291cmNlRXJyb3IgfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LXNvdXJjZSdcbmltcG9ydCB7IEV2ZW50SW5wdXQgfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LXBhcnNlJ1xuaW1wb3J0IHsgY3JlYXRlUGx1Z2luIH0gZnJvbSAnLi4vcGx1Z2luLXN5c3RlbSdcbmltcG9ydCB7IGJ1aWxkUmFuZ2VBcGlXaXRoVGltZVpvbmUgfSBmcm9tICcuLi9zdHJ1Y3RzL2RhdGUtc3BhbidcblxuZXhwb3J0IHR5cGUgRXZlbnRTb3VyY2VGdW5jID0gKFxuICBhcmc6IHtcbiAgICBzdGFydDogRGF0ZVxuICAgIGVuZDogRGF0ZVxuICAgIHN0YXJ0U3RyOiBzdHJpbmdcbiAgICBlbmRTdHI6IHN0cmluZ1xuICAgIHRpbWVab25lOiBzdHJpbmdcbiAgfSxcbiAgc3VjY2Vzc0NhbGxiYWNrOiAoZXZlbnRzOiBFdmVudElucHV0W10pID0+IHZvaWQsXG4gIGZhaWx1cmVDYWxsYmFjazogKGVycm9yOiBFdmVudFNvdXJjZUVycm9yKSA9PiB2b2lkXG4pID0+ICh2b2lkIHwgUHJvbWlzZUxpa2U8RXZlbnRJbnB1dFtdPilcblxuXG5sZXQgZXZlbnRTb3VyY2VEZWY6IEV2ZW50U291cmNlRGVmPEV2ZW50U291cmNlRnVuYz4gPSB7XG5cbiAgcGFyc2VNZXRhKHJlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIHJlZmluZWQuZXZlbnRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gcmVmaW5lZC5ldmVudHNcbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfSxcblxuICBmZXRjaChhcmcsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAgICBsZXQgZGF0ZUVudiA9IGFyZy5jb250ZXh0LmRhdGVFbnZcbiAgICBsZXQgZnVuYyA9IGFyZy5ldmVudFNvdXJjZS5tZXRhXG5cbiAgICB1bnByb21pc2lmeShcbiAgICAgIGZ1bmMuYmluZChudWxsLCBidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lKGFyZy5yYW5nZSwgZGF0ZUVudikpLFxuICAgICAgZnVuY3Rpb24ocmF3RXZlbnRzKSB7IC8vIHN1Y2Nlc3NcbiAgICAgICAgc3VjY2Vzcyh7IHJhd0V2ZW50cyB9KSAvLyBuZWVkcyBhbiBvYmplY3QgcmVzcG9uc2VcbiAgICAgIH0sXG4gICAgICBmYWlsdXJlIC8vIHNlbmQgZXJyb3JPYmogZGlyZWN0bHkgdG8gZmFpbHVyZSBjYWxsYmFja1xuICAgIClcbiAgfVxuXG59XG5cbmV4cG9ydCBjb25zdCBmdW5jRXZlbnRTb3VyY2VQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICBldmVudFNvdXJjZURlZnM6IFsgZXZlbnRTb3VyY2VEZWYgXVxufSlcbiIsImltcG9ydCB7IERpY3Rpb25hcnkgfSBmcm9tICcuLi9vcHRpb25zJ1xuXG5leHBvcnQgZnVuY3Rpb24gcmVxdWVzdEpzb24obWV0aG9kOiBzdHJpbmcsIHVybDogc3RyaW5nLCBwYXJhbXM6IERpY3Rpb25hcnksIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gIG1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG5cbiAgbGV0IGJvZHkgPSBudWxsXG5cbiAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICB1cmwgPSBpbmplY3RRdWVyeVN0cmluZ1BhcmFtcyh1cmwsIHBhcmFtcylcbiAgfSBlbHNlIHtcbiAgICBib2R5ID0gZW5jb2RlUGFyYW1zKHBhcmFtcylcbiAgfVxuXG4gIGxldCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuICB4aHIub3BlbihtZXRob2QsIHVybCwgdHJ1ZSlcblxuICBpZiAobWV0aG9kICE9PSAnR0VUJykge1xuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJylcbiAgfVxuXG4gIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDQwMCkge1xuICAgICAgbGV0IHBhcnNlZCA9IGZhbHNlXG4gICAgICBsZXQgcmVzXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcyA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dClcbiAgICAgICAgcGFyc2VkID0gdHJ1ZVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIHdpbGwgaGFuZGxlIHBhcnNlZD1mYWxzZVxuICAgICAgfVxuXG4gICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgIHN1Y2Nlc3NDYWxsYmFjayhyZXMsIHhocilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZhaWx1cmVDYWxsYmFjaygnRmFpbHVyZSBwYXJzaW5nIEpTT04nLCB4aHIpXG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgZmFpbHVyZUNhbGxiYWNrKCdSZXF1ZXN0IGZhaWxlZCcsIHhocilcbiAgICB9XG4gIH1cblxuICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIGZhaWx1cmVDYWxsYmFjaygnUmVxdWVzdCBmYWlsZWQnLCB4aHIpXG4gIH1cblxuICB4aHIuc2VuZChib2R5KVxufVxuXG5mdW5jdGlvbiBpbmplY3RRdWVyeVN0cmluZ1BhcmFtcyh1cmw6IHN0cmluZywgcGFyYW1zKSB7XG4gIHJldHVybiB1cmwgK1xuICAgICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgK1xuICAgIGVuY29kZVBhcmFtcyhwYXJhbXMpXG59XG5cbmZ1bmN0aW9uIGVuY29kZVBhcmFtcyhwYXJhbXMpIHtcbiAgbGV0IHBhcnRzID0gW11cblxuICBmb3IgKGxldCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbXNba2V5XSkpXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJicpXG59XG4iLCJpbXBvcnQgeyBpZGVudGl0eSwgSWRlbnRpdHksIERpY3Rpb25hcnkgfSBmcm9tICcuLi9vcHRpb25zJ1xuXG5leHBvcnQgY29uc3QgSlNPTl9GRUVEX0VWRU5UX1NPVVJDRV9SRUZJTkVSUyA9IHtcbiAgbWV0aG9kOiBTdHJpbmcsXG4gIGV4dHJhUGFyYW1zOiBpZGVudGl0eSBhcyBJZGVudGl0eTxEaWN0aW9uYXJ5IHwgKCgpID0+IERpY3Rpb25hcnkpPixcbiAgc3RhcnRQYXJhbTogU3RyaW5nLFxuICBlbmRQYXJhbTogU3RyaW5nLFxuICB0aW1lWm9uZVBhcmFtOiBTdHJpbmdcbn1cbiIsImltcG9ydCB7IHJlcXVlc3RKc29uIH0gZnJvbSAnLi4vdXRpbC9yZXF1ZXN0SnNvbidcbmltcG9ydCB7IENhbGVuZGFyQ29udGV4dCB9IGZyb20gJy4uL0NhbGVuZGFyQ29udGV4dCdcbmltcG9ydCB7IEV2ZW50U291cmNlRGVmIH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1zb3VyY2UtZGVmJ1xuaW1wb3J0IHsgRGF0ZVJhbmdlIH0gZnJvbSAnLi4vZGF0ZWxpYi9kYXRlLXJhbmdlJ1xuaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYidcbmltcG9ydCB7IGNyZWF0ZVBsdWdpbiB9IGZyb20gJy4uL3BsdWdpbi1zeXN0ZW0nXG5pbXBvcnQgeyBKU09OX0ZFRURfRVZFTlRfU09VUkNFX1JFRklORVJTIH0gZnJvbSAnLi9qc29uLWZlZWQtZXZlbnQtc291cmNlLXJlZmluZXJzJ1xuXG5cbmludGVyZmFjZSBKc29uRmVlZE1ldGEge1xuICB1cmw6IHN0cmluZ1xuICBtZXRob2Q6IHN0cmluZ1xuICBleHRyYVBhcmFtcz86IGFueVxuICBzdGFydFBhcmFtPzogc3RyaW5nXG4gIGVuZFBhcmFtPzogc3RyaW5nXG4gIHRpbWVab25lUGFyYW0/OiBzdHJpbmdcbn1cblxuXG5sZXQgZXZlbnRTb3VyY2VEZWY6IEV2ZW50U291cmNlRGVmPEpzb25GZWVkTWV0YT4gPSB7XG5cbiAgcGFyc2VNZXRhKHJlZmluZWQpIHtcbiAgICBpZiAocmVmaW5lZC51cmwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVybDogcmVmaW5lZC51cmwsXG4gICAgICAgIG1ldGhvZDogKHJlZmluZWQubWV0aG9kIHx8ICdHRVQnKS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICBleHRyYVBhcmFtczogcmVmaW5lZC5leHRyYVBhcmFtcyxcbiAgICAgICAgc3RhcnRQYXJhbTogcmVmaW5lZC5zdGFydFBhcmFtLFxuICAgICAgICBlbmRQYXJhbTogcmVmaW5lZC5lbmRQYXJhbSxcbiAgICAgICAgdGltZVpvbmVQYXJhbTogcmVmaW5lZC50aW1lWm9uZVBhcmFtXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH0sXG5cbiAgZmV0Y2goYXJnLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gICAgbGV0IG1ldGE6IEpzb25GZWVkTWV0YSA9IGFyZy5ldmVudFNvdXJjZS5tZXRhXG4gICAgbGV0IHJlcXVlc3RQYXJhbXMgPSBidWlsZFJlcXVlc3RQYXJhbXMobWV0YSwgYXJnLnJhbmdlLCBhcmcuY29udGV4dClcblxuICAgIHJlcXVlc3RKc29uKFxuICAgICAgbWV0YS5tZXRob2QsIG1ldGEudXJsLCByZXF1ZXN0UGFyYW1zLFxuICAgICAgZnVuY3Rpb24ocmF3RXZlbnRzLCB4aHIpIHtcbiAgICAgICAgc3VjY2Vzcyh7IHJhd0V2ZW50cywgeGhyIH0pXG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24oZXJyb3JNZXNzYWdlLCB4aHIpIHtcbiAgICAgICAgZmFpbHVyZSh7IG1lc3NhZ2U6IGVycm9yTWVzc2FnZSwgeGhyIH0pXG4gICAgICB9XG4gICAgKVxuICB9XG5cbn1cblxuXG5leHBvcnQgY29uc3QganNvbkZlZWRFdmVudFNvdXJjZVBsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gIGV2ZW50U291cmNlUmVmaW5lcnM6IEpTT05fRkVFRF9FVkVOVF9TT1VSQ0VfUkVGSU5FUlMsXG4gIGV2ZW50U291cmNlRGVmczogWyBldmVudFNvdXJjZURlZiBdXG59KVxuXG5cbmZ1bmN0aW9uIGJ1aWxkUmVxdWVzdFBhcmFtcyhtZXRhOiBKc29uRmVlZE1ldGEsIHJhbmdlOiBEYXRlUmFuZ2UsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCkge1xuICBsZXQgeyBkYXRlRW52LCBvcHRpb25zIH0gPSBjb250ZXh0XG4gIGxldCBzdGFydFBhcmFtXG4gIGxldCBlbmRQYXJhbVxuICBsZXQgdGltZVpvbmVQYXJhbVxuICBsZXQgY3VzdG9tUmVxdWVzdFBhcmFtc1xuICBsZXQgcGFyYW1zID0ge31cblxuICBzdGFydFBhcmFtID0gbWV0YS5zdGFydFBhcmFtXG4gIGlmIChzdGFydFBhcmFtID09IG51bGwpIHtcbiAgICBzdGFydFBhcmFtID0gb3B0aW9ucy5zdGFydFBhcmFtXG4gIH1cblxuICBlbmRQYXJhbSA9IG1ldGEuZW5kUGFyYW1cbiAgaWYgKGVuZFBhcmFtID09IG51bGwpIHtcbiAgICBlbmRQYXJhbSA9IG9wdGlvbnMuZW5kUGFyYW1cbiAgfVxuXG4gIHRpbWVab25lUGFyYW0gPSBtZXRhLnRpbWVab25lUGFyYW1cbiAgaWYgKHRpbWVab25lUGFyYW0gPT0gbnVsbCkge1xuICAgIHRpbWVab25lUGFyYW0gPSBvcHRpb25zLnRpbWVab25lUGFyYW1cbiAgfVxuXG4gIC8vIHJldHJpZXZlIGFueSBvdXRib3VuZCBHRVQvUE9TVCBkYXRhIGZyb20gdGhlIG9wdGlvbnNcbiAgaWYgKHR5cGVvZiBtZXRhLmV4dHJhUGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gc3VwcGxpZWQgYXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBrZXkvdmFsdWUgb2JqZWN0XG4gICAgY3VzdG9tUmVxdWVzdFBhcmFtcyA9IG1ldGEuZXh0cmFQYXJhbXMoKVxuICB9IGVsc2Uge1xuICAgIC8vIHByb2JhYmx5IHN1cHBsaWVkIGFzIGEgc3RyYWlnaHQga2V5L3ZhbHVlIG9iamVjdFxuICAgIGN1c3RvbVJlcXVlc3RQYXJhbXMgPSBtZXRhLmV4dHJhUGFyYW1zIHx8IHt9XG4gIH1cblxuICBfX2Fzc2lnbihwYXJhbXMsIGN1c3RvbVJlcXVlc3RQYXJhbXMpXG5cbiAgcGFyYW1zW3N0YXJ0UGFyYW1dID0gZGF0ZUVudi5mb3JtYXRJc28ocmFuZ2Uuc3RhcnQpXG4gIHBhcmFtc1tlbmRQYXJhbV0gPSBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5lbmQpXG5cbiAgaWYgKGRhdGVFbnYudGltZVpvbmUgIT09ICdsb2NhbCcpIHtcbiAgICBwYXJhbXNbdGltZVpvbmVQYXJhbV0gPSBkYXRlRW52LnRpbWVab25lXG4gIH1cblxuICByZXR1cm4gcGFyYW1zXG59XG4iLCJpbXBvcnQgeyBjcmVhdGVEdXJhdGlvbiB9IGZyb20gJy4uL2RhdGVsaWIvZHVyYXRpb24nXG5pbXBvcnQgeyBEYXRlSW5wdXQgfSBmcm9tICcuLi9kYXRlbGliL2VudidcbmltcG9ydCB7IGlkZW50aXR5LCBJZGVudGl0eSB9IGZyb20gJy4uL29wdGlvbnMnXG5cblxuZXhwb3J0IGNvbnN0IFNJTVBMRV9SRUNVUlJJTkdfUkVGSU5FUlMgPSB7XG4gIGRheXNPZldlZWs6IGlkZW50aXR5IGFzIElkZW50aXR5PG51bWJlcltdPixcbiAgc3RhcnRUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgZW5kVGltZTogY3JlYXRlRHVyYXRpb24sXG4gIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgc3RhcnRSZWN1cjogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGF0ZUlucHV0PixcbiAgZW5kUmVjdXI6IGlkZW50aXR5IGFzIElkZW50aXR5PERhdGVJbnB1dD5cbn1cbiIsImltcG9ydCB7IHN0YXJ0T2ZEYXksIGFkZERheXMsIERhdGVNYXJrZXIgfSBmcm9tICcuLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IER1cmF0aW9uLCBzdWJ0cmFjdER1cmF0aW9ucyB9IGZyb20gJy4uL2RhdGVsaWIvZHVyYXRpb24nXG5pbXBvcnQgeyBhcnJheVRvSGFzaCB9IGZyb20gJy4uL3V0aWwvb2JqZWN0J1xuaW1wb3J0IHsgUmVjdXJyaW5nVHlwZSB9IGZyb20gJy4vcmVjdXJyaW5nLWV2ZW50J1xuaW1wb3J0IHsgRXZlbnRSZWZpbmVkIH0gZnJvbSAnLi9ldmVudC1wYXJzZSdcbmltcG9ydCB7IERhdGVSYW5nZSwgaW50ZXJzZWN0UmFuZ2VzIH0gZnJvbSAnLi4vZGF0ZWxpYi9kYXRlLXJhbmdlJ1xuaW1wb3J0IHsgRGF0ZUVudiB9IGZyb20gJy4uL2RhdGVsaWIvZW52J1xuaW1wb3J0IHsgY3JlYXRlUGx1Z2luIH0gZnJvbSAnLi4vcGx1Z2luLXN5c3RlbSdcbmltcG9ydCB7IFNJTVBMRV9SRUNVUlJJTkdfUkVGSU5FUlMgfSBmcm9tICcuL3JlY3VycmluZy1ldmVudC1zaW1wbGUtcmVmaW5lcnMnXG5pbXBvcnQgJy4vcmVjdXJyaW5nLWV2ZW50LXNpbXBsZS1kZWNsYXJlJ1xuXG5cbi8qXG5BbiBpbXBsZW1lbnRhdGlvbiBvZiByZWN1cnJpbmcgZXZlbnRzIHRoYXQgb25seSBzdXBwb3J0cyBldmVyeS1kYXkgb3Igd2Vla2x5IHJlY3VycmVuY2VzLlxuKi9cblxuaW50ZXJmYWNlIFNpbXBsZVJlY3VycmluZ0RhdGEge1xuICBkYXlzT2ZXZWVrOiBudW1iZXJbXSB8IG51bGxcbiAgc3RhcnRUaW1lOiBEdXJhdGlvbiB8IG51bGxcbiAgZW5kVGltZTogRHVyYXRpb24gfCBudWxsXG4gIHN0YXJ0UmVjdXI6IERhdGVNYXJrZXIgfCBudWxsXG4gIGVuZFJlY3VyOiBEYXRlTWFya2VyIHwgbnVsbFxufVxuXG5cbmxldCByZWN1cnJpbmc6IFJlY3VycmluZ1R5cGU8U2ltcGxlUmVjdXJyaW5nRGF0YT4gPSB7XG5cbiAgcGFyc2UocmVmaW5lZDogRXZlbnRSZWZpbmVkLCBkYXRlRW52OiBEYXRlRW52KSB7XG5cbiAgICBpZiAocmVmaW5lZC5kYXlzT2ZXZWVrIHx8IHJlZmluZWQuc3RhcnRUaW1lIHx8IHJlZmluZWQuZW5kVGltZSB8fCByZWZpbmVkLnN0YXJ0UmVjdXIgfHwgcmVmaW5lZC5lbmRSZWN1cikge1xuICAgICAgbGV0IHJlY3VycmluZ0RhdGE6IFNpbXBsZVJlY3VycmluZ0RhdGEgPSB7XG4gICAgICAgIGRheXNPZldlZWs6IHJlZmluZWQuZGF5c09mV2VlayB8fCBudWxsLFxuICAgICAgICBzdGFydFRpbWU6IHJlZmluZWQuc3RhcnRUaW1lIHx8IG51bGwsXG4gICAgICAgIGVuZFRpbWU6IHJlZmluZWQuZW5kVGltZSB8fCBudWxsLFxuICAgICAgICBzdGFydFJlY3VyOiByZWZpbmVkLnN0YXJ0UmVjdXIgPyBkYXRlRW52LmNyZWF0ZU1hcmtlcihyZWZpbmVkLnN0YXJ0UmVjdXIpIDogbnVsbCxcbiAgICAgICAgZW5kUmVjdXI6IHJlZmluZWQuZW5kUmVjdXIgPyBkYXRlRW52LmNyZWF0ZU1hcmtlcihyZWZpbmVkLmVuZFJlY3VyKSA6IG51bGxcbiAgICAgIH1cblxuICAgICAgbGV0IGR1cmF0aW9uOiBEdXJhdGlvblxuXG4gICAgICBpZiAocmVmaW5lZC5kdXJhdGlvbikge1xuICAgICAgICBkdXJhdGlvbiA9IHJlZmluZWQuZHVyYXRpb25cbiAgICAgIH1cbiAgICAgIGlmICghZHVyYXRpb24gJiYgcmVmaW5lZC5zdGFydFRpbWUgJiYgcmVmaW5lZC5lbmRUaW1lKSB7XG4gICAgICAgIGR1cmF0aW9uID0gc3VidHJhY3REdXJhdGlvbnMocmVmaW5lZC5lbmRUaW1lLCByZWZpbmVkLnN0YXJ0VGltZSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWxsRGF5R3Vlc3M6IEJvb2xlYW4oIXJlZmluZWQuc3RhcnRUaW1lICYmICFyZWZpbmVkLmVuZFRpbWUpLFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgdHlwZURhdGE6IHJlY3VycmluZ0RhdGEgLy8gZG9lc24ndCBuZWVkIGVuZFRpbWUgYW55bW9yZSBidXQgb2ggd2VsbFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsXG4gIH0sXG5cbiAgZXhwYW5kKHR5cGVEYXRhOiBTaW1wbGVSZWN1cnJpbmdEYXRhLCBmcmFtaW5nUmFuZ2U6IERhdGVSYW5nZSwgZGF0ZUVudjogRGF0ZUVudik6IERhdGVNYXJrZXJbXSB7XG4gICAgbGV0IGNsaXBwZWRGcmFtaW5nUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMoXG4gICAgICBmcmFtaW5nUmFuZ2UsXG4gICAgICB7IHN0YXJ0OiB0eXBlRGF0YS5zdGFydFJlY3VyLCBlbmQ6IHR5cGVEYXRhLmVuZFJlY3VyIH1cbiAgICApXG5cbiAgICBpZiAoY2xpcHBlZEZyYW1pbmdSYW5nZSkge1xuICAgICAgcmV0dXJuIGV4cGFuZFJhbmdlcyhcbiAgICAgICAgdHlwZURhdGEuZGF5c09mV2VlayxcbiAgICAgICAgdHlwZURhdGEuc3RhcnRUaW1lLFxuICAgICAgICBjbGlwcGVkRnJhbWluZ1JhbmdlLFxuICAgICAgICBkYXRlRW52XG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgfVxuXG59XG5cblxuZXhwb3J0IGNvbnN0IHNpbXBsZVJlY3VycmluZ0V2ZW50c1BsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gIHJlY3VycmluZ1R5cGVzOiBbIHJlY3VycmluZyBdLFxuICBldmVudFJlZmluZXJzOiBTSU1QTEVfUkVDVVJSSU5HX1JFRklORVJTXG59KVxuXG5cbmZ1bmN0aW9uIGV4cGFuZFJhbmdlcyhcbiAgZGF5c09mV2VlazogbnVtYmVyW10gfCBudWxsLFxuICBzdGFydFRpbWU6IER1cmF0aW9uIHwgbnVsbCxcbiAgZnJhbWluZ1JhbmdlOiBEYXRlUmFuZ2UsXG4gIGRhdGVFbnY6IERhdGVFbnZcbik6IERhdGVNYXJrZXJbXSB7XG4gIGxldCBkb3dIYXNoOiB7IFtudW06IHN0cmluZ106IHRydWUgfSB8IG51bGwgPSBkYXlzT2ZXZWVrID8gYXJyYXlUb0hhc2goZGF5c09mV2VlaykgOiBudWxsXG4gIGxldCBkYXlNYXJrZXIgPSBzdGFydE9mRGF5KGZyYW1pbmdSYW5nZS5zdGFydClcbiAgbGV0IGVuZE1hcmtlciA9IGZyYW1pbmdSYW5nZS5lbmRcbiAgbGV0IGluc3RhbmNlU3RhcnRzOiBEYXRlTWFya2VyW10gPSBbXVxuXG4gIHdoaWxlIChkYXlNYXJrZXIgPCBlbmRNYXJrZXIpIHtcbiAgICBsZXQgaW5zdGFuY2VTdGFydFxuXG4gICAgLy8gaWYgZXZlcnlkYXksIG9yIHRoaXMgcGFydGljdWxhciBkYXktb2Ytd2Vla1xuICAgIGlmICghZG93SGFzaCB8fCBkb3dIYXNoW2RheU1hcmtlci5nZXRVVENEYXkoKV0pIHtcblxuICAgICAgaWYgKHN0YXJ0VGltZSkge1xuICAgICAgICBpbnN0YW5jZVN0YXJ0ID0gZGF0ZUVudi5hZGQoZGF5TWFya2VyLCBzdGFydFRpbWUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0YW5jZVN0YXJ0ID0gZGF5TWFya2VyXG4gICAgICB9XG5cbiAgICAgIGluc3RhbmNlU3RhcnRzLnB1c2goaW5zdGFuY2VTdGFydClcbiAgICB9XG5cbiAgICBkYXlNYXJrZXIgPSBhZGREYXlzKGRheU1hcmtlciwgMSlcbiAgfVxuXG4gIHJldHVybiBpbnN0YW5jZVN0YXJ0c1xufVxuIiwiaW1wb3J0IHsgY3JlYXRlUGx1Z2luIH0gZnJvbSAnLi9wbHVnaW4tc3lzdGVtJ1xuaW1wb3J0IHsgaGFzaFZhbHVlc1RvQXJyYXkgfSBmcm9tICcuL3V0aWwvb2JqZWN0J1xuaW1wb3J0IHsgRXZlbnRTb3VyY2UgfSBmcm9tICcuL3N0cnVjdHMvZXZlbnQtc291cmNlJ1xuaW1wb3J0IHsgQ2FsZW5kYXJDb250ZXh0IH0gZnJvbSAnLi9DYWxlbmRhckNvbnRleHQnXG5cbmV4cG9ydCBjb25zdCBjaGFuZ2VIYW5kbGVyUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcbiAgb3B0aW9uQ2hhbmdlSGFuZGxlcnM6IHtcbiAgICBldmVudHMoZXZlbnRzLCBjb250ZXh0KSB7XG4gICAgICBoYW5kbGVFdmVudFNvdXJjZXMoWyBldmVudHMgXSwgY29udGV4dClcbiAgICB9LFxuICAgIGV2ZW50U291cmNlczogaGFuZGxlRXZlbnRTb3VyY2VzXG4gIH1cbn0pXG5cbi8qXG5CVUc6IGlmIGBldmVudGAgd2FzIHN1cHBsaWVkLCBhbGwgcHJldmlvdXNseS1naXZlbiBgZXZlbnRTb3VyY2VzYCB3aWxsIGJlIHdpcGVkIG91dFxuKi9cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50U291cmNlcyhpbnB1dHMsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCkge1xuICBsZXQgdW5mb3VuZFNvdXJjZXM6IEV2ZW50U291cmNlPGFueT5bXSA9IGhhc2hWYWx1ZXNUb0FycmF5KGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKS5ldmVudFNvdXJjZXMpXG4gIGxldCBuZXdJbnB1dHMgPSBbXVxuXG4gIGZvciAobGV0IGlucHV0IG9mIGlucHV0cykge1xuICAgIGxldCBpbnB1dEZvdW5kID0gZmFsc2VcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5mb3VuZFNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh1bmZvdW5kU291cmNlc1tpXS5fcmF3ID09PSBpbnB1dCkge1xuICAgICAgICB1bmZvdW5kU291cmNlcy5zcGxpY2UoaSwgMSkgLy8gZGVsZXRlXG4gICAgICAgIGlucHV0Rm91bmQgPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpbnB1dEZvdW5kKSB7XG4gICAgICBuZXdJbnB1dHMucHVzaChpbnB1dClcbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCB1bmZvdW5kU291cmNlIG9mIHVuZm91bmRTb3VyY2VzKSB7XG4gICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UX1NPVVJDRScsXG4gICAgICBzb3VyY2VJZDogdW5mb3VuZFNvdXJjZS5zb3VyY2VJZFxuICAgIH0pXG4gIH1cblxuICBmb3IgKGxldCBuZXdJbnB1dCBvZiBuZXdJbnB1dHMpIHtcbiAgICBjb250ZXh0LmNhbGVuZGFyQXBpLmFkZEV2ZW50U291cmNlKG5ld0lucHV0KVxuICB9XG59XG4iLCJpbXBvcnQgeyBEYXRlUHJvZmlsZSB9IGZyb20gJy4vRGF0ZVByb2ZpbGVHZW5lcmF0b3InXG5pbXBvcnQgeyBDYWxlbmRhckRhdGEgfSBmcm9tICcuL3JlZHVjZXJzL2RhdGEtdHlwZXMnXG5pbXBvcnQgeyBSYW5nZUFwaVdpdGhUaW1lWm9uZSwgYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZSB9IGZyb20gJy4vc3RydWN0cy9kYXRlLXNwYW4nXG5pbXBvcnQgeyBWaWV3QXBpIH0gZnJvbSAnLi9WaWV3QXBpJ1xuXG5cbmV4cG9ydCB0eXBlIERhdGVzU2V0QXJnID0gUmFuZ2VBcGlXaXRoVGltZVpvbmUgJiB7IHZpZXc6IFZpZXdBcGkgfVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVEYXRlUHJvZmlsZShkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGUsIGNvbnRleHQ6IENhbGVuZGFyRGF0YSkge1xuICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZGF0ZXNTZXQnLCB7XG4gICAgLi4uYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZShkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgY29udGV4dC5kYXRlRW52KSxcbiAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGlcbiAgfSlcbn1cbiIsImltcG9ydCB7IEV2ZW50U3RvcmUgfSBmcm9tICcuL3N0cnVjdHMvZXZlbnQtc3RvcmUnXG5pbXBvcnQgeyBDYWxlbmRhckRhdGEgfSBmcm9tICcuL3JlZHVjZXJzL2RhdGEtdHlwZXMnXG5pbXBvcnQgeyBFdmVudEFwaSwgYnVpbGRFdmVudEFwaXMgfSBmcm9tICcuL2FwaS9FdmVudEFwaSdcblxuXG5leHBvcnQgaW50ZXJmYWNlIEV2ZW50QWRkQXJnIHtcbiAgZXZlbnQ6IEV2ZW50QXBpXG4gIHJlbGF0ZWRFdmVudHM6IEV2ZW50QXBpW11cbiAgcmV2ZXJ0OiAoKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnRDaGFuZ2VBcmcge1xuICBvbGRFdmVudDogRXZlbnRBcGlcbiAgZXZlbnQ6IEV2ZW50QXBpXG4gIHJlbGF0ZWRFdmVudHM6IEV2ZW50QXBpW11cbiAgcmV2ZXJ0OiAoKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnRSZW1vdmVBcmcge1xuICBldmVudDogRXZlbnRBcGlcbiAgcmVsYXRlZEV2ZW50czogRXZlbnRBcGlbXVxuICByZXZlcnQ6ICgpID0+IHZvaWRcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlRXZlbnRTdG9yZShldmVudFN0b3JlOiBFdmVudFN0b3JlLCBjb250ZXh0OiBDYWxlbmRhckRhdGEpIHtcbiAgbGV0IHsgZW1pdHRlciB9ID0gY29udGV4dFxuXG4gIGlmIChlbWl0dGVyLmhhc0hhbmRsZXJzKCdldmVudHNTZXQnKSkge1xuICAgIGVtaXR0ZXIudHJpZ2dlcignZXZlbnRzU2V0JywgYnVpbGRFdmVudEFwaXMoZXZlbnRTdG9yZSwgY29udGV4dCkpXG4gIH1cbn1cbiIsImltcG9ydCB7IFBsdWdpbkRlZiB9IGZyb20gJy4vcGx1Z2luLXN5c3RlbS1zdHJ1Y3QnXG5pbXBvcnQgeyBjcmVhdGVQbHVnaW4gfSBmcm9tICcuL3BsdWdpbi1zeXN0ZW0nXG5pbXBvcnQgeyBhcnJheUV2ZW50U291cmNlUGx1Z2luIH0gZnJvbSAnLi9ldmVudC1zb3VyY2VzL2FycmF5LWV2ZW50LXNvdXJjZSdcbmltcG9ydCB7IGZ1bmNFdmVudFNvdXJjZVBsdWdpbiB9IGZyb20gJy4vZXZlbnQtc291cmNlcy9mdW5jLWV2ZW50LXNvdXJjZSdcbmltcG9ydCB7IGpzb25GZWVkRXZlbnRTb3VyY2VQbHVnaW4gfSBmcm9tICcuL2V2ZW50LXNvdXJjZXMvanNvbi1mZWVkLWV2ZW50LXNvdXJjZSdcbmltcG9ydCB7IHNpbXBsZVJlY3VycmluZ0V2ZW50c1BsdWdpbiB9IGZyb20gJy4vc3RydWN0cy9yZWN1cnJpbmctZXZlbnQtc2ltcGxlJ1xuaW1wb3J0IHsgY2hhbmdlSGFuZGxlclBsdWdpbiB9IGZyb20gJy4vb3B0aW9uLWNoYW5nZS1oYW5kbGVycydcbmltcG9ydCB7IGluamVjdEh0bWwsIGluamVjdERvbU5vZGVzIH0gZnJvbSAnLi91dGlsL2RvbS1tYW5pcCdcbmltcG9ydCB7IGhhbmRsZURhdGVQcm9maWxlIH0gZnJvbSAnLi9kYXRlcy1zZXQnXG5pbXBvcnQgeyBoYW5kbGVFdmVudFN0b3JlIH0gZnJvbSAnLi9ldmVudC1jcnVkJ1xuXG5cbi8qXG50aGlzIGFycmF5IGlzIGV4cG9zZWQgb24gdGhlIHJvb3QgbmFtZXNwYWNlIHNvIHRoYXQgVU1EIHBsdWdpbnMgY2FuIGFkZCB0byBpdC5cbnNlZSB0aGUgcm9sbHVwLWJ1bmRsZXMgc2NyaXB0LlxuKi9cbmV4cG9ydCBsZXQgZ2xvYmFsUGx1Z2luczogUGx1Z2luRGVmW10gPSBbIC8vIFRPRE86IG1ha2UgYSBjb25zdD9cbiAgYXJyYXlFdmVudFNvdXJjZVBsdWdpbixcbiAgZnVuY0V2ZW50U291cmNlUGx1Z2luLFxuICBqc29uRmVlZEV2ZW50U291cmNlUGx1Z2luLFxuICBzaW1wbGVSZWN1cnJpbmdFdmVudHNQbHVnaW4sXG4gIGNoYW5nZUhhbmRsZXJQbHVnaW4sXG4gIGNyZWF0ZVBsdWdpbih7IC8vIG1pc2MuLi5cbiAgICBjb250ZW50VHlwZUhhbmRsZXJzOiB7XG4gICAgICBodG1sOiAoKSA9PiBpbmplY3RIdG1sLFxuICAgICAgZG9tTm9kZXM6ICgpID0+IGluamVjdERvbU5vZGVzXG4gICAgfSxcbiAgICBwcm9wU2V0SGFuZGxlcnM6IHtcbiAgICAgIGRhdGVQcm9maWxlOiBoYW5kbGVEYXRlUHJvZmlsZSxcbiAgICAgIGV2ZW50U3RvcmU6IGhhbmRsZUV2ZW50U3RvcmVcbiAgICB9XG4gIH0pXG5dXG4iLCJcblxuZXhwb3J0IGNsYXNzIERlbGF5ZWRSdW5uZXIge1xuXG4gIHByaXZhdGUgaXNSdW5uaW5nID0gZmFsc2VcbiAgcHJpdmF0ZSBpc0RpcnR5ID0gZmFsc2VcbiAgcHJpdmF0ZSBwYXVzZURlcHRoczogeyBbc2NvcGU6IHN0cmluZ106IG51bWJlciB9ID0ge31cbiAgcHJpdmF0ZSB0aW1lb3V0SWQ6IG51bWJlciA9IDBcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGRyYWluZWRPcHRpb24/OiAoKSA9PiB2b2lkXG4gICkge1xuICB9XG5cbiAgcmVxdWVzdChkZWxheT86IG51bWJlcikge1xuICAgIHRoaXMuaXNEaXJ0eSA9IHRydWVcblxuICAgIGlmICghdGhpcy5pc1BhdXNlZCgpKSB7XG4gICAgICB0aGlzLmNsZWFyVGltZW91dCgpXG5cbiAgICAgIGlmIChkZWxheSA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMudHJ5RHJhaW4oKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCAvLyBOT1QgT1BUSU1BTCEgVE9ETzogbG9vayBhdCBkZWJvdW5jZVxuICAgICAgICAgIHRoaXMudHJ5RHJhaW4uYmluZCh0aGlzKSxcbiAgICAgICAgICBkZWxheVxuICAgICAgICApIGFzIHVua25vd24gYXMgbnVtYmVyXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcGF1c2Uoc2NvcGUgPSAnJykge1xuICAgIGxldCB7IHBhdXNlRGVwdGhzIH0gPSB0aGlzXG5cbiAgICBwYXVzZURlcHRoc1tzY29wZV0gPSAocGF1c2VEZXB0aHNbc2NvcGVdIHx8IDApICsgMVxuXG4gICAgdGhpcy5jbGVhclRpbWVvdXQoKVxuICB9XG5cbiAgcmVzdW1lKHNjb3BlID0gJycsIGZvcmNlPzogYm9vbGVhbikge1xuICAgIGxldCB7IHBhdXNlRGVwdGhzIH0gPSB0aGlzXG5cbiAgICBpZiAoc2NvcGUgaW4gcGF1c2VEZXB0aHMpIHtcblxuICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgIGRlbGV0ZSBwYXVzZURlcHRoc1tzY29wZV1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGRlcHRoID0gLS1wYXVzZURlcHRoc1tzY29wZV1cblxuICAgICAgICBpZiAoZGVwdGggPD0gMCkge1xuICAgICAgICAgIGRlbGV0ZSBwYXVzZURlcHRoc1tzY29wZV1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnRyeURyYWluKClcbiAgICB9XG4gIH1cblxuICBpc1BhdXNlZCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5wYXVzZURlcHRocykubGVuZ3RoXG4gIH1cblxuICB0cnlEcmFpbigpIHtcbiAgICBpZiAoIXRoaXMuaXNSdW5uaW5nICYmICF0aGlzLmlzUGF1c2VkKCkpIHtcbiAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZVxuXG4gICAgICB3aGlsZSAodGhpcy5pc0RpcnR5KSB7XG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlXG4gICAgICAgIHRoaXMuZHJhaW5lZCgpIC8vIG1pZ2h0IHNldCBpc0RpcnR5IHRvIHRydWUgYWdhaW5cbiAgICAgIH1cblxuICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuY2xlYXJUaW1lb3V0KClcbiAgICB0aGlzLmlzRGlydHkgPSBmYWxzZVxuICAgIHRoaXMucGF1c2VEZXB0aHMgPSB7fVxuICB9XG5cbiAgcHJpdmF0ZSBjbGVhclRpbWVvdXQoKSB7XG4gICAgaWYgKHRoaXMudGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpXG4gICAgICB0aGlzLnRpbWVvdXRJZCA9IDBcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgZHJhaW5lZCgpIHsgLy8gc3ViY2xhc3NlcyBjYW4gaW1wbGVtZW50XG4gICAgaWYgKHRoaXMuZHJhaW5lZE9wdGlvbikge1xuICAgICAgdGhpcy5kcmFpbmVkT3B0aW9uKClcbiAgICB9XG4gIH1cblxufVxuXG5cbmV4cG9ydCBjbGFzcyBUYXNrUnVubmVyPFRhc2s+IHsgLy8gdGhpcyBjbGFzcyBVU0VTIHRoZSBEZWxheWVkUnVubmVyXG5cbiAgcHJpdmF0ZSBxdWV1ZTogVGFza1tdID0gW11cbiAgcHJpdmF0ZSBkZWxheWVkUnVubmVyOiBEZWxheWVkUnVubmVyIC8vIHdpbGwgbW9zdCBsaWtlbHkgYmUgdXNlZCBXSVRIT1VUIGFueSBkZWxheVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcnVuVGFza09wdGlvbj86ICh0YXNrOiBUYXNrKSA9PiB2b2lkLFxuICAgIHByaXZhdGUgZHJhaW5lZE9wdGlvbj86IChjb21wbGV0ZWRUYXNrczogVGFza1tdKSA9PiB2b2lkXG4gICkge1xuICAgIHRoaXMuZGVsYXllZFJ1bm5lciA9IG5ldyBEZWxheWVkUnVubmVyKHRoaXMuZHJhaW4uYmluZCh0aGlzKSlcbiAgfVxuXG4gIHJlcXVlc3QodGFzazogVGFzaywgZGVsYXk/OiBudW1iZXIpIHtcbiAgICB0aGlzLnF1ZXVlLnB1c2godGFzaylcbiAgICB0aGlzLmRlbGF5ZWRSdW5uZXIucmVxdWVzdChkZWxheSlcbiAgfVxuXG4gIHBhdXNlKHNjb3BlPzogc3RyaW5nKSB7XG4gICAgdGhpcy5kZWxheWVkUnVubmVyLnBhdXNlKHNjb3BlKVxuICB9XG5cbiAgcmVzdW1lKHNjb3BlPzogc3RyaW5nLCBmb3JjZT86IGJvb2xlYW4pIHtcbiAgICB0aGlzLmRlbGF5ZWRSdW5uZXIucmVzdW1lKHNjb3BlLCBmb3JjZSlcbiAgfVxuXG4gIGRyYWluKCkge1xuICAgIGxldCB7IHF1ZXVlIH0gPSB0aGlzXG5cbiAgICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgICBsZXQgY29tcGxldGVkVGFza3M6IFRhc2tbXSA9IFtdXG4gICAgICBsZXQgdGFzazogVGFza1xuXG4gICAgICB3aGlsZSAoKHRhc2sgPSBxdWV1ZS5zaGlmdCgpKSkge1xuICAgICAgICB0aGlzLnJ1blRhc2sodGFzaylcbiAgICAgICAgY29tcGxldGVkVGFza3MucHVzaCh0YXNrKVxuICAgICAgfVxuXG4gICAgICB0aGlzLmRyYWluZWQoY29tcGxldGVkVGFza3MpXG4gICAgfSAvLyBrZWVwIGdvaW5nLCBpbiBjYXNlIG5ldyB0YXNrcyB3ZXJlIGFkZGVkIGluIHRoZSBkcmFpbmVkIGhhbmRsZXJcbiAgfVxuXG4gIHByb3RlY3RlZCBydW5UYXNrKHRhc2s6IFRhc2spIHsgLy8gc3ViY2xhc3NlcyBjYW4gaW1wbGVtZW50XG4gICAgaWYgKHRoaXMucnVuVGFza09wdGlvbikge1xuICAgICAgdGhpcy5ydW5UYXNrT3B0aW9uKHRhc2spXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGRyYWluZWQoY29tcGxldGVkVGFza3M6IFRhc2tbXSkgeyAvLyBzdWJjbGFzc2VzIGNhbiBpbXBsZW1lbnRcbiAgICBpZiAodGhpcy5kcmFpbmVkT3B0aW9uKSB7XG4gICAgICB0aGlzLmRyYWluZWRPcHRpb24oY29tcGxldGVkVGFza3MpXG4gICAgfVxuICB9XG5cbn1cbiIsImltcG9ydCB7IERhdGVQcm9maWxlIH0gZnJvbSAnLi4vRGF0ZVByb2ZpbGVHZW5lcmF0b3InXG5pbXBvcnQgeyBkaWZmV2hvbGVEYXlzIH0gZnJvbSAnLi4vZGF0ZWxpYi9tYXJrZXInXG5pbXBvcnQgeyBjcmVhdGVGb3JtYXR0ZXIsIEZvcm1hdHRlcklucHV0IH0gZnJvbSAnLi4vZGF0ZWxpYi9mb3JtYXR0aW5nJ1xuaW1wb3J0IHsgRGF0ZVJhbmdlIH0gZnJvbSAnLi4vZGF0ZWxpYi9kYXRlLXJhbmdlJ1xuaW1wb3J0IHsgRGF0ZUVudiB9IGZyb20gJy4uL2RhdGVsaWIvZW52J1xuaW1wb3J0IHsgQmFzZU9wdGlvbnMgfSBmcm9tICcuLi9vcHRpb25zJ1xuXG5cbi8vIENvbXB1dGVzIHdoYXQgdGhlIHRpdGxlIGF0IHRoZSB0b3Agb2YgdGhlIGNhbGVuZGFyQXBpIHNob3VsZCBiZSBmb3IgdGhpcyB2aWV3XG5leHBvcnQgZnVuY3Rpb24gYnVpbGRUaXRsZShkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGUsIHZpZXdPcHRpb25zOiBCYXNlT3B0aW9ucywgZGF0ZUVudjogRGF0ZUVudikge1xuICBsZXQgcmFuZ2U6IERhdGVSYW5nZVxuXG4gIC8vIGZvciB2aWV3cyB0aGF0IHNwYW4gYSBsYXJnZSB1bml0IG9mIHRpbWUsIHNob3cgdGhlIHByb3BlciBpbnRlcnZhbCwgaWdub3Jpbmcgc3RyYXkgZGF5cyBiZWZvcmUgYW5kIGFmdGVyXG4gIGlmICgvXih5ZWFyfG1vbnRoKSQvLnRlc3QoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCkpIHtcbiAgICByYW5nZSA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVxuICB9IGVsc2UgeyAvLyBmb3IgZGF5IHVuaXRzIG9yIHNtYWxsZXIsIHVzZSB0aGUgYWN0dWFsIGRheSByYW5nZVxuICAgIHJhbmdlID0gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2VcbiAgfVxuXG4gIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKFxuICAgIHJhbmdlLnN0YXJ0LFxuICAgIHJhbmdlLmVuZCxcbiAgICBjcmVhdGVGb3JtYXR0ZXIoXG4gICAgICB2aWV3T3B0aW9ucy50aXRsZUZvcm1hdCB8fCBidWlsZFRpdGxlRm9ybWF0KGRhdGVQcm9maWxlKSxcbiAgICAgIHZpZXdPcHRpb25zLnRpdGxlUmFuZ2VTZXBhcmF0b3JcbiAgICApLFxuICAgIHsgaXNFbmRFeGNsdXNpdmU6IGRhdGVQcm9maWxlLmlzUmFuZ2VBbGxEYXkgfVxuICApXG59XG5cblxuLy8gR2VuZXJhdGVzIHRoZSBmb3JtYXQgc3RyaW5nIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpdGxlIGZvciB0aGUgY3VycmVudCBkYXRlIHJhbmdlLlxuLy8gQXR0ZW1wdHMgdG8gY29tcHV0ZSB0aGUgbW9zdCBhcHByb3ByaWF0ZSBmb3JtYXQgaWYgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkIHdpdGggYHRpdGxlRm9ybWF0YC5cbmZ1bmN0aW9uIGJ1aWxkVGl0bGVGb3JtYXQoZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlKTogRm9ybWF0dGVySW5wdXQge1xuICBsZXQgY3VycmVudFJhbmdlVW5pdCA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXRcblxuICBpZiAoY3VycmVudFJhbmdlVW5pdCA9PT0gJ3llYXInKSB7XG4gICAgcmV0dXJuIHsgeWVhcjogJ251bWVyaWMnIH1cbiAgfSBlbHNlIGlmIChjdXJyZW50UmFuZ2VVbml0ID09PSAnbW9udGgnKSB7XG4gICAgcmV0dXJuIHsgeWVhcjogJ251bWVyaWMnLCBtb250aDogJ2xvbmcnIH0gLy8gbGlrZSBcIlNlcHRlbWJlciAyMDE0XCJcbiAgfSBlbHNlIHtcbiAgICBsZXQgZGF5cyA9IGRpZmZXaG9sZURheXMoXG4gICAgICBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQsXG4gICAgICBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UuZW5kXG4gICAgKVxuICAgIGlmIChkYXlzICE9PSBudWxsICYmIGRheXMgPiAxKSB7XG4gICAgICAvLyBtdWx0aS1kYXkgcmFuZ2UuIHNob3J0ZXIsIGxpa2UgXCJTZXAgOSAtIDEwIDIwMTRcIlxuICAgICAgcmV0dXJuIHsgeWVhcjogJ251bWVyaWMnLCBtb250aDogJ3Nob3J0JywgZGF5OiAnbnVtZXJpYycgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvbmUgZGF5LiBsb25nZXIsIGxpa2UgXCJTZXB0ZW1iZXIgOSAyMDE0XCJcbiAgICAgIHJldHVybiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycgfVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgYnVpbGRMb2NhbGUsIFJhd0xvY2FsZUluZm8sIG9yZ2FuaXplUmF3TG9jYWxlcywgTG9jYWxlU2luZ3VsYXJBcmcgfSBmcm9tICcuLi9kYXRlbGliL2xvY2FsZSdcbmltcG9ydCB7IG1lbW9pemUsIG1lbW9pemVPYmpBcmcgfSBmcm9tICcuLi91dGlsL21lbW9pemUnXG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tICcuL0FjdGlvbidcbmltcG9ydCB7IGJ1aWxkQnVpbGRQbHVnaW5Ib29rcyB9IGZyb20gJy4uL3BsdWdpbi1zeXN0ZW0nXG5pbXBvcnQgeyBQbHVnaW5Ib29rcyB9IGZyb20gJy4uL3BsdWdpbi1zeXN0ZW0tc3RydWN0J1xuaW1wb3J0IHsgRGF0ZUVudiB9IGZyb20gJy4uL2RhdGVsaWIvZW52J1xuaW1wb3J0IHsgQ2FsZW5kYXJBcGkgfSBmcm9tICcuLi9DYWxlbmRhckFwaSdcbmltcG9ydCB7IFN0YW5kYXJkVGhlbWUgfSBmcm9tICcuLi90aGVtZS9TdGFuZGFyZFRoZW1lJ1xuaW1wb3J0IHsgRXZlbnRTb3VyY2VIYXNoIH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1zb3VyY2UnXG5pbXBvcnQgeyBidWlsZFZpZXdTcGVjcywgVmlld1NwZWMgfSBmcm9tICcuLi9zdHJ1Y3RzL3ZpZXctc3BlYydcbmltcG9ydCB7IG1hcEhhc2gsIGlzUHJvcHNFcXVhbCB9IGZyb20gJy4uL3V0aWwvb2JqZWN0J1xuaW1wb3J0IHsgRGF0ZVByb2ZpbGVHZW5lcmF0b3IsIERhdGVQcm9maWxlR2VuZXJhdG9yUHJvcHMgfSBmcm9tICcuLi9EYXRlUHJvZmlsZUdlbmVyYXRvcidcbmltcG9ydCB7IHJlZHVjZVZpZXdUeXBlIH0gZnJvbSAnLi92aWV3LXR5cGUnXG5pbXBvcnQgeyBnZXRJbml0aWFsRGF0ZSwgcmVkdWNlQ3VycmVudERhdGUgfSBmcm9tICcuL2N1cnJlbnQtZGF0ZSdcbmltcG9ydCB7IHJlZHVjZUR5bmFtaWNPcHRpb25PdmVycmlkZXMgfSBmcm9tICcuL29wdGlvbnMnXG5pbXBvcnQgeyByZWR1Y2VEYXRlUHJvZmlsZSB9IGZyb20gJy4vZGF0ZS1wcm9maWxlJ1xuaW1wb3J0IHsgcmVkdWNlRXZlbnRTb3VyY2VzLCBpbml0RXZlbnRTb3VyY2VzLCByZWR1Y2VFdmVudFNvdXJjZXNOZXdUaW1lWm9uZSwgY29tcHV0ZUV2ZW50U291cmNlTG9hZGluZ0xldmVsIH0gZnJvbSAnLi9ldmVudFNvdXJjZXMnXG5pbXBvcnQgeyByZWR1Y2VFdmVudFN0b3JlLCByZXpvbmVFdmVudFN0b3JlRGF0ZXMgfSBmcm9tICcuL2V2ZW50U3RvcmUnXG5pbXBvcnQgeyByZWR1Y2VEYXRlU2VsZWN0aW9uIH0gZnJvbSAnLi9kYXRlLXNlbGVjdGlvbidcbmltcG9ydCB7IHJlZHVjZVNlbGVjdGVkRXZlbnQgfSBmcm9tICcuL3NlbGVjdGVkLWV2ZW50J1xuaW1wb3J0IHsgcmVkdWNlRXZlbnREcmFnIH0gZnJvbSAnLi9ldmVudC1kcmFnJ1xuaW1wb3J0IHsgcmVkdWNlRXZlbnRSZXNpemUgfSBmcm9tICcuL2V2ZW50LXJlc2l6ZSdcbmltcG9ydCB7IEVtaXR0ZXIgfSBmcm9tICcuLi9jb21tb24vRW1pdHRlcidcbmltcG9ydCB7IEV2ZW50VWlIYXNoLCBFdmVudFVpLCBjcmVhdGVFdmVudFVpIH0gZnJvbSAnLi4vY29tcG9uZW50L2V2ZW50LXVpJ1xuaW1wb3J0IHsgRXZlbnREZWZIYXNoIH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1kZWYnXG5pbXBvcnQgeyBwYXJzZVRvb2xiYXJzIH0gZnJvbSAnLi4vdG9vbGJhci1wYXJzZSdcbmltcG9ydCB7XG4gIENhbGVuZGFyT3B0aW9uc1JlZmluZWQsIENhbGVuZGFyT3B0aW9ucyxcbiAgQ0FMRU5EQVJfT1BUSU9OX1JFRklORVJTLCBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SUyxcbiAgVmlld09wdGlvbnMsIFZpZXdPcHRpb25zUmVmaW5lZCxcbiAgQkFTRV9PUFRJT05fREVGQVVMVFMsIG1lcmdlUmF3T3B0aW9ucyxcbiAgQkFTRV9PUFRJT05fUkVGSU5FUlMsIFZJRVdfT1BUSU9OX1JFRklORVJTLFxuICBDYWxlbmRhckxpc3RlbmVycywgQ0FMRU5EQVJfTElTVEVORVJfUkVGSU5FUlMsIERpY3Rpb25hcnlcbn0gZnJvbSAnLi4vb3B0aW9ucydcbmltcG9ydCB7IHJhbmdlQ29udGFpbnNNYXJrZXIgfSBmcm9tICcuLi9kYXRlbGliL2RhdGUtcmFuZ2UnXG5pbXBvcnQgeyBWaWV3QXBpIH0gZnJvbSAnLi4vVmlld0FwaSdcbmltcG9ydCB7IHBhcnNlQnVzaW5lc3NIb3VycyB9IGZyb20gJy4uL3N0cnVjdHMvYnVzaW5lc3MtaG91cnMnXG5pbXBvcnQgeyBnbG9iYWxQbHVnaW5zIH0gZnJvbSAnLi4vZ2xvYmFsLXBsdWdpbnMnXG5pbXBvcnQgeyBjcmVhdGVFbXB0eUV2ZW50U3RvcmUgfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LXN0b3JlJ1xuaW1wb3J0IHsgQ2FsZW5kYXJDb250ZXh0IH0gZnJvbSAnLi4vQ2FsZW5kYXJDb250ZXh0J1xuaW1wb3J0IHsgQ2FsZW5kYXJEYXRhTWFuYWdlclN0YXRlLCBDYWxlbmRhck9wdGlvbnNEYXRhLCBDYWxlbmRhckN1cnJlbnRWaWV3RGF0YSwgQ2FsZW5kYXJEYXRhIH0gZnJvbSAnLi9kYXRhLXR5cGVzJ1xuaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYidcbmltcG9ydCB7IFRhc2tSdW5uZXIgfSBmcm9tICcuLi91dGlsL3J1bm5lcidcbmltcG9ydCB7IGJ1aWxkVGl0bGUgfSBmcm9tICcuL3RpdGxlLWZvcm1hdHRpbmcnXG5cblxuZXhwb3J0IGludGVyZmFjZSBDYWxlbmRhckRhdGFNYW5hZ2VyUHJvcHMge1xuICBvcHRpb25PdmVycmlkZXM6IENhbGVuZGFyT3B0aW9uc1xuICBjYWxlbmRhckFwaTogQ2FsZW5kYXJBcGlcbiAgb25BY3Rpb24/OiAoYWN0aW9uOiBBY3Rpb24pID0+IHZvaWRcbiAgb25EYXRhPzogKGRhdGE6IENhbGVuZGFyRGF0YSkgPT4gdm9pZFxufVxuXG5leHBvcnQgdHlwZSBSZWR1Y2VyRnVuYyA9ICggLy8gVE9ETzogcmVuYW1lIHRvIENhbGVuZGFyRGF0YUluamVjdG9yLiBtb3ZlIHZpZXctcHJvcHMtbWFuaXAgaG9vayBoZXJlIGFzIHdlbGw/XG4gIGN1cnJlbnRTdGF0ZTogRGljdGlvbmFyeSB8IG51bGwsXG4gIGFjdGlvbjogQWN0aW9uIHwgbnVsbCxcbiAgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0ICYgQ2FsZW5kYXJEYXRhTWFuYWdlclN0YXRlIC8vIG1vcmUgdGhhbiBqdXN0IGNvbnRleHRcbikgPT4gRGljdGlvbmFyeVxuXG5cbi8vIGluIGZ1dHVyZSByZWZhY3RvciwgZG8gdGhlIHJlZHV4LXN0eWxlIGZ1bmN0aW9uKHN0YXRlPWluaXRpYWwpIGZvciBpbml0aWFsLXN0YXRlXG4vLyBhbHNvLCB3aGF0ZXZlciBpcyBoYXBwZW5pbmcgaW4gY29uc3RydWN0b3IsIGhhdmUgaXQgaGFwcGVuIGluIGFjdGlvbiBxdWV1ZSB0b29cblxuXG5leHBvcnQgY2xhc3MgQ2FsZW5kYXJEYXRhTWFuYWdlciB7XG5cbiAgcHJpdmF0ZSBjb21wdXRlT3B0aW9uc0RhdGEgPSBtZW1vaXplKHRoaXMuX2NvbXB1dGVPcHRpb25zRGF0YSlcbiAgcHJpdmF0ZSBjb21wdXRlQ3VycmVudFZpZXdEYXRhID0gbWVtb2l6ZSh0aGlzLl9jb21wdXRlQ3VycmVudFZpZXdEYXRhKVxuICBwcml2YXRlIG9yZ2FuaXplUmF3TG9jYWxlcyA9IG1lbW9pemUob3JnYW5pemVSYXdMb2NhbGVzKVxuICBwcml2YXRlIGJ1aWxkTG9jYWxlID0gbWVtb2l6ZShidWlsZExvY2FsZSlcbiAgcHJpdmF0ZSBidWlsZFBsdWdpbkhvb2tzID0gYnVpbGRCdWlsZFBsdWdpbkhvb2tzKClcbiAgcHJpdmF0ZSBidWlsZERhdGVFbnYgPSBtZW1vaXplKGJ1aWxkRGF0ZUVudilcbiAgcHJpdmF0ZSBidWlsZFRoZW1lID0gbWVtb2l6ZShidWlsZFRoZW1lKVxuICBwcml2YXRlIHBhcnNlVG9vbGJhcnMgPSBtZW1vaXplKHBhcnNlVG9vbGJhcnMpXG4gIHByaXZhdGUgYnVpbGRWaWV3U3BlY3MgPSBtZW1vaXplKGJ1aWxkVmlld1NwZWNzKVxuICBwcml2YXRlIGJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSBtZW1vaXplT2JqQXJnKGJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3IpXG4gIHByaXZhdGUgYnVpbGRWaWV3QXBpID0gbWVtb2l6ZShidWlsZFZpZXdBcGkpXG4gIHByaXZhdGUgYnVpbGRWaWV3VWlQcm9wcyA9IG1lbW9pemVPYmpBcmcoYnVpbGRWaWV3VWlQcm9wcylcbiAgcHJpdmF0ZSBidWlsZEV2ZW50VWlCeVNvdXJjZSA9IG1lbW9pemUoYnVpbGRFdmVudFVpQnlTb3VyY2UsIGlzUHJvcHNFcXVhbClcbiAgcHJpdmF0ZSBidWlsZEV2ZW50VWlCYXNlcyA9IG1lbW9pemUoYnVpbGRFdmVudFVpQmFzZXMpXG4gIHByaXZhdGUgcGFyc2VDb250ZXh0QnVzaW5lc3NIb3VycyA9IG1lbW9pemVPYmpBcmcocGFyc2VDb250ZXh0QnVzaW5lc3NIb3VycylcbiAgcHJpdmF0ZSBidWlsZFRpdGxlID0gbWVtb2l6ZShidWlsZFRpdGxlKVxuXG4gIHB1YmxpYyBlbWl0dGVyID0gbmV3IEVtaXR0ZXI8Q2FsZW5kYXJMaXN0ZW5lcnM+KClcbiAgcHJpdmF0ZSBhY3Rpb25SdW5uZXIgPSBuZXcgVGFza1J1bm5lcih0aGlzLl9oYW5kbGVBY3Rpb24uYmluZCh0aGlzKSwgdGhpcy51cGRhdGVEYXRhLmJpbmQodGhpcykpXG4gIHByaXZhdGUgcHJvcHM6IENhbGVuZGFyRGF0YU1hbmFnZXJQcm9wc1xuICBwcml2YXRlIHN0YXRlOiBDYWxlbmRhckRhdGFNYW5hZ2VyU3RhdGVcbiAgcHJpdmF0ZSBkYXRhOiBDYWxlbmRhckRhdGFcblxuICBwdWJsaWMgY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0OiBDYWxlbmRhck9wdGlvbnMgPSB7fVxuICBwcml2YXRlIGN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkOiBDYWxlbmRhck9wdGlvbnNSZWZpbmVkID0gKHt9IGFzIGFueSlcbiAgcHJpdmF0ZSBjdXJyZW50Vmlld09wdGlvbnNJbnB1dDogVmlld09wdGlvbnMgPSB7fVxuICBwcml2YXRlIGN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQ6IFZpZXdPcHRpb25zUmVmaW5lZCA9ICh7fSBhcyBhbnkpXG4gIHB1YmxpYyBjdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lcnM6IGFueSA9IHt9XG5cblxuICBjb25zdHJ1Y3Rvcihwcm9wczogQ2FsZW5kYXJEYXRhTWFuYWdlclByb3BzKSB7XG4gICAgdGhpcy5wcm9wcyA9IHByb3BzXG4gICAgdGhpcy5hY3Rpb25SdW5uZXIucGF1c2UoKVxuXG4gICAgbGV0IGR5bmFtaWNPcHRpb25PdmVycmlkZXM6IENhbGVuZGFyT3B0aW9ucyA9IHt9XG4gICAgbGV0IG9wdGlvbnNEYXRhID0gdGhpcy5jb21wdXRlT3B0aW9uc0RhdGEoXG4gICAgICBwcm9wcy5vcHRpb25PdmVycmlkZXMsXG4gICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgcHJvcHMuY2FsZW5kYXJBcGlcbiAgICApXG5cbiAgICBsZXQgY3VycmVudFZpZXdUeXBlID0gb3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zLmluaXRpYWxWaWV3IHx8IG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLmluaXRpYWxWaWV3XG4gICAgbGV0IGN1cnJlbnRWaWV3RGF0YSA9IHRoaXMuY29tcHV0ZUN1cnJlbnRWaWV3RGF0YShcbiAgICAgIGN1cnJlbnRWaWV3VHlwZSxcbiAgICAgIG9wdGlvbnNEYXRhLFxuICAgICAgcHJvcHMub3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlc1xuICAgIClcblxuICAgIC8vIHdpcmUgdGhpbmdzIHVwXG4gICAgLy8gVE9ETzogbm90IERSWVxuICAgIHByb3BzLmNhbGVuZGFyQXBpLmN1cnJlbnREYXRhTWFuYWdlciA9IHRoaXNcbiAgICB0aGlzLmVtaXR0ZXIuc2V0VGhpc0NvbnRleHQocHJvcHMuY2FsZW5kYXJBcGkpXG4gICAgdGhpcy5lbWl0dGVyLnNldE9wdGlvbnMoY3VycmVudFZpZXdEYXRhLm9wdGlvbnMpXG5cbiAgICBsZXQgY3VycmVudERhdGUgPSBnZXRJbml0aWFsRGF0ZShvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMsIG9wdGlvbnNEYXRhLmRhdGVFbnYpXG4gICAgbGV0IGRhdGVQcm9maWxlID0gY3VycmVudFZpZXdEYXRhLmRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKGN1cnJlbnREYXRlKVxuXG4gICAgaWYgKCFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBjdXJyZW50RGF0ZSkpIHtcbiAgICAgIGN1cnJlbnREYXRlID0gZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLnN0YXJ0XG4gICAgfVxuXG4gICAgbGV0IGNhbGVuZGFyQ29udGV4dDogQ2FsZW5kYXJDb250ZXh0ID0ge1xuICAgICAgZGF0ZUVudjogb3B0aW9uc0RhdGEuZGF0ZUVudixcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucyxcbiAgICAgIHBsdWdpbkhvb2tzOiBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcyxcbiAgICAgIGNhbGVuZGFyQXBpOiBwcm9wcy5jYWxlbmRhckFwaSxcbiAgICAgIGRpc3BhdGNoOiB0aGlzLmRpc3BhdGNoLFxuICAgICAgZW1pdHRlcjogdGhpcy5lbWl0dGVyLFxuICAgICAgZ2V0Q3VycmVudERhdGE6IHRoaXMuZ2V0Q3VycmVudERhdGFcbiAgICB9XG5cbiAgICAvLyBuZWVkcyB0byBiZSBhZnRlciBzZXRUaGlzQ29udGV4dFxuICAgIGZvciAobGV0IGNhbGxiYWNrIG9mIG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLmNvbnRleHRJbml0KSB7XG4gICAgICBjYWxsYmFjayhjYWxlbmRhckNvbnRleHQpXG4gICAgfVxuXG4gICAgLy8gTk9UIERSWVxuICAgIGxldCBldmVudFNvdXJjZXMgPSBpbml0RXZlbnRTb3VyY2VzKG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucywgZGF0ZVByb2ZpbGUsIGNhbGVuZGFyQ29udGV4dClcblxuICAgIGxldCBpbml0aWFsU3RhdGU6IENhbGVuZGFyRGF0YU1hbmFnZXJTdGF0ZSA9IHtcbiAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgICBjdXJyZW50Vmlld1R5cGUsXG4gICAgICBjdXJyZW50RGF0ZSxcbiAgICAgIGRhdGVQcm9maWxlLFxuICAgICAgYnVzaW5lc3NIb3VyczogdGhpcy5wYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzKGNhbGVuZGFyQ29udGV4dCksIC8vIHdlaXJkIHRvIGhhdmUgdGhpcyBpbiBzdGF0ZVxuICAgICAgZXZlbnRTb3VyY2VzLFxuICAgICAgZXZlbnRVaUJhc2VzOiB7fSxcbiAgICAgIGxvYWRpbmdMZXZlbDogY29tcHV0ZUV2ZW50U291cmNlTG9hZGluZ0xldmVsKGV2ZW50U291cmNlcyksXG4gICAgICBldmVudFN0b3JlOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgIHJlbmRlcmFibGVFdmVudFN0b3JlOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgIGRhdGVTZWxlY3Rpb246IG51bGwsXG4gICAgICBldmVudFNlbGVjdGlvbjogJycsXG4gICAgICBldmVudERyYWc6IG51bGwsXG4gICAgICBldmVudFJlc2l6ZTogbnVsbCxcbiAgICAgIHNlbGVjdGlvbkNvbmZpZzogdGhpcy5idWlsZFZpZXdVaVByb3BzKGNhbGVuZGFyQ29udGV4dCkuc2VsZWN0aW9uQ29uZmlnXG4gICAgfVxuICAgIGxldCBjb250ZXh0QW5kU3RhdGUgPSB7IC4uLmNhbGVuZGFyQ29udGV4dCwgLi4uaW5pdGlhbFN0YXRlIH1cblxuICAgIGZvciAobGV0IHJlZHVjZXIgb2Ygb3B0aW9uc0RhdGEucGx1Z2luSG9va3MucmVkdWNlcnMpIHtcbiAgICAgIF9fYXNzaWduKGluaXRpYWxTdGF0ZSwgcmVkdWNlcihudWxsLCBudWxsLCBjb250ZXh0QW5kU3RhdGUpKVxuICAgIH1cblxuICAgIGlmIChpbml0aWFsU3RhdGUubG9hZGluZ0xldmVsKSB7XG4gICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignbG9hZGluZycsIHRydWUpIC8vIE5PVCBEUllcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlXG4gICAgdGhpcy51cGRhdGVEYXRhKClcbiAgICB0aGlzLmFjdGlvblJ1bm5lci5yZXN1bWUoKVxuICB9XG5cblxuICBnZXRDdXJyZW50RGF0YSA9ICgpID0+IHtcbiAgICByZXR1cm4gdGhpcy5kYXRhXG4gIH1cblxuXG4gIGRpc3BhdGNoID0gKGFjdGlvbjogQWN0aW9uKSA9PiB7XG4gICAgdGhpcy5hY3Rpb25SdW5uZXIucmVxdWVzdChhY3Rpb24pIC8vIHByb3RlY3RzIGFnYWluc3QgcmVjdXJzaXZlIGNhbGxzIHRvIF9oYW5kbGVBY3Rpb25cbiAgfVxuXG5cbiAgcmVzZXRPcHRpb25zKG9wdGlvbk92ZXJyaWRlczogQ2FsZW5kYXJPcHRpb25zLCBhcHBlbmQ/OiBib29sZWFuKSB7XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcblxuICAgIHByb3BzLm9wdGlvbk92ZXJyaWRlcyA9IGFwcGVuZFxuICAgICAgPyB7IC4uLnByb3BzLm9wdGlvbk92ZXJyaWRlcywgLi4ub3B0aW9uT3ZlcnJpZGVzIH1cbiAgICAgIDogb3B0aW9uT3ZlcnJpZGVzXG5cbiAgICB0aGlzLmFjdGlvblJ1bm5lci5yZXF1ZXN0KHsgLy8gaGFjay4gd2lsbCBjYXVzZSB1cGRhdGVEYXRhXG4gICAgICB0eXBlOiAnTk9USElORydcbiAgICB9KVxuICB9XG5cblxuICBfaGFuZGxlQWN0aW9uKGFjdGlvbjogQWN0aW9uKSB7XG4gICAgbGV0IHsgcHJvcHMsIHN0YXRlLCBlbWl0dGVyIH0gPSB0aGlzXG5cbiAgICBsZXQgZHluYW1pY09wdGlvbk92ZXJyaWRlcyA9IHJlZHVjZUR5bmFtaWNPcHRpb25PdmVycmlkZXMoc3RhdGUuZHluYW1pY09wdGlvbk92ZXJyaWRlcywgYWN0aW9uKVxuICAgIGxldCBvcHRpb25zRGF0YSA9IHRoaXMuY29tcHV0ZU9wdGlvbnNEYXRhKFxuICAgICAgcHJvcHMub3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICAgIHByb3BzLmNhbGVuZGFyQXBpXG4gICAgKVxuXG4gICAgbGV0IGN1cnJlbnRWaWV3VHlwZSA9IHJlZHVjZVZpZXdUeXBlKHN0YXRlLmN1cnJlbnRWaWV3VHlwZSwgYWN0aW9uKVxuICAgIGxldCBjdXJyZW50Vmlld0RhdGEgPSB0aGlzLmNvbXB1dGVDdXJyZW50Vmlld0RhdGEoXG4gICAgICBjdXJyZW50Vmlld1R5cGUsXG4gICAgICBvcHRpb25zRGF0YSxcbiAgICAgIHByb3BzLm9wdGlvbk92ZXJyaWRlcyxcbiAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXNcbiAgICApXG5cbiAgICAvLyB3aXJlIHRoaW5ncyB1cFxuICAgIC8vIFRPRE86IG5vdCBEUllcbiAgICBwcm9wcy5jYWxlbmRhckFwaS5jdXJyZW50RGF0YU1hbmFnZXIgPSB0aGlzXG4gICAgZW1pdHRlci5zZXRUaGlzQ29udGV4dChwcm9wcy5jYWxlbmRhckFwaSlcbiAgICBlbWl0dGVyLnNldE9wdGlvbnMoY3VycmVudFZpZXdEYXRhLm9wdGlvbnMpXG5cbiAgICBsZXQgY2FsZW5kYXJDb250ZXh0OiBDYWxlbmRhckNvbnRleHQgPSB7XG4gICAgICBkYXRlRW52OiBvcHRpb25zRGF0YS5kYXRlRW52LFxuICAgICAgb3B0aW9uczogb3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zLFxuICAgICAgcGx1Z2luSG9va3M6IG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLFxuICAgICAgY2FsZW5kYXJBcGk6IHByb3BzLmNhbGVuZGFyQXBpLFxuICAgICAgZGlzcGF0Y2g6IHRoaXMuZGlzcGF0Y2gsXG4gICAgICBlbWl0dGVyLFxuICAgICAgZ2V0Q3VycmVudERhdGE6IHRoaXMuZ2V0Q3VycmVudERhdGFcbiAgICB9XG5cbiAgICBsZXQgY3VycmVudERhdGUgPSBzdGF0ZS5jdXJyZW50RGF0ZVxuICAgIGxldCBkYXRlUHJvZmlsZSA9IHN0YXRlLmRhdGVQcm9maWxlXG5cbiAgICBpZiAodGhpcy5kYXRhICYmIHRoaXMuZGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvciAhPT0gY3VycmVudFZpZXdEYXRhLmRhdGVQcm9maWxlR2VuZXJhdG9yKSB7IC8vIGhhY2tcbiAgICAgIGRhdGVQcm9maWxlID0gY3VycmVudFZpZXdEYXRhLmRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKGN1cnJlbnREYXRlKVxuICAgIH1cblxuICAgIGN1cnJlbnREYXRlID0gcmVkdWNlQ3VycmVudERhdGUoY3VycmVudERhdGUsIGFjdGlvbilcbiAgICBkYXRlUHJvZmlsZSA9IHJlZHVjZURhdGVQcm9maWxlKGRhdGVQcm9maWxlLCBhY3Rpb24sIGN1cnJlbnREYXRlLCBjdXJyZW50Vmlld0RhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IpXG5cbiAgICBpZiAoIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBjdXJyZW50RGF0ZSkpIHtcbiAgICAgIGN1cnJlbnREYXRlID0gZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLnN0YXJ0XG4gICAgfVxuXG4gICAgbGV0IGV2ZW50U291cmNlcyA9IHJlZHVjZUV2ZW50U291cmNlcyhzdGF0ZS5ldmVudFNvdXJjZXMsIGFjdGlvbiwgZGF0ZVByb2ZpbGUsIGNhbGVuZGFyQ29udGV4dClcbiAgICBsZXQgZXZlbnRTb3VyY2VMb2FkaW5nTGV2ZWwgPSBjb21wdXRlRXZlbnRTb3VyY2VMb2FkaW5nTGV2ZWwoZXZlbnRTb3VyY2VzKVxuICAgIGxldCBldmVudFN0b3JlID0gcmVkdWNlRXZlbnRTdG9yZShzdGF0ZS5ldmVudFN0b3JlLCBhY3Rpb24sIGV2ZW50U291cmNlcywgZGF0ZVByb2ZpbGUsIGNhbGVuZGFyQ29udGV4dClcblxuICAgIGxldCByZW5kZXJhYmxlRXZlbnRTdG9yZSA9XG4gICAgICAoZXZlbnRTb3VyY2VMb2FkaW5nTGV2ZWwgJiYgIWN1cnJlbnRWaWV3RGF0YS5vcHRpb25zLnByb2dyZXNzaXZlRXZlbnRSZW5kZXJpbmcpID9cbiAgICAgICAgKHN0YXRlLnJlbmRlcmFibGVFdmVudFN0b3JlIHx8IGV2ZW50U3RvcmUpIDogLy8gdHJ5IGZyb20gcHJldmlvdXMgc3RhdGVcbiAgICAgICAgZXZlbnRTdG9yZVxuXG4gICAgbGV0IHsgZXZlbnRVaVNpbmdsZUJhc2UsIHNlbGVjdGlvbkNvbmZpZyB9ID0gdGhpcy5idWlsZFZpZXdVaVByb3BzKGNhbGVuZGFyQ29udGV4dCkgLy8gd2lsbCBtZW1vaXplIG9ialxuICAgIGxldCBldmVudFVpQnlTb3VyY2UgPSB0aGlzLmJ1aWxkRXZlbnRVaUJ5U291cmNlKGV2ZW50U291cmNlcylcbiAgICBsZXQgZXZlbnRVaUJhc2VzID0gdGhpcy5idWlsZEV2ZW50VWlCYXNlcyhyZW5kZXJhYmxlRXZlbnRTdG9yZS5kZWZzLCBldmVudFVpU2luZ2xlQmFzZSwgZXZlbnRVaUJ5U291cmNlKVxuXG4gICAgbGV0IHByZXZMb2FkaW5nTGV2ZWwgPSBzdGF0ZS5sb2FkaW5nTGV2ZWwgfHwgMFxuICAgIGxldCBsb2FkaW5nTGV2ZWwgPSBldmVudFNvdXJjZUxvYWRpbmdMZXZlbFxuXG4gICAgbGV0IG5ld1N0YXRlOiBDYWxlbmRhckRhdGFNYW5hZ2VyU3RhdGUgPSB7XG4gICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgY3VycmVudFZpZXdUeXBlLFxuICAgICAgY3VycmVudERhdGUsXG4gICAgICBkYXRlUHJvZmlsZSxcbiAgICAgIGV2ZW50U291cmNlcyxcbiAgICAgIGV2ZW50U3RvcmUsXG4gICAgICByZW5kZXJhYmxlRXZlbnRTdG9yZSxcbiAgICAgIHNlbGVjdGlvbkNvbmZpZyxcbiAgICAgIGV2ZW50VWlCYXNlcyxcbiAgICAgIGxvYWRpbmdMZXZlbCxcbiAgICAgIGJ1c2luZXNzSG91cnM6IHRoaXMucGFyc2VDb250ZXh0QnVzaW5lc3NIb3VycyhjYWxlbmRhckNvbnRleHQpLCAvLyB3aWxsIG1lbW9pemUgb2JqXG4gICAgICBkYXRlU2VsZWN0aW9uOiByZWR1Y2VEYXRlU2VsZWN0aW9uKHN0YXRlLmRhdGVTZWxlY3Rpb24sIGFjdGlvbiksXG4gICAgICBldmVudFNlbGVjdGlvbjogcmVkdWNlU2VsZWN0ZWRFdmVudChzdGF0ZS5ldmVudFNlbGVjdGlvbiwgYWN0aW9uKSxcbiAgICAgIGV2ZW50RHJhZzogcmVkdWNlRXZlbnREcmFnKHN0YXRlLmV2ZW50RHJhZywgYWN0aW9uKSxcbiAgICAgIGV2ZW50UmVzaXplOiByZWR1Y2VFdmVudFJlc2l6ZShzdGF0ZS5ldmVudFJlc2l6ZSwgYWN0aW9uKVxuICAgIH1cbiAgICBsZXQgY29udGV4dEFuZFN0YXRlID0geyAuLi5jYWxlbmRhckNvbnRleHQsIC4uLm5ld1N0YXRlIH1cblxuICAgIGZvciAobGV0IHJlZHVjZXIgb2Ygb3B0aW9uc0RhdGEucGx1Z2luSG9va3MucmVkdWNlcnMpIHtcbiAgICAgIF9fYXNzaWduKG5ld1N0YXRlLCByZWR1Y2VyKHN0YXRlLCBhY3Rpb24sIGNvbnRleHRBbmRTdGF0ZSkpIC8vIGdpdmUgdGhlIE9MRCBzdGF0ZSwgZm9yIG9sZCB2YWx1ZVxuICAgIH1cblxuICAgIC8vIFRPRE86IHVzZSBwcm9wU2V0SGFuZGxlcnMgaW4gcGx1Z2luIHN5c3RlbVxuICAgIGlmICghcHJldkxvYWRpbmdMZXZlbCAmJiBsb2FkaW5nTGV2ZWwpIHtcbiAgICAgIGVtaXR0ZXIudHJpZ2dlcignbG9hZGluZycsIHRydWUpXG4gICAgfSBlbHNlIGlmIChwcmV2TG9hZGluZ0xldmVsICYmICFsb2FkaW5nTGV2ZWwpIHtcbiAgICAgIGVtaXR0ZXIudHJpZ2dlcignbG9hZGluZycsIGZhbHNlKVxuICAgIH1cblxuICAgIHRoaXMuc3RhdGUgPSBuZXdTdGF0ZVxuXG4gICAgaWYgKHByb3BzLm9uQWN0aW9uKSB7XG4gICAgICBwcm9wcy5vbkFjdGlvbihhY3Rpb24pXG4gICAgfVxuICB9XG5cblxuICB1cGRhdGVEYXRhKCkge1xuICAgIGxldCB7IHByb3BzLCBzdGF0ZSB9ID0gdGhpc1xuICAgIGxldCBvbGREYXRhID0gdGhpcy5kYXRhXG5cbiAgICBsZXQgb3B0aW9uc0RhdGEgPSB0aGlzLmNvbXB1dGVPcHRpb25zRGF0YShcbiAgICAgIHByb3BzLm9wdGlvbk92ZXJyaWRlcyxcbiAgICAgIHN0YXRlLmR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgICBwcm9wcy5jYWxlbmRhckFwaVxuICAgIClcblxuICAgIGxldCBjdXJyZW50Vmlld0RhdGEgPSB0aGlzLmNvbXB1dGVDdXJyZW50Vmlld0RhdGEoXG4gICAgICBzdGF0ZS5jdXJyZW50Vmlld1R5cGUsXG4gICAgICBvcHRpb25zRGF0YSxcbiAgICAgIHByb3BzLm9wdGlvbk92ZXJyaWRlcyxcbiAgICAgIHN0YXRlLmR5bmFtaWNPcHRpb25PdmVycmlkZXNcbiAgICApXG5cbiAgICBsZXQgZGF0YTogQ2FsZW5kYXJEYXRhID0gdGhpcy5kYXRhID0ge1xuICAgICAgdmlld1RpdGxlOiB0aGlzLmJ1aWxkVGl0bGUoc3RhdGUuZGF0ZVByb2ZpbGUsIGN1cnJlbnRWaWV3RGF0YS5vcHRpb25zLCBvcHRpb25zRGF0YS5kYXRlRW52KSxcbiAgICAgIGNhbGVuZGFyQXBpOiBwcm9wcy5jYWxlbmRhckFwaSxcbiAgICAgIGRpc3BhdGNoOiB0aGlzLmRpc3BhdGNoLFxuICAgICAgZW1pdHRlcjogdGhpcy5lbWl0dGVyLFxuICAgICAgZ2V0Q3VycmVudERhdGE6IHRoaXMuZ2V0Q3VycmVudERhdGEsXG4gICAgICAuLi5vcHRpb25zRGF0YSxcbiAgICAgIC4uLmN1cnJlbnRWaWV3RGF0YSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfVxuXG4gICAgbGV0IGNoYW5nZUhhbmRsZXJzID0gb3B0aW9uc0RhdGEucGx1Z2luSG9va3Mub3B0aW9uQ2hhbmdlSGFuZGxlcnNcbiAgICBsZXQgb2xkQ2FsZW5kYXJPcHRpb25zID0gb2xkRGF0YSAmJiBvbGREYXRhLmNhbGVuZGFyT3B0aW9uc1xuICAgIGxldCBuZXdDYWxlbmRhck9wdGlvbnMgPSBvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnNcblxuICAgIGlmIChvbGRDYWxlbmRhck9wdGlvbnMgJiYgb2xkQ2FsZW5kYXJPcHRpb25zICE9PSBuZXdDYWxlbmRhck9wdGlvbnMpIHtcblxuICAgICAgaWYgKG9sZENhbGVuZGFyT3B0aW9ucy50aW1lWm9uZSAhPT0gbmV3Q2FsZW5kYXJPcHRpb25zLnRpbWVab25lKSB7XG4gICAgICAgIC8vIGhhY2tcbiAgICAgICAgc3RhdGUuZXZlbnRTb3VyY2VzID0gZGF0YS5ldmVudFNvdXJjZXMgPSByZWR1Y2VFdmVudFNvdXJjZXNOZXdUaW1lWm9uZShkYXRhLmV2ZW50U291cmNlcywgc3RhdGUuZGF0ZVByb2ZpbGUsIGRhdGEpXG4gICAgICAgIHN0YXRlLmV2ZW50U3RvcmUgPSBkYXRhLmV2ZW50U3RvcmUgPSByZXpvbmVFdmVudFN0b3JlRGF0ZXMoZGF0YS5ldmVudFN0b3JlLCBvbGREYXRhLmRhdGVFbnYsIGRhdGEuZGF0ZUVudilcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgb3B0aW9uTmFtZSBpbiBjaGFuZ2VIYW5kbGVycykge1xuICAgICAgICBpZiAob2xkQ2FsZW5kYXJPcHRpb25zW29wdGlvbk5hbWVdICE9PSBuZXdDYWxlbmRhck9wdGlvbnNbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICBjaGFuZ2VIYW5kbGVyc1tvcHRpb25OYW1lXShuZXdDYWxlbmRhck9wdGlvbnNbb3B0aW9uTmFtZV0sIGRhdGEpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvcHMub25EYXRhKSB7XG4gICAgICBwcm9wcy5vbkRhdGEoZGF0YSlcbiAgICB9XG4gIH1cblxuXG4gIF9jb21wdXRlT3B0aW9uc0RhdGEob3B0aW9uT3ZlcnJpZGVzOiBDYWxlbmRhck9wdGlvbnMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXM6IENhbGVuZGFyT3B0aW9ucywgY2FsZW5kYXJBcGk6IENhbGVuZGFyQXBpKTogQ2FsZW5kYXJPcHRpb25zRGF0YSB7XG4gICAgLy8gVE9ETzogYmxhY2tsaXN0IG9wdGlvbnMgdGhhdCBhcmUgaGFuZGxlZCBieSBvcHRpb25DaGFuZ2VIYW5kbGVyc1xuXG4gICAgbGV0IHtcbiAgICAgIHJlZmluZWRPcHRpb25zLCBwbHVnaW5Ib29rcywgbG9jYWxlRGVmYXVsdHMsIGF2YWlsYWJsZUxvY2FsZURhdGEsIGV4dHJhXG4gICAgfSA9IHRoaXMucHJvY2Vzc1Jhd0NhbGVuZGFyT3B0aW9ucyhvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpXG5cbiAgICB3YXJuVW5rbm93bk9wdGlvbnMoZXh0cmEpXG5cbiAgICBsZXQgZGF0ZUVudiA9IHRoaXMuYnVpbGREYXRlRW52KFxuICAgICAgcmVmaW5lZE9wdGlvbnMudGltZVpvbmUsXG4gICAgICByZWZpbmVkT3B0aW9ucy5sb2NhbGUsXG4gICAgICByZWZpbmVkT3B0aW9ucy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24sXG4gICAgICByZWZpbmVkT3B0aW9ucy5maXJzdERheSxcbiAgICAgIHJlZmluZWRPcHRpb25zLndlZWtUZXh0LFxuICAgICAgcGx1Z2luSG9va3MsXG4gICAgICBhdmFpbGFibGVMb2NhbGVEYXRhLFxuICAgICAgcmVmaW5lZE9wdGlvbnMuZGVmYXVsdFJhbmdlU2VwYXJhdG9yXG4gICAgKVxuXG4gICAgbGV0IHZpZXdTcGVjcyA9IHRoaXMuYnVpbGRWaWV3U3BlY3MocGx1Z2luSG9va3Mudmlld3MsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgbG9jYWxlRGVmYXVsdHMpXG4gICAgbGV0IHRoZW1lID0gdGhpcy5idWlsZFRoZW1lKHJlZmluZWRPcHRpb25zLCBwbHVnaW5Ib29rcylcbiAgICBsZXQgdG9vbGJhckNvbmZpZyA9IHRoaXMucGFyc2VUb29sYmFycyhyZWZpbmVkT3B0aW9ucywgb3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSlcblxuICAgIHJldHVybiB7XG4gICAgICBjYWxlbmRhck9wdGlvbnM6IHJlZmluZWRPcHRpb25zLFxuICAgICAgcGx1Z2luSG9va3MsXG4gICAgICBkYXRlRW52LFxuICAgICAgdmlld1NwZWNzLFxuICAgICAgdGhlbWUsXG4gICAgICB0b29sYmFyQ29uZmlnLFxuICAgICAgbG9jYWxlRGVmYXVsdHMsXG4gICAgICBhdmFpbGFibGVSYXdMb2NhbGVzOiBhdmFpbGFibGVMb2NhbGVEYXRhLm1hcFxuICAgIH1cbiAgfVxuXG5cbiAgLy8gYWx3YXlzIGNhbGxlZCBmcm9tIGJlaGluZCBhIG1lbW9pemVyXG4gIHByb2Nlc3NSYXdDYWxlbmRhck9wdGlvbnMob3B0aW9uT3ZlcnJpZGVzOiBDYWxlbmRhck9wdGlvbnMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXM6IENhbGVuZGFyT3B0aW9ucykge1xuICAgIGxldCB7IGxvY2FsZXMsIGxvY2FsZSB9ID0gbWVyZ2VSYXdPcHRpb25zKFtcbiAgICAgIEJBU0VfT1BUSU9OX0RFRkFVTFRTLFxuICAgICAgb3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlc1xuICAgIF0pXG4gICAgbGV0IGF2YWlsYWJsZUxvY2FsZURhdGEgPSB0aGlzLm9yZ2FuaXplUmF3TG9jYWxlcyhsb2NhbGVzKVxuICAgIGxldCBhdmFpbGFibGVSYXdMb2NhbGVzID0gYXZhaWxhYmxlTG9jYWxlRGF0YS5tYXBcbiAgICBsZXQgbG9jYWxlRGVmYXVsdHMgPSB0aGlzLmJ1aWxkTG9jYWxlKGxvY2FsZSB8fCBhdmFpbGFibGVMb2NhbGVEYXRhLmRlZmF1bHRDb2RlLCBhdmFpbGFibGVSYXdMb2NhbGVzKS5vcHRpb25zXG4gICAgbGV0IHBsdWdpbkhvb2tzID0gdGhpcy5idWlsZFBsdWdpbkhvb2tzKG9wdGlvbk92ZXJyaWRlcy5wbHVnaW5zIHx8IFtdLCBnbG9iYWxQbHVnaW5zKVxuICAgIGxldCByZWZpbmVycyA9IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZXJzID0ge1xuICAgICAgLi4uQkFTRV9PUFRJT05fUkVGSU5FUlMsXG4gICAgICAuLi5DQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyxcbiAgICAgIC4uLkNBTEVOREFSX09QVElPTl9SRUZJTkVSUyxcbiAgICAgIC4uLnBsdWdpbkhvb2tzLmxpc3RlbmVyUmVmaW5lcnMsXG4gICAgICAuLi5wbHVnaW5Ib29rcy5vcHRpb25SZWZpbmVyc1xuICAgIH1cbiAgICBsZXQgZXh0cmEgPSB7fVxuXG4gICAgbGV0IHJhdyA9IG1lcmdlUmF3T3B0aW9ucyhbXG4gICAgICBCQVNFX09QVElPTl9ERUZBVUxUUyxcbiAgICAgIGxvY2FsZURlZmF1bHRzLFxuICAgICAgb3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlc1xuICAgIF0pXG4gICAgbGV0IHJlZmluZWQ6IFBhcnRpYWw8Q2FsZW5kYXJPcHRpb25zUmVmaW5lZD4gPSB7fVxuICAgIGxldCBjdXJyZW50UmF3ID0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXRcbiAgICBsZXQgY3VycmVudFJlZmluZWQgPSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkXG4gICAgbGV0IGFueUNoYW5nZXMgPSBmYWxzZVxuXG4gICAgZm9yIChsZXQgb3B0aW9uTmFtZSBpbiByYXcpIHtcbiAgICAgIGlmIChvcHRpb25OYW1lICE9PSAncGx1Z2lucycpIHsgLy8gYmVjYXVzZSBwbHVnaW5zIGlzIHNwZWNpYWwtY2FzZWRcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgcmF3W29wdGlvbk5hbWVdID09PSBjdXJyZW50UmF3W29wdGlvbk5hbWVdIHx8XG4gICAgICAgICAgKENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTW29wdGlvbk5hbWVdICYmIChvcHRpb25OYW1lIGluIGN1cnJlbnRSYXcpICYmIENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTW29wdGlvbk5hbWVdKGN1cnJlbnRSYXdbb3B0aW9uTmFtZV0sIHJhd1tvcHRpb25OYW1lXSkpXG4gICAgICAgICkge1xuICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSBjdXJyZW50UmVmaW5lZFtvcHRpb25OYW1lXVxuXG4gICAgICAgIH0gZWxzZSBpZiAocmVmaW5lcnNbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICByZWZpbmVkW29wdGlvbk5hbWVdID0gcmVmaW5lcnNbb3B0aW9uTmFtZV0ocmF3W29wdGlvbk5hbWVdKVxuICAgICAgICAgIGFueUNoYW5nZXMgPSB0cnVlXG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHRyYVtvcHRpb25OYW1lXSA9IGN1cnJlbnRSYXdbb3B0aW9uTmFtZV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhbnlDaGFuZ2VzKSB7XG4gICAgICB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dCA9IHJhd1xuICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCA9IHJlZmluZWQgYXMgQ2FsZW5kYXJPcHRpb25zUmVmaW5lZFxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICByYXdPcHRpb25zOiB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dCxcbiAgICAgIHJlZmluZWRPcHRpb25zOiB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkLFxuICAgICAgcGx1Z2luSG9va3MsXG4gICAgICBhdmFpbGFibGVMb2NhbGVEYXRhLFxuICAgICAgbG9jYWxlRGVmYXVsdHMsXG4gICAgICBleHRyYVxuICAgIH1cbiAgfVxuXG5cbiAgX2NvbXB1dGVDdXJyZW50Vmlld0RhdGEodmlld1R5cGU6IHN0cmluZywgb3B0aW9uc0RhdGE6IENhbGVuZGFyT3B0aW9uc0RhdGEsIG9wdGlvbk92ZXJyaWRlczogQ2FsZW5kYXJPcHRpb25zLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzOiBDYWxlbmRhck9wdGlvbnMpOiBDYWxlbmRhckN1cnJlbnRWaWV3RGF0YSB7XG4gICAgbGV0IHZpZXdTcGVjID0gb3B0aW9uc0RhdGEudmlld1NwZWNzW3ZpZXdUeXBlXVxuXG4gICAgaWYgKCF2aWV3U3BlYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB2aWV3VHlwZSBcIiR7dmlld1R5cGV9XCIgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIG1ha2Ugc3VyZSB5b3UndmUgbG9hZGVkIGFsbCBuZWNjZXNzYXJ5IHBsdWdpbnNgKVxuICAgIH1cblxuICAgIGxldCB7IHJlZmluZWRPcHRpb25zLCBleHRyYSB9ID0gdGhpcy5wcm9jZXNzUmF3Vmlld09wdGlvbnMoXG4gICAgICB2aWV3U3BlYyxcbiAgICAgIG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLFxuICAgICAgb3B0aW9uc0RhdGEubG9jYWxlRGVmYXVsdHMsXG4gICAgICBvcHRpb25PdmVycmlkZXMsXG4gICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzXG4gICAgKVxuXG4gICAgd2FyblVua25vd25PcHRpb25zKGV4dHJhKVxuXG4gICAgbGV0IGRhdGVQcm9maWxlR2VuZXJhdG9yID0gdGhpcy5idWlsZERhdGVQcm9maWxlR2VuZXJhdG9yKHtcbiAgICAgIGRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3M6IHZpZXdTcGVjLm9wdGlvbkRlZmF1bHRzLmRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MsXG4gICAgICBkdXJhdGlvbjogdmlld1NwZWMuZHVyYXRpb24sXG4gICAgICBkdXJhdGlvblVuaXQ6IHZpZXdTcGVjLmR1cmF0aW9uVW5pdCxcbiAgICAgIHVzZXNNaW5NYXhUaW1lOiB2aWV3U3BlYy5vcHRpb25EZWZhdWx0cy51c2VzTWluTWF4VGltZSxcbiAgICAgIGRhdGVFbnY6IG9wdGlvbnNEYXRhLmRhdGVFbnYsXG4gICAgICBjYWxlbmRhckFwaTogdGhpcy5wcm9wcy5jYWxlbmRhckFwaSwgLy8gc2hvdWxkIGNvbWUgZnJvbSBlbHNld2hlcmU/XG4gICAgICBzbG90TWluVGltZTogcmVmaW5lZE9wdGlvbnMuc2xvdE1pblRpbWUsXG4gICAgICBzbG90TWF4VGltZTogcmVmaW5lZE9wdGlvbnMuc2xvdE1heFRpbWUsXG4gICAgICBzaG93Tm9uQ3VycmVudERhdGVzOiByZWZpbmVkT3B0aW9ucy5zaG93Tm9uQ3VycmVudERhdGVzLFxuICAgICAgZGF5Q291bnQ6IHJlZmluZWRPcHRpb25zLmRheUNvdW50LFxuICAgICAgZGF0ZUFsaWdubWVudDogcmVmaW5lZE9wdGlvbnMuZGF0ZUFsaWdubWVudCxcbiAgICAgIGRhdGVJbmNyZW1lbnQ6IHJlZmluZWRPcHRpb25zLmRhdGVJbmNyZW1lbnQsXG4gICAgICBoaWRkZW5EYXlzOiByZWZpbmVkT3B0aW9ucy5oaWRkZW5EYXlzLFxuICAgICAgd2Vla2VuZHM6IHJlZmluZWRPcHRpb25zLndlZWtlbmRzLFxuICAgICAgbm93SW5wdXQ6IHJlZmluZWRPcHRpb25zLm5vdyxcbiAgICAgIHZhbGlkUmFuZ2VJbnB1dDogcmVmaW5lZE9wdGlvbnMudmFsaWRSYW5nZSxcbiAgICAgIHZpc2libGVSYW5nZUlucHV0OiByZWZpbmVkT3B0aW9ucy52aXNpYmxlUmFuZ2UsXG4gICAgICBtb250aE1vZGU6IHJlZmluZWRPcHRpb25zLm1vbnRoTW9kZSxcbiAgICAgIGZpeGVkV2Vla0NvdW50OiByZWZpbmVkT3B0aW9ucy5maXhlZFdlZWtDb3VudFxuICAgIH0pXG5cbiAgICBsZXQgdmlld0FwaSA9IHRoaXMuYnVpbGRWaWV3QXBpKHZpZXdUeXBlLCB0aGlzLmdldEN1cnJlbnREYXRhLCBvcHRpb25zRGF0YS5kYXRlRW52KVxuXG4gICAgcmV0dXJuIHsgdmlld1NwZWMsIG9wdGlvbnM6IHJlZmluZWRPcHRpb25zLCBkYXRlUHJvZmlsZUdlbmVyYXRvciwgdmlld0FwaSB9XG4gIH1cblxuXG4gIHByb2Nlc3NSYXdWaWV3T3B0aW9ucyh2aWV3U3BlYzogVmlld1NwZWMsIHBsdWdpbkhvb2tzOiBQbHVnaW5Ib29rcywgbG9jYWxlRGVmYXVsdHM6IENhbGVuZGFyT3B0aW9ucywgb3B0aW9uT3ZlcnJpZGVzOiBDYWxlbmRhck9wdGlvbnMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXM6IENhbGVuZGFyT3B0aW9ucykge1xuICAgIGxldCByYXcgPSBtZXJnZVJhd09wdGlvbnMoW1xuICAgICAgQkFTRV9PUFRJT05fREVGQVVMVFMsXG4gICAgICB2aWV3U3BlYy5vcHRpb25EZWZhdWx0cyxcbiAgICAgIGxvY2FsZURlZmF1bHRzLFxuICAgICAgb3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgdmlld1NwZWMub3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlc1xuICAgIF0pXG4gICAgbGV0IHJlZmluZXJzID0ge1xuICAgICAgLi4uQkFTRV9PUFRJT05fUkVGSU5FUlMsXG4gICAgICAuLi5DQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyxcbiAgICAgIC4uLkNBTEVOREFSX09QVElPTl9SRUZJTkVSUyxcbiAgICAgIC4uLlZJRVdfT1BUSU9OX1JFRklORVJTLFxuICAgICAgLi4ucGx1Z2luSG9va3MubGlzdGVuZXJSZWZpbmVycyxcbiAgICAgIC4uLnBsdWdpbkhvb2tzLm9wdGlvblJlZmluZXJzXG4gICAgfVxuICAgIGxldCByZWZpbmVkOiBQYXJ0aWFsPFZpZXdPcHRpb25zUmVmaW5lZD4gPSB7fVxuICAgIGxldCBjdXJyZW50UmF3ID0gdGhpcy5jdXJyZW50Vmlld09wdGlvbnNJbnB1dFxuICAgIGxldCBjdXJyZW50UmVmaW5lZCA9IHRoaXMuY3VycmVudFZpZXdPcHRpb25zUmVmaW5lZFxuICAgIGxldCBhbnlDaGFuZ2VzID0gZmFsc2VcbiAgICBsZXQgZXh0cmEgPSB7fVxuXG4gICAgZm9yIChsZXQgb3B0aW9uTmFtZSBpbiByYXcpIHtcblxuICAgICAgaWYgKHJhd1tvcHRpb25OYW1lXSA9PT0gY3VycmVudFJhd1tvcHRpb25OYW1lXSkge1xuICAgICAgICByZWZpbmVkW29wdGlvbk5hbWVdID0gY3VycmVudFJlZmluZWRbb3B0aW9uTmFtZV1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJhd1tvcHRpb25OYW1lXSA9PT0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXRbb3B0aW9uTmFtZV0pIHtcblxuICAgICAgICAgIGlmIChvcHRpb25OYW1lIGluIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQpIHsgIC8vIG1pZ2h0IGJlIGFuIFwiZXh0cmFcIiBwcm9wXG4gICAgICAgICAgICByZWZpbmVkW29wdGlvbk5hbWVdID0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZFtvcHRpb25OYW1lXVxuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKHJlZmluZXJzW29wdGlvbk5hbWVdKSB7XG4gICAgICAgICAgcmVmaW5lZFtvcHRpb25OYW1lXSA9IHJlZmluZXJzW29wdGlvbk5hbWVdKHJhd1tvcHRpb25OYW1lXSlcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4dHJhW29wdGlvbk5hbWVdID0gcmF3W29wdGlvbk5hbWVdXG4gICAgICAgIH1cblxuICAgICAgICBhbnlDaGFuZ2VzID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhbnlDaGFuZ2VzKSB7XG4gICAgICB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc0lucHV0ID0gcmF3XG4gICAgICB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQgPSByZWZpbmVkIGFzIFZpZXdPcHRpb25zUmVmaW5lZFxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICByYXdPcHRpb25zOiB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc0lucHV0LFxuICAgICAgcmVmaW5lZE9wdGlvbnM6IHRoaXMuY3VycmVudFZpZXdPcHRpb25zUmVmaW5lZCxcbiAgICAgIGV4dHJhXG4gICAgfVxuICB9XG5cbn1cblxuXG5mdW5jdGlvbiBidWlsZERhdGVFbnYoXG4gIHRpbWVab25lOiBzdHJpbmcsXG4gIGV4cGxpY2l0TG9jYWxlOiBMb2NhbGVTaW5ndWxhckFyZyxcbiAgd2Vla051bWJlckNhbGN1bGF0aW9uLFxuICBmaXJzdERheTogbnVtYmVyIHwgdW5kZWZpbmVkLFxuICB3ZWVrVGV4dCxcbiAgcGx1Z2luSG9va3M6IFBsdWdpbkhvb2tzLFxuICBhdmFpbGFibGVMb2NhbGVEYXRhOiBSYXdMb2NhbGVJbmZvLFxuICBkZWZhdWx0U2VwYXJhdG9yOiBzdHJpbmdcbikge1xuICBsZXQgbG9jYWxlID0gYnVpbGRMb2NhbGUoZXhwbGljaXRMb2NhbGUgfHwgYXZhaWxhYmxlTG9jYWxlRGF0YS5kZWZhdWx0Q29kZSwgYXZhaWxhYmxlTG9jYWxlRGF0YS5tYXApXG5cbiAgcmV0dXJuIG5ldyBEYXRlRW52KHtcbiAgICBjYWxlbmRhclN5c3RlbTogJ2dyZWdvcnknLCAvLyBUT0RPOiBtYWtlIHRoaXMgYSBzZXR0aW5nXG4gICAgdGltZVpvbmU6IHRpbWVab25lLFxuICAgIG5hbWVkVGltZVpvbmVJbXBsOiBwbHVnaW5Ib29rcy5uYW1lZFRpbWVab25lZEltcGwsXG4gICAgbG9jYWxlLFxuICAgIHdlZWtOdW1iZXJDYWxjdWxhdGlvbixcbiAgICBmaXJzdERheSxcbiAgICB3ZWVrVGV4dCxcbiAgICBjbWRGb3JtYXR0ZXI6IHBsdWdpbkhvb2tzLmNtZEZvcm1hdHRlcixcbiAgICBkZWZhdWx0U2VwYXJhdG9yXG4gIH0pXG59XG5cblxuZnVuY3Rpb24gYnVpbGRUaGVtZShvcHRpb25zOiBDYWxlbmRhck9wdGlvbnNSZWZpbmVkLCBwbHVnaW5Ib29rczogUGx1Z2luSG9va3MpIHtcbiAgbGV0IFRoZW1lQ2xhc3MgPSBwbHVnaW5Ib29rcy50aGVtZUNsYXNzZXNbb3B0aW9ucy50aGVtZVN5c3RlbV0gfHwgU3RhbmRhcmRUaGVtZVxuXG4gIHJldHVybiBuZXcgVGhlbWVDbGFzcyhvcHRpb25zKVxufVxuXG5cbmZ1bmN0aW9uIGJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3IocHJvcHM6IERhdGVQcm9maWxlR2VuZXJhdG9yUHJvcHMpOiBEYXRlUHJvZmlsZUdlbmVyYXRvciB7XG4gIGxldCBEYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzID0gcHJvcHMuZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyB8fCBEYXRlUHJvZmlsZUdlbmVyYXRvclxuXG4gIHJldHVybiBuZXcgRGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyhwcm9wcylcbn1cblxuXG5mdW5jdGlvbiBidWlsZFZpZXdBcGkodHlwZTogc3RyaW5nLCBnZXRDdXJyZW50RGF0YTogKCkgPT4gQ2FsZW5kYXJEYXRhLCBkYXRlRW52OiBEYXRlRW52KSB7XG4gIHJldHVybiBuZXcgVmlld0FwaSh0eXBlLCBnZXRDdXJyZW50RGF0YSwgZGF0ZUVudilcbn1cblxuXG5mdW5jdGlvbiBidWlsZEV2ZW50VWlCeVNvdXJjZShldmVudFNvdXJjZXM6IEV2ZW50U291cmNlSGFzaCk6IEV2ZW50VWlIYXNoIHtcbiAgcmV0dXJuIG1hcEhhc2goZXZlbnRTb3VyY2VzLCBmdW5jdGlvbihldmVudFNvdXJjZSkge1xuICAgIHJldHVybiBldmVudFNvdXJjZS51aVxuICB9KVxufVxuXG5cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRVaUJhc2VzKGV2ZW50RGVmczogRXZlbnREZWZIYXNoLCBldmVudFVpU2luZ2xlQmFzZTogRXZlbnRVaSwgZXZlbnRVaUJ5U291cmNlOiBFdmVudFVpSGFzaCkge1xuICBsZXQgZXZlbnRVaUJhc2VzOiBFdmVudFVpSGFzaCA9IHsgJyc6IGV2ZW50VWlTaW5nbGVCYXNlIH1cblxuICBmb3IgKGxldCBkZWZJZCBpbiBldmVudERlZnMpIHtcbiAgICBsZXQgZGVmID0gZXZlbnREZWZzW2RlZklkXVxuXG4gICAgaWYgKGRlZi5zb3VyY2VJZCAmJiBldmVudFVpQnlTb3VyY2VbZGVmLnNvdXJjZUlkXSkge1xuICAgICAgZXZlbnRVaUJhc2VzW2RlZklkXSA9IGV2ZW50VWlCeVNvdXJjZVtkZWYuc291cmNlSWRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50VWlCYXNlc1xufVxuXG5cbmZ1bmN0aW9uIGJ1aWxkVmlld1VpUHJvcHMoY2FsZW5kYXJDb250ZXh0OiBDYWxlbmRhckNvbnRleHQpIHtcbiAgbGV0IHsgb3B0aW9ucyB9ID0gY2FsZW5kYXJDb250ZXh0XG5cbiAgcmV0dXJuIHtcbiAgICBldmVudFVpU2luZ2xlQmFzZTogY3JlYXRlRXZlbnRVaSh7XG4gICAgICBkaXNwbGF5OiBvcHRpb25zLmV2ZW50RGlzcGxheSxcbiAgICAgIGVkaXRhYmxlOiBvcHRpb25zLmVkaXRhYmxlLCAvLyB3aXRob3V0IFwiZXZlbnRcIiBhdCBzdGFydFxuICAgICAgc3RhcnRFZGl0YWJsZTogb3B0aW9ucy5ldmVudFN0YXJ0RWRpdGFibGUsXG4gICAgICBkdXJhdGlvbkVkaXRhYmxlOiBvcHRpb25zLmV2ZW50RHVyYXRpb25FZGl0YWJsZSxcbiAgICAgIGNvbnN0cmFpbnQ6IG9wdGlvbnMuZXZlbnRDb25zdHJhaW50LFxuICAgICAgb3ZlcmxhcDogdHlwZW9mIG9wdGlvbnMuZXZlbnRPdmVybGFwID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmV2ZW50T3ZlcmxhcCA6IHVuZGVmaW5lZCxcbiAgICAgIGFsbG93OiBvcHRpb25zLmV2ZW50QWxsb3csXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuZXZlbnRCYWNrZ3JvdW5kQ29sb3IsXG4gICAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ldmVudEJvcmRlckNvbG9yLFxuICAgICAgdGV4dENvbG9yOiBvcHRpb25zLmV2ZW50VGV4dENvbG9yLFxuICAgICAgY29sb3I6IG9wdGlvbnMuZXZlbnRDb2xvclxuICAgICAgLy8gY2xhc3NOYW1lczogb3B0aW9ucy5ldmVudENsYXNzTmFtZXMgLy8gcmVuZGVyIGhvb2sgd2lsbCBoYW5kbGUgdGhpc1xuICAgIH0sIGNhbGVuZGFyQ29udGV4dCksXG5cbiAgICBzZWxlY3Rpb25Db25maWc6IGNyZWF0ZUV2ZW50VWkoe1xuICAgICAgY29uc3RyYWludDogb3B0aW9ucy5zZWxlY3RDb25zdHJhaW50LFxuICAgICAgb3ZlcmxhcDogdHlwZW9mIG9wdGlvbnMuc2VsZWN0T3ZlcmxhcCA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5zZWxlY3RPdmVybGFwIDogdW5kZWZpbmVkLFxuICAgICAgYWxsb3c6IG9wdGlvbnMuc2VsZWN0QWxsb3dcbiAgICB9LCBjYWxlbmRhckNvbnRleHQpXG4gIH1cbn1cblxuXG5mdW5jdGlvbiBwYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzKGNhbGVuZGFyQ29udGV4dDogQ2FsZW5kYXJDb250ZXh0KSB7XG4gIHJldHVybiBwYXJzZUJ1c2luZXNzSG91cnMoY2FsZW5kYXJDb250ZXh0Lm9wdGlvbnMuYnVzaW5lc3NIb3VycywgY2FsZW5kYXJDb250ZXh0KVxufVxuXG5cbmZ1bmN0aW9uIHdhcm5Vbmtub3duT3B0aW9ucyhvcHRpb25zOiBhbnksIHZpZXdOYW1lPzogc3RyaW5nKSB7XG4gIGZvciAobGV0IG9wdGlvbk5hbWUgaW4gb3B0aW9ucykge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBVbmtub3duIG9wdGlvbiAnJHtvcHRpb25OYW1lfSdgICtcbiAgICAgICh2aWV3TmFtZSA/IGAgZm9yIHZpZXcgJyR7dmlld05hbWV9J2AgOiAnJylcbiAgICApXG4gIH1cbn1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgQ29tcG9uZW50Q2hpbGRyZW4gfSBmcm9tICcuLi92ZG9tJ1xuaW1wb3J0IHsgQ2FsZW5kYXJEYXRhTWFuYWdlciB9IGZyb20gJy4uL3JlZHVjZXJzL0NhbGVuZGFyRGF0YU1hbmFnZXInXG5pbXBvcnQgeyBDYWxlbmRhckFwaSB9IGZyb20gJy4uL0NhbGVuZGFyQXBpJ1xuaW1wb3J0IHsgQ2FsZW5kYXJEYXRhIH0gZnJvbSAnLi4vcmVkdWNlcnMvZGF0YS10eXBlcydcblxuXG5leHBvcnQgaW50ZXJmYWNlIENhbGVuZGFyRGF0YVByb3ZpZGVyUHJvcHMge1xuICBvcHRpb25PdmVycmlkZXM6IGFueVxuICBjYWxlbmRhckFwaTogQ2FsZW5kYXJBcGlcbiAgY2hpbGRyZW4/OiAoZGF0YTogQ2FsZW5kYXJEYXRhKSA9PiBDb21wb25lbnRDaGlsZHJlblxufVxuXG5cbi8vIFRPRE86IG1vdmUgdGhpcyB0byByZWFjdCBwbHVnaW4/XG5leHBvcnQgY2xhc3MgQ2FsZW5kYXJEYXRhUHJvdmlkZXIgZXh0ZW5kcyBDb21wb25lbnQ8Q2FsZW5kYXJEYXRhUHJvdmlkZXJQcm9wcywgQ2FsZW5kYXJEYXRhPiB7XG5cbiAgZGF0YU1hbmFnZXI6IENhbGVuZGFyRGF0YU1hbmFnZXJcblxuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBDYWxlbmRhckRhdGFQcm92aWRlclByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpXG5cbiAgICB0aGlzLmRhdGFNYW5hZ2VyID0gbmV3IENhbGVuZGFyRGF0YU1hbmFnZXIoe1xuICAgICAgb3B0aW9uT3ZlcnJpZGVzOiBwcm9wcy5vcHRpb25PdmVycmlkZXMsXG4gICAgICBjYWxlbmRhckFwaTogcHJvcHMuY2FsZW5kYXJBcGksXG4gICAgICBvbkRhdGE6IHRoaXMuaGFuZGxlRGF0YVxuICAgIH0pXG4gIH1cblxuXG4gIGhhbmRsZURhdGEgPSAoZGF0YTogQ2FsZW5kYXJEYXRhKSA9PiB7XG4gICAgaWYgKCF0aGlzLmRhdGFNYW5hZ2VyKSB7IC8vIHN0aWxsIHdpdGhpbiBpbml0aWFsIHJ1biwgYmVmb3JlIGFzc2lnbm1lbnQgaW4gY29uc3RydWN0b3JcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1kaXJlY3QtbXV0YXRpb24tc3RhdGVcbiAgICAgIHRoaXMuc3RhdGUgPSBkYXRhIC8vIGNhbid0IHVzZSBzZXRTdGF0ZSB5ZXRcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRTdGF0ZShkYXRhKVxuICAgIH1cbiAgfVxuXG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuKHRoaXMuc3RhdGUpXG4gIH1cblxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IENhbGVuZGFyRGF0YVByb3ZpZGVyUHJvcHMpIHtcbiAgICBsZXQgbmV3T3B0aW9uT3ZlcnJpZGVzID0gdGhpcy5wcm9wcy5vcHRpb25PdmVycmlkZXNcblxuICAgIGlmIChuZXdPcHRpb25PdmVycmlkZXMgIT09IHByZXZQcm9wcy5vcHRpb25PdmVycmlkZXMpIHsgLy8gcHJldmVudCByZWN1cnNpdmUgaGFuZGxlRGF0YVxuICAgICAgdGhpcy5kYXRhTWFuYWdlci5yZXNldE9wdGlvbnMobmV3T3B0aW9uT3ZlcnJpZGVzKVxuICAgIH1cbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBEYXRlUHJvZmlsZSB9IGZyb20gJy4vRGF0ZVByb2ZpbGVHZW5lcmF0b3InXG5pbXBvcnQgeyBFdmVudFN0b3JlIH0gZnJvbSAnLi9zdHJ1Y3RzL2V2ZW50LXN0b3JlJ1xuaW1wb3J0IHsgRXZlbnRVaUhhc2ggfSBmcm9tICcuL2NvbXBvbmVudC9ldmVudC11aSdcbmltcG9ydCB7IHNsaWNlRXZlbnRTdG9yZSwgRXZlbnRSZW5kZXJSYW5nZSB9IGZyb20gJy4vY29tcG9uZW50L2V2ZW50LXJlbmRlcmluZydcbmltcG9ydCB7IERhdGVTcGFuIH0gZnJvbSAnLi9zdHJ1Y3RzL2RhdGUtc3BhbidcbmltcG9ydCB7IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSB9IGZyb20gJy4vaW50ZXJhY3Rpb25zL2V2ZW50LWludGVyYWN0aW9uLXN0YXRlJ1xuaW1wb3J0IHsgRHVyYXRpb24gfSBmcm9tICcuL2RhdGVsaWIvZHVyYXRpb24nXG5cblxuZXhwb3J0IGludGVyZmFjZSBWaWV3UHJvcHMge1xuICBkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGVcbiAgYnVzaW5lc3NIb3VyczogRXZlbnRTdG9yZVxuICBldmVudFN0b3JlOiBFdmVudFN0b3JlXG4gIGV2ZW50VWlCYXNlczogRXZlbnRVaUhhc2hcbiAgZGF0ZVNlbGVjdGlvbjogRGF0ZVNwYW4gfCBudWxsXG4gIGV2ZW50U2VsZWN0aW9uOiBzdHJpbmdcbiAgZXZlbnREcmFnOiBFdmVudEludGVyYWN0aW9uU3RhdGUgfCBudWxsXG4gIGV2ZW50UmVzaXplOiBFdmVudEludGVyYWN0aW9uU3RhdGUgfCBudWxsXG4gIGlzSGVpZ2h0QXV0bzogYm9vbGVhblxuICBmb3JQcmludDogYm9vbGVhblxufVxuXG5cbi8vIEhFTFBFUlNcblxuLypcbmlmIG5leHREYXlUaHJlc2hvbGQgaXMgc3BlY2lmaWVkLCBzbGljaW5nIGlzIGRvbmUgaW4gYW4gYWxsLWRheSBmYXNoaW9uLlxueW91IGNhbiBnZXQgbmV4dERheVRocmVzaG9sZCBmcm9tIGNvbnRleHQubmV4dERheVRocmVzaG9sZFxuKi9cbmV4cG9ydCBmdW5jdGlvbiBzbGljZUV2ZW50cyhwcm9wczogVmlld1Byb3BzICYgeyBkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQ6IER1cmF0aW9uIH0sIGFsbERheT86IGJvb2xlYW4pOiBFdmVudFJlbmRlclJhbmdlW10ge1xuICByZXR1cm4gc2xpY2VFdmVudFN0b3JlKFxuICAgIHByb3BzLmV2ZW50U3RvcmUsXG4gICAgcHJvcHMuZXZlbnRVaUJhc2VzLFxuICAgIHByb3BzLmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLFxuICAgIGFsbERheSA/IHByb3BzLm5leHREYXlUaHJlc2hvbGQgOiBudWxsXG4gICkuZmdcbn1cbiIsIlxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIE5hbWVkVGltZVpvbmVJbXBsIHtcblxuICB0aW1lWm9uZU5hbWU6IHN0cmluZ1xuXG4gIGNvbnN0cnVjdG9yKHRpbWVab25lTmFtZTogc3RyaW5nKSB7XG4gICAgdGhpcy50aW1lWm9uZU5hbWUgPSB0aW1lWm9uZU5hbWVcbiAgfVxuXG4gIGFic3RyYWN0IG9mZnNldEZvckFycmF5KGE6IG51bWJlcltdKTogbnVtYmVyXG4gIGFic3RyYWN0IHRpbWVzdGFtcFRvQXJyYXkobXM6IG51bWJlcik6IG51bWJlcltdXG59XG5cbmV4cG9ydCB0eXBlIE5hbWVkVGltZVpvbmVJbXBsQ2xhc3MgPSB7IG5ldyh0aW1lWm9uZU5hbWU6IHN0cmluZyk6IE5hbWVkVGltZVpvbmVJbXBsIH1cbiIsImltcG9ydCB7IERhdGVDb21wb25lbnQgfSBmcm9tICcuLi9jb21wb25lbnQvRGF0ZUNvbXBvbmVudCdcblxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSW50ZXJhY3Rpb24ge1xuXG4gIGNvbXBvbmVudDogRGF0ZUNvbXBvbmVudDxhbnk+XG5cbiAgY29uc3RydWN0b3Ioc2V0dGluZ3M6IEludGVyYWN0aW9uU2V0dGluZ3MpIHtcbiAgICB0aGlzLmNvbXBvbmVudCA9IHNldHRpbmdzLmNvbXBvbmVudFxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgfVxuXG59XG5cbmV4cG9ydCB0eXBlIEludGVyYWN0aW9uQ2xhc3MgPSB7IG5ldyhzZXR0aW5nczogSW50ZXJhY3Rpb25TZXR0aW5ncyk6IEludGVyYWN0aW9uIH1cblxuXG5leHBvcnQgaW50ZXJmYWNlIEludGVyYWN0aW9uU2V0dGluZ3NJbnB1dCB7XG4gIGVsOiBIVE1MRWxlbWVudFxuICB1c2VFdmVudENlbnRlcj86IGJvb2xlYW5cbiAgLy8gVE9ETzogYWRkIGxhcmdlVW5pdFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEludGVyYWN0aW9uU2V0dGluZ3Mge1xuICBjb21wb25lbnQ6IERhdGVDb21wb25lbnQ8YW55PlxuICBlbDogSFRNTEVsZW1lbnRcbiAgdXNlRXZlbnRDZW50ZXI6IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgSW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlID0geyBbY29tcG9uZW5VaWQ6IHN0cmluZ106IEludGVyYWN0aW9uU2V0dGluZ3MgfVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJbnRlcmFjdGlvblNldHRpbmdzKGNvbXBvbmVudDogRGF0ZUNvbXBvbmVudDxhbnk+LCBpbnB1dDogSW50ZXJhY3Rpb25TZXR0aW5nc0lucHV0KTogSW50ZXJhY3Rpb25TZXR0aW5ncyB7XG4gIHJldHVybiB7XG4gICAgY29tcG9uZW50OiBjb21wb25lbnQsXG4gICAgZWw6IGlucHV0LmVsLFxuICAgIHVzZUV2ZW50Q2VudGVyOiBpbnB1dC51c2VFdmVudENlbnRlciAhPSBudWxsID8gaW5wdXQudXNlRXZlbnRDZW50ZXIgOiB0cnVlXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlKHNldHRpbmdzOiBJbnRlcmFjdGlvblNldHRpbmdzKSB7XG4gIHJldHVybiB7XG4gICAgW3NldHRpbmdzLmNvbXBvbmVudC51aWRdOiBzZXR0aW5nc1xuICB9XG59XG5cblxuXG4vLyBnbG9iYWwgc3RhdGVcbmV4cG9ydCBsZXQgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlOiBJbnRlcmFjdGlvblNldHRpbmdzU3RvcmUgPSB7fVxuIiwiaW1wb3J0IHsgRW1pdHRlciB9IGZyb20gJy4uL2NvbW1vbi9FbWl0dGVyJ1xuXG4vKlxuQW4gYWJzdHJhY3Rpb24gZm9yIGEgZHJhZ2dpbmcgaW50ZXJhY3Rpb24gb3JpZ2luYXRpbmcgb24gYW4gZXZlbnQuXG5Eb2VzIGhpZ2hlci1sZXZlbCB0aGluZ3MgdGhhbiBQb2ludGVyRHJhZ2dlciwgc3VjaCBhcyBwb3NzaWJseTpcbi0gYSBcIm1pcnJvclwiIHRoYXQgbW92ZXMgd2l0aCB0aGUgcG9pbnRlclxuLSBhIG1pbmltdW0gbnVtYmVyIG9mIHBpeGVscyBvciBvdGhlciBjcml0ZXJpYSBmb3IgYSB0cnVlIGRyYWcgdG8gYmVnaW5cblxuc3ViY2xhc3NlcyBtdXN0IGVtaXQ6XG4tIHBvaW50ZXJkb3duXG4tIGRyYWdzdGFydFxuLSBkcmFnbW92ZVxuLSBwb2ludGVydXBcbi0gZHJhZ2VuZFxuKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBFbGVtZW50RHJhZ2dpbmcgeyAvLyBUT0RPOiByZW5hbWUgdG8gKkludGVyZmFjZT9cblxuICBlbWl0dGVyOiBFbWl0dGVyPGFueT5cblxuXG4gIGNvbnN0cnVjdG9yKGVsOiBIVE1MRWxlbWVudCwgc2VsZWN0b3I/OiBzdHJpbmcpIHtcbiAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpXG4gIH1cblxuICBkZXN0cm95KCkge1xuICB9XG5cbiAgLy8gaWYgZ2l2ZW4gdHJ1ZSwgc2hvdWxkIHByZXZlbnQgZHJhZ3N0YXJ0K2RyYWdtb3ZlK2RyYWdlbmQgZnJvbSBmaXJpbmdcbiAgYWJzdHJhY3Qgc2V0SWdub3JlTW92ZShib29sOiBib29sZWFuKTogdm9pZFxuXG4gIHNldE1pcnJvcklzVmlzaWJsZShib29sOiBib29sZWFuKSB7XG4gICAgLy8gb3B0aW9uYWwgaWYgc3ViY2xhc3MgZG9lc24ndCB3YW50IHRvIHN1cHBvcnQgYSBtaXJyb3JcbiAgfVxuXG4gIHNldE1pcnJvck5lZWRzUmV2ZXJ0KGJvb2w6IGJvb2xlYW4pIHtcbiAgICAvLyBvcHRpb25hbCBpZiBzdWJjbGFzcyBkb2Vzbid0IHdhbnQgdG8gc3VwcG9ydCBhIG1pcnJvclxuICB9XG5cbiAgc2V0QXV0b1Njcm9sbEVuYWJsZWQoYm9vbDogYm9vbGVhbikge1xuICAgIC8vIG9wdGlvbmFsXG4gIH1cblxufVxuXG5leHBvcnQgdHlwZSBFbGVtZW50RHJhZ2dpbmdDbGFzcyA9IHsgbmV3KGVsOiBIVE1MRWxlbWVudCwgc2VsZWN0b3I/OiBzdHJpbmcpOiBFbGVtZW50RHJhZ2dpbmcgfVxuIiwiXG4vLyBUT0RPOiBnZXQgcmlkIG9mIHRoaXMgaW4gZmF2b3Igb2Ygb3B0aW9ucyBzeXN0ZW0sXG4vLyB0aG8gaXQncyByZWFsbHkgZWFzeSB0byBhY2Nlc3MgdGhpcyBnbG9iYWxseSByYXRoZXIgdGhhbiBwYXNzIHRocnUgb3B0aW9ucy5cbmV4cG9ydCBjb25zdCBjb25maWcgPSB7fSBhcyBhbnlcbiIsImltcG9ydCB7IGNyZWF0ZUR1cmF0aW9uLCBEdXJhdGlvbiB9IGZyb20gJy4uL2RhdGVsaWIvZHVyYXRpb24nXG5pbXBvcnQgeyByZWZpbmVQcm9wcywgUmF3T3B0aW9uc0Zyb21SZWZpbmVycywgRGljdGlvbmFyeSB9IGZyb20gJy4uL29wdGlvbnMnXG5cbi8qXG5JbmZvcm1hdGlvbiBhYm91dCB3aGF0IHdpbGwgaGFwcGVuIHdoZW4gYW4gZXh0ZXJuYWwgZWxlbWVudCBpcyBkcmFnZ2VkLWFuZC1kcm9wcGVkXG5vbnRvIGEgY2FsZW5kYXIuIENvbnRhaW5zIGluZm9ybWF0aW9uIGZvciBjcmVhdGluZyBhbiBldmVudC5cbiovXG5cbmNvbnN0IERSQUdfTUVUQV9SRUZJTkVSUyA9IHtcbiAgc3RhcnRUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgZHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICBjcmVhdGU6IEJvb2xlYW4sXG4gIHNvdXJjZUlkOiBTdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgRHJhZ01ldGFJbnB1dCA9XG4gIFJhd09wdGlvbnNGcm9tUmVmaW5lcnM8dHlwZW9mIERSQUdfTUVUQV9SRUZJTkVSUz4gJlxuICB7IFtvdGhlclByb3A6IHN0cmluZ106IGFueSB9IC8vIGZvciBsZWZ0b3ZlclByb3BzXG5cbmV4cG9ydCBpbnRlcmZhY2UgRHJhZ01ldGEge1xuICBzdGFydFRpbWU6IER1cmF0aW9uIHwgbnVsbFxuICBkdXJhdGlvbjogRHVyYXRpb24gfCBudWxsXG4gIGNyZWF0ZTogYm9vbGVhbiAvLyBjcmVhdGUgYW4gZXZlbnQgd2hlbiBkcm9wcGVkP1xuICBzb3VyY2VJZDogc3RyaW5nIC8vIHNpbWlsYXIgdG8gYWRkRXZlbnQncyBwYXJhbWV0ZXJcbiAgbGVmdG92ZXJQcm9wczogRGljdGlvbmFyeVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZURyYWdNZXRhKHJhdzogRHJhZ01ldGFJbnB1dCk6IERyYWdNZXRhIHtcbiAgbGV0IHsgcmVmaW5lZCwgZXh0cmEgfSA9IHJlZmluZVByb3BzKHJhdywgRFJBR19NRVRBX1JFRklORVJTKVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnRUaW1lOiByZWZpbmVkLnN0YXJ0VGltZSB8fCBudWxsLFxuICAgIGR1cmF0aW9uOiByZWZpbmVkLmR1cmF0aW9uIHx8IG51bGwsXG4gICAgY3JlYXRlOiByZWZpbmVkLmNyZWF0ZSAhPSBudWxsID8gcmVmaW5lZC5jcmVhdGUgOiB0cnVlLFxuICAgIHNvdXJjZUlkOiByZWZpbmVkLnNvdXJjZUlkLFxuICAgIGxlZnRvdmVyUHJvcHM6IGV4dHJhXG4gIH1cbn1cbiIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIFZOb2RlIH0gZnJvbSAnLi92ZG9tJ1xuaW1wb3J0IHsgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4vdmRvbS11dGlsJ1xuaW1wb3J0IHsgVG9vbGJhck1vZGVsLCBUb29sYmFyV2lkZ2V0IH0gZnJvbSAnLi90b29sYmFyLXN0cnVjdCdcblxuXG5leHBvcnQgaW50ZXJmYWNlIFRvb2xiYXJQcm9wcyBleHRlbmRzIFRvb2xiYXJDb250ZW50IHtcbiAgZXh0cmFDbGFzc05hbWU6IHN0cmluZyAvLyB3aXNoIHRoaXMgY291bGQgYmUgYXJyYXksIGJ1dCBlYXNpZXIgZm9yIHB1cmVuZXNzXG4gIG1vZGVsOiBUb29sYmFyTW9kZWxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUb29sYmFyQ29udGVudCB7XG4gIHRpdGxlOiBzdHJpbmdcbiAgYWN0aXZlQnV0dG9uOiBzdHJpbmdcbiAgaXNUb2RheUVuYWJsZWQ6IGJvb2xlYW5cbiAgaXNQcmV2RW5hYmxlZDogYm9vbGVhblxuICBpc05leHRFbmFibGVkOiBib29sZWFuXG59XG5cblxuZXhwb3J0IGNsYXNzIFRvb2xiYXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50PFRvb2xiYXJQcm9wcz4ge1xuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBtb2RlbCwgZXh0cmFDbGFzc05hbWUgfSA9IHRoaXMucHJvcHNcbiAgICBsZXQgZm9yY2VMdHIgPSBmYWxzZVxuICAgIGxldCBzdGFydENvbnRlbnQsIGVuZENvbnRlbnRcbiAgICBsZXQgY2VudGVyQ29udGVudCA9IG1vZGVsLmNlbnRlclxuXG4gICAgaWYgKG1vZGVsLmxlZnQpIHtcbiAgICAgIGZvcmNlTHRyID0gdHJ1ZVxuICAgICAgc3RhcnRDb250ZW50ID0gbW9kZWwubGVmdFxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydENvbnRlbnQgPSBtb2RlbC5zdGFydFxuICAgIH1cblxuICAgIGlmIChtb2RlbC5yaWdodCkge1xuICAgICAgZm9yY2VMdHIgPSB0cnVlXG4gICAgICBlbmRDb250ZW50ID0gbW9kZWwucmlnaHRcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kQ29udGVudCA9IG1vZGVsLmVuZFxuICAgIH1cblxuICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgZXh0cmFDbGFzc05hbWUgfHwgJycsXG4gICAgICAnZmMtdG9vbGJhcicsXG4gICAgICBmb3JjZUx0ciA/ICdmYy10b29sYmFyLWx0cicgOiAnJ1xuICAgIF1cblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lcy5qb2luKCcgJyl9PlxuICAgICAgICB7dGhpcy5yZW5kZXJTZWN0aW9uKCdzdGFydCcsIHN0YXJ0Q29udGVudCB8fCBbXSl9XG4gICAgICAgIHt0aGlzLnJlbmRlclNlY3Rpb24oJ2NlbnRlcicsIGNlbnRlckNvbnRlbnQgfHwgW10pfVxuICAgICAgICB7dGhpcy5yZW5kZXJTZWN0aW9uKCdlbmQnLCBlbmRDb250ZW50IHx8IFtdKX1cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxuXG5cbiAgcmVuZGVyU2VjdGlvbihrZXk6IHN0cmluZywgd2lkZ2V0R3JvdXBzOiBUb29sYmFyV2lkZ2V0W11bXSkge1xuICAgIGxldCB7IHByb3BzIH0gPSB0aGlzXG5cbiAgICByZXR1cm4gKFxuICAgICAgPFRvb2xiYXJTZWN0aW9uXG4gICAgICAgIGtleT17a2V5fVxuICAgICAgICB3aWRnZXRHcm91cHM9e3dpZGdldEdyb3Vwc31cbiAgICAgICAgdGl0bGU9e3Byb3BzLnRpdGxlfVxuICAgICAgICBhY3RpdmVCdXR0b249e3Byb3BzLmFjdGl2ZUJ1dHRvbn1cbiAgICAgICAgaXNUb2RheUVuYWJsZWQ9e3Byb3BzLmlzVG9kYXlFbmFibGVkfVxuICAgICAgICBpc1ByZXZFbmFibGVkPXtwcm9wcy5pc1ByZXZFbmFibGVkfVxuICAgICAgICBpc05leHRFbmFibGVkPXtwcm9wcy5pc05leHRFbmFibGVkfVxuICAgICAgLz5cbiAgICApXG4gIH1cblxufVxuXG5cbmludGVyZmFjZSBUb29sYmFyU2VjdGlvblByb3BzIGV4dGVuZHMgVG9vbGJhckNvbnRlbnQge1xuICB3aWRnZXRHcm91cHM6IFRvb2xiYXJXaWRnZXRbXVtdXG59XG5cbmNsYXNzIFRvb2xiYXJTZWN0aW9uIGV4dGVuZHMgQmFzZUNvbXBvbmVudDxUb29sYmFyU2VjdGlvblByb3BzPiB7XG5cbiAgcmVuZGVyKCkge1xuICAgIGxldCBjaGlsZHJlbiA9IHRoaXMucHJvcHMud2lkZ2V0R3JvdXBzLm1hcCgod2lkZ2V0R3JvdXApID0+IHRoaXMucmVuZGVyV2lkZ2V0R3JvdXAod2lkZ2V0R3JvdXApKVxuXG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHsgY2xhc3NOYW1lOiAnZmMtdG9vbGJhci1jaHVuaycgfSwgLi4uY2hpbGRyZW4pXG4gIH1cblxuXG4gIHJlbmRlcldpZGdldEdyb3VwKHdpZGdldEdyb3VwOiBUb29sYmFyV2lkZ2V0W10pIHtcbiAgICBsZXQgeyBwcm9wcyB9ID0gdGhpc1xuICAgIGxldCB7IHRoZW1lIH0gPSB0aGlzLmNvbnRleHRcbiAgICBsZXQgY2hpbGRyZW46IFZOb2RlW10gPSBbXVxuICAgIGxldCBpc09ubHlCdXR0b25zID0gdHJ1ZVxuXG4gICAgZm9yIChsZXQgd2lkZ2V0IG9mIHdpZGdldEdyb3VwKSB7XG4gICAgICBsZXQgeyBidXR0b25OYW1lLCBidXR0b25DbGljaywgYnV0dG9uVGV4dCwgYnV0dG9uSWNvbiB9ID0gd2lkZ2V0XG5cbiAgICAgIGlmIChidXR0b25OYW1lID09PSAndGl0bGUnKSB7XG4gICAgICAgIGlzT25seUJ1dHRvbnMgPSBmYWxzZVxuICAgICAgICBjaGlsZHJlbi5wdXNoKFxuICAgICAgICAgIDxoMiBjbGFzc05hbWU9J2ZjLXRvb2xiYXItdGl0bGUnPntwcm9wcy50aXRsZX08L2gyPlxuICAgICAgICApXG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBhcmlhQXR0cnMgPSBidXR0b25JY29uID8geyAnYXJpYS1sYWJlbCc6IGJ1dHRvbk5hbWUgfSA6IHt9XG5cbiAgICAgICAgbGV0IGJ1dHRvbkNsYXNzZXMgPSBbICdmYy0nICsgYnV0dG9uTmFtZSArICctYnV0dG9uJywgdGhlbWUuZ2V0Q2xhc3MoJ2J1dHRvbicpIF1cbiAgICAgICAgaWYgKGJ1dHRvbk5hbWUgPT09IHByb3BzLmFjdGl2ZUJ1dHRvbikge1xuICAgICAgICAgIGJ1dHRvbkNsYXNzZXMucHVzaCh0aGVtZS5nZXRDbGFzcygnYnV0dG9uQWN0aXZlJykpXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaXNEaXNhYmxlZCA9XG4gICAgICAgICAgKCFwcm9wcy5pc1RvZGF5RW5hYmxlZCAmJiBidXR0b25OYW1lID09PSAndG9kYXknKSB8fFxuICAgICAgICAgICghcHJvcHMuaXNQcmV2RW5hYmxlZCAmJiBidXR0b25OYW1lID09PSAncHJldicpIHx8XG4gICAgICAgICAgKCFwcm9wcy5pc05leHRFbmFibGVkICYmIGJ1dHRvbk5hbWUgPT09ICduZXh0JylcblxuICAgICAgICBjaGlsZHJlbi5wdXNoKFxuICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIGRpc2FibGVkPXtpc0Rpc2FibGVkfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtidXR0b25DbGFzc2VzLmpvaW4oJyAnKX1cbiAgICAgICAgICAgIG9uQ2xpY2s9e2J1dHRvbkNsaWNrfVxuICAgICAgICAgICAgeyAuLi5hcmlhQXR0cnMgfVxuICAgICAgICAgID57IGJ1dHRvblRleHQgfHwgKGJ1dHRvbkljb24gPyA8c3BhbiBjbGFzc05hbWU9e2J1dHRvbkljb259IC8+IDogJycpfTwvYnV0dG9uPlxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIGxldCBncm91cENsYXNzTmFtZSA9IChpc09ubHlCdXR0b25zICYmIHRoZW1lLmdldENsYXNzKCdidXR0b25Hcm91cCcpKSB8fCAnJ1xuXG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnZGl2JywgeyBjbGFzc05hbWU6IGdyb3VwQ2xhc3NOYW1lIH0sIC4uLmNoaWxkcmVuKVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjaGlsZHJlblswXVxuICAgIH1cbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi92ZG9tLXV0aWwnXG5pbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgUmVmLCBjcmVhdGVFbGVtZW50LCBWVUlFdmVudCB9IGZyb20gJy4vdmRvbSdcbmltcG9ydCB7IENzc0RpbVZhbHVlIH0gZnJvbSAnLi9zY3JvbGxncmlkL3V0aWwnXG5cblxuZXhwb3J0IGludGVyZmFjZSBWaWV3Q29udGFpbmVyUHJvcHMge1xuICBsaXF1aWQ/OiBib29sZWFuXG4gIGhlaWdodD86IENzc0RpbVZhbHVlXG4gIGFzcGVjdFJhdGlvPzogbnVtYmVyXG4gIG9uQ2xpY2s/OiAoZXY6IFZVSUV2ZW50KSA9PiB2b2lkXG4gIGVsUmVmPzogUmVmPEhUTUxEaXZFbGVtZW50PlxuICBjaGlsZHJlbj86IENvbXBvbmVudENoaWxkcmVuXG59XG5cblxuLy8gVE9ETzogZG8gZnVuY3Rpb24gY29tcG9uZW50P1xuZXhwb3J0IGNsYXNzIFZpZXdDb250YWluZXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50PFZpZXdDb250YWluZXJQcm9wcz4ge1xuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBwcm9wcyB9ID0gdGhpc1xuICAgIGxldCB7IGFzcGVjdFJhdGlvIH0gPSBwcm9wc1xuXG4gICAgbGV0IGNsYXNzTmFtZXMgPSBbXG4gICAgICAnZmMtdmlldy1oYXJuZXNzJyxcbiAgICAgIChhc3BlY3RSYXRpbyB8fCBwcm9wcy5saXF1aWQgfHwgcHJvcHMuaGVpZ2h0KVxuICAgICAgICA/ICdmYy12aWV3LWhhcm5lc3MtYWN0aXZlJyAvLyBoYXJuZXNzIGNvbnRyb2xzIHRoZSBoZWlnaHRcbiAgICAgICAgOiAnZmMtdmlldy1oYXJuZXNzLXBhc3NpdmUnIC8vIGxldCB0aGUgdmlldyBkbyB0aGUgaGVpZ2h0XG4gICAgXVxuICAgIGxldCBoZWlnaHQ6IENzc0RpbVZhbHVlID0gJydcbiAgICBsZXQgcGFkZGluZ0JvdHRvbTogQ3NzRGltVmFsdWUgPSAnJ1xuXG4gICAgaWYgKGFzcGVjdFJhdGlvKSB7XG4gICAgICBwYWRkaW5nQm90dG9tID0gKDEgLyBhc3BlY3RSYXRpbykgKiAxMDAgKyAnJSdcbiAgICB9IGVsc2Uge1xuICAgICAgaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0IHx8ICcnXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXZcbiAgICAgICAgcmVmPXtwcm9wcy5lbFJlZn1cbiAgICAgICAgb25DbGljaz17cHJvcHMub25DbGlja31cbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzLmpvaW4oJyAnKX0gc3R5bGU9e3sgaGVpZ2h0LCBwYWRkaW5nQm90dG9tIH19XG4gICAgICA+e3Byb3BzLmNoaWxkcmVufTwvZGl2PlxuICAgIClcbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBsaXN0ZW5CeVNlbGVjdG9yIH0gZnJvbSAnLi4vdXRpbC9kb20tZXZlbnQnXG5pbXBvcnQgeyBFdmVudEFwaSB9IGZyb20gJy4uL2FwaS9FdmVudEFwaSdcbmltcG9ydCB7IGVsZW1lbnRDbG9zZXN0IH0gZnJvbSAnLi4vdXRpbC9kb20tbWFuaXAnXG5pbXBvcnQgeyBnZXRFbFNlZyB9IGZyb20gJy4uL2NvbXBvbmVudC9ldmVudC1yZW5kZXJpbmcnXG5pbXBvcnQgeyBJbnRlcmFjdGlvbiwgSW50ZXJhY3Rpb25TZXR0aW5ncyB9IGZyb20gJy4vaW50ZXJhY3Rpb24nXG5pbXBvcnQgeyBWaWV3QXBpIH0gZnJvbSAnLi4vVmlld0FwaSdcblxuZXhwb3J0IGludGVyZmFjZSBFdmVudENsaWNrQXJnIHtcbiAgZWw6IEhUTUxFbGVtZW50XG4gIGV2ZW50OiBFdmVudEFwaVxuICBqc0V2ZW50OiBNb3VzZUV2ZW50XG4gIHZpZXc6IFZpZXdBcGlcbn1cblxuLypcbkRldGVjdHMgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gYW4gZXZlbnQgd2l0aGluIGEgRGF0ZUNvbXBvbmVudFxuKi9cbmV4cG9ydCBjbGFzcyBFdmVudENsaWNraW5nIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xuXG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzOiBJbnRlcmFjdGlvblNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpXG5cbiAgICB0aGlzLmRlc3Ryb3kgPSBsaXN0ZW5CeVNlbGVjdG9yKFxuICAgICAgc2V0dGluZ3MuZWwsXG4gICAgICAnY2xpY2snLFxuICAgICAgJy5mYy1ldmVudCcsIC8vIG9uIGJvdGggZmcgYW5kIGJnIGV2ZW50c1xuICAgICAgdGhpcy5oYW5kbGVTZWdDbGlja1xuICAgIClcbiAgfVxuXG4gIGhhbmRsZVNlZ0NsaWNrID0gKGV2OiBFdmVudCwgc2VnRWw6IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgbGV0IHsgY29tcG9uZW50IH0gPSB0aGlzXG4gICAgbGV0IHsgY29udGV4dCB9ID0gY29tcG9uZW50XG4gICAgbGV0IHNlZyA9IGdldEVsU2VnKHNlZ0VsKVxuXG4gICAgaWYgKFxuICAgICAgc2VnICYmIC8vIG1pZ2h0IGJlIHRoZSA8ZGl2PiBzdXJyb3VuZGluZyB0aGUgbW9yZSBsaW5rXG4gICAgICBjb21wb25lbnQuaXNWYWxpZFNlZ0Rvd25FbChldi50YXJnZXQgYXMgSFRNTEVsZW1lbnQpXG4gICAgKSB7XG5cbiAgICAgIC8vIG91ciB3YXkgdG8gc2ltdWxhdGUgYSBsaW5rIGNsaWNrIGZvciBlbGVtZW50cyB0aGF0IGNhbid0IGJlIDxhPiB0YWdzXG4gICAgICAvLyBncmFiIGJlZm9yZSB0cmlnZ2VyIGZpcmVkIGluIGNhc2UgdHJpZ2dlciB0cmFzaGVzIERPTSB0aHJ1IHJlcmVuZGVyaW5nXG4gICAgICBsZXQgaGFzVXJsQ29udGFpbmVyID0gZWxlbWVudENsb3Nlc3QoZXYudGFyZ2V0IGFzIEhUTUxFbGVtZW50LCAnLmZjLWV2ZW50LWZvcmNlZC11cmwnKVxuICAgICAgbGV0IHVybCA9IGhhc1VybENvbnRhaW5lciA/IChoYXNVcmxDb250YWluZXIucXVlcnlTZWxlY3RvcignYVtocmVmXScpIGFzIGFueSkuaHJlZiA6ICcnXG5cbiAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudENsaWNrJywge1xuICAgICAgICBlbDogc2VnRWwsXG4gICAgICAgIGV2ZW50OiBuZXcgRXZlbnRBcGkoXG4gICAgICAgICAgY29tcG9uZW50LmNvbnRleHQsXG4gICAgICAgICAgc2VnLmV2ZW50UmFuZ2UuZGVmLFxuICAgICAgICAgIHNlZy5ldmVudFJhbmdlLmluc3RhbmNlXG4gICAgICAgICksXG4gICAgICAgIGpzRXZlbnQ6IGV2IGFzIE1vdXNlRXZlbnQsIC8vIElzIHRoaXMgYWx3YXlzIGEgbW91c2UgZXZlbnQ/IFNlZSAjNDY1NVxuICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGlcbiAgICAgIH0gYXMgRXZlbnRDbGlja0FyZylcblxuICAgICAgaWYgKHVybCAmJiAhZXYuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBsaXN0ZW5Ub0hvdmVyQnlTZWxlY3RvciB9IGZyb20gJy4uL3V0aWwvZG9tLWV2ZW50J1xuaW1wb3J0IHsgRXZlbnRBcGkgfSBmcm9tICcuLi9hcGkvRXZlbnRBcGknXG5pbXBvcnQgeyBnZXRFbFNlZyB9IGZyb20gJy4uL2NvbXBvbmVudC9ldmVudC1yZW5kZXJpbmcnXG5pbXBvcnQgeyBJbnRlcmFjdGlvbiwgSW50ZXJhY3Rpb25TZXR0aW5ncyB9IGZyb20gJy4vaW50ZXJhY3Rpb24nXG5pbXBvcnQgeyBWaWV3QXBpIH0gZnJvbSAnLi4vVmlld0FwaSdcblxuZXhwb3J0IGludGVyZmFjZSBFdmVudEhvdmVyaW5nQXJnIHtcbiAgZWw6IEhUTUxFbGVtZW50XG4gIGV2ZW50OiBFdmVudEFwaVxuICBqc0V2ZW50OiBNb3VzZUV2ZW50XG4gIHZpZXc6IFZpZXdBcGlcbn1cblxuLypcblRyaWdnZXJzIGV2ZW50cyBhbmQgYWRkcy9yZW1vdmVzIGNvcmUgY2xhc3NOYW1lcyB3aGVuIHRoZSB1c2VyJ3MgcG9pbnRlclxuZW50ZXJzL2xlYXZlcyBldmVudC1lbGVtZW50cyBvZiBhIGNvbXBvbmVudC5cbiovXG5leHBvcnQgY2xhc3MgRXZlbnRIb3ZlcmluZyBleHRlbmRzIEludGVyYWN0aW9uIHtcblxuICByZW1vdmVIb3Zlckxpc3RlbmVyczogKCkgPT4gdm9pZFxuICBjdXJyZW50U2VnRWw6IEhUTUxFbGVtZW50XG5cbiAgY29uc3RydWN0b3Ioc2V0dGluZ3M6IEludGVyYWN0aW9uU2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncylcblxuICAgIHRoaXMucmVtb3ZlSG92ZXJMaXN0ZW5lcnMgPSBsaXN0ZW5Ub0hvdmVyQnlTZWxlY3RvcihcbiAgICAgIHNldHRpbmdzLmVsLFxuICAgICAgJy5mYy1ldmVudCcsIC8vIG9uIGJvdGggZmcgYW5kIGJnIGV2ZW50c1xuICAgICAgdGhpcy5oYW5kbGVTZWdFbnRlcixcbiAgICAgIHRoaXMuaGFuZGxlU2VnTGVhdmVcbiAgICApXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVtb3ZlSG92ZXJMaXN0ZW5lcnMoKVxuICB9XG5cbiAgLy8gZm9yIHNpbXVsYXRpbmcgYW4gZXZlbnRNb3VzZUxlYXZlIHdoZW4gdGhlIGV2ZW50IGVsIGlzIGRlc3Ryb3llZCB3aGlsZSBtb3VzZSBpcyBvdmVyIGl0XG4gIGhhbmRsZUV2ZW50RWxSZW1vdmUgPSAoZWw6IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgaWYgKGVsID09PSB0aGlzLmN1cnJlbnRTZWdFbCkge1xuICAgICAgdGhpcy5oYW5kbGVTZWdMZWF2ZShudWxsLCB0aGlzLmN1cnJlbnRTZWdFbClcbiAgICB9XG4gIH1cblxuICBoYW5kbGVTZWdFbnRlciA9IChldjogRXZlbnQsIHNlZ0VsOiBIVE1MRWxlbWVudCkgPT4ge1xuICAgIGlmIChnZXRFbFNlZyhzZWdFbCkpIHsgLy8gVE9ETzogYmV0dGVyIHdheSB0byBtYWtlIHN1cmUgbm90IGhvdmVyaW5nIG92ZXIgbW9yZSsgbGluayBvciBpdHMgd3JhcHBlclxuICAgICAgdGhpcy5jdXJyZW50U2VnRWwgPSBzZWdFbFxuICAgICAgdGhpcy50cmlnZ2VyRXZlbnQoJ2V2ZW50TW91c2VFbnRlcicsIGV2LCBzZWdFbClcbiAgICB9XG4gIH1cblxuICBoYW5kbGVTZWdMZWF2ZSA9IChldjogRXZlbnQgfCBudWxsLCBzZWdFbDogSFRNTEVsZW1lbnQpID0+IHtcbiAgICBpZiAodGhpcy5jdXJyZW50U2VnRWwpIHtcbiAgICAgIHRoaXMuY3VycmVudFNlZ0VsID0gbnVsbFxuICAgICAgdGhpcy50cmlnZ2VyRXZlbnQoJ2V2ZW50TW91c2VMZWF2ZScsIGV2LCBzZWdFbClcbiAgICB9XG4gIH1cblxuICB0cmlnZ2VyRXZlbnQocHVibGljRXZOYW1lOiAnZXZlbnRNb3VzZUVudGVyJyB8ICdldmVudE1vdXNlTGVhdmUnLCBldjogRXZlbnQgfCBudWxsLCBzZWdFbDogSFRNTEVsZW1lbnQpIHtcbiAgICBsZXQgeyBjb21wb25lbnQgfSA9IHRoaXNcbiAgICBsZXQgeyBjb250ZXh0IH0gPSBjb21wb25lbnRcbiAgICBsZXQgc2VnID0gZ2V0RWxTZWcoc2VnRWwpIVxuXG4gICAgaWYgKCFldiB8fCBjb21wb25lbnQuaXNWYWxpZFNlZ0Rvd25FbChldi50YXJnZXQgYXMgSFRNTEVsZW1lbnQpKSB7XG4gICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcihwdWJsaWNFdk5hbWUsIHtcbiAgICAgICAgZWw6IHNlZ0VsLFxuICAgICAgICBldmVudDogbmV3IEV2ZW50QXBpKFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgc2VnLmV2ZW50UmFuZ2UuZGVmLFxuICAgICAgICAgIHNlZy5ldmVudFJhbmdlLmluc3RhbmNlXG4gICAgICAgICksXG4gICAgICAgIGpzRXZlbnQ6IGV2IGFzIE1vdXNlRXZlbnQsIC8vIElzIHRoaXMgYWx3YXlzIGEgbW91c2UgZXZlbnQ/IFNlZSAjNDY1NVxuICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGlcbiAgICAgIH0gYXMgRXZlbnRIb3ZlcmluZ0FyZylcbiAgICB9XG4gIH1cblxufVxuIiwiaW1wb3J0IHsgVmlld0NvbnRleHRUeXBlLCBidWlsZFZpZXdDb250ZXh0IH0gZnJvbSAnLi9WaWV3Q29udGV4dCdcbmltcG9ydCB7IFZpZXdTcGVjIH0gZnJvbSAnLi9zdHJ1Y3RzL3ZpZXctc3BlYydcbmltcG9ydCB7IFZpZXdQcm9wcyB9IGZyb20gJy4vVmlldydcbmltcG9ydCB7IFRvb2xiYXIgfSBmcm9tICcuL1Rvb2xiYXInXG5pbXBvcnQgeyBEYXRlUHJvZmlsZUdlbmVyYXRvciwgRGF0ZVByb2ZpbGUgfSBmcm9tICcuL0RhdGVQcm9maWxlR2VuZXJhdG9yJ1xuaW1wb3J0IHsgcmFuZ2VDb250YWluc01hcmtlciB9IGZyb20gJy4vZGF0ZWxpYi9kYXRlLXJhbmdlJ1xuaW1wb3J0IHsgbWVtb2l6ZSB9IGZyb20gJy4vdXRpbC9tZW1vaXplJ1xuaW1wb3J0IHsgRGF0ZU1hcmtlciB9IGZyb20gJy4vZGF0ZWxpYi9tYXJrZXInXG5pbXBvcnQgeyBDYWxlbmRhckRhdGEgfSBmcm9tICcuL3JlZHVjZXJzL2RhdGEtdHlwZXMnXG5pbXBvcnQgeyBWaWV3UHJvcHNUcmFuc2Zvcm1lckNsYXNzIH0gZnJvbSAnLi9wbHVnaW4tc3lzdGVtLXN0cnVjdCdcbmltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSAndHNsaWInXG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBjcmVhdGVSZWYsIFZVSUV2ZW50LCBGcmFnbWVudCB9IGZyb20gJy4vdmRvbSdcbmltcG9ydCB7IGJ1aWxkRGVsZWdhdGlvbkhhbmRsZXIgfSBmcm9tICcuL3V0aWwvZG9tLWV2ZW50J1xuaW1wb3J0IHsgVmlld0NvbnRhaW5lciB9IGZyb20gJy4vVmlld0NvbnRhaW5lcidcbmltcG9ydCB7IEludGVyYWN0aW9uLCBJbnRlcmFjdGlvblNldHRpbmdzSW5wdXQsIEludGVyYWN0aW9uQ2xhc3MsIHBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncywgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlIH0gZnJvbSAnLi9pbnRlcmFjdGlvbnMvaW50ZXJhY3Rpb24nXG5pbXBvcnQgeyBEYXRlQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnQvRGF0ZUNvbXBvbmVudCdcbmltcG9ydCB7IEV2ZW50Q2xpY2tpbmcgfSBmcm9tICcuL2ludGVyYWN0aW9ucy9FdmVudENsaWNraW5nJ1xuaW1wb3J0IHsgRXZlbnRIb3ZlcmluZyB9IGZyb20gJy4vaW50ZXJhY3Rpb25zL0V2ZW50SG92ZXJpbmcnXG5pbXBvcnQgeyBnZXROb3cgfSBmcm9tICcuL3JlZHVjZXJzL2N1cnJlbnQtZGF0ZSdcbmltcG9ydCB7IENhbGVuZGFySW50ZXJhY3Rpb24gfSBmcm9tICcuL2NhbGVuZGFyLXV0aWxzJ1xuaW1wb3J0IHsgRGVsYXllZFJ1bm5lciB9IGZyb20gJy4vdXRpbC9ydW5uZXInXG5pbXBvcnQgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAnLi92ZG9tLXV0aWwnXG5cblxuZXhwb3J0IGludGVyZmFjZSBDYWxlbmRhckNvbnRlbnRQcm9wcyBleHRlbmRzIENhbGVuZGFyRGF0YSB7XG4gIGZvclByaW50OiBib29sZWFuXG4gIGlzSGVpZ2h0QXV0bzogYm9vbGVhblxufVxuXG5cbmV4cG9ydCBjbGFzcyBDYWxlbmRhckNvbnRlbnQgZXh0ZW5kcyBQdXJlQ29tcG9uZW50PENhbGVuZGFyQ29udGVudFByb3BzPiB7XG5cbiAgY29udGV4dDogbmV2ZXJcblxuICBwcml2YXRlIGJ1aWxkVmlld0NvbnRleHQgPSBtZW1vaXplKGJ1aWxkVmlld0NvbnRleHQpXG4gIHByaXZhdGUgYnVpbGRWaWV3UHJvcFRyYW5zZm9ybWVycyA9IG1lbW9pemUoYnVpbGRWaWV3UHJvcFRyYW5zZm9ybWVycylcbiAgcHJpdmF0ZSBidWlsZFRvb2xiYXJQcm9wcyA9IG1lbW9pemUoYnVpbGRUb29sYmFyUHJvcHMpXG4gIHByaXZhdGUgaGFuZGxlTmF2TGlua0NsaWNrID0gYnVpbGREZWxlZ2F0aW9uSGFuZGxlcignYVtkYXRhLW5hdmxpbmtdJywgdGhpcy5faGFuZGxlTmF2TGlua0NsaWNrLmJpbmQodGhpcykpXG4gIHByaXZhdGUgaGVhZGVyUmVmID0gY3JlYXRlUmVmPFRvb2xiYXI+KClcbiAgcHJpdmF0ZSBmb290ZXJSZWYgPSBjcmVhdGVSZWY8VG9vbGJhcj4oKVxuICBwcml2YXRlIGludGVyYWN0aW9uc1N0b3JlOiB7IFtjb21wb25lbnRVaWQ6IHN0cmluZ106IEludGVyYWN0aW9uW10gfSA9IHt9XG4gIHByaXZhdGUgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IENhbGVuZGFySW50ZXJhY3Rpb25bXVxuXG5cbiAgLypcbiAgcmVuZGVycyBJTlNJREUgb2YgYW4gb3V0ZXIgZGl2XG4gICovXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBwcm9wcyB9ID0gdGhpc1xuICAgIGxldCB7IHRvb2xiYXJDb25maWcsIG9wdGlvbnMgfSA9IHByb3BzXG5cbiAgICBsZXQgdG9vbGJhclByb3BzID0gdGhpcy5idWlsZFRvb2xiYXJQcm9wcyhcbiAgICAgIHByb3BzLnZpZXdTcGVjLFxuICAgICAgcHJvcHMuZGF0ZVByb2ZpbGUsXG4gICAgICBwcm9wcy5kYXRlUHJvZmlsZUdlbmVyYXRvcixcbiAgICAgIHByb3BzLmN1cnJlbnREYXRlLFxuICAgICAgZ2V0Tm93KHByb3BzLm9wdGlvbnMubm93LCBwcm9wcy5kYXRlRW52KSwgLy8gVE9ETzogdXNlIE5vd1RpbWVyPz8/P1xuICAgICAgcHJvcHMudmlld1RpdGxlXG4gICAgKVxuXG4gICAgbGV0IHZpZXdWR3JvdyA9IGZhbHNlXG4gICAgbGV0IHZpZXdIZWlnaHQ6IHN0cmluZyB8IG51bWJlciA9ICcnXG4gICAgbGV0IHZpZXdBc3BlY3RSYXRpbzogbnVtYmVyIHwgdW5kZWZpbmVkXG5cbiAgICBpZiAocHJvcHMuaXNIZWlnaHRBdXRvIHx8IHByb3BzLmZvclByaW50KSB7XG4gICAgICB2aWV3SGVpZ2h0ID0gJydcblxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5oZWlnaHQgIT0gbnVsbCkge1xuICAgICAgdmlld1ZHcm93ID0gdHJ1ZVxuXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmNvbnRlbnRIZWlnaHQgIT0gbnVsbCkge1xuICAgICAgdmlld0hlaWdodCA9IG9wdGlvbnMuY29udGVudEhlaWdodFxuXG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZXdBc3BlY3RSYXRpbyA9IE1hdGgubWF4KG9wdGlvbnMuYXNwZWN0UmF0aW8sIDAuNSkgLy8gcHJldmVudCBmcm9tIGdldHRpbmcgdG9vIHRhbGxcbiAgICB9XG5cbiAgICBsZXQgdmlld0NvbnRleHQgPSB0aGlzLmJ1aWxkVmlld0NvbnRleHQoXG4gICAgICBwcm9wcy52aWV3U3BlYyxcbiAgICAgIHByb3BzLnZpZXdBcGksXG4gICAgICBwcm9wcy5vcHRpb25zLFxuICAgICAgcHJvcHMuZGF0ZVByb2ZpbGVHZW5lcmF0b3IsXG4gICAgICBwcm9wcy5kYXRlRW52LFxuICAgICAgcHJvcHMudGhlbWUsXG4gICAgICBwcm9wcy5wbHVnaW5Ib29rcyxcbiAgICAgIHByb3BzLmRpc3BhdGNoLFxuICAgICAgcHJvcHMuZ2V0Q3VycmVudERhdGEsXG4gICAgICBwcm9wcy5lbWl0dGVyLFxuICAgICAgcHJvcHMuY2FsZW5kYXJBcGksXG4gICAgICB0aGlzLnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQsXG4gICAgICB0aGlzLnVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudFxuICAgIClcblxuICAgIHJldHVybiAoXG4gICAgICA8Vmlld0NvbnRleHRUeXBlLlByb3ZpZGVyIHZhbHVlPXt2aWV3Q29udGV4dH0+XG4gICAgICAgIHt0b29sYmFyQ29uZmlnLmhlYWRlclRvb2xiYXIgJiZcbiAgICAgICAgICA8VG9vbGJhclxuICAgICAgICAgICAgcmVmPXt0aGlzLmhlYWRlclJlZn1cbiAgICAgICAgICAgIGV4dHJhQ2xhc3NOYW1lPSdmYy1oZWFkZXItdG9vbGJhcidcbiAgICAgICAgICAgIG1vZGVsPXt0b29sYmFyQ29uZmlnLmhlYWRlclRvb2xiYXJ9XG4gICAgICAgICAgICB7IC4uLnRvb2xiYXJQcm9wcyB9XG4gICAgICAgICAgLz5cbiAgICAgICAgfVxuICAgICAgICA8Vmlld0NvbnRhaW5lclxuICAgICAgICAgIGxpcXVpZD17dmlld1ZHcm93fVxuICAgICAgICAgIGhlaWdodD17dmlld0hlaWdodH1cbiAgICAgICAgICBhc3BlY3RSYXRpbz17dmlld0FzcGVjdFJhdGlvfVxuICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuaGFuZGxlTmF2TGlua0NsaWNrfVxuICAgICAgICA+XG4gICAgICAgICAge3RoaXMucmVuZGVyVmlldyhwcm9wcyl9XG4gICAgICAgICAge3RoaXMuYnVpbGRBcHBlbmRDb250ZW50KCl9XG4gICAgICAgIDwvVmlld0NvbnRhaW5lcj5cbiAgICAgICAge3Rvb2xiYXJDb25maWcuZm9vdGVyVG9vbGJhciAmJlxuICAgICAgICAgIDxUb29sYmFyXG4gICAgICAgICAgICByZWY9e3RoaXMuZm9vdGVyUmVmfVxuICAgICAgICAgICAgZXh0cmFDbGFzc05hbWU9J2ZjLWZvb3Rlci10b29sYmFyJ1xuICAgICAgICAgICAgbW9kZWw9e3Rvb2xiYXJDb25maWcuZm9vdGVyVG9vbGJhcn1cbiAgICAgICAgICAgIHsgLi4udG9vbGJhclByb3BzIH1cbiAgICAgICAgICAvPlxuICAgICAgICB9XG4gICAgICA8L1ZpZXdDb250ZXh0VHlwZS5Qcm92aWRlcj5cbiAgICApXG4gIH1cblxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGxldCB7IHByb3BzIH0gPSB0aGlzXG5cbiAgICB0aGlzLmNhbGVuZGFySW50ZXJhY3Rpb25zID0gcHJvcHMucGx1Z2luSG9va3MuY2FsZW5kYXJJbnRlcmFjdGlvbnNcbiAgICAgIC5tYXAoKGNhbGVuZGFySW50ZXJhY3Rpb25DbGFzcykgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IGNhbGVuZGFySW50ZXJhY3Rpb25DbGFzcyhwcm9wcylcbiAgICAgIH0pXG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5oYW5kbGVXaW5kb3dSZXNpemUpXG5cbiAgICBsZXQgcHJvcFNldEhhbmRsZXJzID0gcHJvcHMucGx1Z2luSG9va3MucHJvcFNldEhhbmRsZXJzXG4gICAgZm9yIChsZXQgcHJvcE5hbWUgaW4gcHJvcFNldEhhbmRsZXJzKSB7XG4gICAgICBwcm9wU2V0SGFuZGxlcnNbcHJvcE5hbWVdKHByb3BzW3Byb3BOYW1lXSwgcHJvcHMpXG4gICAgfVxuICB9XG5cblxuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzOiBDYWxlbmRhckNvbnRlbnRQcm9wcykge1xuICAgIGxldCB7IHByb3BzIH0gPSB0aGlzXG5cbiAgICBsZXQgcHJvcFNldEhhbmRsZXJzID0gcHJvcHMucGx1Z2luSG9va3MucHJvcFNldEhhbmRsZXJzXG4gICAgZm9yIChsZXQgcHJvcE5hbWUgaW4gcHJvcFNldEhhbmRsZXJzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdICE9PSBwcmV2UHJvcHNbcHJvcE5hbWVdKSB7XG4gICAgICAgIHByb3BTZXRIYW5kbGVyc1twcm9wTmFtZV0ocHJvcHNbcHJvcE5hbWVdLCBwcm9wcylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVdpbmRvd1Jlc2l6ZSlcbiAgICB0aGlzLnJlc2l6ZVJ1bm5lci5jbGVhcigpXG5cbiAgICBmb3IgKGxldCBpbnRlcmFjdGlvbiBvZiB0aGlzLmNhbGVuZGFySW50ZXJhY3Rpb25zKSB7XG4gICAgICBpbnRlcmFjdGlvbi5kZXN0cm95KClcbiAgICB9XG5cbiAgICB0aGlzLnByb3BzLmVtaXR0ZXIudHJpZ2dlcignX3VubW91bnQnKVxuICB9XG5cblxuICBfaGFuZGxlTmF2TGlua0NsaWNrKGV2OiBWVUlFdmVudCwgYW5jaG9yRWw6IEhUTUxFbGVtZW50KSB7XG4gICAgbGV0IHsgZGF0ZUVudiwgb3B0aW9ucywgY2FsZW5kYXJBcGkgfSA9IHRoaXMucHJvcHNcblxuICAgIGxldCBuYXZMaW5rT3B0aW9uczogYW55ID0gYW5jaG9yRWwuZ2V0QXR0cmlidXRlKCdkYXRhLW5hdmxpbmsnKVxuICAgIG5hdkxpbmtPcHRpb25zID0gbmF2TGlua09wdGlvbnMgPyBKU09OLnBhcnNlKG5hdkxpbmtPcHRpb25zKSA6IHt9XG5cbiAgICBsZXQgZGF0ZU1hcmtlciA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKG5hdkxpbmtPcHRpb25zLmRhdGUpXG4gICAgbGV0IHZpZXdUeXBlID0gbmF2TGlua09wdGlvbnMudHlwZVxuXG4gICAgbGV0IGN1c3RvbUFjdGlvbiA9XG4gICAgICB2aWV3VHlwZSA9PT0gJ2RheScgPyBvcHRpb25zLm5hdkxpbmtEYXlDbGljayA6XG4gICAgICB2aWV3VHlwZSA9PT0gJ3dlZWsnID8gb3B0aW9ucy5uYXZMaW5rV2Vla0NsaWNrIDogbnVsbFxuXG4gICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGN1c3RvbUFjdGlvbi5jYWxsKGNhbGVuZGFyQXBpLCBkYXRlRW52LnRvRGF0ZShkYXRlTWFya2VyKSwgZXYpXG5cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZpZXdUeXBlID0gY3VzdG9tQWN0aW9uXG4gICAgICB9XG5cbiAgICAgIGNhbGVuZGFyQXBpLnpvb21UbyhkYXRlTWFya2VyLCB2aWV3VHlwZSlcbiAgICB9XG4gIH1cblxuXG4gIGJ1aWxkQXBwZW5kQ29udGVudCgpIHtcbiAgICBsZXQgeyBwcm9wcyB9ID0gdGhpc1xuXG4gICAgbGV0IGNoaWxkcmVuID0gcHJvcHMucGx1Z2luSG9va3Mudmlld0NvbnRhaW5lckFwcGVuZHMubWFwKFxuICAgICAgKGJ1aWxkQXBwZW5kQ29udGVudCkgPT4gYnVpbGRBcHBlbmRDb250ZW50KHByb3BzKVxuICAgIClcblxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCB7fSwgLi4uY2hpbGRyZW4pXG4gIH1cblxuXG4gIHJlbmRlclZpZXcocHJvcHM6IENhbGVuZGFyQ29udGVudFByb3BzKSB7XG4gICAgbGV0IHsgcGx1Z2luSG9va3MgfSA9IHByb3BzXG4gICAgbGV0IHsgdmlld1NwZWMgfSA9IHByb3BzXG5cbiAgICBsZXQgdmlld1Byb3BzOiBWaWV3UHJvcHMgPSB7XG4gICAgICBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsXG4gICAgICBidXNpbmVzc0hvdXJzOiBwcm9wcy5idXNpbmVzc0hvdXJzLFxuICAgICAgZXZlbnRTdG9yZTogcHJvcHMucmVuZGVyYWJsZUV2ZW50U3RvcmUsIC8vICFcbiAgICAgIGV2ZW50VWlCYXNlczogcHJvcHMuZXZlbnRVaUJhc2VzLFxuICAgICAgZGF0ZVNlbGVjdGlvbjogcHJvcHMuZGF0ZVNlbGVjdGlvbixcbiAgICAgIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbixcbiAgICAgIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLFxuICAgICAgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLFxuICAgICAgaXNIZWlnaHRBdXRvOiBwcm9wcy5pc0hlaWdodEF1dG8sXG4gICAgICBmb3JQcmludDogcHJvcHMuZm9yUHJpbnRcbiAgICB9XG5cbiAgICBsZXQgdHJhbnNmb3JtZXJzID0gdGhpcy5idWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzKHBsdWdpbkhvb2tzLnZpZXdQcm9wc1RyYW5zZm9ybWVycylcblxuICAgIGZvciAobGV0IHRyYW5zZm9ybWVyIG9mIHRyYW5zZm9ybWVycykge1xuICAgICAgX19hc3NpZ24oXG4gICAgICAgIHZpZXdQcm9wcyxcbiAgICAgICAgdHJhbnNmb3JtZXIudHJhbnNmb3JtKHZpZXdQcm9wcywgcHJvcHMpXG4gICAgICApXG4gICAgfVxuXG4gICAgbGV0IFZpZXdDb21wb25lbnQgPSB2aWV3U3BlYy5jb21wb25lbnRcblxuICAgIHJldHVybiAoXG4gICAgICA8Vmlld0NvbXBvbmVudCB7Li4udmlld1Byb3BzfSAvPlxuICAgIClcbiAgfVxuXG5cbiAgLy8gQ29tcG9uZW50IFJlZ2lzdHJhdGlvblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgcmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCA9IChjb21wb25lbnQ6IERhdGVDb21wb25lbnQ8YW55Piwgc2V0dGluZ3NJbnB1dDogSW50ZXJhY3Rpb25TZXR0aW5nc0lucHV0KSA9PiB7XG4gICAgbGV0IHNldHRpbmdzID0gcGFyc2VJbnRlcmFjdGlvblNldHRpbmdzKGNvbXBvbmVudCwgc2V0dGluZ3NJbnB1dClcbiAgICBsZXQgREVGQVVMVF9JTlRFUkFDVElPTlM6IEludGVyYWN0aW9uQ2xhc3NbXSA9IFtcbiAgICAgIEV2ZW50Q2xpY2tpbmcsXG4gICAgICBFdmVudEhvdmVyaW5nXG4gICAgXVxuICAgIGxldCBpbnRlcmFjdGlvbkNsYXNzZXM6IEludGVyYWN0aW9uQ2xhc3NbXSA9IERFRkFVTFRfSU5URVJBQ1RJT05TLmNvbmNhdChcbiAgICAgIHRoaXMucHJvcHMucGx1Z2luSG9va3MuY29tcG9uZW50SW50ZXJhY3Rpb25zXG4gICAgKVxuICAgIGxldCBpbnRlcmFjdGlvbnMgPSBpbnRlcmFjdGlvbkNsYXNzZXMubWFwKChpbnRlcmFjdGlvbkNsYXNzKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IGludGVyYWN0aW9uQ2xhc3Moc2V0dGluZ3MpXG4gICAgfSlcblxuICAgIHRoaXMuaW50ZXJhY3Rpb25zU3RvcmVbY29tcG9uZW50LnVpZF0gPSBpbnRlcmFjdGlvbnNcbiAgICBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmVbY29tcG9uZW50LnVpZF0gPSBzZXR0aW5nc1xuICB9XG5cblxuICB1bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQgPSAoY29tcG9uZW50OiBEYXRlQ29tcG9uZW50PGFueT4pID0+IHtcblxuICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuaW50ZXJhY3Rpb25zU3RvcmVbY29tcG9uZW50LnVpZF0pIHtcbiAgICAgIGxpc3RlbmVyLmRlc3Ryb3koKVxuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLmludGVyYWN0aW9uc1N0b3JlW2NvbXBvbmVudC51aWRdXG4gICAgZGVsZXRlIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZVtjb21wb25lbnQudWlkXVxuICB9XG5cblxuICAvLyBSZXNpemluZ1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgcmVzaXplUnVubmVyID0gbmV3IERlbGF5ZWRSdW5uZXIoKCkgPT4ge1xuICAgIHRoaXMucHJvcHMuZW1pdHRlci50cmlnZ2VyKCdfcmVzaXplJywgdHJ1ZSkgLy8gc2hvdWxkIHdpbmRvdyByZXNpemVzIGJlIGNvbnNpZGVyZWQgXCJmb3JjZWRcIiA/XG4gICAgdGhpcy5wcm9wcy5lbWl0dGVyLnRyaWdnZXIoJ3dpbmRvd1Jlc2l6ZScsIHsgdmlldzogdGhpcy5wcm9wcy52aWV3QXBpIH0pXG4gIH0pXG5cblxuICBoYW5kbGVXaW5kb3dSZXNpemUgPSAoZXY6IFVJRXZlbnQpID0+IHtcbiAgICBsZXQgeyBvcHRpb25zIH0gPSB0aGlzLnByb3BzXG5cbiAgICBpZiAoXG4gICAgICBvcHRpb25zLmhhbmRsZVdpbmRvd1Jlc2l6ZSAmJlxuICAgICAgZXYudGFyZ2V0ID09PSB3aW5kb3cgLy8gYXZvaWQganF1aSBldmVudHNcbiAgICApIHtcbiAgICAgIHRoaXMucmVzaXplUnVubmVyLnJlcXVlc3Qob3B0aW9ucy53aW5kb3dSZXNpemVEZWxheSlcbiAgICB9XG4gIH1cblxufVxuXG5cbmZ1bmN0aW9uIGJ1aWxkVG9vbGJhclByb3BzKFxuICB2aWV3U3BlYzogVmlld1NwZWMsXG4gIGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZSxcbiAgZGF0ZVByb2ZpbGVHZW5lcmF0b3I6IERhdGVQcm9maWxlR2VuZXJhdG9yLFxuICBjdXJyZW50RGF0ZTogRGF0ZU1hcmtlcixcbiAgbm93OiBEYXRlTWFya2VyLFxuICB0aXRsZTogc3RyaW5nXG4pIHtcbiAgLy8gZG9uJ3QgZm9yY2UgYW55IGRhdGUtcHJvZmlsZXMgdG8gdmFsaWQgZGF0ZSBwcm9maWxlcyAodGhlIGBmYWxzZWApIHNvIHRoYXQgd2UgY2FuIHRlbGwgaWYgaXQncyBpbnZhbGlkXG4gIGxldCB0b2RheUluZm8gPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChub3csIHVuZGVmaW5lZCwgZmFsc2UpIC8vIFRPRE86IG5lZWQgYHVuZGVmaW5lZGAgb3IgZWxzZSBJTkZJTklURSBMT09QIGZvciBzb21lIHJlYXNvblxuICBsZXQgcHJldkluZm8gPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZFByZXYoZGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlLCBmYWxzZSlcbiAgbGV0IG5leHRJbmZvID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGROZXh0KGRhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSwgZmFsc2UpXG5cbiAgcmV0dXJuIHtcbiAgICB0aXRsZSxcbiAgICBhY3RpdmVCdXR0b246IHZpZXdTcGVjLnR5cGUsXG4gICAgaXNUb2RheUVuYWJsZWQ6IHRvZGF5SW5mby5pc1ZhbGlkICYmICFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZSwgbm93KSxcbiAgICBpc1ByZXZFbmFibGVkOiBwcmV2SW5mby5pc1ZhbGlkLFxuICAgIGlzTmV4dEVuYWJsZWQ6IG5leHRJbmZvLmlzVmFsaWRcbiAgfVxufVxuXG5cbi8vIFBsdWdpblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5mdW5jdGlvbiBidWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzKHRoZUNsYXNzZXM6IFZpZXdQcm9wc1RyYW5zZm9ybWVyQ2xhc3NbXSkge1xuICByZXR1cm4gdGhlQ2xhc3Nlcy5tYXAoZnVuY3Rpb24odGhlQ2xhc3MpIHtcbiAgICByZXR1cm4gbmV3IHRoZUNsYXNzKClcbiAgfSlcbn1cbiIsIlxubGV0IGNhblZHcm93V2l0aGluQ2VsbDogYm9vbGVhblxuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDYW5WR3Jvd1dpdGhpbkNlbGwoKSB7XG4gIGlmIChjYW5WR3Jvd1dpdGhpbkNlbGwgPT0gbnVsbCkge1xuICAgIGNhblZHcm93V2l0aGluQ2VsbCA9IGNvbXB1dGVDYW5WR3Jvd1dpdGhpbkNlbGwoKVxuICB9XG4gIHJldHVybiBjYW5WR3Jvd1dpdGhpbkNlbGxcbn1cblxuXG5mdW5jdGlvbiBjb21wdXRlQ2FuVkdyb3dXaXRoaW5DZWxsKCkge1xuICAvLyBUT0RPOiBhYnN0cmFjdGlvbiBmb3IgY3JlYXRpbmcgdGhlc2UgdGVtcG9yYXJ5IGRldGVjdGlvbi1iYXNlZCBlbHNcbiAgbGV0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgZWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnIC8vIGZvciBub3QgaW50ZXJmZXJpbmcgd2l0aCBjdXJyZW50IGxheW91dFxuICBlbC5zdHlsZS50b3AgPSAnMCdcbiAgZWwuc3R5bGUubGVmdCA9ICcwJ1xuICBlbC5pbm5lckhUTUwgPSAnPHRhYmxlIHN0eWxlPVwiaGVpZ2h0OjEwMHB4XCI+PHRyPjx0ZD48ZGl2IHN0eWxlPVwiaGVpZ2h0OjEwMCVcIj48L2Rpdj48L3RkPjwvdHI+PC90YWJsZT4nXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwpXG4gIGxldCBkaXYgPSBlbC5xdWVyeVNlbGVjdG9yKCdkaXYnKVxuICBsZXQgcG9zc2libGUgPSBkaXYub2Zmc2V0SGVpZ2h0ID4gMFxuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKVxuICByZXR1cm4gcG9zc2libGVcbn1cbiIsImltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuIH0gZnJvbSAnLi92ZG9tJ1xuaW1wb3J0IHsgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4vdmRvbS11dGlsJ1xuaW1wb3J0IHsgQ3NzRGltVmFsdWUgfSBmcm9tICcuL3Njcm9sbGdyaWQvdXRpbCdcbmltcG9ydCB7IENhbGVuZGFyT3B0aW9ucywgQ2FsZW5kYXJMaXN0ZW5lcnMgfSBmcm9tICcuL29wdGlvbnMnXG5pbXBvcnQgeyBUaGVtZSB9IGZyb20gJy4vdGhlbWUvVGhlbWUnXG5pbXBvcnQgeyBnZXRDYW5WR3Jvd1dpdGhpbkNlbGwgfSBmcm9tICcuL3V0aWwvdGFibGUtc3R5bGluZydcbmltcG9ydCB7IEVtaXR0ZXIgfSBmcm9tICcuL2NvbW1vbi9FbWl0dGVyJ1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsZW5kYXJSb290UHJvcHMge1xuICBvcHRpb25zOiBDYWxlbmRhck9wdGlvbnNcbiAgdGhlbWU6IFRoZW1lXG4gIGVtaXR0ZXI6IEVtaXR0ZXI8Q2FsZW5kYXJMaXN0ZW5lcnM+XG4gIGNoaWxkcmVuOiAoY2xhc3NOYW1lczogc3RyaW5nW10sIGhlaWdodDogQ3NzRGltVmFsdWUsIGlzSGVpZ2h0QXV0bzogYm9vbGVhbiwgZm9yUHJpbnQ6IGJvb2xlYW4pID0+IENvbXBvbmVudENoaWxkcmVuXG59XG5cbmludGVyZmFjZSBDYWxlbmRhclJvb3RTdGF0ZSB7XG4gIGZvclByaW50OiBib29sZWFuXG59XG5cblxuZXhwb3J0IGNsYXNzIENhbGVuZGFyUm9vdCBleHRlbmRzIEJhc2VDb21wb25lbnQ8Q2FsZW5kYXJSb290UHJvcHMsIENhbGVuZGFyUm9vdFN0YXRlPiB7XG5cbiAgc3RhdGUgPSB7XG4gICAgZm9yUHJpbnQ6IGZhbHNlXG4gIH1cblxuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBwcm9wcyB9ID0gdGhpc1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IHByb3BzXG4gICAgbGV0IHsgZm9yUHJpbnQgfSA9IHRoaXMuc3RhdGVcblxuICAgIGxldCBpc0hlaWdodEF1dG8gPSBmb3JQcmludCB8fCBvcHRpb25zLmhlaWdodCA9PT0gJ2F1dG8nIHx8IG9wdGlvbnMuY29udGVudEhlaWdodCA9PT0gJ2F1dG8nXG4gICAgbGV0IGhlaWdodCA9ICghaXNIZWlnaHRBdXRvICYmIG9wdGlvbnMuaGVpZ2h0ICE9IG51bGwpID8gb3B0aW9ucy5oZWlnaHQgOiAnJ1xuXG4gICAgbGV0IGNsYXNzTmFtZXM6IHN0cmluZ1tdID0gW1xuICAgICAgJ2ZjJyxcbiAgICAgIGZvclByaW50ID8gJ2ZjLW1lZGlhLXByaW50JyA6ICdmYy1tZWRpYS1zY3JlZW4nLFxuICAgICAgJ2ZjLWRpcmVjdGlvbi0nICsgb3B0aW9ucy5kaXJlY3Rpb24sXG4gICAgICBwcm9wcy50aGVtZS5nZXRDbGFzcygncm9vdCcpXG4gICAgXVxuXG4gICAgaWYgKCFnZXRDYW5WR3Jvd1dpdGhpbkNlbGwoKSkge1xuICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1saXF1aWQtaGFjaycpXG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuKGNsYXNzTmFtZXMsIGhlaWdodCwgaXNIZWlnaHRBdXRvLCBmb3JQcmludClcbiAgfVxuXG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgbGV0IHsgZW1pdHRlciB9ID0gdGhpcy5wcm9wc1xuICAgIGVtaXR0ZXIub24oJ19iZWZvcmVwcmludCcsIHRoaXMuaGFuZGxlQmVmb3JlUHJpbnQpXG4gICAgZW1pdHRlci5vbignX2FmdGVycHJpbnQnLCB0aGlzLmhhbmRsZUFmdGVyUHJpbnQpXG4gIH1cblxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGxldCB7IGVtaXR0ZXIgfSA9IHRoaXMucHJvcHNcbiAgICBlbWl0dGVyLm9mZignX2JlZm9yZXByaW50JywgdGhpcy5oYW5kbGVCZWZvcmVQcmludClcbiAgICBlbWl0dGVyLm9mZignX2FmdGVycHJpbnQnLCB0aGlzLmhhbmRsZUFmdGVyUHJpbnQpXG4gIH1cblxuXG4gIGhhbmRsZUJlZm9yZVByaW50ID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBmb3JQcmludDogdHJ1ZSB9KVxuICB9XG5cblxuICBoYW5kbGVBZnRlclByaW50ID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBmb3JQcmludDogZmFsc2UgfSlcbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBjcmVhdGVGb3JtYXR0ZXIgfSBmcm9tICcuLi9kYXRlbGliL2Zvcm1hdHRpbmcnXG5cbi8vIENvbXB1dGVzIGEgZGVmYXVsdCBjb2x1bW4gaGVhZGVyIGZvcm1hdHRpbmcgc3RyaW5nIGlmIGBjb2xGb3JtYXRgIGlzIG5vdCBleHBsaWNpdGx5IGRlZmluZWRcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQoZGF0ZXNSZXBEaXN0aW5jdERheXM6IGJvb2xlYW4sIGRheUNudDogbnVtYmVyKSB7XG4gIC8vIGlmIG1vcmUgdGhhbiBvbmUgd2VlayByb3csIG9yIGlmIHRoZXJlIGFyZSBhIGxvdCBvZiBjb2x1bW5zIHdpdGggbm90IG11Y2ggc3BhY2UsXG4gIC8vIHB1dCBqdXN0IHRoZSBkYXkgbnVtYmVycyB3aWxsIGJlIGluIGVhY2ggY2VsbFxuICBpZiAoIWRhdGVzUmVwRGlzdGluY3REYXlzIHx8IGRheUNudCA+IDEwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUZvcm1hdHRlcih7IHdlZWtkYXk6ICdzaG9ydCcgfSkgLy8gXCJTYXRcIlxuICB9IGVsc2UgaWYgKGRheUNudCA+IDEpIHtcbiAgICByZXR1cm4gY3JlYXRlRm9ybWF0dGVyKHsgd2Vla2RheTogJ3Nob3J0JywgbW9udGg6ICdudW1lcmljJywgZGF5OiAnbnVtZXJpYycsIG9taXRDb21tYXM6IHRydWUgfSkgLy8gXCJTYXQgMTEvMTJcIlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrZGF5OiAnbG9uZycgfSkgLy8gXCJTYXR1cmRheVwiXG4gIH1cbn1cbiIsImltcG9ydCB7IERhdGVSYW5nZSB9IGZyb20gJy4uL2RhdGVsaWIvZGF0ZS1yYW5nZSdcbmltcG9ydCB7IGdldERheUNsYXNzTmFtZXMsIGdldERhdGVNZXRhLCBEYXRlTWV0YSB9IGZyb20gJy4uL2NvbXBvbmVudC9kYXRlLXJlbmRlcmluZydcbmltcG9ydCB7IERhdGVNYXJrZXIsIGFkZERheXMgfSBmcm9tICcuLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQgfSBmcm9tICcuLi92ZG9tJ1xuaW1wb3J0IHsgRGF0ZUZvcm1hdHRlciB9IGZyb20gJy4uL2RhdGVsaWIvRGF0ZUZvcm1hdHRlcidcbmltcG9ydCB7IGZvcm1hdERheVN0cmluZyB9IGZyb20gJy4uL2RhdGVsaWIvZm9ybWF0dGluZy11dGlscydcbmltcG9ydCB7IEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi92ZG9tLXV0aWwnXG5pbXBvcnQgeyBSZW5kZXJIb29rIH0gZnJvbSAnLi9yZW5kZXItaG9vaydcbmltcG9ydCB7IGJ1aWxkTmF2TGlua0RhdGEgfSBmcm9tICcuL25hdi1saW5rJ1xuaW1wb3J0IHsgRGF0ZVByb2ZpbGUgfSBmcm9tICcuLi9EYXRlUHJvZmlsZUdlbmVyYXRvcidcbmltcG9ydCB7IERheUhlYWRlckNvbnRlbnRBcmcgfSBmcm9tICcuLi9yZW5kZXItaG9vay1taXNjJ1xuaW1wb3J0IHsgRGljdGlvbmFyeSB9IGZyb20gJy4uL29wdGlvbnMnXG5cblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZURhdGVDZWxsUHJvcHMge1xuICBkYXRlOiBEYXRlTWFya2VyXG4gIGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZVxuICB0b2RheVJhbmdlOiBEYXRlUmFuZ2VcbiAgY29sQ250OiBudW1iZXJcbiAgZGF5SGVhZGVyRm9ybWF0OiBEYXRlRm9ybWF0dGVyXG4gIGNvbFNwYW4/OiBudW1iZXJcbiAgaXNTdGlja3k/OiBib29sZWFuIC8vIFRPRE86IGdldCB0aGlzIG91dHRhIGhlcmUgc29tZWhvd1xuICBleHRyYURhdGFBdHRycz86IERpY3Rpb25hcnlcbiAgZXh0cmFIb29rUHJvcHM/OiBEaWN0aW9uYXJ5XG59XG5cbmNvbnN0IENMQVNTX05BTUUgPSAnZmMtY29sLWhlYWRlci1jZWxsJyAvLyBkbyB0aGUgY3VzaGlvbiB0b28/IG5vXG5cblxuZXhwb3J0IGNsYXNzIFRhYmxlRGF0ZUNlbGwgZXh0ZW5kcyBCYXNlQ29tcG9uZW50PFRhYmxlRGF0ZUNlbGxQcm9wcz4geyAvLyBCQUQgbmFtZSBmb3IgdGhpcyBjbGFzcyBub3cuIHVzZWQgaW4gdGhlIEhlYWRlclxuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBkYXRlRW52LCBvcHRpb25zLCB0aGVtZSwgdmlld0FwaSB9ID0gdGhpcy5jb250ZXh0XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcbiAgICBsZXQgeyBkYXRlLCBkYXRlUHJvZmlsZSB9ID0gcHJvcHNcbiAgICBsZXQgZGF5TWV0YSA9IGdldERhdGVNZXRhKGRhdGUsIHByb3BzLnRvZGF5UmFuZ2UsIG51bGwsIGRhdGVQcm9maWxlKVxuXG4gICAgbGV0IGNsYXNzTmFtZXMgPSBbIENMQVNTX05BTUUgXS5jb25jYXQoXG4gICAgICBnZXREYXlDbGFzc05hbWVzKGRheU1ldGEsIHRoZW1lKVxuICAgIClcbiAgICBsZXQgdGV4dCA9IGRhdGVFbnYuZm9ybWF0KGRhdGUsIHByb3BzLmRheUhlYWRlckZvcm1hdClcblxuICAgIC8vIGlmIGNvbENudCBpcyAxLCB3ZSBhcmUgYWxyZWFkeSBpbiBhIGRheS12aWV3IGFuZCBkb24ndCBuZWVkIGEgbmF2bGlua1xuICAgIGxldCBuYXZMaW5rQXR0cnMgPSAob3B0aW9ucy5uYXZMaW5rcyAmJiAhZGF5TWV0YS5pc0Rpc2FibGVkICYmIHByb3BzLmNvbENudCA+IDEpXG4gICAgICA/IHsgJ2RhdGEtbmF2bGluayc6IGJ1aWxkTmF2TGlua0RhdGEoZGF0ZSksIHRhYkluZGV4OiAwIH1cbiAgICAgIDoge31cblxuICAgIGxldCBob29rUHJvcHM6IERheUhlYWRlckNvbnRlbnRBcmcgPSB7XG4gICAgICBkYXRlOiBkYXRlRW52LnRvRGF0ZShkYXRlKSxcbiAgICAgIHZpZXc6IHZpZXdBcGksXG4gICAgICAuLi5wcm9wcy5leHRyYUhvb2tQcm9wcyxcbiAgICAgIHRleHQsXG4gICAgICAuLi5kYXlNZXRhXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxSZW5kZXJIb29rXG4gICAgICAgIGhvb2tQcm9wcz17aG9va1Byb3BzfVxuICAgICAgICBjbGFzc05hbWVzPXtvcHRpb25zLmRheUhlYWRlckNsYXNzTmFtZXN9XG4gICAgICAgIGNvbnRlbnQ9e29wdGlvbnMuZGF5SGVhZGVyQ29udGVudH1cbiAgICAgICAgZGVmYXVsdENvbnRlbnQ9e3JlbmRlcklubmVyfVxuICAgICAgICBkaWRNb3VudD17b3B0aW9ucy5kYXlIZWFkZXJEaWRNb3VudH1cbiAgICAgICAgd2lsbFVubW91bnQ9e29wdGlvbnMuZGF5SGVhZGVyV2lsbFVubW91bnR9XG4gICAgICA+XG4gICAgICAgIHsocm9vdEVsUmVmLCBjdXN0b21DbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpID0+IChcbiAgICAgICAgICA8dGhcbiAgICAgICAgICAgIHJlZj17cm9vdEVsUmVmfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzLmNvbmNhdChjdXN0b21DbGFzc05hbWVzKS5qb2luKCcgJyl9XG4gICAgICAgICAgICBkYXRhLWRhdGU9eyFkYXlNZXRhLmlzRGlzYWJsZWQgPyBmb3JtYXREYXlTdHJpbmcoZGF0ZSkgOiB1bmRlZmluZWR9XG4gICAgICAgICAgICBjb2xTcGFuPXtwcm9wcy5jb2xTcGFufVxuICAgICAgICAgICAgey4uLnByb3BzLmV4dHJhRGF0YUF0dHJzfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdmYy1zY3JvbGxncmlkLXN5bmMtaW5uZXInPlxuICAgICAgICAgICAgICB7IWRheU1ldGEuaXNEaXNhYmxlZCAmJlxuICAgICAgICAgICAgICAgIDxhXG4gICAgICAgICAgICAgICAgICByZWY9e2lubmVyRWxSZWZ9XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e1tcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLWNvbC1oZWFkZXItY2VsbC1jdXNoaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuaXNTdGlja3kgPyAnZmMtc3RpY2t5JyA6ICcnXG4gICAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKX1cbiAgICAgICAgICAgICAgICAgIHsuLi5uYXZMaW5rQXR0cnN9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAge2lubmVyQ29udGVudH1cbiAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvdGg+XG4gICAgICAgICl9XG4gICAgICA8L1JlbmRlckhvb2s+XG4gICAgKVxuICB9XG5cbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlRG93Q2VsbFByb3BzIHtcbiAgZG93OiBudW1iZXJcbiAgZGF5SGVhZGVyRm9ybWF0OiBEYXRlRm9ybWF0dGVyXG4gIGNvbFNwYW4/OiBudW1iZXJcbiAgaXNTdGlja3k/OiBib29sZWFuIC8vIFRPRE86IGdldCB0aGlzIG91dHRhIGhlcmUgc29tZWhvd1xuICBleHRyYUhvb2tQcm9wcz86IERpY3Rpb25hcnlcbiAgZXh0cmFEYXRhQXR0cnM/OiBEaWN0aW9uYXJ5XG4gIGV4dHJhQ2xhc3NOYW1lcz86IHN0cmluZ1tdXG59XG5cbmV4cG9ydCBjbGFzcyBUYWJsZURvd0NlbGwgZXh0ZW5kcyBCYXNlQ29tcG9uZW50PFRhYmxlRG93Q2VsbFByb3BzPiB7XG5cbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IHByb3BzIH0gPSB0aGlzXG4gICAgbGV0IHsgZGF0ZUVudiwgdGhlbWUsIHZpZXdBcGksIG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dFxuXG4gICAgbGV0IGRhdGUgPSBhZGREYXlzKG5ldyBEYXRlKDI1OTIwMDAwMCksIHByb3BzLmRvdykgLy8gc3RhcnQgd2l0aCBTdW4sIDA0IEphbiAxOTcwIDAwOjAwOjAwIEdNVFxuXG4gICAgbGV0IGRhdGVNZXRhOiBEYXRlTWV0YSA9IHtcbiAgICAgIGRvdzogcHJvcHMuZG93LFxuICAgICAgaXNEaXNhYmxlZDogZmFsc2UsXG4gICAgICBpc0Z1dHVyZTogZmFsc2UsXG4gICAgICBpc1Bhc3Q6IGZhbHNlLFxuICAgICAgaXNUb2RheTogZmFsc2UsXG4gICAgICBpc090aGVyOiBmYWxzZVxuICAgIH1cblxuICAgIGxldCBjbGFzc05hbWVzID0gWyBDTEFTU19OQU1FIF0uY29uY2F0KFxuICAgICAgZ2V0RGF5Q2xhc3NOYW1lcyhkYXRlTWV0YSwgdGhlbWUpLFxuICAgICAgcHJvcHMuZXh0cmFDbGFzc05hbWVzIHx8IFtdXG4gICAgKVxuXG4gICAgbGV0IHRleHQgPSBkYXRlRW52LmZvcm1hdChkYXRlLCBwcm9wcy5kYXlIZWFkZXJGb3JtYXQpXG5cbiAgICBsZXQgaG9va1Byb3BzOiBEYXlIZWFkZXJDb250ZW50QXJnID0geyAvLyBUT0RPOiBtYWtlIHRoaXMgcHVibGljP1xuICAgICAgZGF0ZSxcbiAgICAgIC4uLmRhdGVNZXRhLFxuICAgICAgdmlldzogdmlld0FwaSxcbiAgICAgIC4uLnByb3BzLmV4dHJhSG9va1Byb3BzLFxuICAgICAgdGV4dFxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8UmVuZGVySG9va1xuICAgICAgICBob29rUHJvcHM9e2hvb2tQcm9wc31cbiAgICAgICAgY2xhc3NOYW1lcz17b3B0aW9ucy5kYXlIZWFkZXJDbGFzc05hbWVzfVxuICAgICAgICBjb250ZW50PXtvcHRpb25zLmRheUhlYWRlckNvbnRlbnR9XG4gICAgICAgIGRlZmF1bHRDb250ZW50PXtyZW5kZXJJbm5lcn1cbiAgICAgICAgZGlkTW91bnQ9e29wdGlvbnMuZGF5SGVhZGVyRGlkTW91bnR9XG4gICAgICAgIHdpbGxVbm1vdW50PXtvcHRpb25zLmRheUhlYWRlcldpbGxVbm1vdW50fVxuICAgICAgPlxuICAgICAgICB7KHJvb3RFbFJlZiwgY3VzdG9tQ2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSA9PiAoXG4gICAgICAgICAgPHRoXG4gICAgICAgICAgICByZWY9e3Jvb3RFbFJlZn1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcy5jb25jYXQoY3VzdG9tQ2xhc3NOYW1lcykuam9pbignICcpfVxuICAgICAgICAgICAgY29sU3Bhbj17cHJvcHMuY29sU3Bhbn1cbiAgICAgICAgICAgIHsuLi5wcm9wcy5leHRyYURhdGFBdHRyc31cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyJz5cbiAgICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e1tcbiAgICAgICAgICAgICAgICAgICdmYy1jb2wtaGVhZGVyLWNlbGwtY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgICBwcm9wcy5pc1N0aWNreSA/ICdmYy1zdGlja3knIDogJydcbiAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKX1cbiAgICAgICAgICAgICAgICByZWY9e2lubmVyRWxSZWZ9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7aW5uZXJDb250ZW50fVxuICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L3RoPlxuICAgICAgICApfVxuICAgICAgPC9SZW5kZXJIb29rPlxuICAgIClcbiAgfVxuXG59XG5cblxuZnVuY3Rpb24gcmVuZGVySW5uZXIoaG9va1Byb3BzOiBEYXlIZWFkZXJDb250ZW50QXJnKSB7XG4gIHJldHVybiBob29rUHJvcHMudGV4dFxufVxuIiwiaW1wb3J0IHsgRGF0ZU1hcmtlciwgYWRkTXMsIHN0YXJ0T2ZEYXksIGFkZERheXMgfSBmcm9tICcuL2RhdGVsaWIvbWFya2VyJ1xuaW1wb3J0IHsgY3JlYXRlRHVyYXRpb24gfSBmcm9tICcuL2RhdGVsaWIvZHVyYXRpb24nXG5pbXBvcnQgeyBWaWV3Q29udGV4dCwgVmlld0NvbnRleHRUeXBlIH0gZnJvbSAnLi9WaWV3Q29udGV4dCdcbmltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuLCBDb21wb25lbnQgfSBmcm9tICcuL3Zkb20nXG5pbXBvcnQgeyBEYXRlUmFuZ2UgfSBmcm9tICcuL2RhdGVsaWIvZGF0ZS1yYW5nZSdcbmltcG9ydCB7IGdldE5vdyB9IGZyb20gJy4vcmVkdWNlcnMvY3VycmVudC1kYXRlJ1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgTm93VGltZXJQcm9wcyB7XG4gIHVuaXQ6IHN0cmluZyAvLyBUT0RPOiBhZGQgdHlwZSBvZiB1bml0XG4gIGNoaWxkcmVuOiAobm93OiBEYXRlTWFya2VyLCB0b2RheVJhbmdlOiBEYXRlUmFuZ2UpID0+IENvbXBvbmVudENoaWxkcmVuXG59XG5cbmludGVyZmFjZSBOb3dUaW1lclN0YXRlIHtcbiAgbm93RGF0ZTogRGF0ZU1hcmtlclxuICB0b2RheVJhbmdlOiBEYXRlUmFuZ2Vcbn1cblxuXG5leHBvcnQgY2xhc3MgTm93VGltZXIgZXh0ZW5kcyBDb21wb25lbnQ8Tm93VGltZXJQcm9wcywgTm93VGltZXJTdGF0ZT4ge1xuXG4gIHN0YXRpYyBjb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZVxuICBjb250ZXh0OiBWaWV3Q29udGV4dCAvLyBkbyB0aGlzIGZvciBhbGwgY29tcG9uZW50cyB0aGF0IHVzZSB0aGUgY29udGV4dCEhIVxuXG4gIGluaXRpYWxOb3dEYXRlOiBEYXRlTWFya2VyXG4gIGluaXRpYWxOb3dRdWVyaWVkTXM6IG51bWJlclxuICB0aW1lb3V0SWQ6IGFueVxuXG5cbiAgY29uc3RydWN0b3IocHJvcHM6IE5vd1RpbWVyUHJvcHMsIGNvbnRleHQ6IFZpZXdDb250ZXh0KSB7XG4gICAgc3VwZXIocHJvcHMsIGNvbnRleHQpXG5cbiAgICB0aGlzLmluaXRpYWxOb3dEYXRlID0gZ2V0Tm93KGNvbnRleHQub3B0aW9ucy5ub3csIGNvbnRleHQuZGF0ZUVudilcbiAgICB0aGlzLmluaXRpYWxOb3dRdWVyaWVkTXMgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKVxuXG4gICAgdGhpcy5zdGF0ZSA9IHRoaXMuY29tcHV0ZVRpbWluZygpLmN1cnJlbnRTdGF0ZVxuICB9XG5cblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgcHJvcHMsIHN0YXRlIH0gPSB0aGlzXG4gICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuKHN0YXRlLm5vd0RhdGUsIHN0YXRlLnRvZGF5UmFuZ2UpXG4gIH1cblxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuc2V0VGltZW91dCgpXG4gIH1cblxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IE5vd1RpbWVyUHJvcHMpIHtcbiAgICBpZiAocHJldlByb3BzLnVuaXQgIT09IHRoaXMucHJvcHMudW5pdCkge1xuICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKVxuICAgICAgdGhpcy5zZXRUaW1lb3V0KClcbiAgICB9XG4gIH1cblxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuY2xlYXJUaW1lb3V0KClcbiAgfVxuXG5cbiAgcHJpdmF0ZSBjb21wdXRlVGltaW5nKCkge1xuICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzXG4gICAgbGV0IHVucm91bmRlZE5vdyA9IGFkZE1zKHRoaXMuaW5pdGlhbE5vd0RhdGUsIG5ldyBEYXRlKCkudmFsdWVPZigpIC0gdGhpcy5pbml0aWFsTm93UXVlcmllZE1zKVxuICAgIGxldCBjdXJyZW50VW5pdFN0YXJ0ID0gY29udGV4dC5kYXRlRW52LnN0YXJ0T2YodW5yb3VuZGVkTm93LCBwcm9wcy51bml0KVxuICAgIGxldCBuZXh0VW5pdFN0YXJ0ID0gY29udGV4dC5kYXRlRW52LmFkZChjdXJyZW50VW5pdFN0YXJ0LCBjcmVhdGVEdXJhdGlvbigxLCBwcm9wcy51bml0KSlcbiAgICBsZXQgd2FpdE1zID0gbmV4dFVuaXRTdGFydC52YWx1ZU9mKCkgLSB1bnJvdW5kZWROb3cudmFsdWVPZigpXG5cbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudFN0YXRlOiB7IG5vd0RhdGU6IGN1cnJlbnRVbml0U3RhcnQsIHRvZGF5UmFuZ2U6IGJ1aWxkRGF5UmFuZ2UoY3VycmVudFVuaXRTdGFydCkgfSBhcyBOb3dUaW1lclN0YXRlLFxuICAgICAgbmV4dFN0YXRlOiB7IG5vd0RhdGU6IG5leHRVbml0U3RhcnQsIHRvZGF5UmFuZ2U6IGJ1aWxkRGF5UmFuZ2UobmV4dFVuaXRTdGFydCkgfSBhcyBOb3dUaW1lclN0YXRlLFxuICAgICAgd2FpdE1zXG4gICAgfVxuICB9XG5cblxuICBwcml2YXRlIHNldFRpbWVvdXQoKSB7XG4gICAgbGV0IHsgbmV4dFN0YXRlLCB3YWl0TXMgfSA9IHRoaXMuY29tcHV0ZVRpbWluZygpXG5cbiAgICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5zZXRTdGF0ZShuZXh0U3RhdGUsICgpID0+IHtcbiAgICAgICAgdGhpcy5zZXRUaW1lb3V0KClcbiAgICAgIH0pXG4gICAgfSwgd2FpdE1zKVxuICB9XG5cblxuICBwcml2YXRlIGNsZWFyVGltZW91dCgpIHtcbiAgICBpZiAodGhpcy50aW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZClcbiAgICB9XG4gIH1cblxufVxuXG5cbmZ1bmN0aW9uIGJ1aWxkRGF5UmFuZ2UoZGF0ZTogRGF0ZU1hcmtlcik6IERhdGVSYW5nZSB7IC8vIFRPRE86IG1ha2UgdGhpcyBhIGdlbmVyYWwgdXRpbFxuICBsZXQgc3RhcnQgPSBzdGFydE9mRGF5KGRhdGUpXG4gIGxldCBlbmQgPSBhZGREYXlzKHN0YXJ0LCAxKVxuXG4gIHJldHVybiB7IHN0YXJ0LCBlbmQgfVxufVxuIiwiaW1wb3J0IHsgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uL3Zkb20tdXRpbCdcbmltcG9ydCB7IERhdGVNYXJrZXIgfSBmcm9tICcuLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IGNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdCB9IGZyb20gJy4vdGFibGUtdXRpbHMnXG5pbXBvcnQgeyBWTm9kZSwgY3JlYXRlRWxlbWVudCB9IGZyb20gJy4uL3Zkb20nXG5pbXBvcnQgeyBUYWJsZURhdGVDZWxsLCBUYWJsZURvd0NlbGwgfSBmcm9tICcuL1RhYmxlRGF0ZUNlbGwnXG5pbXBvcnQgeyBOb3dUaW1lciB9IGZyb20gJy4uL05vd1RpbWVyJ1xuaW1wb3J0IHsgRGF0ZVJhbmdlIH0gZnJvbSAnLi4vZGF0ZWxpYi9kYXRlLXJhbmdlJ1xuaW1wb3J0IHsgbWVtb2l6ZSB9IGZyb20gJy4uL3V0aWwvbWVtb2l6ZSdcbmltcG9ydCB7IERhdGVQcm9maWxlIH0gZnJvbSAnLi4vRGF0ZVByb2ZpbGVHZW5lcmF0b3InXG5pbXBvcnQgeyBEYXRlRm9ybWF0dGVyIH0gZnJvbSAnLi4vZGF0ZWxpYi9EYXRlRm9ybWF0dGVyJ1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF5SGVhZGVyUHJvcHMge1xuICBkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGVcbiAgZGF0ZXM6IERhdGVNYXJrZXJbXVxuICBkYXRlc1JlcERpc3RpbmN0RGF5czogYm9vbGVhblxuICByZW5kZXJJbnRybz86ICgpID0+IFZOb2RlXG59XG5cblxuZXhwb3J0IGNsYXNzIERheUhlYWRlciBleHRlbmRzIEJhc2VDb21wb25lbnQ8RGF5SGVhZGVyUHJvcHM+IHsgLy8gVE9ETzogcmVuYW1lIHRvIERheUhlYWRlclRyP1xuXG4gIGNyZWF0ZURheUhlYWRlckZvcm1hdHRlciA9IG1lbW9pemUoY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyKVxuXG5cbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IGNvbnRleHQgfSA9IHRoaXNcbiAgICBsZXQgeyBkYXRlcywgZGF0ZVByb2ZpbGUsIGRhdGVzUmVwRGlzdGluY3REYXlzLCByZW5kZXJJbnRybyB9ID0gdGhpcy5wcm9wc1xuXG4gICAgbGV0IGRheUhlYWRlckZvcm1hdCA9IHRoaXMuY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyKFxuICAgICAgY29udGV4dC5vcHRpb25zLmRheUhlYWRlckZvcm1hdCxcbiAgICAgIGRhdGVzUmVwRGlzdGluY3REYXlzLFxuICAgICAgZGF0ZXMubGVuZ3RoXG4gICAgKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxOb3dUaW1lciB1bml0PSdkYXknPlxuICAgICAgICB7KG5vd0RhdGU6IERhdGVNYXJrZXIsIHRvZGF5UmFuZ2U6IERhdGVSYW5nZSkgPT4gKFxuICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgIHtyZW5kZXJJbnRybyAmJiByZW5kZXJJbnRybygpfVxuICAgICAgICAgICAge2RhdGVzLm1hcCgoZGF0ZSkgPT4gKFxuICAgICAgICAgICAgICBkYXRlc1JlcERpc3RpbmN0RGF5cyA/XG4gICAgICAgICAgICAgICAgPFRhYmxlRGF0ZUNlbGxcbiAgICAgICAgICAgICAgICAgIGtleT17ZGF0ZS50b0lTT1N0cmluZygpfVxuICAgICAgICAgICAgICAgICAgZGF0ZT17ZGF0ZX1cbiAgICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlPXtkYXRlUHJvZmlsZX1cbiAgICAgICAgICAgICAgICAgIHRvZGF5UmFuZ2U9e3RvZGF5UmFuZ2V9XG4gICAgICAgICAgICAgICAgICBjb2xDbnQ9e2RhdGVzLmxlbmd0aH1cbiAgICAgICAgICAgICAgICAgIGRheUhlYWRlckZvcm1hdD17ZGF5SGVhZGVyRm9ybWF0fVxuICAgICAgICAgICAgICAgIC8+IDpcbiAgICAgICAgICAgICAgICA8VGFibGVEb3dDZWxsXG4gICAgICAgICAgICAgICAgICBrZXk9e2RhdGUuZ2V0VVRDRGF5KCl9XG4gICAgICAgICAgICAgICAgICBkb3c9e2RhdGUuZ2V0VVRDRGF5KCl9XG4gICAgICAgICAgICAgICAgICBkYXlIZWFkZXJGb3JtYXQ9e2RheUhlYWRlckZvcm1hdH1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKSl9XG4gICAgICAgICAgPC90cj5cbiAgICAgICAgKX1cbiAgICAgIDwvTm93VGltZXI+XG4gICAgKVxuICB9XG5cbn1cblxuXG5mdW5jdGlvbiBjcmVhdGVEYXlIZWFkZXJGb3JtYXR0ZXIoZXhwbGljaXRGb3JtYXQ6IERhdGVGb3JtYXR0ZXIsIGRhdGVzUmVwRGlzdGluY3REYXlzLCBkYXRlQ250KSB7XG4gIHJldHVybiBleHBsaWNpdEZvcm1hdCB8fCBjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQoZGF0ZXNSZXBEaXN0aW5jdERheXMsIGRhdGVDbnQpXG59XG4iLCJpbXBvcnQgeyBEYXRlUHJvZmlsZUdlbmVyYXRvciB9IGZyb20gJy4uL0RhdGVQcm9maWxlR2VuZXJhdG9yJ1xuaW1wb3J0IHsgRGF0ZU1hcmtlciwgYWRkRGF5cywgZGlmZkRheXMgfSBmcm9tICcuLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IERhdGVSYW5nZSB9IGZyb20gJy4uL2RhdGVsaWIvZGF0ZS1yYW5nZSdcblxuZXhwb3J0IGludGVyZmFjZSBEYXlTZXJpZXNTZWcge1xuICBmaXJzdEluZGV4OiBudW1iZXJcbiAgbGFzdEluZGV4OiBudW1iZXJcbiAgaXNTdGFydDogYm9vbGVhblxuICBpc0VuZDogYm9vbGVhblxufVxuXG5leHBvcnQgY2xhc3MgRGF5U2VyaWVzTW9kZWwge1xuXG4gIGNudDogbnVtYmVyXG4gIGRhdGVzOiBEYXRlTWFya2VyW10gLy8gd2hvbGUtZGF5IGRhdGVzIGZvciBlYWNoIGNvbHVtbi4gbGVmdCB0byByaWdodFxuICBpbmRpY2VzOiBudW1iZXJbXSAvLyBmb3IgZWFjaCBkYXkgZnJvbSBzdGFydCwgdGhlIG9mZnNldFxuXG4gIGNvbnN0cnVjdG9yKHJhbmdlOiBEYXRlUmFuZ2UsIGRhdGVQcm9maWxlR2VuZXJhdG9yOiBEYXRlUHJvZmlsZUdlbmVyYXRvcikge1xuICAgIGxldCBkYXRlOiBEYXRlTWFya2VyID0gcmFuZ2Uuc3RhcnRcbiAgICBsZXQgZW5kOiBEYXRlTWFya2VyID0gcmFuZ2UuZW5kXG4gICAgbGV0IGluZGljZXM6IG51bWJlcltdID0gW11cbiAgICBsZXQgZGF0ZXM6IERhdGVNYXJrZXJbXSA9IFtdXG4gICAgbGV0IGRheUluZGV4ID0gLTFcblxuICAgIHdoaWxlIChkYXRlIDwgZW5kKSB7IC8vIGxvb3AgZWFjaCBkYXkgZnJvbSBzdGFydCB0byBlbmRcbiAgICAgIGlmIChkYXRlUHJvZmlsZUdlbmVyYXRvci5pc0hpZGRlbkRheShkYXRlKSkge1xuICAgICAgICBpbmRpY2VzLnB1c2goZGF5SW5kZXggKyAwLjUpIC8vIG1hcmsgdGhhdCBpdCdzIGJldHdlZW4gaW5kaWNlc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF5SW5kZXgrK1xuICAgICAgICBpbmRpY2VzLnB1c2goZGF5SW5kZXgpXG4gICAgICAgIGRhdGVzLnB1c2goZGF0ZSlcbiAgICAgIH1cbiAgICAgIGRhdGUgPSBhZGREYXlzKGRhdGUsIDEpXG4gICAgfVxuXG4gICAgdGhpcy5kYXRlcyA9IGRhdGVzXG4gICAgdGhpcy5pbmRpY2VzID0gaW5kaWNlc1xuICAgIHRoaXMuY250ID0gZGF0ZXMubGVuZ3RoXG4gIH1cblxuICBzbGljZVJhbmdlKHJhbmdlOiBEYXRlUmFuZ2UpOiBEYXlTZXJpZXNTZWcgfCBudWxsIHtcbiAgICBsZXQgZmlyc3RJbmRleCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KHJhbmdlLnN0YXJ0KSAvLyBpbmNsdXNpdmUgZmlyc3QgaW5kZXhcbiAgICBsZXQgbGFzdEluZGV4ID0gdGhpcy5nZXREYXRlRGF5SW5kZXgoYWRkRGF5cyhyYW5nZS5lbmQsIC0xKSkgLy8gaW5jbHVzaXZlIGxhc3QgaW5kZXhcblxuICAgIGxldCBjbGlwcGVkRmlyc3RJbmRleCA9IE1hdGgubWF4KDAsIGZpcnN0SW5kZXgpXG4gICAgbGV0IGNsaXBwZWRMYXN0SW5kZXggPSBNYXRoLm1pbih0aGlzLmNudCAtIDEsIGxhc3RJbmRleClcblxuICAgIC8vIGRlYWwgd2l0aCBpbi1iZXR3ZWVuIGluZGljZXNcbiAgICBjbGlwcGVkRmlyc3RJbmRleCA9IE1hdGguY2VpbChjbGlwcGVkRmlyc3RJbmRleCkgLy8gaW4tYmV0d2VlbiBzdGFydHMgcm91bmQgdG8gbmV4dCBjZWxsXG4gICAgY2xpcHBlZExhc3RJbmRleCA9IE1hdGguZmxvb3IoY2xpcHBlZExhc3RJbmRleCkgLy8gaW4tYmV0d2VlbiBlbmRzIHJvdW5kIHRvIHByZXYgY2VsbFxuXG4gICAgaWYgKGNsaXBwZWRGaXJzdEluZGV4IDw9IGNsaXBwZWRMYXN0SW5kZXgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZpcnN0SW5kZXg6IGNsaXBwZWRGaXJzdEluZGV4LFxuICAgICAgICBsYXN0SW5kZXg6IGNsaXBwZWRMYXN0SW5kZXgsXG4gICAgICAgIGlzU3RhcnQ6IGZpcnN0SW5kZXggPT09IGNsaXBwZWRGaXJzdEluZGV4LFxuICAgICAgICBpc0VuZDogbGFzdEluZGV4ID09PSBjbGlwcGVkTGFzdEluZGV4XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgLy8gR2l2ZW4gYSBkYXRlLCByZXR1cm5zIGl0cyBjaHJvbm9sb2NpYWwgY2VsbC1pbmRleCBmcm9tIHRoZSBmaXJzdCBjZWxsIG9mIHRoZSBncmlkLlxuICAvLyBJZiB0aGUgZGF0ZSBsaWVzIGJldHdlZW4gY2VsbHMgKGJlY2F1c2Ugb2YgaGlkZGVuRGF5cyksIHJldHVybnMgYSBmbG9hdGluZy1wb2ludCB2YWx1ZSBiZXR3ZWVuIG9mZnNldHMuXG4gIC8vIElmIGJlZm9yZSB0aGUgZmlyc3Qgb2Zmc2V0LCByZXR1cm5zIGEgbmVnYXRpdmUgbnVtYmVyLlxuICAvLyBJZiBhZnRlciB0aGUgbGFzdCBvZmZzZXQsIHJldHVybnMgYW4gb2Zmc2V0IHBhc3QgdGhlIGxhc3QgY2VsbCBvZmZzZXQuXG4gIC8vIE9ubHkgd29ya3MgZm9yICpzdGFydCogZGF0ZXMgb2YgY2VsbHMuIFdpbGwgbm90IHdvcmsgZm9yIGV4Y2x1c2l2ZSBlbmQgZGF0ZXMgZm9yIGNlbGxzLlxuICBwcml2YXRlIGdldERhdGVEYXlJbmRleChkYXRlOiBEYXRlTWFya2VyKSB7XG4gICAgbGV0IGluZGljZXMgPSB0aGlzLmluZGljZXNcbiAgICBsZXQgZGF5T2Zmc2V0ID0gTWF0aC5mbG9vcihkaWZmRGF5cyh0aGlzLmRhdGVzWzBdLCBkYXRlKSlcblxuICAgIGlmIChkYXlPZmZzZXQgPCAwKSB7XG4gICAgICByZXR1cm4gaW5kaWNlc1swXSAtIDFcbiAgICB9IGVsc2UgaWYgKGRheU9mZnNldCA+PSBpbmRpY2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSArIDFcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGluZGljZXNbZGF5T2Zmc2V0XVxuICAgIH1cbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBEYXlTZXJpZXNNb2RlbCB9IGZyb20gJy4vRGF5U2VyaWVzTW9kZWwnXG5pbXBvcnQgeyBEYXRlUmFuZ2UgfSBmcm9tICcuLi9kYXRlbGliL2RhdGUtcmFuZ2UnXG5pbXBvcnQgeyBEYXRlTWFya2VyIH0gZnJvbSAnLi4vZGF0ZWxpYi9tYXJrZXInXG5pbXBvcnQgeyBTZWcgfSBmcm9tICcuLi9jb21wb25lbnQvRGF0ZUNvbXBvbmVudCdcbmltcG9ydCB7IERpY3Rpb25hcnkgfSBmcm9tICcuLi9vcHRpb25zJ1xuXG5leHBvcnQgaW50ZXJmYWNlIERheVRhYmxlU2VnIGV4dGVuZHMgU2VnIHtcbiAgcm93OiBudW1iZXJcbiAgZmlyc3RDb2w6IG51bWJlclxuICBsYXN0Q29sOiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXlUYWJsZUNlbGwge1xuICBrZXk6IHN0cmluZyAvLyBwcm9iYWJseSBqdXN0IHRoZSBzZXJpYWxpemVkIGRhdGUsIGJ1dCBjb3VsZCBiZSBvdGhlciBtZXRhZGF0YSBpZiB0aGlzIGNvbCBpcyBzcGVjaWZpYyB0byBhbm90aGVyIGVudGl0eVxuICBkYXRlOiBEYXRlTWFya2VyXG4gIGV4dHJhSG9va1Byb3BzPzogRGljdGlvbmFyeVxuICBleHRyYURhdGFBdHRycz86IERpY3Rpb25hcnlcbiAgZXh0cmFDbGFzc05hbWVzPzogc3RyaW5nW11cbn1cblxuZXhwb3J0IGNsYXNzIERheVRhYmxlTW9kZWwge1xuXG4gIHJvd0NudDogbnVtYmVyXG4gIGNvbENudDogbnVtYmVyXG4gIGNlbGxzOiBEYXlUYWJsZUNlbGxbXVtdXG4gIGhlYWRlckRhdGVzOiBEYXRlTWFya2VyW11cblxuICBwcml2YXRlIGRheVNlcmllczogRGF5U2VyaWVzTW9kZWxcblxuICBjb25zdHJ1Y3RvcihkYXlTZXJpZXM6IERheVNlcmllc01vZGVsLCBicmVha09uV2Vla3M6IGJvb2xlYW4pIHtcbiAgICBsZXQgeyBkYXRlcyB9ID0gZGF5U2VyaWVzXG4gICAgbGV0IGRheXNQZXJSb3dcbiAgICBsZXQgZmlyc3REYXlcbiAgICBsZXQgcm93Q250XG5cbiAgICBpZiAoYnJlYWtPbldlZWtzKSB7XG4gICAgICAvLyBjb3VudCBjb2x1bW5zIHVudGlsIHRoZSBkYXktb2Ytd2VlayByZXBlYXRzXG4gICAgICBmaXJzdERheSA9IGRhdGVzWzBdLmdldFVUQ0RheSgpXG4gICAgICBmb3IgKGRheXNQZXJSb3cgPSAxOyBkYXlzUGVyUm93IDwgZGF0ZXMubGVuZ3RoOyBkYXlzUGVyUm93KyspIHtcbiAgICAgICAgaWYgKGRhdGVzW2RheXNQZXJSb3ddLmdldFVUQ0RheSgpID09PSBmaXJzdERheSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJvd0NudCA9IE1hdGguY2VpbChkYXRlcy5sZW5ndGggLyBkYXlzUGVyUm93KVxuICAgIH0gZWxzZSB7XG4gICAgICByb3dDbnQgPSAxXG4gICAgICBkYXlzUGVyUm93ID0gZGF0ZXMubGVuZ3RoXG4gICAgfVxuXG4gICAgdGhpcy5yb3dDbnQgPSByb3dDbnRcbiAgICB0aGlzLmNvbENudCA9IGRheXNQZXJSb3dcbiAgICB0aGlzLmRheVNlcmllcyA9IGRheVNlcmllc1xuICAgIHRoaXMuY2VsbHMgPSB0aGlzLmJ1aWxkQ2VsbHMoKVxuICAgIHRoaXMuaGVhZGVyRGF0ZXMgPSB0aGlzLmJ1aWxkSGVhZGVyRGF0ZXMoKVxuICB9XG5cbiAgcHJpdmF0ZSBidWlsZENlbGxzKCkge1xuICAgIGxldCByb3dzID0gW11cblxuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRoaXMucm93Q250OyByb3crKykge1xuICAgICAgbGV0IGNlbGxzID0gW11cblxuICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgdGhpcy5jb2xDbnQ7IGNvbCsrKSB7XG4gICAgICAgIGNlbGxzLnB1c2goXG4gICAgICAgICAgdGhpcy5idWlsZENlbGwocm93LCBjb2wpXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgcm93cy5wdXNoKGNlbGxzKVxuICAgIH1cblxuICAgIHJldHVybiByb3dzXG4gIH1cblxuICBwcml2YXRlIGJ1aWxkQ2VsbChyb3csIGNvbCk6IERheVRhYmxlQ2VsbCB7XG4gICAgbGV0IGRhdGUgPSB0aGlzLmRheVNlcmllcy5kYXRlc1tyb3cgKiB0aGlzLmNvbENudCArIGNvbF1cbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBkYXRlLnRvSVNPU3RyaW5nKCksXG4gICAgICBkYXRlXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBidWlsZEhlYWRlckRhdGVzKCkge1xuICAgIGxldCBkYXRlcyA9IFtdXG5cbiAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sKyspIHtcbiAgICAgIGRhdGVzLnB1c2godGhpcy5jZWxsc1swXVtjb2xdLmRhdGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGVzXG4gIH1cblxuICBzbGljZVJhbmdlKHJhbmdlOiBEYXRlUmFuZ2UpOiBEYXlUYWJsZVNlZ1tdIHtcbiAgICBsZXQgeyBjb2xDbnQgfSA9IHRoaXNcbiAgICBsZXQgc2VyaWVzU2VnID0gdGhpcy5kYXlTZXJpZXMuc2xpY2VSYW5nZShyYW5nZSlcbiAgICBsZXQgc2VnczogRGF5VGFibGVTZWdbXSA9IFtdXG5cbiAgICBpZiAoc2VyaWVzU2VnKSB7XG4gICAgICBsZXQgeyBmaXJzdEluZGV4LCBsYXN0SW5kZXggfSA9IHNlcmllc1NlZ1xuICAgICAgbGV0IGluZGV4ID0gZmlyc3RJbmRleFxuXG4gICAgICB3aGlsZSAoaW5kZXggPD0gbGFzdEluZGV4KSB7XG4gICAgICAgIGxldCByb3cgPSBNYXRoLmZsb29yKGluZGV4IC8gY29sQ250KVxuICAgICAgICBsZXQgbmV4dEluZGV4ID0gTWF0aC5taW4oKHJvdyArIDEpICogY29sQ250LCBsYXN0SW5kZXggKyAxKVxuXG4gICAgICAgIHNlZ3MucHVzaCh7XG4gICAgICAgICAgcm93LFxuICAgICAgICAgIGZpcnN0Q29sOiBpbmRleCAlIGNvbENudCxcbiAgICAgICAgICBsYXN0Q29sOiAobmV4dEluZGV4IC0gMSkgJSBjb2xDbnQsXG4gICAgICAgICAgaXNTdGFydDogc2VyaWVzU2VnLmlzU3RhcnQgJiYgaW5kZXggPT09IGZpcnN0SW5kZXgsXG4gICAgICAgICAgaXNFbmQ6IHNlcmllc1NlZy5pc0VuZCAmJiAobmV4dEluZGV4IC0gMSkgPT09IGxhc3RJbmRleFxuICAgICAgICB9KVxuXG4gICAgICAgIGluZGV4ID0gbmV4dEluZGV4XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlZ3NcbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBEYXRlUmFuZ2UgfSBmcm9tICcuLi9kYXRlbGliL2RhdGUtcmFuZ2UnXG5pbXBvcnQgeyBFdmVudFN0b3JlIH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1zdG9yZSdcbmltcG9ydCB7IEV2ZW50VWlIYXNoIH0gZnJvbSAnLi4vY29tcG9uZW50L2V2ZW50LXVpJ1xuaW1wb3J0IHsgc2xpY2VFdmVudFN0b3JlLCBFdmVudFJlbmRlclJhbmdlIH0gZnJvbSAnLi4vY29tcG9uZW50L2V2ZW50LXJlbmRlcmluZydcbmltcG9ydCB7IERhdGVQcm9maWxlIH0gZnJvbSAnLi4vRGF0ZVByb2ZpbGVHZW5lcmF0b3InXG5pbXBvcnQgeyBTZWcsIEV2ZW50U2VnVWlJbnRlcmFjdGlvblN0YXRlIH0gZnJvbSAnLi4vY29tcG9uZW50L0RhdGVDb21wb25lbnQnIC8vIFRPRE86IHJlbmFtZSBFdmVudFNlZ1VpSW50ZXJhY3Rpb25TdGF0ZSwgbW92ZSBoZXJlXG5pbXBvcnQgeyBEYXRlU3BhbiwgZmFicmljYXRlRXZlbnRSYW5nZSB9IGZyb20gJy4uL3N0cnVjdHMvZGF0ZS1zcGFuJ1xuaW1wb3J0IHsgRXZlbnRJbnRlcmFjdGlvblN0YXRlIH0gZnJvbSAnLi4vaW50ZXJhY3Rpb25zL2V2ZW50LWludGVyYWN0aW9uLXN0YXRlJ1xuaW1wb3J0IHsgRHVyYXRpb24gfSBmcm9tICcuLi9kYXRlbGliL2R1cmF0aW9uJ1xuaW1wb3J0IHsgbWVtb2l6ZSB9IGZyb20gJy4uL3V0aWwvbWVtb2l6ZSdcbmltcG9ydCB7IERhdGVNYXJrZXIsIGFkZE1zLCBhZGREYXlzIH0gZnJvbSAnLi4vZGF0ZWxpYi9tYXJrZXInXG5pbXBvcnQgeyBDYWxlbmRhckNvbnRleHQgfSBmcm9tICcuLi9DYWxlbmRhckNvbnRleHQnXG5pbXBvcnQgeyBleHBhbmRSZWN1cnJpbmcgfSBmcm9tICcuLi9zdHJ1Y3RzL3JlY3VycmluZy1ldmVudCdcblxuZXhwb3J0IGludGVyZmFjZSBTbGljZWFibGVQcm9wcyB7XG4gIGRhdGVTZWxlY3Rpb246IERhdGVTcGFuXG4gIGJ1c2luZXNzSG91cnM6IEV2ZW50U3RvcmVcbiAgZXZlbnRTdG9yZTogRXZlbnRTdG9yZVxuICBldmVudERyYWc6IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSB8IG51bGxcbiAgZXZlbnRSZXNpemU6IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSB8IG51bGxcbiAgZXZlbnRTZWxlY3Rpb246IHN0cmluZ1xuICBldmVudFVpQmFzZXM6IEV2ZW50VWlIYXNoXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpY2VkUHJvcHM8U2VnVHlwZSBleHRlbmRzIFNlZz4ge1xuICBkYXRlU2VsZWN0aW9uU2VnczogU2VnVHlwZVtdXG4gIGJ1c2luZXNzSG91clNlZ3M6IFNlZ1R5cGVbXVxuICBmZ0V2ZW50U2VnczogU2VnVHlwZVtdXG4gIGJnRXZlbnRTZWdzOiBTZWdUeXBlW11cbiAgZXZlbnREcmFnOiBFdmVudFNlZ1VpSW50ZXJhY3Rpb25TdGF0ZSB8IG51bGxcbiAgZXZlbnRSZXNpemU6IEV2ZW50U2VnVWlJbnRlcmFjdGlvblN0YXRlIHwgbnVsbFxuICBldmVudFNlbGVjdGlvbjogc3RyaW5nXG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTbGljZXI8U2VnVHlwZSBleHRlbmRzIFNlZywgRXh0cmFBcmdzIGV4dGVuZHMgYW55W10gPSBbXT4ge1xuXG4gIHByaXZhdGUgc2xpY2VCdXNpbmVzc0hvdXJzID0gbWVtb2l6ZSh0aGlzLl9zbGljZUJ1c2luZXNzSG91cnMpXG4gIHByaXZhdGUgc2xpY2VEYXRlU2VsZWN0aW9uID0gbWVtb2l6ZSh0aGlzLl9zbGljZURhdGVTcGFuKVxuICBwcml2YXRlIHNsaWNlRXZlbnRTdG9yZSA9IG1lbW9pemUodGhpcy5fc2xpY2VFdmVudFN0b3JlKVxuICBwcml2YXRlIHNsaWNlRXZlbnREcmFnID0gbWVtb2l6ZSh0aGlzLl9zbGljZUludGVyYWN0aW9uKVxuICBwcml2YXRlIHNsaWNlRXZlbnRSZXNpemUgPSBtZW1vaXplKHRoaXMuX3NsaWNlSW50ZXJhY3Rpb24pXG5cbiAgYWJzdHJhY3Qgc2xpY2VSYW5nZShkYXRlUmFuZ2U6IERhdGVSYW5nZSwgLi4uZXh0cmFBcmdzOiBFeHRyYUFyZ3MpOiBTZWdUeXBlW11cbiAgcHJvdGVjdGVkIGZvcmNlRGF5SWZMaXN0SXRlbSA9IGZhbHNlIC8vIGhhY2tcblxuICBzbGljZVByb3BzKFxuICAgIHByb3BzOiBTbGljZWFibGVQcm9wcyxcbiAgICBkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGUsXG4gICAgbmV4dERheVRocmVzaG9sZDogRHVyYXRpb24gfCBudWxsLFxuICAgIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCxcbiAgICAuLi5leHRyYUFyZ3M6IEV4dHJhQXJnc1xuICApOiBTbGljZWRQcm9wczxTZWdUeXBlPiB7XG4gICAgbGV0IHsgZXZlbnRVaUJhc2VzIH0gPSBwcm9wc1xuICAgIGxldCBldmVudFNlZ3MgPSB0aGlzLnNsaWNlRXZlbnRTdG9yZShwcm9wcy5ldmVudFN0b3JlLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCAuLi5leHRyYUFyZ3MpXG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0ZVNlbGVjdGlvblNlZ3M6IHRoaXMuc2xpY2VEYXRlU2VsZWN0aW9uKHByb3BzLmRhdGVTZWxlY3Rpb24sIGV2ZW50VWlCYXNlcywgY29udGV4dCwgLi4uZXh0cmFBcmdzKSxcbiAgICAgIGJ1c2luZXNzSG91clNlZ3M6IHRoaXMuc2xpY2VCdXNpbmVzc0hvdXJzKHByb3BzLmJ1c2luZXNzSG91cnMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0LCAuLi5leHRyYUFyZ3MpLFxuICAgICAgZmdFdmVudFNlZ3M6IGV2ZW50U2Vncy5mZyxcbiAgICAgIGJnRXZlbnRTZWdzOiBldmVudFNlZ3MuYmcsXG4gICAgICBldmVudERyYWc6IHRoaXMuc2xpY2VFdmVudERyYWcocHJvcHMuZXZlbnREcmFnLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCAuLi5leHRyYUFyZ3MpLFxuICAgICAgZXZlbnRSZXNpemU6IHRoaXMuc2xpY2VFdmVudFJlc2l6ZShwcm9wcy5ldmVudFJlc2l6ZSwgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgLi4uZXh0cmFBcmdzKSxcbiAgICAgIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvblxuICAgIH0gLy8gVE9ETzogZ2l2ZSBpbnRlcmFjdGlvblNlZ3M/XG4gIH1cblxuICBzbGljZU5vd0RhdGUoIC8vIGRvZXMgbm90IG1lbW9pemVcbiAgICBkYXRlOiBEYXRlTWFya2VyLFxuICAgIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCxcbiAgICAuLi5leHRyYUFyZ3M6IEV4dHJhQXJnc1xuICApOiBTZWdUeXBlW10ge1xuICAgIHJldHVybiB0aGlzLl9zbGljZURhdGVTcGFuKFxuICAgICAgeyByYW5nZTogeyBzdGFydDogZGF0ZSwgZW5kOiBhZGRNcyhkYXRlLCAxKSB9LCBhbGxEYXk6IGZhbHNlIH0sIC8vIGFkZCAxIG1zLCBwcm90ZWN0IGFnYWluc3QgbnVsbCByYW5nZVxuICAgICAge30sXG4gICAgICBjb250ZXh0LFxuICAgICAgLi4uZXh0cmFBcmdzXG4gICAgKVxuICB9XG5cbiAgcHJpdmF0ZSBfc2xpY2VCdXNpbmVzc0hvdXJzKFxuICAgIGJ1c2luZXNzSG91cnM6IEV2ZW50U3RvcmUsXG4gICAgZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlLFxuICAgIG5leHREYXlUaHJlc2hvbGQ6IER1cmF0aW9uIHwgbnVsbCxcbiAgICBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQsXG4gICAgLi4uZXh0cmFBcmdzOiBFeHRyYUFyZ3NcbiAgKTogU2VnVHlwZVtdIHtcbiAgICBpZiAoIWJ1c2luZXNzSG91cnMpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zbGljZUV2ZW50U3RvcmUoXG4gICAgICBleHBhbmRSZWN1cnJpbmcoXG4gICAgICAgIGJ1c2luZXNzSG91cnMsXG4gICAgICAgIGNvbXB1dGVBY3RpdmVSYW5nZShkYXRlUHJvZmlsZSwgQm9vbGVhbihuZXh0RGF5VGhyZXNob2xkKSksXG4gICAgICAgIGNvbnRleHRcbiAgICAgICksXG4gICAgICB7fSxcbiAgICAgIGRhdGVQcm9maWxlLFxuICAgICAgbmV4dERheVRocmVzaG9sZCxcbiAgICAgIC4uLmV4dHJhQXJnc1xuICAgICkuYmdcbiAgfVxuXG4gIHByaXZhdGUgX3NsaWNlRXZlbnRTdG9yZShcbiAgICBldmVudFN0b3JlOiBFdmVudFN0b3JlLFxuICAgIGV2ZW50VWlCYXNlczogRXZlbnRVaUhhc2gsXG4gICAgZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlLFxuICAgIG5leHREYXlUaHJlc2hvbGQ6IER1cmF0aW9uIHwgbnVsbCxcbiAgICAuLi5leHRyYUFyZ3M6IEV4dHJhQXJnc1xuICApOiB7IGJnOiBTZWdUeXBlW10sIGZnOiBTZWdUeXBlW10gfSB7XG4gICAgaWYgKGV2ZW50U3RvcmUpIHtcbiAgICAgIGxldCByYW5nZVJlcyA9IHNsaWNlRXZlbnRTdG9yZShcbiAgICAgICAgZXZlbnRTdG9yZSxcbiAgICAgICAgZXZlbnRVaUJhc2VzLFxuICAgICAgICBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpLFxuICAgICAgICBuZXh0RGF5VGhyZXNob2xkXG4gICAgICApXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJnOiB0aGlzLnNsaWNlRXZlbnRSYW5nZXMocmFuZ2VSZXMuYmcsIGV4dHJhQXJncyksXG4gICAgICAgIGZnOiB0aGlzLnNsaWNlRXZlbnRSYW5nZXMocmFuZ2VSZXMuZmcsIGV4dHJhQXJncylcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyBiZzogW10sIGZnOiBbXSB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfc2xpY2VJbnRlcmFjdGlvbihcbiAgICBpbnRlcmFjdGlvbjogRXZlbnRJbnRlcmFjdGlvblN0YXRlLFxuICAgIGV2ZW50VWlCYXNlczogRXZlbnRVaUhhc2gsXG4gICAgZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlLFxuICAgIG5leHREYXlUaHJlc2hvbGQ6IER1cmF0aW9uIHwgbnVsbCxcbiAgICAuLi5leHRyYUFyZ3M6IEV4dHJhQXJnc1xuICApOiBFdmVudFNlZ1VpSW50ZXJhY3Rpb25TdGF0ZSB7XG4gICAgaWYgKCFpbnRlcmFjdGlvbikge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBsZXQgcmFuZ2VSZXMgPSBzbGljZUV2ZW50U3RvcmUoXG4gICAgICBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzLFxuICAgICAgZXZlbnRVaUJhc2VzLFxuICAgICAgY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlLCBCb29sZWFuKG5leHREYXlUaHJlc2hvbGQpKSxcbiAgICAgIG5leHREYXlUaHJlc2hvbGRcbiAgICApXG5cbiAgICByZXR1cm4ge1xuICAgICAgc2VnczogdGhpcy5zbGljZUV2ZW50UmFuZ2VzKHJhbmdlUmVzLmZnLCBleHRyYUFyZ3MpLFxuICAgICAgYWZmZWN0ZWRJbnN0YW5jZXM6IGludGVyYWN0aW9uLmFmZmVjdGVkRXZlbnRzLmluc3RhbmNlcyxcbiAgICAgIGlzRXZlbnQ6IGludGVyYWN0aW9uLmlzRXZlbnRcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9zbGljZURhdGVTcGFuKFxuICAgIGRhdGVTcGFuOiBEYXRlU3BhbixcbiAgICBldmVudFVpQmFzZXM6IEV2ZW50VWlIYXNoLFxuICAgIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCxcbiAgICAuLi5leHRyYUFyZ3M6IEV4dHJhQXJnc1xuICApOiBTZWdUeXBlW10ge1xuICAgIGlmICghZGF0ZVNwYW4pIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIGxldCBldmVudFJhbmdlID0gZmFicmljYXRlRXZlbnRSYW5nZShkYXRlU3BhbiwgZXZlbnRVaUJhc2VzLCBjb250ZXh0KVxuICAgIGxldCBzZWdzID0gdGhpcy5zbGljZVJhbmdlKGRhdGVTcGFuLnJhbmdlLCAuLi5leHRyYUFyZ3MpXG5cbiAgICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xuICAgICAgc2VnLmV2ZW50UmFuZ2UgPSBldmVudFJhbmdlXG4gICAgfVxuXG4gICAgcmV0dXJuIHNlZ3NcbiAgfVxuXG4gIC8qXG4gIFwiY29tcGxldGVcIiBzZWcgbWVhbnMgaXQgaGFzIGNvbXBvbmVudCBhbmQgZXZlbnRSYW5nZVxuICAqL1xuICBwcml2YXRlIHNsaWNlRXZlbnRSYW5nZXMoXG4gICAgZXZlbnRSYW5nZXM6IEV2ZW50UmVuZGVyUmFuZ2VbXSxcbiAgICBleHRyYUFyZ3M6IEV4dHJhQXJnc1xuICApOiBTZWdUeXBlW10ge1xuICAgIGxldCBzZWdzOiBTZWdUeXBlW10gPSBbXVxuXG4gICAgZm9yIChsZXQgZXZlbnRSYW5nZSBvZiBldmVudFJhbmdlcykge1xuICAgICAgc2Vncy5wdXNoKC4uLnRoaXMuc2xpY2VFdmVudFJhbmdlKGV2ZW50UmFuZ2UsIGV4dHJhQXJncykpXG4gICAgfVxuXG4gICAgcmV0dXJuIHNlZ3NcbiAgfVxuXG4gIC8qXG4gIFwiY29tcGxldGVcIiBzZWcgbWVhbnMgaXQgaGFzIGNvbXBvbmVudCBhbmQgZXZlbnRSYW5nZVxuICAqL1xuICBwcml2YXRlIHNsaWNlRXZlbnRSYW5nZShcbiAgICBldmVudFJhbmdlOiBFdmVudFJlbmRlclJhbmdlLFxuICAgIGV4dHJhQXJnczogRXh0cmFBcmdzXG4gICk6IFNlZ1R5cGVbXSB7XG4gICAgbGV0IGRhdGVSYW5nZSA9IGV2ZW50UmFuZ2UucmFuZ2VcblxuICAgIC8vIGhhY2sgdG8gbWFrZSBtdWx0aS1kYXkgZXZlbnRzIHRoYXQgYXJlIGJlaW5nIGZvcmNlLWRpc3BsYXllZCBhcyBsaXN0LWl0ZW1zIHRvIHRha2UgdXAgb25seSBvbmUgZGF5XG4gICAgaWYgKHRoaXMuZm9yY2VEYXlJZkxpc3RJdGVtICYmIGV2ZW50UmFuZ2UudWkuZGlzcGxheSA9PT0gJ2xpc3QtaXRlbScpIHtcbiAgICAgIGRhdGVSYW5nZSA9IHtcbiAgICAgICAgc3RhcnQ6IGRhdGVSYW5nZS5zdGFydCxcbiAgICAgICAgZW5kOiBhZGREYXlzKGRhdGVSYW5nZS5zdGFydCwgMSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgc2VncyA9IHRoaXMuc2xpY2VSYW5nZShkYXRlUmFuZ2UsIC4uLmV4dHJhQXJncylcblxuICAgIGZvciAobGV0IHNlZyBvZiBzZWdzKSB7XG4gICAgICBzZWcuZXZlbnRSYW5nZSA9IGV2ZW50UmFuZ2VcbiAgICAgIHNlZy5pc1N0YXJ0ID0gZXZlbnRSYW5nZS5pc1N0YXJ0ICYmIHNlZy5pc1N0YXJ0XG4gICAgICBzZWcuaXNFbmQgPSBldmVudFJhbmdlLmlzRW5kICYmIHNlZy5pc0VuZFxuICAgIH1cblxuICAgIHJldHVybiBzZWdzXG4gIH1cblxufVxuXG4vKlxuZm9yIGluY29ycG9yYXRpbmcgc2xvdE1pblRpbWUvc2xvdE1heFRpbWUgaWYgYXBwcm9wcmlhdGVcblRPRE86IHNob3VsZCBiZSBwYXJ0IG9mIERhdGVQcm9maWxlIVxuVGltZWxpbmVEYXRlUHJvZmlsZSBhbHJlYWR5IGRvZXMgdGhpcyBidHdcbiovXG5mdW5jdGlvbiBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlLCBpc0NvbXBvbmVudEFsbERheTogYm9vbGVhbik6IERhdGVSYW5nZSB7XG4gIGxldCByYW5nZSA9IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlXG5cbiAgaWYgKGlzQ29tcG9uZW50QWxsRGF5KSB7XG4gICAgcmV0dXJuIHJhbmdlXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBhZGRNcyhyYW5nZS5zdGFydCwgZGF0ZVByb2ZpbGUuc2xvdE1pblRpbWUubWlsbGlzZWNvbmRzKSxcbiAgICBlbmQ6IGFkZE1zKHJhbmdlLmVuZCwgZGF0ZVByb2ZpbGUuc2xvdE1heFRpbWUubWlsbGlzZWNvbmRzIC0gODY0ZTUpIC8vIDg2NGU1ID0gbXMgaW4gYSBkYXlcbiAgfVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgQ29tcG9uZW50Q2hpbGRyZW4sIFJlZiB9IGZyb20gJy4uL3Zkb20nXG5pbXBvcnQgeyBCYXNlQ29tcG9uZW50LCBzZXRSZWYgfSBmcm9tICcuLi92ZG9tLXV0aWwnXG5pbXBvcnQgeyBDc3NEaW1WYWx1ZSwgU2Nyb2xsZXJMaWtlIH0gZnJvbSAnLi91dGlsJ1xuXG5cbmV4cG9ydCB0eXBlIE92ZXJmbG93VmFsdWUgPSAnYXV0bycgfCAnaGlkZGVuJyB8ICdzY3JvbGwnIHwgJ3Zpc2libGUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgU2Nyb2xsZXJQcm9wcyB7XG4gIG92ZXJmbG93WDogT3ZlcmZsb3dWYWx1ZVxuICBvdmVyZmxvd1k6IE92ZXJmbG93VmFsdWVcbiAgb3ZlcmNvbWVMZWZ0PzogbnVtYmVyXG4gIG92ZXJjb21lUmlnaHQ/OiBudW1iZXJcbiAgb3ZlcmNvbWVCb3R0b20/OiBudW1iZXJcbiAgbWF4SGVpZ2h0PzogQ3NzRGltVmFsdWVcbiAgbGlxdWlkPzogYm9vbGVhblxuICBsaXF1aWRJc0Fic29sdXRlPzogYm9vbGVhblxuICBjaGlsZHJlbj86IENvbXBvbmVudENoaWxkcmVuXG4gIGVsUmVmPzogUmVmPEhUTUxFbGVtZW50PlxufVxuXG5jb25zdCBWSVNJQkxFX0hJRERFTl9SRSA9IC9eKHZpc2libGV8aGlkZGVuKSQvXG5cblxuZXhwb3J0IGNsYXNzIFNjcm9sbGVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudDxTY3JvbGxlclByb3BzPiBpbXBsZW1lbnRzIFNjcm9sbGVyTGlrZSB7XG5cbiAgcHJpdmF0ZSBlbDogSFRNTEVsZW1lbnQgLy8gVE9ETzoganVzdCB1c2UgdGhpcy5iYXNlP1xuXG5cbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IHByb3BzIH0gPSB0aGlzXG4gICAgbGV0IHsgbGlxdWlkLCBsaXF1aWRJc0Fic29sdXRlIH0gPSBwcm9wc1xuICAgIGxldCBpc0Fic29sdXRlID0gbGlxdWlkICYmIGxpcXVpZElzQWJzb2x1dGVcbiAgICBsZXQgY2xhc3NOYW1lID0gWyAnZmMtc2Nyb2xsZXInIF1cblxuICAgIGlmIChsaXF1aWQpIHtcbiAgICAgIGlmIChsaXF1aWRJc0Fic29sdXRlKSB7XG4gICAgICAgIGNsYXNzTmFtZS5wdXNoKCdmYy1zY3JvbGxlci1saXF1aWQtYWJzb2x1dGUnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xhc3NOYW1lLnB1c2goJ2ZjLXNjcm9sbGVyLWxpcXVpZCcpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgcmVmPXt0aGlzLmhhbmRsZUVsfSBjbGFzc05hbWU9e2NsYXNzTmFtZS5qb2luKCcgJyl9IHN0eWxlPXt7XG4gICAgICAgIG92ZXJmbG93WDogcHJvcHMub3ZlcmZsb3dYLFxuICAgICAgICBvdmVyZmxvd1k6IHByb3BzLm92ZXJmbG93WSxcbiAgICAgICAgbGVmdDogKGlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZUxlZnQgfHwgMCkpIHx8ICcnLFxuICAgICAgICByaWdodDogKGlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZVJpZ2h0IHx8IDApKSB8fCAnJyxcbiAgICAgICAgYm90dG9tOiAoaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lQm90dG9tIHx8IDApKSB8fCAnJyxcbiAgICAgICAgbWFyZ2luTGVmdDogKCFpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVMZWZ0IHx8IDApKSB8fCAnJyxcbiAgICAgICAgbWFyZ2luUmlnaHQ6ICghaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lUmlnaHQgfHwgMCkpIHx8ICcnLFxuICAgICAgICBtYXJnaW5Cb3R0b206ICghaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lQm90dG9tIHx8IDApKSB8fCAnJyxcbiAgICAgICAgbWF4SGVpZ2h0OiBwcm9wcy5tYXhIZWlnaHQgfHwgJydcbiAgICAgIH19Pntwcm9wcy5jaGlsZHJlbn08L2Rpdj5cbiAgICApXG4gIH1cblxuXG4gIGhhbmRsZUVsID0gKGVsOiBIVE1MRWxlbWVudCkgPT4ge1xuICAgIHRoaXMuZWwgPSBlbFxuICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBlbClcbiAgfVxuXG5cbiAgbmVlZHNYU2Nyb2xsaW5nKCkge1xuICAgIGlmIChWSVNJQkxFX0hJRERFTl9SRS50ZXN0KHRoaXMucHJvcHMub3ZlcmZsb3dYKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gdGVzdGluZyBzY3JvbGxXaWR0aD5jbGllbnRXaWR0aCBpcyB1bnJlbGlhYmxlIGNyb3NzLWJyb3dzZXIgd2hlbiBwaXhlbCBoZWlnaHRzIGFyZW4ndCBpbnRlZ2Vycy5cbiAgICAvLyBtdWNoIG1vcmUgcmVsaWFibGUgdG8gc2VlIGlmIGNoaWxkcmVuIGFyZSB0YWxsZXIgdGhhbiB0aGUgc2Nyb2xsZXIsIGV2ZW4gdGhvIGRvZXNuJ3QgYWNjb3VudCBmb3JcbiAgICAvLyBpbm5lci1jaGlsZCBtYXJnaW5zIGFuZCBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuXG4gICAgbGV0IHsgZWwgfSA9IHRoaXNcbiAgICBsZXQgcmVhbENsaWVudFdpZHRoID0gdGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAtIHRoaXMuZ2V0WVNjcm9sbGJhcldpZHRoKClcbiAgICBsZXQgeyBjaGlsZHJlbiB9ID0gZWxcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBjaGlsZEVsID0gY2hpbGRyZW5baV1cblxuICAgICAgaWYgKGNoaWxkRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggPiByZWFsQ2xpZW50V2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG5cbiAgbmVlZHNZU2Nyb2xsaW5nKCkge1xuICAgIGlmIChWSVNJQkxFX0hJRERFTl9SRS50ZXN0KHRoaXMucHJvcHMub3ZlcmZsb3dZKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gdGVzdGluZyBzY3JvbGxIZWlnaHQ+Y2xpZW50SGVpZ2h0IGlzIHVucmVsaWFibGUgY3Jvc3MtYnJvd3NlciB3aGVuIHBpeGVsIGhlaWdodHMgYXJlbid0IGludGVnZXJzLlxuICAgIC8vIG11Y2ggbW9yZSByZWxpYWJsZSB0byBzZWUgaWYgY2hpbGRyZW4gYXJlIHRhbGxlciB0aGFuIHRoZSBzY3JvbGxlciwgZXZlbiB0aG8gZG9lc24ndCBhY2NvdW50IGZvclxuICAgIC8vIGlubmVyLWNoaWxkIG1hcmdpbnMgYW5kIGFic29sdXRlIHBvc2l0aW9uaW5nXG5cbiAgICBsZXQgeyBlbCB9ID0gdGhpc1xuICAgIGxldCByZWFsQ2xpZW50SGVpZ2h0ID0gdGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgLSB0aGlzLmdldFhTY3JvbGxiYXJXaWR0aCgpXG4gICAgbGV0IHsgY2hpbGRyZW4gfSA9IGVsXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgY2hpbGRFbCA9IGNoaWxkcmVuW2ldXG5cbiAgICAgIGlmIChjaGlsZEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCA+IHJlYWxDbGllbnRIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG5cbiAgZ2V0WFNjcm9sbGJhcldpZHRoKCkge1xuICAgIGlmIChWSVNJQkxFX0hJRERFTl9SRS50ZXN0KHRoaXMucHJvcHMub3ZlcmZsb3dYKSkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZWwub2Zmc2V0SGVpZ2h0IC0gdGhpcy5lbC5jbGllbnRIZWlnaHQgLy8gb25seSB3b3JrcyBiZWNhdXNlIHdlIGd1YXJhbnRlZSBubyBib3JkZXJzLiBUT0RPOiBhZGQgdG8gQ1NTIHdpdGggaW1wb3J0YW50P1xuICAgIH1cbiAgfVxuXG5cbiAgZ2V0WVNjcm9sbGJhcldpZHRoKCkge1xuICAgIGlmIChWSVNJQkxFX0hJRERFTl9SRS50ZXN0KHRoaXMucHJvcHMub3ZlcmZsb3dZKSkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZWwub2Zmc2V0V2lkdGggLSB0aGlzLmVsLmNsaWVudFdpZHRoIC8vIG9ubHkgd29ya3MgYmVjYXVzZSB3ZSBndWFyYW50ZWUgbm8gYm9yZGVycy4gVE9ETzogYWRkIHRvIENTUyB3aXRoIGltcG9ydGFudD9cbiAgICB9XG4gIH1cblxufVxuIiwiaW1wb3J0IHsgaGFzaFZhbHVlc1RvQXJyYXksIGNvbGxlY3RGcm9tSGFzaCB9IGZyb20gJy4vb2JqZWN0J1xuXG4vKlxuVE9ETzogc29tZWhvdyBpbmZlciBPdGhlckFyZ3MgZnJvbSBtYXN0ZXJDYWxsYmFjaz9cblRPRE86IGluZmVyIFJlZlR5cGUgZnJvbSBtYXN0ZXJDYWxsYmFjayBpZiBwcm92aWRlZFxuKi9cbmV4cG9ydCBjbGFzcyBSZWZNYXA8UmVmVHlwZT4ge1xuXG4gIHB1YmxpYyBjdXJyZW50TWFwOiB7IFtrZXk6IHN0cmluZ106IFJlZlR5cGUgfSA9IHt9XG4gIHByaXZhdGUgZGVwdGhzOiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9ID0ge31cbiAgcHJpdmF0ZSBjYWxsYmFja01hcDogeyBba2V5OiBzdHJpbmddOiAodmFsOiBSZWZUeXBlIHwgbnVsbCkgPT4gdm9pZCB9ID0ge31cblxuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBtYXN0ZXJDYWxsYmFjaz86ICh2YWw6IFJlZlR5cGUgfCBudWxsLCBrZXk6IHN0cmluZykgPT4gdm9pZCkge1xuICB9XG5cblxuICBjcmVhdGVSZWYoa2V5OiBzdHJpbmcgfCBudW1iZXIpIHtcbiAgICBsZXQgcmVmQ2FsbGJhY2sgPSB0aGlzLmNhbGxiYWNrTWFwW2tleV1cblxuICAgIGlmICghcmVmQ2FsbGJhY2spIHtcbiAgICAgIHJlZkNhbGxiYWNrID0gdGhpcy5jYWxsYmFja01hcFtrZXldID0gKHZhbDogUmVmVHlwZSB8IG51bGwpID0+IHtcbiAgICAgICAgdGhpcy5oYW5kbGVWYWx1ZSh2YWwsIFN0cmluZyhrZXkpKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZWZDYWxsYmFja1xuICB9XG5cblxuICBoYW5kbGVWYWx1ZSA9ICh2YWw6IFJlZlR5cGUgfCBudWxsLCBrZXk6IHN0cmluZykgPT4geyAvLyBiaW5kIGluIGNhc2UgdXNlcnMgd2FudCB0byBwYXNzIGl0IGFyb3VuZFxuICAgIGxldCB7IGRlcHRocywgY3VycmVudE1hcCB9ID0gdGhpc1xuICAgIGxldCByZW1vdmVkID0gZmFsc2VcbiAgICBsZXQgYWRkZWQgPSBmYWxzZVxuXG4gICAgaWYgKHZhbCAhPT0gbnVsbCkge1xuICAgICAgcmVtb3ZlZCA9IChrZXkgaW4gY3VycmVudE1hcCkgLy8gZm9yIGJ1Zy4uLiBBQ1RVQUxMWTogY2FuIHByb2JhYmx5IGRvIGF3YXkgd2l0aCB0aGlzIG5vdyB0aGF0IGNhbGxlcnMgZG9uJ3Qgc2hhcmUgbnVtZXJpYyBpbmRpY2VzIGFueW1vcmVcbiAgICAgIGN1cnJlbnRNYXBba2V5XSA9IHZhbFxuICAgICAgZGVwdGhzW2tleV0gPSAoZGVwdGhzW2tleV0gfHwgMCkgKyAxXG4gICAgICBhZGRlZCA9IHRydWVcblxuICAgIH0gZWxzZSBpZiAoLS1kZXB0aHNba2V5XSA9PT0gMCkge1xuICAgICAgZGVsZXRlIGN1cnJlbnRNYXBba2V5XVxuICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tNYXBba2V5XVxuICAgICAgcmVtb3ZlZCA9IHRydWVcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tYXN0ZXJDYWxsYmFjaykge1xuICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgdGhpcy5tYXN0ZXJDYWxsYmFjayhudWxsLCBTdHJpbmcoa2V5KSlcbiAgICAgIH1cbiAgICAgIGlmIChhZGRlZCkge1xuICAgICAgICB0aGlzLm1hc3RlckNhbGxiYWNrKHZhbCwgU3RyaW5nKGtleSkpXG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICAvLyBUT0RPOiBjaGVjayBjYWxsZXJzIHRoYXQgZG9uJ3QgY2FyZSBhYm91dCBvcmRlci4gc2hvdWxkIHVzZSBnZXRBbGwgaW5zdGVhZFxuICAvLyBOT1RFOiB0aGlzIG1ldGhvZCBoYXMgYmVjb21lIGxlc3MgdmFsdWFibGUgbm93IHRoYXQgd2UgYXJlIGVuY291cmFnZWQgdG8gbWFwIG9yZGVyIGJ5IHNvbWUgb3RoZXIgaW5kZXhcbiAgLy8gVE9ETzogcHJvdmlkZSBPTkUgYXJyYXktZXhwb3J0IGZ1bmN0aW9uLCBidWlsZEFycmF5LCB3aGljaCBmYWlscyBvbiBub24tbnVtZXJpYyBpbmRleGVzLiBjYWxsZXIgY2FuIG1hbmlwdWxhdGUgYW5kIFwiY29sbGVjdFwiXG4gIGNvbGxlY3QoXG4gICAgc3RhcnRJbmRleD86IG51bWJlcixcbiAgICBlbmRJbmRleD86IG51bWJlcixcbiAgICBzdGVwPzogbnVtYmVyXG4gICkge1xuICAgIHJldHVybiBjb2xsZWN0RnJvbUhhc2godGhpcy5jdXJyZW50TWFwLCBzdGFydEluZGV4LCBlbmRJbmRleCwgc3RlcClcbiAgfVxuXG5cbiAgZ2V0QWxsKCk6IFJlZlR5cGVbXSB7IC8vIHJldHVybnMgaW4gbm8gcGFydGljYWwgb3JkZXIhXG4gICAgcmV0dXJuIGhhc2hWYWx1ZXNUb0FycmF5KHRoaXMuY3VycmVudE1hcClcbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBWTm9kZSwgY3JlYXRlRWxlbWVudCwgUmVmIH0gZnJvbSAnLi4vdmRvbSdcbmltcG9ydCB7IGZpbmRFbGVtZW50cyB9IGZyb20gJy4uL3V0aWwvZG9tLW1hbmlwJ1xuaW1wb3J0IHsgVmlld0NvbnRleHQgfSBmcm9tICcuLi9WaWV3Q29udGV4dCdcbmltcG9ydCB7IGNvbXB1dGVTbWFsbGVzdENlbGxXaWR0aCB9IGZyb20gJy4uL3V0aWwvbWlzYydcbmltcG9ydCB7IGlzUHJvcHNFcXVhbCB9IGZyb20gJy4uL3V0aWwvb2JqZWN0J1xuaW1wb3J0IHsgaXNBcnJheXNFcXVhbCB9IGZyb20gJy4uL3V0aWwvYXJyYXknXG5pbXBvcnQgeyBCYXNlT3B0aW9uc1JlZmluZWQgfSBmcm9tICcuLi9vcHRpb25zJ1xuXG5cbmV4cG9ydCB0eXBlIENzc0RpbVZhbHVlID0gc3RyaW5nIHwgbnVtYmVyIC8vIFRPRE86IG1vdmUgdG8gbW9yZSBnZW5lcmFsIGZpbGVcblxuXG5leHBvcnQgaW50ZXJmYWNlIENvbFByb3BzIHtcbiAgd2lkdGg/OiBDc3NEaW1WYWx1ZVxuICBtaW5XaWR0aD86IENzc0RpbVZhbHVlXG4gIHNwYW4/OiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZWN0aW9uQ29uZmlnIHtcbiAgb3V0ZXJDb250ZW50PzogVk5vZGVcbiAgdHlwZTogJ2JvZHknIHwgJ2hlYWRlcicgfCAnZm9vdGVyJ1xuICBjbGFzc05hbWU/OiBzdHJpbmdcbiAgbWF4SGVpZ2h0PzogbnVtYmVyXG4gIGxpcXVpZD86IGJvb2xlYW5cbiAgZXhwYW5kUm93cz86IGJvb2xlYW4gLy8gVE9ETzogaG93IHRvIGdldCBhIGJvdHRvbSBydWxlP1xuICBzeW5jUm93SGVpZ2h0cz86IGJvb2xlYW4gLy8geXVja1xuICBpc1N0aWNreT86IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgQ2h1bmtDb25maWdDb250ZW50ID0gKGNvbnRlbnRQcm9wczogQ2h1bmtDb250ZW50Q2FsbGJhY2tBcmdzKSA9PiBWTm9kZVxuZXhwb3J0IHR5cGUgQ2h1bmtDb25maWdSb3dDb250ZW50ID0gVk5vZGUgfCBDaHVua0NvbmZpZ0NvbnRlbnRcblxuZXhwb3J0IGludGVyZmFjZSBDaHVua0NvbmZpZyB7XG4gIG91dGVyQ29udGVudD86IFZOb2RlXG4gIGNvbnRlbnQ/OiBDaHVua0NvbmZpZ0NvbnRlbnRcbiAgcm93Q29udGVudD86IENodW5rQ29uZmlnUm93Q29udGVudFxuICBzY3JvbGxlckVsUmVmPzogUmVmPEhUTUxEaXZFbGVtZW50PlxuICBlbFJlZj86IFJlZjxIVE1MVGFibGVDZWxsRWxlbWVudD5cbiAgdGFibGVDbGFzc05hbWU/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaHVua0NvbnRlbnRDYWxsYmFja0FyZ3MgeyAvLyBUT0RPOiB1dGlsIGZvciB3cmFwcGluZyB0YWJsZXMhP1xuICB0YWJsZUNvbEdyb3VwTm9kZTogVk5vZGVcbiAgdGFibGVNaW5XaWR0aDogQ3NzRGltVmFsdWVcbiAgY2xpZW50V2lkdGg6IG51bWJlciB8IG51bGwgLy8gaW1wb3J0YW50IHRvIGtub3cgd2hldGhlciAwIG9yIG5vdC15ZXQtZGV0ZXJtaW5lZC4gZm9yIGhlYWRsZXNzIHRlc3RpbmdcbiAgY2xpZW50SGVpZ2h0OiBudW1iZXJ8IG51bGwgLy9cbiAgZXhwYW5kUm93czogYm9vbGVhblxuICBzeW5jUm93SGVpZ2h0czogYm9vbGVhblxuICByb3dTeW5jSGVpZ2h0czogbnVtYmVyW11cbiAgcmVwb3J0Um93SGVpZ2h0Q2hhbmdlOiAocm93RWw6IEhUTUxFbGVtZW50LCBpc1N0YWJsZTogYm9vbGVhbikgPT4gdm9pZFxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlU2hyaW5rV2lkdGgoY2h1bmtFbHM6IEhUTUxFbGVtZW50W10pIHsgLy8gYWxsIGluIHNhbWUgQ09MIVxuICBsZXQgc2hyaW5rQ2VsbHMgPSBmaW5kRWxlbWVudHMoY2h1bmtFbHMsICcuZmMtc2Nyb2xsZ3JpZC1zaHJpbmsnKVxuICBsZXQgbGFyZ2VzdFdpZHRoID0gMFxuXG4gIGZvciAobGV0IHNocmlua0NlbGwgb2Ygc2hyaW5rQ2VsbHMpIHtcbiAgICBsYXJnZXN0V2lkdGggPSBNYXRoLm1heChcbiAgICAgIGxhcmdlc3RXaWR0aCxcbiAgICAgIGNvbXB1dGVTbWFsbGVzdENlbGxXaWR0aChzaHJpbmtDZWxsKVxuICAgIClcbiAgfVxuXG4gIHJldHVybiBNYXRoLmNlaWwobGFyZ2VzdFdpZHRoKSAvLyA8dGFibGU+IGVsZW1lbnRzIHdvcmsgYmVzdCB3aXRoIGludGVnZXJzLiByb3VuZCB1cCB0byBlbnN1cmUgY29udGVudHMgZml0c1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgU2Nyb2xsZXJMaWtlIHsgLy8gaGF2ZSBzY3JvbGxlcnMgaW1wbGVtZW50P1xuICBuZWVkc1lTY3JvbGxpbmcoKTogYm9vbGVhblxuICBuZWVkc1hTY3JvbGxpbmcoKTogYm9vbGVhblxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWN0aW9uSGFzTGlxdWlkSGVpZ2h0KHByb3BzOiB7IGxpcXVpZDogYm9vbGVhbiB9LCBzZWN0aW9uQ29uZmlnOiBTZWN0aW9uQ29uZmlnKSB7XG4gIHJldHVybiBwcm9wcy5saXF1aWQgJiYgc2VjdGlvbkNvbmZpZy5saXF1aWQgLy8gZG9lcyB0aGUgc2VjdGlvbiBkbyBsaXF1aWQtaGVpZ2h0PyAobmVlZCB0byBoYXZlIHdob2xlIHNjcm9sbGdyaWQgbGlxdWlkLWhlaWdodCBhcyB3ZWxsKVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxvd1lTY3JvbGxpbmcocHJvcHM6IHsgbGlxdWlkOiBib29sZWFuIH0sIHNlY3Rpb25Db25maWc6IFNlY3Rpb25Db25maWcpIHtcbiAgcmV0dXJuIHNlY3Rpb25Db25maWcubWF4SGVpZ2h0ICE9IG51bGwgfHwgLy8gaWYgaXRzIHBvc3NpYmxlIGZvciB0aGUgaGVpZ2h0IHRvIG1heCBvdXQsIHdlIG1pZ2h0IG5lZWQgc2Nyb2xsYmFyc1xuICAgIGdldFNlY3Rpb25IYXNMaXF1aWRIZWlnaHQocHJvcHMsIHNlY3Rpb25Db25maWcpIC8vIGlmIHRoZSBzZWN0aW9uIGlzIGxpcXVpZCBoZWlnaHQsIGl0IG1pZ2h0IGNvbmRlbnNlIGVub3VnaCB0byByZXF1aXJlIHNjcm9sbGJhcnNcbn1cblxuXG4vLyBUT0RPOiBPTkxZIHVzZSBgYXJnYC4gZm9yY2Ugb3V0IGludGVybmFsIGZ1bmN0aW9uIHRvIHVzZSBzYW1lIEFQSVxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlckNodW5rQ29udGVudChzZWN0aW9uQ29uZmlnOiBTZWN0aW9uQ29uZmlnLCBjaHVua0NvbmZpZzogQ2h1bmtDb25maWcsIGFyZzogQ2h1bmtDb250ZW50Q2FsbGJhY2tBcmdzKSB7XG4gIGxldCBleHBhbmRSb3dzID0gYXJnLmV4cGFuZFJvd3NcblxuICBsZXQgY29udGVudDogVk5vZGUgPSB0eXBlb2YgY2h1bmtDb25maWcuY29udGVudCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgY2h1bmtDb25maWcuY29udGVudChhcmcpIDpcbiAgICBjcmVhdGVFbGVtZW50KCd0YWJsZScsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogW1xuICAgICAgICAgIGNodW5rQ29uZmlnLnRhYmxlQ2xhc3NOYW1lLFxuICAgICAgICAgIHNlY3Rpb25Db25maWcuc3luY1Jvd0hlaWdodHMgPyAnZmMtc2Nyb2xsZ3JpZC1zeW5jLXRhYmxlJyA6ICcnXG4gICAgICAgIF0uam9pbignICcpLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIG1pbldpZHRoOiBhcmcudGFibGVNaW5XaWR0aCwgLy8gYmVjYXVzZSBjb2xNaW5XaWR0aHMgYXJlbnQgZW5vdWdoXG4gICAgICAgICAgd2lkdGg6IGFyZy5jbGllbnRXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGV4cGFuZFJvd3MgPyBhcmcuY2xpZW50SGVpZ2h0IDogJycgLy8gY3NzIGBoZWlnaHRgIG9uIGEgPHRhYmxlPiBzZXJ2ZXMgYXMgYSBtaW4taGVpZ2h0XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhcmcudGFibGVDb2xHcm91cE5vZGUsXG4gICAgICBjcmVhdGVFbGVtZW50KCd0Ym9keScsIHt9LCB0eXBlb2YgY2h1bmtDb25maWcucm93Q29udGVudCA9PT0gJ2Z1bmN0aW9uJyA/IGNodW5rQ29uZmlnLnJvd0NvbnRlbnQoYXJnKSA6IGNodW5rQ29uZmlnLnJvd0NvbnRlbnQpXG4gICAgKVxuXG4gIHJldHVybiBjb250ZW50XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29sUHJvcHNFcXVhbChjb2xzMDogQ29sUHJvcHNbXSwgY29sczE6IENvbFByb3BzW10pIHtcbiAgcmV0dXJuIGlzQXJyYXlzRXF1YWwoY29sczAsIGNvbHMxLCBpc1Byb3BzRXF1YWwpXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlck1pY3JvQ29sR3JvdXAoY29sczogQ29sUHJvcHNbXSwgc2hyaW5rV2lkdGg/OiBudW1iZXIpIHtcbiAgbGV0IGNvbE5vZGVzOiBWTm9kZVtdID0gW11cblxuICAvKlxuICBmb3IgQ29sUHJvcHMgd2l0aCBzcGFucywgaXQgd291bGQgaGF2ZSBiZWVuIGdyZWF0IHRvIG1ha2UgYSBzaW5nbGUgPGNvbCBzcGFuPVwiXCI+XG4gIEhPV0VWRVIsIENocm9tZSB3YXMgZ2V0dGluZyBtZXNzaW5nIHVwIGRpc3RyaWJ1dGluZyB0aGUgd2lkdGggdG8gPHRkPi88dGg+IGVsZW1lbnRzIHdpdGggY29sc3BhbnMuXG4gIFNPTFVUSU9OOiBtYWtpbmcgaW5kaXZpZHVhbCA8Y29sPiBlbGVtZW50cyBtYWtlcyBDaHJvbWUgYmVoYXZlLlxuICAqL1xuICBmb3IgKGxldCBjb2xQcm9wcyBvZiBjb2xzKSB7XG4gICAgbGV0IHNwYW4gPSBjb2xQcm9wcy5zcGFuIHx8IDFcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BhbjsgaSsrKSB7XG4gICAgICBjb2xOb2Rlcy5wdXNoKFxuICAgICAgICA8Y29sXG4gICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgIHdpZHRoOiBjb2xQcm9wcy53aWR0aCA9PT0gJ3NocmluaycgPyBzYW5pdGl6ZVNocmlua1dpZHRoKHNocmlua1dpZHRoKSA6IChjb2xQcm9wcy53aWR0aCB8fCAnJyksXG4gICAgICAgICAgICBtaW5XaWR0aDogY29sUHJvcHMubWluV2lkdGggfHwgJydcbiAgICAgICAgICB9fVxuICAgICAgICAvPlxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjcmVhdGVFbGVtZW50KCdjb2xncm91cCcsIHt9LCAuLi5jb2xOb2Rlcylcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVTaHJpbmtXaWR0aChzaHJpbmtXaWR0aD86IG51bWJlcikge1xuICAvKiB3aHkgND8gaWYgd2UgZG8gMCwgaXQgd2lsbCBraWxsIGFueSBib3JkZXIsIHdoaWNoIGFyZSBuZWVkZWQgZm9yIGNvbXB1dGVTbWFsbGVzdENlbGxXaWR0aFxuICA0IGFjY291bnRzIGZvciAyIDItcGl4ZWwgYm9yZGVycy4gVE9ETzogYmV0dGVyIHNvbHV0aW9uPyAqL1xuICByZXR1cm4gc2hyaW5rV2lkdGggPT0gbnVsbCA/IDQgOiBzaHJpbmtXaWR0aFxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNTaHJpbmtXaWR0aChjb2xzOiBDb2xQcm9wc1tdKSB7XG4gIGZvciAobGV0IGNvbCBvZiBjb2xzKSB7XG4gICAgaWYgKGNvbC53aWR0aCA9PT0gJ3NocmluaycpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjcm9sbEdyaWRDbGFzc05hbWVzKGxpcXVpZDogYm9vbGVhbiwgY29udGV4dDogVmlld0NvbnRleHQpIHtcbiAgbGV0IGNsYXNzTmFtZXMgPSBbXG4gICAgJ2ZjLXNjcm9sbGdyaWQnLFxuICAgIGNvbnRleHQudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlJylcbiAgXVxuXG4gIGlmIChsaXF1aWQpIHtcbiAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNjcm9sbGdyaWQtbGlxdWlkJylcbiAgfVxuXG4gIHJldHVybiBjbGFzc05hbWVzXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlY3Rpb25DbGFzc05hbWVzKHNlY3Rpb25Db25maWc6IFNlY3Rpb25Db25maWcsIHdob2xlVGFibGVWR3JvdzogYm9vbGVhbikge1xuICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAnZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uJyxcbiAgICBzZWN0aW9uQ29uZmlnLmNsYXNzTmFtZSAvLyB1c2VkP1xuICBdXG5cbiAgaWYgKHdob2xlVGFibGVWR3JvdyAmJiBzZWN0aW9uQ29uZmlnLmxpcXVpZCAmJiBzZWN0aW9uQ29uZmlnLm1heEhlaWdodCA9PSBudWxsKSB7XG4gICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zY3JvbGxncmlkLXNlY3Rpb24tbGlxdWlkJylcbiAgfVxuXG4gIGlmIChzZWN0aW9uQ29uZmlnLmlzU3RpY2t5KSB7XG4gICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zY3JvbGxncmlkLXNlY3Rpb24tc3RpY2t5JylcbiAgfVxuXG4gIHJldHVybiBjbGFzc05hbWVzXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlclNjcm9sbFNoaW0oYXJnOiBDaHVua0NvbnRlbnRDYWxsYmFja0FyZ3MpIHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT0nZmMtc2Nyb2xsZ3JpZC1zdGlja3ktc2hpbScgc3R5bGU9e3tcbiAgICAgIHdpZHRoOiBhcmcuY2xpZW50V2lkdGgsXG4gICAgICBtaW5XaWR0aDogYXJnLnRhYmxlTWluV2lkdGhcbiAgICB9fSAvPlxuICApXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0aWNreUhlYWRlckRhdGVzKG9wdGlvbnM6IEJhc2VPcHRpb25zUmVmaW5lZCkge1xuICBsZXQgeyBzdGlja3lIZWFkZXJEYXRlcyB9ID0gb3B0aW9uc1xuXG4gIGlmIChzdGlja3lIZWFkZXJEYXRlcyA9PSBudWxsIHx8IHN0aWNreUhlYWRlckRhdGVzID09PSAnYXV0bycpIHtcbiAgICBzdGlja3lIZWFkZXJEYXRlcyA9IG9wdGlvbnMuaGVpZ2h0ID09PSAnYXV0bycgfHwgb3B0aW9ucy52aWV3SGVpZ2h0ID09PSAnYXV0bydcbiAgfVxuXG4gIHJldHVybiBzdGlja3lIZWFkZXJEYXRlc1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIob3B0aW9uczogQmFzZU9wdGlvbnNSZWZpbmVkKSB7XG4gIGxldCB7IHN0aWNreUZvb3RlclNjcm9sbGJhciB9ID0gb3B0aW9uc1xuXG4gIGlmIChzdGlja3lGb290ZXJTY3JvbGxiYXIgPT0gbnVsbCB8fCBzdGlja3lGb290ZXJTY3JvbGxiYXIgPT09ICdhdXRvJykge1xuICAgIHN0aWNreUZvb3RlclNjcm9sbGJhciA9IG9wdGlvbnMuaGVpZ2h0ID09PSAnYXV0bycgfHwgb3B0aW9ucy52aWV3SGVpZ2h0ID09PSAnYXV0bydcbiAgfVxuXG4gIHJldHVybiBzdGlja3lGb290ZXJTY3JvbGxiYXJcbn1cbiIsImltcG9ydCB7IFZOb2RlLCBjcmVhdGVFbGVtZW50LCBGcmFnbWVudCB9IGZyb20gJy4uL3Zkb20nXG5pbXBvcnQgeyBCYXNlQ29tcG9uZW50LCBzZXRSZWYgfSBmcm9tICcuLi92ZG9tLXV0aWwnXG5pbXBvcnQgeyBTY3JvbGxlciwgT3ZlcmZsb3dWYWx1ZSB9IGZyb20gJy4vU2Nyb2xsZXInXG5pbXBvcnQgeyBSZWZNYXAgfSBmcm9tICcuLi91dGlsL1JlZk1hcCdcbmltcG9ydCB7XG4gIENvbFByb3BzLCBTZWN0aW9uQ29uZmlnLCByZW5kZXJNaWNyb0NvbEdyb3VwLCBjb21wdXRlU2hyaW5rV2lkdGgsIGdldFNjcm9sbEdyaWRDbGFzc05hbWVzLCBnZXRTZWN0aW9uQ2xhc3NOYW1lcywgZ2V0QWxsb3dZU2Nyb2xsaW5nLFxuICByZW5kZXJDaHVua0NvbnRlbnQsIGdldFNlY3Rpb25IYXNMaXF1aWRIZWlnaHQsIENodW5rQ29uZmlnLCBoYXNTaHJpbmtXaWR0aCwgQ3NzRGltVmFsdWUsXG4gIGlzQ29sUHJvcHNFcXVhbFxufSBmcm9tICcuL3V0aWwnXG5pbXBvcnQgeyBtZW1vaXplIH0gZnJvbSAnLi4vdXRpbC9tZW1vaXplJ1xuaW1wb3J0IHsgaXNQcm9wc0VxdWFsIH0gZnJvbSAnLi4vdXRpbC9vYmplY3QnXG5pbXBvcnQgeyBnZXRTY3JvbGxiYXJXaWR0aHMgfSBmcm9tICcuLi91dGlsL3Njcm9sbGJhci13aWR0aCdcblxuXG5leHBvcnQgaW50ZXJmYWNlIFNpbXBsZVNjcm9sbEdyaWRQcm9wcyB7XG4gIGNvbHM6IENvbFByb3BzW11cbiAgc2VjdGlvbnM6IFNpbXBsZVNjcm9sbEdyaWRTZWN0aW9uW11cbiAgbGlxdWlkOiBib29sZWFuXG4gIGhlaWdodD86IENzc0RpbVZhbHVlIC8vIFRPRE86IGdpdmUgdG8gcmVhbCBTY3JvbGxHcmlkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2ltcGxlU2Nyb2xsR3JpZFNlY3Rpb24gZXh0ZW5kcyBTZWN0aW9uQ29uZmlnIHtcbiAga2V5OiBzdHJpbmdcbiAgY2h1bms/OiBDaHVua0NvbmZpZ1xufVxuXG5pbnRlcmZhY2UgU2ltcGxlU2Nyb2xsR3JpZFN0YXRlIHtcbiAgc2hyaW5rV2lkdGg6IG51bWJlciB8IG51bGxcbiAgZm9yY2VZU2Nyb2xsYmFyczogYm9vbGVhblxuICBzY3JvbGxlckNsaWVudFdpZHRoczogeyBbaW5kZXg6IHN0cmluZ106IG51bWJlciB9IC8vIHdoeSBub3QgdXNlIGFycmF5P1xuICBzY3JvbGxlckNsaWVudEhlaWdodHM6IHsgW2luZGV4OiBzdHJpbmddOiBudW1iZXIgfVxufVxuXG5cbmV4cG9ydCBjbGFzcyBTaW1wbGVTY3JvbGxHcmlkIGV4dGVuZHMgQmFzZUNvbXBvbmVudDxTaW1wbGVTY3JvbGxHcmlkUHJvcHMsIFNpbXBsZVNjcm9sbEdyaWRTdGF0ZT4ge1xuXG4gIHByb2Nlc3NDb2xzID0gbWVtb2l6ZSgoYSkgPT4gYSwgaXNDb2xQcm9wc0VxdWFsKSAvLyBzbyB3ZSBnZXQgc2FtZSBgY29sc2AgcHJvcHMgZXZlcnkgdGltZVxuICByZW5kZXJNaWNyb0NvbEdyb3VwID0gbWVtb2l6ZShyZW5kZXJNaWNyb0NvbEdyb3VwKSAvLyB5dWNreSB0byBtZW1vaXplIFZOb2RlcywgYnV0IG11Y2ggbW9yZSBlZmZpY2llbnQgZm9yIGNvbnN1bWVyc1xuICBzY3JvbGxlclJlZnMgPSBuZXcgUmVmTWFwPFNjcm9sbGVyPigpXG4gIHNjcm9sbGVyRWxSZWZzID0gbmV3IFJlZk1hcDxIVE1MRWxlbWVudD4odGhpcy5faGFuZGxlU2Nyb2xsZXJFbC5iaW5kKHRoaXMpKVxuXG4gIHN0YXRlOiBTaW1wbGVTY3JvbGxHcmlkU3RhdGUgPSB7XG4gICAgc2hyaW5rV2lkdGg6IG51bGwsXG4gICAgZm9yY2VZU2Nyb2xsYmFyczogZmFsc2UsXG4gICAgc2Nyb2xsZXJDbGllbnRXaWR0aHM6IHt9LFxuICAgIHNjcm9sbGVyQ2xpZW50SGVpZ2h0czoge31cbiAgfVxuXG5cbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IHByb3BzLCBzdGF0ZSwgY29udGV4dCB9ID0gdGhpc1xuICAgIGxldCBzZWN0aW9uQ29uZmlncyA9IHByb3BzLnNlY3Rpb25zIHx8IFtdXG4gICAgbGV0IGNvbHMgPSB0aGlzLnByb2Nlc3NDb2xzKHByb3BzLmNvbHMpXG5cbiAgICBsZXQgbWljcm9Db2xHcm91cE5vZGUgPSB0aGlzLnJlbmRlck1pY3JvQ29sR3JvdXAoY29scywgc3RhdGUuc2hyaW5rV2lkdGgpXG4gICAgbGV0IGNsYXNzTmFtZXMgPSBnZXRTY3JvbGxHcmlkQ2xhc3NOYW1lcyhwcm9wcy5saXF1aWQsIGNvbnRleHQpXG5cbiAgICAvLyBUT0RPOiBtYWtlIERSWVxuICAgIGxldCBjb25maWdDbnQgPSBzZWN0aW9uQ29uZmlncy5sZW5ndGhcbiAgICBsZXQgY29uZmlnSSA9IDBcbiAgICBsZXQgY3VycmVudENvbmZpZzogU2ltcGxlU2Nyb2xsR3JpZFNlY3Rpb25cbiAgICBsZXQgaGVhZFNlY3Rpb25Ob2RlczogVk5vZGVbXSA9IFtdXG4gICAgbGV0IGJvZHlTZWN0aW9uTm9kZXM6IFZOb2RlW10gPSBbXVxuICAgIGxldCBmb290U2VjdGlvbk5vZGVzOiBWTm9kZVtdID0gW11cblxuICAgIHdoaWxlIChjb25maWdJIDwgY29uZmlnQ250ICYmIChjdXJyZW50Q29uZmlnID0gc2VjdGlvbkNvbmZpZ3NbY29uZmlnSV0pLnR5cGUgPT09ICdoZWFkZXInKSB7XG4gICAgICBoZWFkU2VjdGlvbk5vZGVzLnB1c2godGhpcy5yZW5kZXJTZWN0aW9uKGN1cnJlbnRDb25maWcsIGNvbmZpZ0ksIG1pY3JvQ29sR3JvdXBOb2RlKSlcbiAgICAgIGNvbmZpZ0krK1xuICAgIH1cblxuICAgIHdoaWxlIChjb25maWdJIDwgY29uZmlnQ250ICYmIChjdXJyZW50Q29uZmlnID0gc2VjdGlvbkNvbmZpZ3NbY29uZmlnSV0pLnR5cGUgPT09ICdib2R5Jykge1xuICAgICAgYm9keVNlY3Rpb25Ob2Rlcy5wdXNoKHRoaXMucmVuZGVyU2VjdGlvbihjdXJyZW50Q29uZmlnLCBjb25maWdJLCBtaWNyb0NvbEdyb3VwTm9kZSkpXG4gICAgICBjb25maWdJKytcbiAgICB9XG5cbiAgICB3aGlsZSAoY29uZmlnSSA8IGNvbmZpZ0NudCAmJiAoY3VycmVudENvbmZpZyA9IHNlY3Rpb25Db25maWdzW2NvbmZpZ0ldKS50eXBlID09PSAnZm9vdGVyJykge1xuICAgICAgZm9vdFNlY3Rpb25Ob2Rlcy5wdXNoKHRoaXMucmVuZGVyU2VjdGlvbihjdXJyZW50Q29uZmlnLCBjb25maWdJLCBtaWNyb0NvbEdyb3VwTm9kZSkpXG4gICAgICBjb25maWdJKytcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPHRhYmxlIGNsYXNzTmFtZT17Y2xhc3NOYW1lcy5qb2luKCcgJyl9IHN0eWxlPXt7IGhlaWdodDogcHJvcHMuaGVpZ2h0IH19PlxuICAgICAgICB7Qm9vbGVhbihoZWFkU2VjdGlvbk5vZGVzLmxlbmd0aCkgJiZcbiAgICAgICAgICBjcmVhdGVFbGVtZW50KCd0aGVhZCcsIHt9LCAuLi5oZWFkU2VjdGlvbk5vZGVzKVxuICAgICAgICB9XG4gICAgICAgIHtCb29sZWFuKGJvZHlTZWN0aW9uTm9kZXMubGVuZ3RoKSAmJlxuICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoJ3Rib2R5Jywge30sIC4uLmJvZHlTZWN0aW9uTm9kZXMpXG4gICAgICAgIH1cbiAgICAgICAge0Jvb2xlYW4oZm9vdFNlY3Rpb25Ob2Rlcy5sZW5ndGgpICYmXG4gICAgICAgICAgY3JlYXRlRWxlbWVudCgndGZvb3QnLCB7fSwgLi4uZm9vdFNlY3Rpb25Ob2RlcylcbiAgICAgICAgfVxuICAgICAgPC90YWJsZT5cbiAgICApXG4gIH1cblxuXG4gIHJlbmRlclNlY3Rpb24oc2VjdGlvbkNvbmZpZzogU2ltcGxlU2Nyb2xsR3JpZFNlY3Rpb24sIHNlY3Rpb25JOiBudW1iZXIsIG1pY3JvQ29sR3JvdXBOb2RlOiBWTm9kZSkge1xuXG4gICAgaWYgKCdvdXRlckNvbnRlbnQnIGluIHNlY3Rpb25Db25maWcpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxGcmFnbWVudCBrZXk9e3NlY3Rpb25Db25maWcua2V5fT5cbiAgICAgICAgICB7c2VjdGlvbkNvbmZpZy5vdXRlckNvbnRlbnR9XG4gICAgICAgIDwvRnJhZ21lbnQ+XG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDx0ciBrZXk9e3NlY3Rpb25Db25maWcua2V5fSBjbGFzc05hbWU9e2dldFNlY3Rpb25DbGFzc05hbWVzKHNlY3Rpb25Db25maWcsIHRoaXMucHJvcHMubGlxdWlkKS5qb2luKCcgJyl9PlxuICAgICAgICB7dGhpcy5yZW5kZXJDaHVua1RkKHNlY3Rpb25Db25maWcsIHNlY3Rpb25JLCBtaWNyb0NvbEdyb3VwTm9kZSwgc2VjdGlvbkNvbmZpZy5jaHVuayl9XG4gICAgICA8L3RyPlxuICAgIClcbiAgfVxuXG5cbiAgcmVuZGVyQ2h1bmtUZChzZWN0aW9uQ29uZmlnOiBTaW1wbGVTY3JvbGxHcmlkU2VjdGlvbiwgc2VjdGlvbkk6IG51bWJlciwgbWljcm9Db2xHcm91cE5vZGU6IFZOb2RlLCBjaHVua0NvbmZpZzogQ2h1bmtDb25maWcpIHtcblxuICAgIGlmICgnb3V0ZXJDb250ZW50JyBpbiBjaHVua0NvbmZpZykge1xuICAgICAgcmV0dXJuIGNodW5rQ29uZmlnLm91dGVyQ29udGVudFxuICAgIH1cblxuICAgIGxldCB7IHByb3BzIH0gPSB0aGlzXG4gICAgbGV0IHsgZm9yY2VZU2Nyb2xsYmFycywgc2Nyb2xsZXJDbGllbnRXaWR0aHMsIHNjcm9sbGVyQ2xpZW50SGVpZ2h0cyB9ID0gdGhpcy5zdGF0ZVxuXG4gICAgbGV0IG5lZWRzWVNjcm9sbGluZyA9IGdldEFsbG93WVNjcm9sbGluZyhwcm9wcywgc2VjdGlvbkNvbmZpZykgLy8gVE9ETzogZG8gbGF6aWx5LiBkbyBpbiBzZWN0aW9uIGNvbmZpZz9cbiAgICBsZXQgaXNMaXF1aWQgPSBnZXRTZWN0aW9uSGFzTGlxdWlkSGVpZ2h0KHByb3BzLCBzZWN0aW9uQ29uZmlnKVxuXG4gICAgLy8gZm9yIGAhcHJvcHMubGlxdWlkYCAtIGlzIFdIT0xFIHNjcm9sbGdyaWQgbmF0dXJhbCBoZWlnaHQ/XG4gICAgLy8gVE9ETzogZG8gc2FtZSB0aGluZyBpbiBhZHZhbmNlZCBzY3JvbGxncmlkPyBwcm9sbHkgbm90IGIvYyBhbHdheXMgaGFzIGhvcml6b250YWwgc2Nyb2xsYmFyc1xuICAgIGxldCBvdmVyZmxvd1k6IE92ZXJmbG93VmFsdWUgPVxuICAgICAgIXByb3BzLmxpcXVpZCA/ICd2aXNpYmxlJyA6XG4gICAgICBmb3JjZVlTY3JvbGxiYXJzID8gJ3Njcm9sbCcgOlxuICAgICAgIW5lZWRzWVNjcm9sbGluZyA/ICdoaWRkZW4nIDpcbiAgICAgICdhdXRvJ1xuXG4gICAgbGV0IGNvbnRlbnQgPSByZW5kZXJDaHVua0NvbnRlbnQoc2VjdGlvbkNvbmZpZywgY2h1bmtDb25maWcsIHtcbiAgICAgIHRhYmxlQ29sR3JvdXBOb2RlOiBtaWNyb0NvbEdyb3VwTm9kZSxcbiAgICAgIHRhYmxlTWluV2lkdGg6ICcnLFxuICAgICAgY2xpZW50V2lkdGg6IHNjcm9sbGVyQ2xpZW50V2lkdGhzW3NlY3Rpb25JXSAhPT0gdW5kZWZpbmVkID8gc2Nyb2xsZXJDbGllbnRXaWR0aHNbc2VjdGlvbkldIDogbnVsbCxcbiAgICAgIGNsaWVudEhlaWdodDogc2Nyb2xsZXJDbGllbnRIZWlnaHRzW3NlY3Rpb25JXSAhPT0gdW5kZWZpbmVkID8gc2Nyb2xsZXJDbGllbnRIZWlnaHRzW3NlY3Rpb25JXSA6IG51bGwsXG4gICAgICBleHBhbmRSb3dzOiBzZWN0aW9uQ29uZmlnLmV4cGFuZFJvd3MsXG4gICAgICBzeW5jUm93SGVpZ2h0czogZmFsc2UsXG4gICAgICByb3dTeW5jSGVpZ2h0czogW10sXG4gICAgICByZXBvcnRSb3dIZWlnaHRDaGFuZ2U6ICgpID0+IHt9XG4gICAgfSlcblxuICAgIHJldHVybiAoXG4gICAgICA8dGQgcmVmPXtjaHVua0NvbmZpZy5lbFJlZn0+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXsnZmMtc2Nyb2xsZXItaGFybmVzcycgKyAoaXNMaXF1aWQgPyAnIGZjLXNjcm9sbGVyLWhhcm5lc3MtbGlxdWlkJyA6ICcnKX0+XG4gICAgICAgICAgPFNjcm9sbGVyXG4gICAgICAgICAgICByZWY9e3RoaXMuc2Nyb2xsZXJSZWZzLmNyZWF0ZVJlZihzZWN0aW9uSSl9XG4gICAgICAgICAgICBlbFJlZj17dGhpcy5zY3JvbGxlckVsUmVmcy5jcmVhdGVSZWYoc2VjdGlvbkkpfVxuICAgICAgICAgICAgb3ZlcmZsb3dZPXtvdmVyZmxvd1l9XG4gICAgICAgICAgICBvdmVyZmxvd1g9eyFwcm9wcy5saXF1aWQgPyAndmlzaWJsZScgOiAnaGlkZGVuJyAvKiBuYXR1cmFsIGhlaWdodD8gKi99XG4gICAgICAgICAgICBtYXhIZWlnaHQ9e3NlY3Rpb25Db25maWcubWF4SGVpZ2h0fVxuICAgICAgICAgICAgbGlxdWlkPXtpc0xpcXVpZH1cbiAgICAgICAgICAgIGxpcXVpZElzQWJzb2x1dGU9e3RydWUgLyogYmVjYXVzZSBpdHMgd2l0aGluIGEgaGFybmVzcyAqL31cbiAgICAgICAgICA+e2NvbnRlbnR9PC9TY3JvbGxlcj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L3RkPlxuICAgIClcbiAgfVxuXG5cbiAgX2hhbmRsZVNjcm9sbGVyRWwoc2Nyb2xsZXJFbDogSFRNTEVsZW1lbnQgfCBudWxsLCBrZXk6IHN0cmluZykge1xuICAgIGxldCBzZWN0aW9uSSA9IHBhcnNlSW50KGtleSwgMTApXG4gICAgbGV0IGNodW5rQ29uZmlnID0gdGhpcy5wcm9wcy5zZWN0aW9uc1tzZWN0aW9uSV0uY2h1bmtcblxuICAgIHNldFJlZihjaHVua0NvbmZpZy5zY3JvbGxlckVsUmVmLCBzY3JvbGxlckVsKVxuICB9XG5cblxuICAvLyBUT0RPOiBjYW4gZG8gYSByZWFsbHkgc2ltcGxlIHByaW50LXZpZXcuIGRvbnQgbmVlZCB0byBqb2luIHJvd3NcbiAgaGFuZGxlU2l6aW5nID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgc2hyaW5rV2lkdGg6IHRoaXMuY29tcHV0ZVNocmlua1dpZHRoKCksIC8vIHdpbGwgY3JlYXRlIGVhY2ggY2h1bmsncyA8Y29sZ3JvdXA+LiBUT0RPOiBwcmVjb21wdXRlIGhhc1Nocmlua1dpZHRoXG4gICAgICAuLi50aGlzLmNvbXB1dGVTY3JvbGxlckRpbXMoKVxuICAgIH0pXG4gIH1cblxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuaGFuZGxlU2l6aW5nKClcbiAgICB0aGlzLmNvbnRleHQuYWRkUmVzaXplSGFuZGxlcih0aGlzLmhhbmRsZVNpemluZylcbiAgfVxuXG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIC8vIFRPRE86IG5lZWQgYmV0dGVyIHNvbHV0aW9uIHdoZW4gc3RhdGUgY29udGFpbnMgbm9uLXNpemluZyB0aGluZ3NcbiAgICB0aGlzLmhhbmRsZVNpemluZygpXG4gIH1cblxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuY29udGV4dC5yZW1vdmVSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlU2l6aW5nKVxuICB9XG5cblxuICBjb21wdXRlU2hyaW5rV2lkdGgoKSB7XG4gICAgcmV0dXJuIGhhc1Nocmlua1dpZHRoKHRoaXMucHJvcHMuY29scylcbiAgICAgID8gY29tcHV0ZVNocmlua1dpZHRoKHRoaXMuc2Nyb2xsZXJFbFJlZnMuZ2V0QWxsKCkpXG4gICAgICA6IDBcbiAgfVxuXG5cbiAgY29tcHV0ZVNjcm9sbGVyRGltcygpIHtcbiAgICBsZXQgc2Nyb2xsYmFyV2lkdGggPSBnZXRTY3JvbGxiYXJXaWR0aHMoKVxuICAgIGxldCBzZWN0aW9uQ250ID0gdGhpcy5wcm9wcy5zZWN0aW9ucy5sZW5ndGhcbiAgICBsZXQgeyBzY3JvbGxlclJlZnMsIHNjcm9sbGVyRWxSZWZzIH0gPSB0aGlzXG5cbiAgICBsZXQgZm9yY2VZU2Nyb2xsYmFycyA9IGZhbHNlXG4gICAgbGV0IHNjcm9sbGVyQ2xpZW50V2lkdGhzOiB7IFtpbmRleDogc3RyaW5nXTogbnVtYmVyIH0gPSB7fVxuICAgIGxldCBzY3JvbGxlckNsaWVudEhlaWdodHM6IHsgW2luZGV4OiBzdHJpbmddOiBudW1iZXIgfSA9IHt9XG5cbiAgICBmb3IgKGxldCBzZWN0aW9uSSA9IDA7IHNlY3Rpb25JIDwgc2VjdGlvbkNudDsgc2VjdGlvbkkrKykgeyAvLyBhbG9uZyBlZGdlXG4gICAgICBsZXQgc2Nyb2xsZXIgPSBzY3JvbGxlclJlZnMuY3VycmVudE1hcFtzZWN0aW9uSV1cblxuICAgICAgaWYgKHNjcm9sbGVyICYmIHNjcm9sbGVyLm5lZWRzWVNjcm9sbGluZygpKSB7XG4gICAgICAgIGZvcmNlWVNjcm9sbGJhcnMgPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgc2VjdGlvbkkgPSAwOyBzZWN0aW9uSSA8IHNlY3Rpb25DbnQ7IHNlY3Rpb25JKyspIHsgLy8gYWxvbmcgZWRnZVxuICAgICAgbGV0IHNjcm9sbGVyRWwgPSBzY3JvbGxlckVsUmVmcy5jdXJyZW50TWFwW3NlY3Rpb25JXVxuXG4gICAgICBpZiAoc2Nyb2xsZXJFbCkge1xuICAgICAgICBsZXQgaGFybmVzc0VsID0gc2Nyb2xsZXJFbC5wYXJlbnROb2RlIGFzIEhUTUxFbGVtZW50IC8vIFRPRE86IHdlaXJkIHdheSB0byBnZXQgdGhpcy4gbmVlZCBoYXJuZXNzIGIvYyBkb2Vzbid0IGluY2x1ZGUgdGFibGUgYm9yZGVyc1xuXG4gICAgICAgIHNjcm9sbGVyQ2xpZW50V2lkdGhzW3NlY3Rpb25JXSA9IE1hdGguZmxvb3IoXG4gICAgICAgICAgaGFybmVzc0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gKFxuICAgICAgICAgICAgZm9yY2VZU2Nyb2xsYmFyc1xuICAgICAgICAgICAgICA/IHNjcm9sbGJhcldpZHRoLnkgLy8gdXNlIGdsb2JhbCBiZWNhdXNlIHNjcm9sbGVyIG1pZ2h0IG5vdCBoYXZlIHNjcm9sbGJhcnMgeWV0IGJ1dCB3aWxsIG5lZWQgdGhlbSBpbiBmdXR1cmVcbiAgICAgICAgICAgICAgOiAwXG4gICAgICAgICAgKVxuICAgICAgICApXG5cbiAgICAgICAgc2Nyb2xsZXJDbGllbnRIZWlnaHRzW3NlY3Rpb25JXSA9IE1hdGguZmxvb3IoXG4gICAgICAgICAgaGFybmVzc0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCAvLyBuZXZlciBoYXMgaG9yaXpvbnRhbCBzY3JvbGxiYXJzXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBmb3JjZVlTY3JvbGxiYXJzLCBzY3JvbGxlckNsaWVudFdpZHRocywgc2Nyb2xsZXJDbGllbnRIZWlnaHRzIH1cbiAgfVxuXG59XG5cblNpbXBsZVNjcm9sbEdyaWQuYWRkU3RhdGVFcXVhbGl0eSh7XG4gIHNjcm9sbGVyQ2xpZW50V2lkdGhzOiBpc1Byb3BzRXF1YWwsXG4gIHNjcm9sbGVyQ2xpZW50SGVpZ2h0czogaXNQcm9wc0VxdWFsXG59KVxuIiwiaW1wb3J0IHsgU2VnIH0gZnJvbSAnLi4vY29tcG9uZW50L0RhdGVDb21wb25lbnQnXG5pbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgY3JlYXRlRWxlbWVudCwgUmVmLCBjcmVhdGVSZWYgfSBmcm9tICcuLi92ZG9tJ1xuaW1wb3J0IHsgRXZlbnRBcGkgfSBmcm9tICcuLi9hcGkvRXZlbnRBcGknXG5pbXBvcnQgeyBjb21wdXRlU2VnRHJhZ2dhYmxlLCBjb21wdXRlU2VnU3RhcnRSZXNpemFibGUsIGNvbXB1dGVTZWdFbmRSZXNpemFibGUsIHNldEVsU2VnIH0gZnJvbSAnLi4vY29tcG9uZW50L2V2ZW50LXJlbmRlcmluZydcbmltcG9ydCB7IEV2ZW50Q29udGVudEFyZywgZ2V0RXZlbnRDbGFzc05hbWVzIH0gZnJvbSAnLi4vY29tcG9uZW50L2V2ZW50LXJlbmRlcmluZydcbmltcG9ydCB7IFJlbmRlckhvb2sgfSBmcm9tICcuL3JlbmRlci1ob29rJ1xuaW1wb3J0IHsgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uL3Zkb20tdXRpbCdcblxuXG5leHBvcnQgaW50ZXJmYWNlIE1pbmltYWxFdmVudFByb3BzIHtcbiAgc2VnOiBTZWdcbiAgaXNEcmFnZ2luZzogYm9vbGVhbiAgICAgIC8vIHJlbmFtZSB0byBpc01pcnJvckRyYWdnaW5nPyBtYWtlIG9wdGlvbmFsP1xuICBpc1Jlc2l6aW5nOiBib29sZWFuICAgICAgLy8gcmVuYW1lIHRvIGlzTWlycm9yUmVzaXppbmc/IG1ha2Ugb3B0aW9uYWw/XG4gIGlzRGF0ZVNlbGVjdGluZzogYm9vbGVhbiAvLyByZW5hbWUgdG8gaXNNaXJyb3JEYXRlU2VsZWN0aW5nPyBtYWtlIG9wdGlvbmFsP1xuICBpc1NlbGVjdGVkOiBib29sZWFuXG4gIGlzUGFzdDogYm9vbGVhblxuICBpc0Z1dHVyZTogYm9vbGVhblxuICBpc1RvZGF5OiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnRSb290UHJvcHMgZXh0ZW5kcyBNaW5pbWFsRXZlbnRQcm9wcyB7XG4gIHRpbWVUZXh0OiBzdHJpbmdcbiAgZGlzYWJsZURyYWdnaW5nPzogYm9vbGVhblxuICBkaXNhYmxlUmVzaXppbmc/OiBib29sZWFuXG4gIGRlZmF1bHRDb250ZW50OiAoaG9va1Byb3BzOiBFdmVudENvbnRlbnRBcmcpID0+IENvbXBvbmVudENoaWxkcmVuXG4gIGNoaWxkcmVuOiAoXG4gICAgcm9vdEVsUmVmOiBSZWY8YW55PixcbiAgICBjbGFzc05hbWVzOiBzdHJpbmdbXSxcbiAgICBpbm5lckVsUmVmOiBSZWY8YW55PixcbiAgICBpbm5lckNvbnRlbnQ6IENvbXBvbmVudENoaWxkcmVuLFxuICAgIGhvb2tQcm9wczogRXZlbnRDb250ZW50QXJnXG4gICkgPT4gQ29tcG9uZW50Q2hpbGRyZW5cbn1cblxuXG5leHBvcnQgY2xhc3MgRXZlbnRSb290IGV4dGVuZHMgQmFzZUNvbXBvbmVudDxFdmVudFJvb3RQcm9wcz4ge1xuXG4gIGVsUmVmID0gY3JlYXRlUmVmPEhUTUxFbGVtZW50PigpXG5cblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXNcbiAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0XG4gICAgbGV0IHsgc2VnIH0gPSBwcm9wc1xuICAgIGxldCB7IGV2ZW50UmFuZ2UgfSA9IHNlZ1xuICAgIGxldCB7IHVpIH0gPSBldmVudFJhbmdlXG5cbiAgICBsZXQgaG9va1Byb3BzOiBFdmVudENvbnRlbnRBcmcgPSB7XG4gICAgICBldmVudDogbmV3IEV2ZW50QXBpKGNvbnRleHQsIGV2ZW50UmFuZ2UuZGVmLCBldmVudFJhbmdlLmluc3RhbmNlKSxcbiAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgIHRpbWVUZXh0OiBwcm9wcy50aW1lVGV4dCxcbiAgICAgIHRleHRDb2xvcjogdWkudGV4dENvbG9yLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiB1aS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICBib3JkZXJDb2xvcjogdWkuYm9yZGVyQ29sb3IsXG4gICAgICBpc0RyYWdnYWJsZTogIXByb3BzLmRpc2FibGVEcmFnZ2luZyAmJiBjb21wdXRlU2VnRHJhZ2dhYmxlKHNlZywgY29udGV4dCksXG4gICAgICBpc1N0YXJ0UmVzaXphYmxlOiAhcHJvcHMuZGlzYWJsZVJlc2l6aW5nICYmIGNvbXB1dGVTZWdTdGFydFJlc2l6YWJsZShzZWcsIGNvbnRleHQpLFxuICAgICAgaXNFbmRSZXNpemFibGU6ICFwcm9wcy5kaXNhYmxlUmVzaXppbmcgJiYgY29tcHV0ZVNlZ0VuZFJlc2l6YWJsZShzZWcsIGNvbnRleHQpLFxuICAgICAgaXNNaXJyb3I6IEJvb2xlYW4ocHJvcHMuaXNEcmFnZ2luZyB8fCBwcm9wcy5pc1Jlc2l6aW5nIHx8IHByb3BzLmlzRGF0ZVNlbGVjdGluZyksXG4gICAgICBpc1N0YXJ0OiBCb29sZWFuKHNlZy5pc1N0YXJ0KSxcbiAgICAgIGlzRW5kOiBCb29sZWFuKHNlZy5pc0VuZCksXG4gICAgICBpc1Bhc3Q6IEJvb2xlYW4ocHJvcHMuaXNQYXN0KSwgLy8gVE9ETzogZG9uJ3QgY2FzdC4gZ2V0RGF0ZU1ldGEgZG9lcyBpdFxuICAgICAgaXNGdXR1cmU6IEJvb2xlYW4ocHJvcHMuaXNGdXR1cmUpLCAvLyBUT0RPOiBkb24ndCBjYXN0LiBnZXREYXRlTWV0YSBkb2VzIGl0XG4gICAgICBpc1RvZGF5OiBCb29sZWFuKHByb3BzLmlzVG9kYXkpLCAvLyBUT0RPOiBkb24ndCBjYXN0LiBnZXREYXRlTWV0YSBkb2VzIGl0XG4gICAgICBpc1NlbGVjdGVkOiBCb29sZWFuKHByb3BzLmlzU2VsZWN0ZWQpLFxuICAgICAgaXNEcmFnZ2luZzogQm9vbGVhbihwcm9wcy5pc0RyYWdnaW5nKSxcbiAgICAgIGlzUmVzaXppbmc6IEJvb2xlYW4ocHJvcHMuaXNSZXNpemluZylcbiAgICB9XG5cbiAgICBsZXQgc3RhbmRhcmRDbGFzc05hbWVzID0gZ2V0RXZlbnRDbGFzc05hbWVzKGhvb2tQcm9wcykuY29uY2F0KHVpLmNsYXNzTmFtZXMpXG5cbiAgICByZXR1cm4gKFxuICAgICAgPFJlbmRlckhvb2tcbiAgICAgICAgaG9va1Byb3BzPXtob29rUHJvcHN9XG4gICAgICAgIGNsYXNzTmFtZXM9e29wdGlvbnMuZXZlbnRDbGFzc05hbWVzfVxuICAgICAgICBjb250ZW50PXtvcHRpb25zLmV2ZW50Q29udGVudH1cbiAgICAgICAgZGVmYXVsdENvbnRlbnQ9e3Byb3BzLmRlZmF1bHRDb250ZW50fVxuICAgICAgICBkaWRNb3VudD17b3B0aW9ucy5ldmVudERpZE1vdW50fVxuICAgICAgICB3aWxsVW5tb3VudD17b3B0aW9ucy5ldmVudFdpbGxVbm1vdW50fVxuICAgICAgICBlbFJlZj17dGhpcy5lbFJlZn1cbiAgICAgID5cbiAgICAgICAgeyhyb290RWxSZWYsIGN1c3RvbUNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgPT4gcHJvcHMuY2hpbGRyZW4oXG4gICAgICAgICAgcm9vdEVsUmVmLCBzdGFuZGFyZENsYXNzTmFtZXMuY29uY2F0KGN1c3RvbUNsYXNzTmFtZXMpLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQsIGhvb2tQcm9wc1xuICAgICAgICApfVxuICAgICAgPC9SZW5kZXJIb29rPlxuICAgIClcbiAgfVxuXG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgc2V0RWxTZWcodGhpcy5lbFJlZi5jdXJyZW50LCB0aGlzLnByb3BzLnNlZylcbiAgfVxuXG5cbiAgLypcbiAgbmVlZCB0byByZS1hc3NpZ24gc2VnIHRvIHRoZSBlbGVtZW50IGlmIHNlZyBjaGFuZ2VzLCBldmVuIGlmIHRoZSBlbGVtZW50IGlzIHRoZSBzYW1lXG4gICovXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IEV2ZW50Um9vdFByb3BzKSB7XG4gICAgbGV0IHsgc2VnIH0gPSB0aGlzLnByb3BzXG5cbiAgICBpZiAoc2VnICE9PSBwcmV2UHJvcHMuc2VnKSB7XG4gICAgICBzZXRFbFNlZyh0aGlzLmVsUmVmLmN1cnJlbnQsIHNlZylcbiAgICB9XG4gIH1cblxufVxuIiwiXG5pbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQgfSBmcm9tICcuLi92ZG9tJ1xuaW1wb3J0IHsgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uL3Zkb20tdXRpbCdcbmltcG9ydCB7IGJ1aWxkU2VnVGltZVRleHQsIEV2ZW50Q29udGVudEFyZyB9IGZyb20gJy4uL2NvbXBvbmVudC9ldmVudC1yZW5kZXJpbmcnXG5pbXBvcnQgeyBFdmVudFJvb3QsIE1pbmltYWxFdmVudFByb3BzIH0gZnJvbSAnLi9FdmVudFJvb3QnXG5pbXBvcnQgeyBTZWcgfSBmcm9tICcuLi9jb21wb25lbnQvRGF0ZUNvbXBvbmVudCdcbmltcG9ydCB7IERhdGVGb3JtYXR0ZXIgfSBmcm9tICcuLi9kYXRlbGliL0RhdGVGb3JtYXR0ZXInXG5cblxuZXhwb3J0IGludGVyZmFjZSBTdGFuZGFyZEV2ZW50UHJvcHMgZXh0ZW5kcyBNaW5pbWFsRXZlbnRQcm9wcyB7XG4gIGV4dHJhQ2xhc3NOYW1lczogc3RyaW5nW11cbiAgZGVmYXVsdFRpbWVGb3JtYXQ6IERhdGVGb3JtYXR0ZXJcbiAgZGVmYXVsdERpc3BsYXlFdmVudFRpbWU/OiBib29sZWFuIC8vIGRlZmF1bHQgdHJ1ZVxuICBkZWZhdWx0RGlzcGxheUV2ZW50RW5kPzogYm9vbGVhbiAvLyBkZWZhdWx0IHRydWVcbiAgZGlzYWJsZURyYWdnaW5nPzogYm9vbGVhbiAvLyBkZWZhdWx0IGZhbHNlXG4gIGRpc2FibGVSZXNpemluZz86IGJvb2xlYW4gLy8gZGVmYXVsdCBmYWxzZVxuICBkZWZhdWx0Q29udGVudD86IChob29rUHJvcHM6IEV2ZW50Q29udGVudEFyZykgPT4gQ29tcG9uZW50Q2hpbGRyZW4gLy8gbm90IHVzZWQgYnkgYW55b25lIHlldFxufVxuXG5cbi8vIHNob3VsZCBub3QgYmUgYSBwdXJlY29tcG9uZW50XG5leHBvcnQgY2xhc3MgU3RhbmRhcmRFdmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQ8U3RhbmRhcmRFdmVudFByb3BzPiB7XG5cbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzXG4gICAgbGV0IHsgc2VnIH0gPSBwcm9wc1xuICAgIGxldCB0aW1lRm9ybWF0ID0gY29udGV4dC5vcHRpb25zLmV2ZW50VGltZUZvcm1hdCB8fCBwcm9wcy5kZWZhdWx0VGltZUZvcm1hdFxuICAgIGxldCB0aW1lVGV4dCA9IGJ1aWxkU2VnVGltZVRleHQoXG4gICAgICBzZWcsXG4gICAgICB0aW1lRm9ybWF0LFxuICAgICAgY29udGV4dCxcbiAgICAgIHByb3BzLmRlZmF1bHREaXNwbGF5RXZlbnRUaW1lLFxuICAgICAgcHJvcHMuZGVmYXVsdERpc3BsYXlFdmVudEVuZFxuICAgIClcblxuICAgIHJldHVybiAoXG4gICAgICA8RXZlbnRSb290XG4gICAgICAgIHNlZz17c2VnfVxuICAgICAgICB0aW1lVGV4dD17dGltZVRleHR9XG4gICAgICAgIGRpc2FibGVEcmFnZ2luZz17cHJvcHMuZGlzYWJsZURyYWdnaW5nfVxuICAgICAgICBkaXNhYmxlUmVzaXppbmc9e3Byb3BzLmRpc2FibGVSZXNpemluZ31cbiAgICAgICAgZGVmYXVsdENvbnRlbnQ9e3Byb3BzLmRlZmF1bHRDb250ZW50IHx8IHJlbmRlcklubmVyQ29udGVudH1cbiAgICAgICAgaXNEcmFnZ2luZz17cHJvcHMuaXNEcmFnZ2luZ31cbiAgICAgICAgaXNSZXNpemluZz17cHJvcHMuaXNSZXNpemluZ31cbiAgICAgICAgaXNEYXRlU2VsZWN0aW5nPXtwcm9wcy5pc0RhdGVTZWxlY3Rpbmd9XG4gICAgICAgIGlzU2VsZWN0ZWQ9e3Byb3BzLmlzU2VsZWN0ZWR9XG4gICAgICAgIGlzUGFzdD17cHJvcHMuaXNQYXN0fVxuICAgICAgICBpc0Z1dHVyZT17cHJvcHMuaXNGdXR1cmV9XG4gICAgICAgIGlzVG9kYXk9e3Byb3BzLmlzVG9kYXl9XG4gICAgICA+XG4gICAgICAgIHsocm9vdEVsUmVmLCBjbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQsIGhvb2tQcm9wcykgPT4gKFxuICAgICAgICAgIDxhXG4gICAgICAgICAgICBjbGFzc05hbWU9e3Byb3BzLmV4dHJhQ2xhc3NOYW1lcy5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpfVxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGhvb2tQcm9wcy5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBob29rUHJvcHMuYmFja2dyb3VuZENvbG9yXG4gICAgICAgICAgICB9fVxuICAgICAgICAgICAgcmVmPXtyb290RWxSZWZ9XG4gICAgICAgICAgICB7Li4uZ2V0U2VnQW5jaG9yQXR0cnMoc2VnKX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nZmMtZXZlbnQtbWFpbicgcmVmPXtpbm5lckVsUmVmfSBzdHlsZT17eyBjb2xvcjogaG9va1Byb3BzLnRleHRDb2xvciB9fT5cbiAgICAgICAgICAgICAge2lubmVyQ29udGVudH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAge2hvb2tQcm9wcy5pc1N0YXJ0UmVzaXphYmxlICYmXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdmYy1ldmVudC1yZXNpemVyIGZjLWV2ZW50LXJlc2l6ZXItc3RhcnQnIC8+XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB7aG9va1Byb3BzLmlzRW5kUmVzaXphYmxlICYmXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdmYy1ldmVudC1yZXNpemVyIGZjLWV2ZW50LXJlc2l6ZXItZW5kJyAvPlxuICAgICAgICAgICAgfVxuICAgICAgICAgIDwvYT5cbiAgICAgICAgKX1cbiAgICAgIDwvRXZlbnRSb290PlxuICAgIClcbiAgfVxuXG59XG5cblxuZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50KGlubmVyUHJvcHM6IEV2ZW50Q29udGVudEFyZykge1xuICByZXR1cm4gKFxuICAgIDxGcmFnbWVudD5cbiAgICAgIHtpbm5lclByb3BzLnRpbWVUZXh0ICYmXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPSdmYy1ldmVudC10aW1lJz57aW5uZXJQcm9wcy50aW1lVGV4dH08L2Rpdj5cbiAgICAgIH1cbiAgICAgIDxkaXYgY2xhc3NOYW1lPSdmYy1ldmVudC10aXRsZS1mcmFtZSc+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPSdmYy1ldmVudC10aXRsZSBmYy1zdGlja3knPlxuICAgICAgICAgIHtpbm5lclByb3BzLmV2ZW50LnRpdGxlIHx8IDxGcmFnbWVudD4mbmJzcDs8L0ZyYWdtZW50Pn1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L0ZyYWdtZW50PlxuICApXG59XG5cblxuZnVuY3Rpb24gZ2V0U2VnQW5jaG9yQXR0cnMoc2VnOiBTZWcpIHtcbiAgbGV0IHVybCA9IHNlZy5ldmVudFJhbmdlLmRlZi51cmxcbiAgcmV0dXJuIHVybCA/IHsgaHJlZjogdXJsIH0gOiB7fVxufVxuIiwiaW1wb3J0IHsgUmVuZGVySG9vaywgUmVuZGVySG9va1Byb3BzQ2hpbGRyZW4sIE1vdW50QXJnIH0gZnJvbSAnLi9yZW5kZXItaG9vaydcbmltcG9ydCB7IERhdGVNYXJrZXIgfSBmcm9tICcuLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IFZpZXdDb250ZXh0LCBWaWV3Q29udGV4dFR5cGUgfSBmcm9tICcuLi9WaWV3Q29udGV4dCdcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQgfSBmcm9tICcuLi92ZG9tJ1xuaW1wb3J0IHsgVmlld0FwaSB9IGZyb20gJy4uL1ZpZXdBcGknXG5cblxuZXhwb3J0IGludGVyZmFjZSBOb3dJbmRpY2F0b3JSb290UHJvcHMge1xuICBpc0F4aXM6IGJvb2xlYW5cbiAgZGF0ZTogRGF0ZU1hcmtlclxuICBjaGlsZHJlbjogUmVuZGVySG9va1Byb3BzQ2hpbGRyZW5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBOb3dJbmRpY2F0b3JDb250ZW50QXJnIHtcbiAgaXNBeGlzOiBib29sZWFuXG4gIGRhdGU6IERhdGVcbiAgdmlldzogVmlld0FwaVxufVxuXG5leHBvcnQgdHlwZSBOb3dJbmRpY2F0b3JNb3VudEFyZyA9IE1vdW50QXJnPE5vd0luZGljYXRvckNvbnRlbnRBcmc+XG5cblxuZXhwb3J0IGNvbnN0IE5vd0luZGljYXRvclJvb3QgPSAocHJvcHM6IE5vd0luZGljYXRvclJvb3RQcm9wcykgPT4gKFxuICA8Vmlld0NvbnRleHRUeXBlLkNvbnN1bWVyPlxuICAgIHsoY29udGV4dDogVmlld0NvbnRleHQpID0+IHtcbiAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHRcbiAgICAgIGxldCBob29rUHJvcHM6IE5vd0luZGljYXRvckNvbnRlbnRBcmcgPSB7XG4gICAgICAgIGlzQXhpczogcHJvcHMuaXNBeGlzLFxuICAgICAgICBkYXRlOiBjb250ZXh0LmRhdGVFbnYudG9EYXRlKHByb3BzLmRhdGUpLFxuICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPFJlbmRlckhvb2tcbiAgICAgICAgICBob29rUHJvcHM9e2hvb2tQcm9wc31cbiAgICAgICAgICBjbGFzc05hbWVzPXtvcHRpb25zLm5vd0luZGljYXRvckNsYXNzTmFtZXN9XG4gICAgICAgICAgY29udGVudD17b3B0aW9ucy5ub3dJbmRpY2F0b3JDb250ZW50fVxuICAgICAgICAgIGRpZE1vdW50PXtvcHRpb25zLm5vd0luZGljYXRvckRpZE1vdW50fVxuICAgICAgICAgIHdpbGxVbm1vdW50PXtvcHRpb25zLm5vd0luZGljYXRvcldpbGxVbm1vdW50fVxuICAgICAgICA+XG4gICAgICAgICAge3Byb3BzLmNoaWxkcmVufVxuICAgICAgICA8L1JlbmRlckhvb2s+XG4gICAgICApXG4gICAgfX1cbiAgPC9WaWV3Q29udGV4dFR5cGUuQ29uc3VtZXI+XG4pXG4iLCJpbXBvcnQgeyBSZWYsIENvbXBvbmVudENoaWxkcmVuLCBjcmVhdGVFbGVtZW50IH0gZnJvbSAnLi4vdmRvbSdcbmltcG9ydCB7IERhdGVNYXJrZXIgfSBmcm9tICcuLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IERhdGVSYW5nZSB9IGZyb20gJy4uL2RhdGVsaWIvZGF0ZS1yYW5nZSdcbmltcG9ydCB7IGdldERhdGVNZXRhLCBnZXREYXlDbGFzc05hbWVzLCBEYXRlTWV0YSB9IGZyb20gJy4uL2NvbXBvbmVudC9kYXRlLXJlbmRlcmluZydcbmltcG9ydCB7IGNyZWF0ZUZvcm1hdHRlciB9IGZyb20gJy4uL2RhdGVsaWIvZm9ybWF0dGluZydcbmltcG9ydCB7IGZvcm1hdERheVN0cmluZyB9IGZyb20gJy4uL2RhdGVsaWIvZm9ybWF0dGluZy11dGlscydcbmltcG9ydCB7IGJ1aWxkQ2xhc3NOYW1lTm9ybWFsaXplciwgTW91bnRIb29rLCBDb250ZW50SG9vaywgTW91bnRBcmcgfSBmcm9tICcuL3JlbmRlci1ob29rJ1xuaW1wb3J0IHsgVmlld0FwaSB9IGZyb20gJy4uL1ZpZXdBcGknXG5pbXBvcnQgeyBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vdmRvbS11dGlsJ1xuaW1wb3J0IHsgRGF0ZVByb2ZpbGUgfSBmcm9tICcuLi9EYXRlUHJvZmlsZUdlbmVyYXRvcidcbmltcG9ydCB7IG1lbW9pemVPYmpBcmcgfSBmcm9tICcuLi91dGlsL21lbW9pemUnXG5pbXBvcnQgeyBEYXRlRW52IH0gZnJvbSAnLi4vZGF0ZWxpYi9lbnYnXG5pbXBvcnQgeyBEaWN0aW9uYXJ5IH0gZnJvbSAnLi4vb3B0aW9ucydcblxuXG5jb25zdCBEQVlfTlVNX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7IGRheTogJ251bWVyaWMnIH0pXG5cbmludGVyZmFjZSBEYXlDZWxsSG9va1Byb3BzSW5wdXQge1xuICBkYXRlOiBEYXRlTWFya2VyIC8vIGdlbmVyaWNcbiAgZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlXG4gIHRvZGF5UmFuZ2U6IERhdGVSYW5nZVxuICBkYXRlRW52OiBEYXRlRW52XG4gIHZpZXdBcGk6IFZpZXdBcGlcbiAgc2hvd0RheU51bWJlcj86IGJvb2xlYW4gLy8gZGVmYXVsdHMgdG8gZmFsc2VcbiAgZXh0cmFQcm9wcz86IERpY3Rpb25hcnkgLy8gc28gY2FuIGluY2x1ZGUgYSByZXNvdXJjZVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERheUNlbGxDb250ZW50QXJnIGV4dGVuZHMgRGF0ZU1ldGEge1xuICBkYXRlOiBEYXRlTWFya2VyIC8vIGxvY2FsaXplZFxuICB2aWV3OiBWaWV3QXBpXG4gIGRheU51bWJlclRleHQ6IHN0cmluZ1xuICBbZXh0cmFQcm9wOiBzdHJpbmddOiBhbnkgLy8gc28gY2FuIGluY2x1ZGUgYSByZXNvdXJjZVxufVxuZXhwb3J0IHR5cGUgRGF5Q2VsbE1vdW50QXJnID0gTW91bnRBcmc8RGF5Q2VsbENvbnRlbnRBcmc+XG5cblxuZXhwb3J0IGludGVyZmFjZSBEYXlDZWxsUm9vdFByb3BzIHtcbiAgZWxSZWY/OiBSZWY8YW55PlxuICBkYXRlOiBEYXRlTWFya2VyXG4gIGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZVxuICB0b2RheVJhbmdlOiBEYXRlUmFuZ2VcbiAgc2hvd0RheU51bWJlcj86IGJvb2xlYW4gLy8gZGVmYXVsdHMgdG8gZmFsc2VcbiAgZXh0cmFIb29rUHJvcHM/OiBEaWN0aW9uYXJ5XG4gIGNoaWxkcmVuOiAoXG4gICAgcm9vdEVsUmVmOiBSZWY8YW55PixcbiAgICBjbGFzc05hbWVzOiBzdHJpbmdbXSxcbiAgICByb290RGF0YUF0dHJzLFxuICAgIGlzRGlzYWJsZWQ6IGJvb2xlYW5cbiAgKSA9PiBDb21wb25lbnRDaGlsZHJlblxufVxuXG5leHBvcnQgY2xhc3MgRGF5Q2VsbFJvb3QgZXh0ZW5kcyBCYXNlQ29tcG9uZW50PERheUNlbGxSb290UHJvcHM+IHtcblxuICByZWZpbmVIb29rUHJvcHMgPSBtZW1vaXplT2JqQXJnKHJlZmluZUhvb2tQcm9wcylcbiAgbm9ybWFsaXplQ2xhc3NOYW1lcyA9IGJ1aWxkQ2xhc3NOYW1lTm9ybWFsaXplcjxEYXlDZWxsQ29udGVudEFyZz4oKVxuXG5cbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzXG4gICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dFxuICAgIGxldCBob29rUHJvcHMgPSB0aGlzLnJlZmluZUhvb2tQcm9wcyh7XG4gICAgICBkYXRlOiBwcm9wcy5kYXRlLFxuICAgICAgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLFxuICAgICAgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSxcbiAgICAgIHNob3dEYXlOdW1iZXI6IHByb3BzLnNob3dEYXlOdW1iZXIsXG4gICAgICBleHRyYVByb3BzOiBwcm9wcy5leHRyYUhvb2tQcm9wcyxcbiAgICAgIHZpZXdBcGk6IGNvbnRleHQudmlld0FwaSxcbiAgICAgIGRhdGVFbnY6IGNvbnRleHQuZGF0ZUVudlxuICAgIH0pXG5cbiAgICBsZXQgY2xhc3NOYW1lcyA9IGdldERheUNsYXNzTmFtZXMoaG9va1Byb3BzLCBjb250ZXh0LnRoZW1lKS5jb25jYXQoXG4gICAgICBob29rUHJvcHMuaXNEaXNhYmxlZFxuICAgICAgICA/IFtdIC8vIGRvbid0IHVzZSBjdXN0b20gY2xhc3NOYW1lcyBpZiBkaXNhYmxlZFxuICAgICAgICA6IHRoaXMubm9ybWFsaXplQ2xhc3NOYW1lcyhvcHRpb25zLmRheUNlbGxDbGFzc05hbWVzLCBob29rUHJvcHMpXG4gICAgKVxuXG4gICAgbGV0IGRhdGFBdHRycyA9IGhvb2tQcm9wcy5pc0Rpc2FibGVkID8ge30gOiB7XG4gICAgICAnZGF0YS1kYXRlJzogZm9ybWF0RGF5U3RyaW5nKHByb3BzLmRhdGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxNb3VudEhvb2tcbiAgICAgICAgaG9va1Byb3BzPXtob29rUHJvcHN9XG4gICAgICAgIGRpZE1vdW50PXtvcHRpb25zLmRheUNlbGxEaWRNb3VudH1cbiAgICAgICAgd2lsbFVubW91bnQ9e29wdGlvbnMuZGF5Q2VsbFdpbGxVbm1vdW50fVxuICAgICAgICBlbFJlZj17cHJvcHMuZWxSZWZ9XG4gICAgICA+XG4gICAgICAgIHsocm9vdEVsUmVmKSA9PiBwcm9wcy5jaGlsZHJlbihyb290RWxSZWYsIGNsYXNzTmFtZXMsIGRhdGFBdHRycywgaG9va1Byb3BzLmlzRGlzYWJsZWQpfVxuICAgICAgPC9Nb3VudEhvb2s+XG4gICAgKVxuICB9XG5cbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIERheUNlbGxDb250ZW50UHJvcHMge1xuICBkYXRlOiBEYXRlTWFya2VyXG4gIGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZVxuICB0b2RheVJhbmdlOiBEYXRlUmFuZ2VcbiAgc2hvd0RheU51bWJlcj86IGJvb2xlYW4gLy8gZGVmYXVsdHMgdG8gZmFsc2VcbiAgZXh0cmFIb29rUHJvcHM/OiBEaWN0aW9uYXJ5XG4gIGRlZmF1bHRDb250ZW50PzogKGhvb2tQcm9wczogRGF5Q2VsbENvbnRlbnRBcmcpID0+IENvbXBvbmVudENoaWxkcmVuXG4gIGNoaWxkcmVuOiAoXG4gICAgaW5uZXJFbFJlZjogUmVmPGFueT4sXG4gICAgaW5uZXJDb250ZW50OiBDb21wb25lbnRDaGlsZHJlblxuICApID0+IENvbXBvbmVudENoaWxkcmVuXG59XG5cbmV4cG9ydCBjbGFzcyBEYXlDZWxsQ29udGVudCBleHRlbmRzIEJhc2VDb21wb25lbnQ8RGF5Q2VsbENvbnRlbnRQcm9wcz4ge1xuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpc1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHRcbiAgICBsZXQgaG9va1Byb3BzID0gcmVmaW5lSG9va1Byb3BzKHtcbiAgICAgIGRhdGU6IHByb3BzLmRhdGUsXG4gICAgICBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsXG4gICAgICB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLFxuICAgICAgc2hvd0RheU51bWJlcjogcHJvcHMuc2hvd0RheU51bWJlcixcbiAgICAgIGV4dHJhUHJvcHM6IHByb3BzLmV4dHJhSG9va1Byb3BzLFxuICAgICAgdmlld0FwaTogY29udGV4dC52aWV3QXBpLFxuICAgICAgZGF0ZUVudjogY29udGV4dC5kYXRlRW52XG4gICAgfSlcblxuICAgIHJldHVybiAoXG4gICAgICA8Q29udGVudEhvb2tcbiAgICAgICAgaG9va1Byb3BzPXtob29rUHJvcHN9XG4gICAgICAgIGNvbnRlbnQ9e29wdGlvbnMuZGF5Q2VsbENvbnRlbnR9XG4gICAgICAgIGRlZmF1bHRDb250ZW50PXtwcm9wcy5kZWZhdWx0Q29udGVudH1cbiAgICAgID5cbiAgICAgICAge3Byb3BzLmNoaWxkcmVufVxuICAgICAgPC9Db250ZW50SG9vaz5cbiAgICApXG4gIH1cblxufVxuXG5cbmZ1bmN0aW9uIHJlZmluZUhvb2tQcm9wcyhyYXc6IERheUNlbGxIb29rUHJvcHNJbnB1dCk6IERheUNlbGxDb250ZW50QXJnIHtcbiAgbGV0IHsgZGF0ZSwgZGF0ZUVudiB9ID0gcmF3XG4gIGxldCBkYXlNZXRhID0gZ2V0RGF0ZU1ldGEoZGF0ZSwgcmF3LnRvZGF5UmFuZ2UsIG51bGwsIHJhdy5kYXRlUHJvZmlsZSlcblxuICByZXR1cm4ge1xuICAgIGRhdGU6IGRhdGVFbnYudG9EYXRlKGRhdGUpLFxuICAgIHZpZXc6IHJhdy52aWV3QXBpLFxuICAgIC4uLmRheU1ldGEsXG4gICAgZGF5TnVtYmVyVGV4dDogcmF3LnNob3dEYXlOdW1iZXIgPyBkYXRlRW52LmZvcm1hdChkYXRlLCBEQVlfTlVNX0ZPUk1BVCkgOiAnJyxcbiAgICAuLi5yYXcuZXh0cmFQcm9wc1xuICB9XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVFbGVtZW50IH0gZnJvbSAnLi4vdmRvbSdcbmltcG9ydCB7IEV2ZW50Um9vdCB9IGZyb20gJy4vRXZlbnRSb290J1xuaW1wb3J0IHsgU2VnIH0gZnJvbSAnLi4vY29tcG9uZW50L0RhdGVDb21wb25lbnQnXG5pbXBvcnQgeyBFdmVudENvbnRlbnRBcmcgfSBmcm9tICcuLi9jb21wb25lbnQvZXZlbnQtcmVuZGVyaW5nJ1xuXG5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJGaWxsKGZpbGxUeXBlOiBzdHJpbmcpIHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17YGZjLSR7ZmlsbFR5cGV9YH0gLz5cbiAgKVxufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgQmdFdmVudFByb3BzIHtcbiAgc2VnOiBTZWdcbiAgaXNQYXN0OiBib29sZWFuXG4gIGlzRnV0dXJlOiBib29sZWFuXG4gIGlzVG9kYXk6IGJvb2xlYW5cbn1cblxuZXhwb3J0IGNvbnN0IEJnRXZlbnQgPSAocHJvcHM6IEJnRXZlbnRQcm9wcykgPT4gKFxuICA8RXZlbnRSb290XG4gICAgZGVmYXVsdENvbnRlbnQ9e3JlbmRlcklubmVyQ29udGVudH1cbiAgICBzZWc9e3Byb3BzLnNlZyAvKiB1c2VsZXNzcyBpIHRoaW5rICovfVxuICAgIHRpbWVUZXh0PXsnJyAvKiB3ZWlyZCAqL31cbiAgICBkaXNhYmxlRHJhZ2dpbmc9e3RydWV9XG4gICAgZGlzYWJsZVJlc2l6aW5nPXt0cnVlfVxuICAgIGlzRHJhZ2dpbmc9e2ZhbHNlfVxuICAgIGlzUmVzaXppbmc9e2ZhbHNlfVxuICAgIGlzRGF0ZVNlbGVjdGluZz17ZmFsc2V9XG4gICAgaXNTZWxlY3RlZD17ZmFsc2V9XG4gICAgaXNQYXN0PXtwcm9wcy5pc1Bhc3R9XG4gICAgaXNGdXR1cmU9e3Byb3BzLmlzRnV0dXJlfVxuICAgIGlzVG9kYXk9e3Byb3BzLmlzVG9kYXl9XG4gID5cbiAgICB7KHJvb3RFbFJlZiwgY2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50LCBob29rUHJvcHMpID0+IChcbiAgICAgIDxkaXZcbiAgICAgICAgcmVmPXtyb290RWxSZWZ9XG4gICAgICAgIGNsYXNzTmFtZT17WyAnZmMtYmctZXZlbnQnIF0uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKX1cbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGhvb2tQcm9wcy5iYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAge2lubmVyQ29udGVudH1cbiAgICAgIDwvZGl2PlxuICAgICl9XG4gIDwvRXZlbnRSb290PlxuKVxuXG5mdW5jdGlvbiByZW5kZXJJbm5lckNvbnRlbnQocHJvcHM6IEV2ZW50Q29udGVudEFyZykge1xuICBsZXQgdGl0bGUgPSBwcm9wcy5ldmVudC50aXRsZVxuXG4gIHJldHVybiB0aXRsZSAmJiAoXG4gICAgPGRpdiBjbGFzc05hbWU9J2ZjLWV2ZW50LXRpdGxlJz57cHJvcHMuZXZlbnQudGl0bGV9PC9kaXY+XG4gIClcbn1cbiIsImltcG9ydCB7IFZpZXdDb250ZXh0LCBWaWV3Q29udGV4dFR5cGUgfSBmcm9tICcuLi9WaWV3Q29udGV4dCdcbmltcG9ydCB7IERhdGVNYXJrZXIgfSBmcm9tICcuLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IFJlbmRlckhvb2ssIFJlbmRlckhvb2tQcm9wc0NoaWxkcmVuLCBNb3VudEFyZyB9IGZyb20gJy4vcmVuZGVyLWhvb2snXG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50IH0gZnJvbSAnLi4vdmRvbSdcbmltcG9ydCB7IERhdGVGb3JtYXR0ZXIgfSBmcm9tICcuLi9kYXRlbGliL0RhdGVGb3JtYXR0ZXInXG5cblxuZXhwb3J0IGludGVyZmFjZSBXZWVrTnVtYmVyUm9vdFByb3BzIHtcbiAgZGF0ZTogRGF0ZU1hcmtlclxuICBkZWZhdWx0Rm9ybWF0OiBEYXRlRm9ybWF0dGVyXG4gIGNoaWxkcmVuOiBSZW5kZXJIb29rUHJvcHNDaGlsZHJlblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdlZWtOdW1iZXJDb250ZW50QXJnIHtcbiAgbnVtOiBudW1iZXJcbiAgdGV4dDogc3RyaW5nXG4gIGRhdGU6IERhdGVcbn1cbmV4cG9ydCB0eXBlIFdlZWtOdW1iZXJNb3VudEFyZyA9IE1vdW50QXJnPFdlZWtOdW1iZXJDb250ZW50QXJnPlxuXG5cbmV4cG9ydCBjb25zdCBXZWVrTnVtYmVyUm9vdCA9IChwcm9wczogV2Vla051bWJlclJvb3RQcm9wcykgPT4gKFxuICA8Vmlld0NvbnRleHRUeXBlLkNvbnN1bWVyPlxuICAgIHsoY29udGV4dDogVmlld0NvbnRleHQpID0+IHtcbiAgICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMgfSA9IGNvbnRleHRcbiAgICAgIGxldCB7IGRhdGUgfSA9IHByb3BzXG4gICAgICBsZXQgZm9ybWF0ID0gb3B0aW9ucy53ZWVrTnVtYmVyRm9ybWF0IHx8IHByb3BzLmRlZmF1bHRGb3JtYXRcbiAgICAgIGxldCBudW0gPSBkYXRlRW52LmNvbXB1dGVXZWVrTnVtYmVyKGRhdGUpIC8vIFRPRE86IHNvbWVob3cgdXNlIGZvciBmb3JtYXR0aW5nIGFzIHdlbGw/XG4gICAgICBsZXQgdGV4dCA9IGRhdGVFbnYuZm9ybWF0KGRhdGUsIGZvcm1hdClcbiAgICAgIGxldCBob29rUHJvcHM6IFdlZWtOdW1iZXJDb250ZW50QXJnID0geyBudW0sIHRleHQsIGRhdGUgfVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICA8UmVuZGVySG9vazxXZWVrTnVtYmVyQ29udGVudEFyZz4gLy8gd2h5IGlzbid0IFdlZWtOdW1iZXJDb250ZW50QXJnIGJlaW5nIGF1dG8tZGV0ZWN0ZWQ/XG4gICAgICAgICAgaG9va1Byb3BzPXtob29rUHJvcHN9XG4gICAgICAgICAgY2xhc3NOYW1lcz17b3B0aW9ucy53ZWVrTnVtYmVyQ2xhc3NOYW1lc31cbiAgICAgICAgICBjb250ZW50PXtvcHRpb25zLndlZWtOdW1iZXJDb250ZW50fVxuICAgICAgICAgIGRlZmF1bHRDb250ZW50PXtyZW5kZXJJbm5lcn1cbiAgICAgICAgICBkaWRNb3VudD17b3B0aW9ucy53ZWVrTnVtYmVyRGlkTW91bnR9XG4gICAgICAgICAgd2lsbFVubW91bnQ9e29wdGlvbnMud2Vla051bWJlcldpbGxVbm1vdW50fVxuICAgICAgICA+XG4gICAgICAgICAge3Byb3BzLmNoaWxkcmVufVxuICAgICAgICA8L1JlbmRlckhvb2s+XG4gICAgICApXG4gICAgfX1cbiAgPC9WaWV3Q29udGV4dFR5cGUuQ29uc3VtZXI+XG4pXG5cblxuZnVuY3Rpb24gcmVuZGVySW5uZXIoaW5uZXJQcm9wcykge1xuICByZXR1cm4gaW5uZXJQcm9wcy50ZXh0XG59XG4iLCJpbXBvcnQgJy4vbWFpbi5jc3MnXG5cbi8vIGV4cG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCB2ZXJzaW9uOiBzdHJpbmcgPSAnPCU9IHZlcnNpb24gJT4nIC8vIGltcG9ydGFudCB0byB0eXBlIGl0LCBzbyAuZC50cyBoYXMgZ2VuZXJpYyBzdHJpbmdcblxuLy8gZXhwbGljaXQgQVBJXG5leHBvcnQgeyBFdmVudFNvdXJjZUFwaSB9IGZyb20gJy4vYXBpL0V2ZW50U291cmNlQXBpJ1xuZXhwb3J0IHsgRXZlbnRBcGksIGJ1aWxkRXZlbnRBcGlzIH0gZnJvbSAnLi9hcGkvRXZlbnRBcGknXG5leHBvcnQgeyBDYWxlbmRhckFwaSB9IGZyb20gJy4vQ2FsZW5kYXJBcGknXG5leHBvcnQgeyBmb3JtYXREYXRlLCBmb3JtYXRSYW5nZSB9IGZyb20gJy4vZm9ybWF0dGluZy1hcGknXG5leHBvcnQgeyBWaWV3QXBpIH0gZnJvbSAnLi9WaWV3QXBpJ1xuZXhwb3J0ICogZnJvbSAnLi9hcGktdHlwZS1kZXBzJ1xuXG5leHBvcnQgeyAvLyB0aGluZ3MgZm9yIHBsdWdpbnMuIGV2ZXJ5dGhpbmcgZWxzZSBpcyBleHBvcnRlZCBpbiBhcGktdHlwZS1kZXBzXG4gIEJBU0VfT1BUSU9OX0RFRkFVTFRTLCBCQVNFX09QVElPTl9SRUZJTkVSUywgaWRlbnRpdHksIElkZW50aXR5LCBEaWN0aW9uYXJ5LCByZWZpbmVQcm9wcyxcbiAgQmFzZU9wdGlvblJlZmluZXJzLCBCYXNlT3B0aW9uc1JlZmluZWQsIENhbGVuZGFyT3B0aW9uUmVmaW5lcnMsIENhbGVuZGFyT3B0aW9uc1JlZmluZWQsXG4gIFZpZXdPcHRpb25SZWZpbmVycywgVmlld09wdGlvbnNSZWZpbmVkLCBSYXdPcHRpb25zRnJvbVJlZmluZXJzLCBSZWZpbmVkT3B0aW9uc0Zyb21SZWZpbmVycyxcbiAgQ2FsZW5kYXJMaXN0ZW5lclJlZmluZXJzXG59IGZyb20gJy4vb3B0aW9ucydcblxuZXhwb3J0IHsgRXZlbnREZWYsIEV2ZW50RGVmSGFzaCB9IGZyb20gJy4vc3RydWN0cy9ldmVudC1kZWYnXG5leHBvcnQgeyBFdmVudEluc3RhbmNlLCBFdmVudEluc3RhbmNlSGFzaCwgY3JlYXRlRXZlbnRJbnN0YW5jZSB9IGZyb20gJy4vc3RydWN0cy9ldmVudC1pbnN0YW5jZSdcbmV4cG9ydCB7IEV2ZW50SW5wdXQsIEV2ZW50UmVmaW5lZCwgcGFyc2VFdmVudERlZiwgRXZlbnRUdXBsZSwgRXZlbnRSZWZpbmVycywgcmVmaW5lRXZlbnREZWYgfSBmcm9tICcuL3N0cnVjdHMvZXZlbnQtcGFyc2UnXG5leHBvcnQgeyBCdXNpbmVzc0hvdXJzSW5wdXQsIHBhcnNlQnVzaW5lc3NIb3VycyB9IGZyb20gJy4vc3RydWN0cy9idXNpbmVzcy1ob3VycydcblxuZXhwb3J0IHtcbiAgcGFkU3RhcnQsXG4gIGlzSW50LFxuICBwYXJzZUZpZWxkU3BlY3MsXG4gIGNvbXBhcmVCeUZpZWxkU3BlY3MsXG4gIGNvbXBhcmVCeUZpZWxkU3BlYyxcbiAgZmxleGlibGVDb21wYXJlLFxuICBwcmV2ZW50U2VsZWN0aW9uLCBhbGxvd1NlbGVjdGlvbiwgcHJldmVudENvbnRleHRNZW51LCBhbGxvd0NvbnRleHRNZW51LFxuICBjb21wYXJlTnVtYmVycywgZW5hYmxlQ3Vyc29yLCBkaXNhYmxlQ3Vyc29yLFxuICBndWlkLFxuICBjb21wdXRlU21hbGxlc3RDZWxsV2lkdGgsXG4gIE9yZGVyU3BlY1xufSBmcm9tICcuL3V0aWwvbWlzYydcblxuZXhwb3J0IHtcbiAgY29tcHV0ZVZpc2libGVEYXlSYW5nZSxcbiAgaXNNdWx0aURheVJhbmdlLFxuICBkaWZmRGF0ZXNcbn0gZnJvbSAnLi91dGlsL2RhdGUnXG5cbmV4cG9ydCB7XG4gIHJlbW92ZUV4YWN0LFxuICBpc0FycmF5c0VxdWFsXG59IGZyb20gJy4vdXRpbC9hcnJheSdcblxuZXhwb3J0IHsgbWVtb2l6ZSwgbWVtb2l6ZU9iakFyZywgbWVtb2l6ZUFycmF5bGlrZSwgbWVtb2l6ZUhhc2hsaWtlIH0gZnJvbSAnLi91dGlsL21lbW9pemUnXG5cbmV4cG9ydCB7XG4gIGludGVyc2VjdFJlY3RzLFxuICBSZWN0LCBwb2ludEluc2lkZVJlY3QsXG4gIGNvbnN0cmFpblBvaW50LFxuICBnZXRSZWN0Q2VudGVyLCBkaWZmUG9pbnRzLCBQb2ludCxcbiAgdHJhbnNsYXRlUmVjdFxufSBmcm9tICcuL3V0aWwvZ2VvbSdcblxuZXhwb3J0IHsgbWFwSGFzaCwgZmlsdGVySGFzaCwgaXNQcm9wc0VxdWFsLCBjb21wYXJlT2JqcywgYnVpbGRIYXNoRnJvbUFycmF5LCBjb2xsZWN0RnJvbUhhc2gsIGdldFVuZXF1YWxQcm9wcyB9IGZyb20gJy4vdXRpbC9vYmplY3QnXG5cbmV4cG9ydCB7XG4gIGZpbmRFbGVtZW50cyxcbiAgZmluZERpcmVjdENoaWxkcmVuLFxuICBodG1sVG9FbGVtZW50LFxuICByZW1vdmVFbGVtZW50LFxuICBhcHBseVN0eWxlLFxuICBhcHBseVN0eWxlUHJvcCxcbiAgZWxlbWVudE1hdGNoZXMsXG4gIGVsZW1lbnRDbG9zZXN0LFxuICBpc0VsVmlzaWJsZVxufSBmcm9tICcuL3V0aWwvZG9tLW1hbmlwJ1xuZXhwb3J0IHsgcGFyc2VDbGFzc05hbWVzIH0gZnJvbSAnLi91dGlsL2h0bWwnXG5cbmV4cG9ydCB7IEV2ZW50U3RvcmUsIGZpbHRlckV2ZW50U3RvcmVEZWZzLCBjcmVhdGVFbXB0eUV2ZW50U3RvcmUsIG1lcmdlRXZlbnRTdG9yZXMsIGdldFJlbGV2YW50RXZlbnRzLCBldmVudFR1cGxlVG9TdG9yZSB9IGZyb20gJy4vc3RydWN0cy9ldmVudC1zdG9yZSdcbmV4cG9ydCB7IEV2ZW50VWlIYXNoLCBFdmVudFVpLCBjb21iaW5lRXZlbnRVaXMsIGNyZWF0ZUV2ZW50VWkgfSBmcm9tICcuL2NvbXBvbmVudC9ldmVudC11aSdcbmV4cG9ydCB7IFNwbGl0dGVyLCBTcGxpdHRhYmxlUHJvcHMgfSBmcm9tICcuL2NvbXBvbmVudC9ldmVudC1zcGxpdHRpbmcnXG5leHBvcnQgeyBnZXREYXlDbGFzc05hbWVzLCBnZXREYXRlTWV0YSwgRGF0ZU1ldGEsIGdldFNsb3RDbGFzc05hbWVzIH0gZnJvbSAnLi9jb21wb25lbnQvZGF0ZS1yZW5kZXJpbmcnXG5leHBvcnQgeyBidWlsZE5hdkxpbmtEYXRhIH0gZnJvbSAnLi9jb21tb24vbmF2LWxpbmsnXG5cbmV4cG9ydCB7XG4gIHByZXZlbnREZWZhdWx0LFxuICBsaXN0ZW5CeVNlbGVjdG9yLFxuICB3aGVuVHJhbnNpdGlvbkRvbmVcbn0gZnJvbSAnLi91dGlsL2RvbS1ldmVudCdcblxuZXhwb3J0IHtcbiAgY29tcHV0ZUlubmVyUmVjdCxcbiAgY29tcHV0ZUVkZ2VzLFxuICBjb21wdXRlSGVpZ2h0QW5kTWFyZ2lucyxcbiAgZ2V0Q2xpcHBpbmdQYXJlbnRzLFxuICBjb21wdXRlUmVjdFxufSBmcm9tICcuL3V0aWwvZG9tLWdlb20nXG5cbmV4cG9ydCB7IHVucHJvbWlzaWZ5IH0gZnJvbSAnLi91dGlsL3Byb21pc2UnXG5cbmV4cG9ydCB7IEVtaXR0ZXIgfSBmcm9tICcuL2NvbW1vbi9FbWl0dGVyJ1xuZXhwb3J0IHsgRGF0ZVJhbmdlLCByYW5nZUNvbnRhaW5zTWFya2VyLCBpbnRlcnNlY3RSYW5nZXMsIHJhbmdlc0VxdWFsLCByYW5nZXNJbnRlcnNlY3QsIHJhbmdlQ29udGFpbnNSYW5nZSB9IGZyb20gJy4vZGF0ZWxpYi9kYXRlLXJhbmdlJ1xuZXhwb3J0IHsgUG9zaXRpb25DYWNoZSB9IGZyb20gJy4vY29tbW9uL1Bvc2l0aW9uQ2FjaGUnXG5leHBvcnQgeyBTY3JvbGxDb250cm9sbGVyLCBFbGVtZW50U2Nyb2xsQ29udHJvbGxlciwgV2luZG93U2Nyb2xsQ29udHJvbGxlciB9IGZyb20gJy4vY29tbW9uL3Njcm9sbC1jb250cm9sbGVyJ1xuZXhwb3J0IHsgVGhlbWUgfSBmcm9tICcuL3RoZW1lL1RoZW1lJ1xuZXhwb3J0IHsgVmlld0NvbnRleHQsIFZpZXdDb250ZXh0VHlwZSB9IGZyb20gJy4vVmlld0NvbnRleHQnXG5leHBvcnQgeyBEYXRlQ29tcG9uZW50LCBTZWcsIEV2ZW50U2VnVWlJbnRlcmFjdGlvblN0YXRlIH0gZnJvbSAnLi9jb21wb25lbnQvRGF0ZUNvbXBvbmVudCdcbmV4cG9ydCB7IENhbGVuZGFyRGF0YSB9IGZyb20gJy4vcmVkdWNlcnMvZGF0YS10eXBlcydcbmV4cG9ydCB7IENhbGVuZGFyRGF0YU1hbmFnZXIgfSBmcm9tICcuL3JlZHVjZXJzL0NhbGVuZGFyRGF0YU1hbmFnZXInXG5leHBvcnQgeyBDYWxlbmRhckRhdGFQcm92aWRlciwgQ2FsZW5kYXJEYXRhUHJvdmlkZXJQcm9wcyB9IGZyb20gJy4vY29tcG9uZW50L0NhbGVuZGFyRGF0YVByb3ZpZGVyJ1xuZXhwb3J0IHsgVmlld1Byb3BzLCBzbGljZUV2ZW50cyB9IGZyb20gJy4vVmlldydcblxuZXhwb3J0IHsgRGF0ZVByb2ZpbGVHZW5lcmF0b3IsIERhdGVQcm9maWxlIH0gZnJvbSAnLi9EYXRlUHJvZmlsZUdlbmVyYXRvcidcbmV4cG9ydCB7IFZpZXdEZWYgfSBmcm9tICcuL3N0cnVjdHMvdmlldy1kZWYnXG5leHBvcnQgeyBWaWV3U3BlYyB9IGZyb20gJy4vc3RydWN0cy92aWV3LXNwZWMnXG5leHBvcnQgeyBEYXRlU3BhbiwgRGF0ZVNwYW5BcGksIERhdGVQb2ludEFwaSwgaXNEYXRlU3BhbnNFcXVhbCB9IGZyb20gJy4vc3RydWN0cy9kYXRlLXNwYW4nXG5cbmV4cG9ydCB7IERhdGVNYXJrZXIsIGFkZERheXMsIHN0YXJ0T2ZEYXksIGFkZE1zLCBhZGRXZWVrcywgZGlmZldlZWtzLCBkaWZmV2hvbGVXZWVrcywgZGlmZldob2xlRGF5cywgZGlmZkRheUFuZFRpbWUsIGRpZmZEYXlzLCBpc1ZhbGlkRGF0ZSB9IGZyb20gJy4vZGF0ZWxpYi9tYXJrZXInXG5leHBvcnQge1xuICBEdXJhdGlvbiwgY3JlYXRlRHVyYXRpb24sXG4gIGlzU2luZ2xlRGF5LCBtdWx0aXBseUR1cmF0aW9uLCBhZGREdXJhdGlvbnMsXG4gIGFzUm91Z2hNaW51dGVzLCBhc1JvdWdoU2Vjb25kcywgYXNSb3VnaE1zLFxuICB3aG9sZURpdmlkZUR1cmF0aW9ucywgZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yXG59IGZyb20gJy4vZGF0ZWxpYi9kdXJhdGlvbidcbmV4cG9ydCB7IERhdGVFbnYsIERhdGVNYXJrZXJNZXRhIH0gZnJvbSAnLi9kYXRlbGliL2VudidcblxuZXhwb3J0IHtcbiAgY3JlYXRlRm9ybWF0dGVyLFxuICBGb3JtYXR0ZXJJbnB1dFxufSBmcm9tICcuL2RhdGVsaWIvZm9ybWF0dGluZydcbmV4cG9ydCB7XG4gIERhdGVGb3JtYXR0ZXIsXG4gIFZlcmJvc2VGb3JtYXR0aW5nQXJnXG59IGZyb20gJy4vZGF0ZWxpYi9EYXRlRm9ybWF0dGVyJ1xuZXhwb3J0IHtcbiAgZm9ybWF0SXNvVGltZVN0cmluZyxcbiAgZm9ybWF0RGF5U3RyaW5nXG59IGZyb20gJy4vZGF0ZWxpYi9mb3JtYXR0aW5nLXV0aWxzJ1xuZXhwb3J0IHsgTmFtZWRUaW1lWm9uZUltcGwgfSBmcm9tICcuL2RhdGVsaWIvdGltZXpvbmUnXG5leHBvcnQgeyBwYXJzZSBhcyBwYXJzZU1hcmtlciB9IGZyb20gJy4vZGF0ZWxpYi9wYXJzaW5nJ1xuZXhwb3J0IHsgTG9jYWxlSW5wdXQgfSBmcm9tICcuL2RhdGVsaWIvbG9jYWxlJ1xuXG5leHBvcnQgeyBFdmVudFNvdXJjZURlZiB9IGZyb20gJy4vc3RydWN0cy9ldmVudC1zb3VyY2UtZGVmJ1xuZXhwb3J0IHsgRXZlbnRTb3VyY2UsIEV2ZW50U291cmNlSGFzaCB9IGZyb20gJy4vc3RydWN0cy9ldmVudC1zb3VyY2UnXG5leHBvcnQgeyBFdmVudFNvdXJjZVJlZmluZXJzLCBFdmVudFNvdXJjZVJlZmluZWQgfSBmcm9tICcuL3N0cnVjdHMvZXZlbnQtc291cmNlLXBhcnNlJ1xuXG5leHBvcnQgeyBJbnRlcmFjdGlvbiwgSW50ZXJhY3Rpb25TZXR0aW5ncywgaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUsIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSwgSW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlIH0gZnJvbSAnLi9pbnRlcmFjdGlvbnMvaW50ZXJhY3Rpb24nXG5leHBvcnQgeyBQb2ludGVyRHJhZ0V2ZW50IH0gZnJvbSAnLi9pbnRlcmFjdGlvbnMvcG9pbnRlcidcbmV4cG9ydCB7IEhpdCB9IGZyb20gJy4vaW50ZXJhY3Rpb25zL2hpdCdcbmV4cG9ydCB7IGRhdGVTZWxlY3Rpb25Kb2luVHJhbnNmb3JtZXIgfSBmcm9tICcuL2ludGVyYWN0aW9ucy9kYXRlLXNlbGVjdGluZydcbmV4cG9ydCB7IGV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXIsIEV2ZW50RHJvcFRyYW5zZm9ybWVycyB9IGZyb20gJy4vaW50ZXJhY3Rpb25zL2V2ZW50LWRyYWdnaW5nJ1xuZXhwb3J0IHsgRXZlbnRSZXNpemVKb2luVHJhbnNmb3JtcyB9IGZyb20gJy4vaW50ZXJhY3Rpb25zL2V2ZW50LXJlc2l6aW5nJ1xuZXhwb3J0IHsgRWxlbWVudERyYWdnaW5nIH0gZnJvbSAnLi9pbnRlcmFjdGlvbnMvRWxlbWVudERyYWdnaW5nJ1xuXG5leHBvcnQgeyBjb25maWcgfSBmcm9tICcuL2dsb2JhbC1jb25maWcnXG5leHBvcnQgeyBnbG9iYWxMb2NhbGVzIH0gZnJvbSAnLi9nbG9iYWwtbG9jYWxlcydcblxuZXhwb3J0IHsgUmVjdXJyaW5nVHlwZSwgUGFyc2VkUmVjdXJyaW5nIH0gZnJvbSAnLi9zdHJ1Y3RzL3JlY3VycmluZy1ldmVudCdcblxuZXhwb3J0IHsgRHJhZ01ldGFJbnB1dCwgRHJhZ01ldGEsIHBhcnNlRHJhZ01ldGEgfSBmcm9tICcuL3N0cnVjdHMvZHJhZy1tZXRhJ1xuXG5leHBvcnQgeyBQbHVnaW5EZWYsIFBsdWdpbkRlZklucHV0LCBWaWV3UHJvcHNUcmFuc2Zvcm1lciwgVmlld0NvbnRhaW5lckFwcGVuZCB9IGZyb20gJy4vcGx1Z2luLXN5c3RlbS1zdHJ1Y3QnXG5leHBvcnQgeyBjcmVhdGVQbHVnaW4gfSBmcm9tICcuL3BsdWdpbi1zeXN0ZW0nXG5leHBvcnQgeyBBY3Rpb24gfSBmcm9tICcuL3JlZHVjZXJzL0FjdGlvbidcbmV4cG9ydCB7IENhbGVuZGFyQ29udGV4dCB9IGZyb20gJy4vQ2FsZW5kYXJDb250ZXh0J1xuZXhwb3J0IHsgQ2FsZW5kYXJDb250ZW50UHJvcHMsIENhbGVuZGFyQ29udGVudCB9IGZyb20gJy4vQ2FsZW5kYXJDb250ZW50J1xuZXhwb3J0IHsgQ2FsZW5kYXJSb290IH0gZnJvbSAnLi9DYWxlbmRhclJvb3QnXG5cbmV4cG9ydCB7IERheUhlYWRlciB9IGZyb20gJy4vY29tbW9uL0RheUhlYWRlcidcbmV4cG9ydCB7IGNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdCB9IGZyb20gJy4vY29tbW9uL3RhYmxlLXV0aWxzJ1xuZXhwb3J0IHsgVGFibGVEYXRlQ2VsbCwgVGFibGVEb3dDZWxsIH0gZnJvbSAnLi9jb21tb24vVGFibGVEYXRlQ2VsbCdcblxuZXhwb3J0IHsgRGF5U2VyaWVzTW9kZWwgfSBmcm9tICcuL2NvbW1vbi9EYXlTZXJpZXNNb2RlbCdcblxuZXhwb3J0IHsgRXZlbnRJbnRlcmFjdGlvblN0YXRlIH0gZnJvbSAnLi9pbnRlcmFjdGlvbnMvZXZlbnQtaW50ZXJhY3Rpb24tc3RhdGUnXG5leHBvcnQge1xuICBFdmVudFJlbmRlclJhbmdlLCBzbGljZUV2ZW50U3RvcmUsIGhhc0JnUmVuZGVyaW5nLCBzZXRFbFNlZywgZ2V0RWxTZWcsXG4gIGNvbXB1dGVTZWdEcmFnZ2FibGUsIGNvbXB1dGVTZWdTdGFydFJlc2l6YWJsZSwgY29tcHV0ZVNlZ0VuZFJlc2l6YWJsZSxcbiAgZ2V0RXZlbnRDbGFzc05hbWVzLCBidWlsZFNlZ1RpbWVUZXh0LFxuICBidWlsZFNlZ0NvbXBhcmVPYmosIHNvcnRFdmVudFNlZ3MsXG4gIGdldFNlZ01ldGEsIEV2ZW50Q29udGVudEFyZywgYnVpbGRFdmVudFJhbmdlS2V5XG59IGZyb20gJy4vY29tcG9uZW50L2V2ZW50LXJlbmRlcmluZydcblxuZXhwb3J0IHsgRGF5VGFibGVNb2RlbCwgRGF5VGFibGVTZWcsIERheVRhYmxlQ2VsbCB9IGZyb20gJy4vY29tbW9uL0RheVRhYmxlTW9kZWwnXG5cbmV4cG9ydCB7IFNsaWNlciwgU2xpY2VkUHJvcHMgfSBmcm9tICcuL2NvbW1vbi9zbGljaW5nLXV0aWxzJ1xuXG5leHBvcnQgeyBFdmVudE11dGF0aW9uLCBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlIH0gZnJvbSAnLi9zdHJ1Y3RzL2V2ZW50LW11dGF0aW9uJ1xuZXhwb3J0IHsgQ29uc3RyYWludCwgQ29uc3RyYWludElucHV0LCBBbGxvd0Z1bmMgfSBmcm9tICcuL3N0cnVjdHMvY29uc3RyYWludCdcbmV4cG9ydCB7IGlzUHJvcHNWYWxpZCwgaXNJbnRlcmFjdGlvblZhbGlkIH0gZnJvbSAnLi92YWxpZGF0aW9uJ1xuXG5leHBvcnQgeyByZXF1ZXN0SnNvbiB9IGZyb20gJy4vdXRpbC9yZXF1ZXN0SnNvbidcblxuZXhwb3J0ICogZnJvbSAnLi92ZG9tJ1xuZXhwb3J0IHsgQmFzZUNvbXBvbmVudCwgc2V0UmVmIH0gZnJvbSAnLi92ZG9tLXV0aWwnXG5leHBvcnQgeyBEZWxheWVkUnVubmVyIH0gZnJvbSAnLi91dGlsL3J1bm5lcidcblxuZXhwb3J0IHsgU2Nyb2xsR3JpZFByb3BzLCBTY3JvbGxHcmlkU2VjdGlvbkNvbmZpZywgQ29sR3JvdXBDb25maWcsIFNjcm9sbEdyaWRJbXBsLCBTY3JvbGxHcmlkQ2h1bmtDb25maWcgfSBmcm9tICcuL3Njcm9sbGdyaWQvU2Nyb2xsR3JpZEltcGwnXG5leHBvcnQgeyBTaW1wbGVTY3JvbGxHcmlkLCBTaW1wbGVTY3JvbGxHcmlkU2VjdGlvbiB9IGZyb20gJy4vc2Nyb2xsZ3JpZC9TaW1wbGVTY3JvbGxHcmlkJ1xuZXhwb3J0IHtcbiAgQ3NzRGltVmFsdWUsIFNjcm9sbGVyTGlrZSwgU2VjdGlvbkNvbmZpZywgQ29sUHJvcHMsIENodW5rQ29uZmlnLCBoYXNTaHJpbmtXaWR0aCwgcmVuZGVyTWljcm9Db2xHcm91cCxcbiAgZ2V0U2Nyb2xsR3JpZENsYXNzTmFtZXMsIGdldFNlY3Rpb25DbGFzc05hbWVzLCBnZXRTZWN0aW9uSGFzTGlxdWlkSGVpZ2h0LCBnZXRBbGxvd1lTY3JvbGxpbmcsIHJlbmRlckNodW5rQ29udGVudCwgY29tcHV0ZVNocmlua1dpZHRoLFxuICBDaHVua0NvbnRlbnRDYWxsYmFja0FyZ3MsXG4gIHNhbml0aXplU2hyaW5rV2lkdGgsXG4gIENodW5rQ29uZmlnUm93Q29udGVudCwgQ2h1bmtDb25maWdDb250ZW50LFxuICBpc0NvbFByb3BzRXF1YWwsXG4gIHJlbmRlclNjcm9sbFNoaW0sXG4gIGdldFN0aWNreUZvb3RlclNjcm9sbGJhcixcbiAgZ2V0U3RpY2t5SGVhZGVyRGF0ZXNcbn0gZnJvbSAnLi9zY3JvbGxncmlkL3V0aWwnXG5leHBvcnQgeyBTY3JvbGxlciwgU2Nyb2xsZXJQcm9wcywgT3ZlcmZsb3dWYWx1ZSB9IGZyb20gJy4vc2Nyb2xsZ3JpZC9TY3JvbGxlcidcbmV4cG9ydCB7IGdldFNjcm9sbGJhcldpZHRocyB9IGZyb20gJy4vdXRpbC9zY3JvbGxiYXItd2lkdGgnXG5leHBvcnQgeyBSZWZNYXAgfSBmcm9tICcuL3V0aWwvUmVmTWFwJ1xuZXhwb3J0IHsgZ2V0SXNSdGxTY3JvbGxiYXJPbkxlZnQgfSBmcm9tICcuL3V0aWwvc2Nyb2xsYmFyLXNpZGUnXG5cbmV4cG9ydCB7IE5vd1RpbWVyIH0gZnJvbSAnLi9Ob3dUaW1lcidcbmV4cG9ydCB7IFNjcm9sbFJlc3BvbmRlciwgU2Nyb2xsUmVxdWVzdCB9IGZyb20gJy4vU2Nyb2xsUmVzcG9uZGVyJ1xuZXhwb3J0IHsgZ2xvYmFsUGx1Z2lucyB9IGZyb20gJy4vZ2xvYmFsLXBsdWdpbnMnXG5leHBvcnQge1xuICBSZW5kZXJIb29rLCBSZW5kZXJIb29rUHJvcHMsIFJlbmRlckhvb2tQcm9wc0NoaWxkcmVuLCBNb3VudEhvb2ssIE1vdW50SG9va1Byb3BzLCBidWlsZENsYXNzTmFtZU5vcm1hbGl6ZXIsIENvbnRlbnRIb29rLCBDdXN0b21Db250ZW50UmVuZGVyQ29udGV4dCxcbiAgQ2xhc3NOYW1lc0dlbmVyYXRvciwgQ3VzdG9tQ29udGVudEdlbmVyYXRvciwgRGlkTW91bnRIYW5kbGVyLCBXaWxsVW5tb3VudEhhbmRsZXIsIE1vdW50QXJnXG59IGZyb20gJy4vY29tbW9uL3JlbmRlci1ob29rJ1xuZXhwb3J0IHsgU3RhbmRhcmRFdmVudCwgU3RhbmRhcmRFdmVudFByb3BzIH0gZnJvbSAnLi9jb21tb24vU3RhbmRhcmRFdmVudCdcbmV4cG9ydCB7IE5vd0luZGljYXRvclJvb3QsIE5vd0luZGljYXRvclJvb3RQcm9wcyB9IGZyb20gJy4vY29tbW9uL05vd0luZGljYXRvclJvb3QnXG5cbmV4cG9ydCB7IERheUNlbGxSb290LCBEYXlDZWxsUm9vdFByb3BzLCBEYXlDZWxsQ29udGVudCwgRGF5Q2VsbENvbnRlbnRQcm9wcywgRGF5Q2VsbENvbnRlbnRBcmcgfSBmcm9tICcuL2NvbW1vbi9EYXlDZWxsUm9vdCdcbmV4cG9ydCB7IEV2ZW50Um9vdCwgTWluaW1hbEV2ZW50UHJvcHMgfSBmcm9tICcuL2NvbW1vbi9FdmVudFJvb3QnXG5leHBvcnQgeyByZW5kZXJGaWxsLCBCZ0V2ZW50LCBCZ0V2ZW50UHJvcHMgfSBmcm9tICcuL2NvbW1vbi9iZy1maWxsJ1xuZXhwb3J0IHsgV2Vla051bWJlclJvb3QsIFdlZWtOdW1iZXJSb290UHJvcHMgfSBmcm9tICcuL2NvbW1vbi9XZWVrTnVtYmVyUm9vdCdcblxuZXhwb3J0IHsgVmlld1Jvb3QsIFZpZXdSb290UHJvcHMgfSBmcm9tICcuL2NvbW1vbi9WaWV3Um9vdCdcbmV4cG9ydCB7IHRyaWdnZXJEYXRlU2VsZWN0LCBEYXRlUG9pbnRUcmFuc2Zvcm0sIERhdGVTcGFuVHJhbnNmb3JtLCBEYXRlU2VsZWN0aW9uQXBpLCBnZXREZWZhdWx0RXZlbnRFbmQgfSBmcm9tICcuL2NhbGVuZGFyLXV0aWxzJ1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR0E7QUFDQTtBQUNBOzs7O0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRkE7O0FBQUE7QUFLQTs7QUFBQTtBQUNBO0FBQ0E7QUFGQTs7QUFBQTtBQUlBO0FBQUE7QUFDQTtBQUNBO0FDcENBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFJQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3RJQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU1BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQUlBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQWdCQTs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDcE1BO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQ2pOQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQzdCQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3RNQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBOzs7OztBQUdBO0FBT0E7QUFDQTtBQUdBO0FBQ0E7QUFGQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMvRkE7QUFDQTtBQUNBO0FBSUE7OztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSkE7QUFKQTtBQVdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUM5TkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbERBO0FBTUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQURBO0FBQUE7OztBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFNQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFEQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBWUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBVUE7QUFBQTtBQUFBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBWkE7QUFjQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN4V0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBO0FBQ0E7QUN2QkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FDdEJBOzs7O0FBSUE7Ozs7OztBQUlBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FDeEJBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQ2RBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FDcUJBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBektBO0FBdUxBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBOUNBO0FBd0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJCQTtBQW1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQXlCQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFnQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFvQ0E7QUFDQTtBQUNBO0FBQ0E7QUNsY0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQ2pIQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQUNBO0FBd0NBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQVlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFZQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFHQTtBQURBO0FBQ0E7QUE0QkE7QUFLQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBQ0E7QUFnQkE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDN05BOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQy9HQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFRQTtBQUNBO0FBNkJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUdBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUM5U0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBTEE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUNsSkE7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBOzs7O0FBS0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUZBOztBQUFBO0FBS0E7QUFBQTtBQUNBO0FBQ0E7QUFGQTs7QUFBQTtBQUtBO0FBQUE7QUFDQTtBQUNBO0FBRkE7O0FBQUE7QUFLQTtBQUFBO0FBQ0E7QUFDQTtBQUZBOztBQUFBO0FBS0E7QUFBQTtBQUNBO0FBQ0E7QUFGQTs7QUFBQTtBQUtBO0FBQUE7QUFDQTtBQUNBO0FBRkE7O0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBVEE7QUFDQTtBQWdDQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWRBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1BBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQUE7QUFDQTtBQURBO0FBQUE7OztBQUNBO0FBQ0E7Ozs7QUFPQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBOzs7O0FBS0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQU9BO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7OztBQU9BO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFIQTtBQUNBO0FBS0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUhBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBOzs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7O0FDNWhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTs7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBREE7QUFlQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQVZBOztBQUFBO0FBWUE7QUFBQTtBQUNBO0FBR0E7QUFKQTs7QUFBQTtBQU1BO0FBQUE7QUFDQTtBQUdBO0FBSkE7O0FBQUE7QUFNQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQVRBOztBQUFBO0FBV0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFUQTs7QUFBQTtBQWFBOzs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUdBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQy9iQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2dCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFGQTtBQVFBO0FBQ0E7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQU9BO0FBQ0E7QUFGQTtBQVFBOzs7Ozs7O0FBTUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUM5Y0E7QUN3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBdEJBO0FBQ0E7QUF5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQy9HQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFEQTtBQUlBO0FBQ0E7QUFDQTtBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTs7OztBQUdBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUN2Q0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQ3ZEQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQStJQTtBQUNBO0FBMUlBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNuTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNwRkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQ1BBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FDOUJBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQ2hCQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFTQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBOzs7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekJBO0FBRUE7QUFFQTtBQXVDQTtBQUNBO0FBckNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBREE7QUFBQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2xFQTs7Ozs7OztBQUtBO0FBQUE7QUFBQTtBQWFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQzVHQTs7Ozs7OztBQUtBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF6Q0E7QUFDQTs7OztBQTBDQTtBQUNBO0FBREE7O0FBa0NBO0FBQ0E7QUFqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbENBO0FBQ0E7Ozs7QUNqRkE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9FQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQTJCQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUE5QkE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUM3Q0E7QUFDQTtBQW9CQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQTNCQTtBQTZCQTtBQUNBO0FDN0VBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTs7QUFzQkE7QUFDQTtBQVhBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFuQkE7QUFDQTtBQUNBO0FBa0JBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTs7QUFLQTtBQUNBO0FBSkE7QUFHQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUM3Q0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBUUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaERBO0FBa0RBO0FBQ0E7QUFFQTtBQVNBO0FBRUE7QUFGQTtBQUtBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUN0TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFBQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFPQTtBQUFBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFMQTtBQVFBO0FBQ0E7QUFJQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzVRQTs7Ozs7Ozs7O0FBT0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUNBOztBQXFGQTs7OztBQXZFQTtBQUNBO0FBR0E7QUFDQTtBQUNBOzs7O0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7O0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXZGQTtBQUNBO0FBQ0E7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuQ0E7QUFxQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpDQTtBQUNBO0FBbUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakNBO0FBbUNBO0FBQ0E7QUM5SkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBOztBQUNBO0FBQ0E7QUFEQTtBQURBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQVBBO0FBWUE7QUFDQTtBQUNBO0FDM0RBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQTlCQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUVBO0FBR0E7QUFDQTtBQVVBO0FBbENBO0FBQ0E7QUFDQTtBQStDQTtBQUNBO0FBWUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUNBOztBQWlGQTtBQUNBO0FBMUVBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFFQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUVBOztBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQW5GQTtBQUNBOzs7O0FBbUdBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBMUJBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQVVBO0FBOUJBO0FBQ0E7QUFnQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsUEE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUNBOztBQXdCQTtBQUNBO0FBdEJBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQTFCQTtBQUNBO0FDU0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUtBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUVBO0FBREE7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBR0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUVBO0FBQ0E7QUFmQTtBQW9CQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0RBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQVFBO0FBQ0E7QUFFQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUdBO0FBQ0E7Ozs7O0FBTUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUVBOzs7QUFHQTs7O0FBSUE7O0FBR0E7QUFFQTs7O0FBSUE7OztBQUlBOztBQUdBOztBQUdBO0FBRUE7O0FBR0E7QUFDQTtBQWhDQTtBQWtDQTs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUNBOzs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7OztBQUtBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7Ozs7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBTUE7QUFDQTtBQUNBOzs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7OztBQVFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FDN2NBO0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQ1ZBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBMUJBO0FBQ0E7QUE0QkE7QUFDQTtBQUNBO0FDN0JBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcENBO0FBc0NBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBR0E7QUFFQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUNuUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFkQTtBQWdCQTtBQUNBO0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFkQTtBQWdCQTtBQUNBO0FDaEJBO0FBT0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBU0E7QUFFQTtBQUFBO0FBRUE7QUFHQTs7Ozs7QUFHQTtBQUFBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNyR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQWRBO0FBaUJBO0FBQ0E7QUFEQTtBQ0RBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBSkE7QUFPQTtBQXBCQTtBQXdCQTtBQUNBO0FBREE7QUFDQTtBQzNDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FDaUJBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQTdCQTtBQWtDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBS0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQ29CQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFoREE7QUFxREE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUtBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFEQTtBQVNBOzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdkNBO0FBQ0E7QUFFQTtBQURBO0FBR0E7QUFDQTtBQ1VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbkJBOzs7Ozs7QUFJQTtBQU9BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUxBO0FBQ0E7Ozs7QUNkQTtBQUNBO0FBTkE7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUNoSkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQUE7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FDUUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBZ0NBO0FBQUE7QUFDQTtBQS9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFxRkE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBMUZBO0FBQ0E7QUFFQTtBQUNBO0FBTUE7QUFDQTs7O0FBU0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFDQTtBQVVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQUNBO0FBZ0JBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFZQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7OztBQVNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZkE7QUFDQTtBQWdCQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFNQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFFQTtBQVdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBTUE7QUFFQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQU9BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5CQTtBQXNCQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQVVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQWhCQTtBQXNCQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQ3JwQkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQUE7QUFDQTtBQVVBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7QUFLQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXZDQTtBQUNBO0FDVUE7Ozs7OztBQUlBO0FBQ0E7QUFNQTtBQUNBOzs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUNBOzs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQ2hEQTs7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUFBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FDeENBO0FBQ0E7QUFDQTtBQURBO0FDQUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFtQkE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQ3BCQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7O0FBc0RBO0FBQ0E7QUFyREE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBVUE7QUFDQTtBQUNBO0FBdERBO0FBQ0E7QUE0REE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBOztBQTBEQTtBQUNBO0FBekRBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMURBO0FBQ0E7QUFDQTtBQ2xFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7O0FBOEJBO0FBQ0E7QUE3QkE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUZBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBOUJBO0FDRkE7Ozs7O0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQVJBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF2Q0E7QUFJQTs7QUFFQTtBQUNBO0FBaUNBO0FBN0NBO0FDSkE7Ozs7OztBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUFBO0FBQ0E7QUFDQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFoQ0E7QUFHQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUE1REE7QUFDQTs7OztBQ1lBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBeU1BO0FBQ0E7QUFDQTtBQUlBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7Ozs7OztBQXBQQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBTUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFnQkE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBSEE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBV0E7QUFDQTtBQUNBO0FBSEE7QUFTQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBYUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBd0RBO0FBclFBO0FBQ0E7QUF1UUE7O0FBU0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDclVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNKQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUF5Q0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUEvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBV0E7QUFyREE7QUFDQTtBQUNBO0FDcEJBOzs7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUNZQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBOztBQStEQTtBQUNBO0FBOURBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFEQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFKQTtBQU9BO0FBQUE7QUFHQTtBQUNBO0FBRkE7QUFhQTtBQUdBO0FBQ0E7QUFDQTtBQS9EQTtBQUNBOzs7O0FBMkVBO0FBQ0E7QUFEQTs7QUFpRUE7QUFDQTtBQWhFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBU0E7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFEQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBRUE7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUFBO0FBRUE7QUFJQTtBQUxBO0FBV0E7QUFHQTtBQUNBO0FBQ0E7QUFqRUE7QUFDQTtBQW1FQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdKQTtBQUNBO0FBU0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBekVBO0FBMEVBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7OztBQ3BGQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQ0E7O0FBd0NBO0FBQ0E7QUF0Q0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQTFDQTtBQUNBO0FBNENBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7O0FDdkZBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBOEtBO0FBQ0E7QUE3S0E7QUFLQTtBQUNBO0FBREE7QUFBQTs7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQURBO0FBQUE7OztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQURBO0FBQUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBREE7QUFBQTs7O0FBRUE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQURBO0FBQUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQURBO0FBQUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUlBO0FBQ0E7QUN4TkE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFrQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFxRUE7QUFDQTtBQXhHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBQUE7QUFZQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTVHQTtBQ3JCQTs7Ozs7O0FBSUE7QUFBQTtBQUFBO0FBT0E7QUFBQTtBQUNBO0FBREE7QUFMQTtBQUNBO0FBQ0E7QUFDQTtBQW1CQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBekNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFrQ0E7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUlBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTEE7QUFlQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFBQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN0xBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFrSUE7QUFDQTtBQUNBO0FBREE7QUFJQTtBQUNBOztBQW1FQTtBQUNBO0FBck1BO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVlBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUFBOzs7QUFJQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBV0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFKQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFSQTtBQVlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFuTkE7QUFDQTtBQW9OQTtBQUNBO0FBQ0E7QUFGQTtBQUNBOzs7O0FDck5BO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFDQTs7QUFtRUE7QUFDQTtBQWpFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBRUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyRUE7QUFDQTtBQUNBO0FDaEJBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTs7QUFzREE7QUFDQTtBQXJEQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBUUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBTkE7QUFTQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUFBO0FBR0E7QUFBQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBdERBO0FBQ0E7QUF3REE7QUFDQTtBQUdBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQzVFQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFVQTtBQUVBO0FBQ0E7QUMvQkE7QUFBQTtBQUFBO0FBQ0E7QUFtQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBc0NBO0FBQ0E7QUFwQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBVUE7QUFDQTtBQUtBO0FBQ0E7QUFEQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUF6Q0E7QUFDQTs7OztBQXdEQTtBQUNBO0FBREE7O0FBMEJBO0FBQ0E7QUF6QkE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBVUE7QUFFQTtBQUNBO0FBQ0E7QUFIQTtBQVFBO0FBQ0E7QUFDQTtBQTFCQTtBQUNBO0FBNEJBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQURBO0FBSUE7QUFDQTtBQy9JQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFTQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBRkE7QUFHQTtBQUFBO0FBSEE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUhBO0FBU0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUNuQ0E7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFXQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUMvQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/common/main.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/common/vdom.js":
/*!***************************************************!*\
  !*** ./node_modules/@fullcalendar/common/vdom.js ***!
  \***************************************************/
/*! exports provided: Component, createElement, render, createRef, Fragment, createContext, flushToDom */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return Component; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createElement\", function() { return createElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createRef\", function() { return createRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Fragment\", function() { return Fragment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createContext\", function() { return createContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"flushToDom\", function() { return flushToDom; });\nif (typeof FullCalendarVDom === 'undefined') {\n  throw new Error('Please import the top-level fullcalendar lib before attempting to import a plugin.');\n}\n\nvar Component = FullCalendarVDom.Component;\nvar createElement = FullCalendarVDom.createElement;\nvar render = FullCalendarVDom.render;\nvar createRef = FullCalendarVDom.createRef;\nvar Fragment = FullCalendarVDom.Fragment;\nvar createContext = FullCalendarVDom.createContext;\nvar flushToDom = FullCalendarVDom.flushToDom;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb21tb24vdmRvbS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvbW1vbi92ZG9tLmpzP2RlODkiXSwic291cmNlc0NvbnRlbnQiOlsiXG5pZiAodHlwZW9mIEZ1bGxDYWxlbmRhclZEb20gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgaW1wb3J0IHRoZSB0b3AtbGV2ZWwgZnVsbGNhbGVuZGFyIGxpYiBiZWZvcmUgYXR0ZW1wdGluZyB0byBpbXBvcnQgYSBwbHVnaW4uJyk7XG59XG5leHBvcnQgdmFyIENvbXBvbmVudCA9IEZ1bGxDYWxlbmRhclZEb20uQ29tcG9uZW50O1xuZXhwb3J0IHZhciBjcmVhdGVFbGVtZW50ID0gRnVsbENhbGVuZGFyVkRvbS5jcmVhdGVFbGVtZW50O1xuZXhwb3J0IHZhciByZW5kZXIgPSBGdWxsQ2FsZW5kYXJWRG9tLnJlbmRlcjtcbmV4cG9ydCB2YXIgY3JlYXRlUmVmID0gRnVsbENhbGVuZGFyVkRvbS5jcmVhdGVSZWY7XG5leHBvcnQgdmFyIEZyYWdtZW50ID0gRnVsbENhbGVuZGFyVkRvbS5GcmFnbWVudDtcbmV4cG9ydCB2YXIgY3JlYXRlQ29udGV4dCA9IEZ1bGxDYWxlbmRhclZEb20uY3JlYXRlQ29udGV4dDtcbmV4cG9ydCB2YXIgZmx1c2hUb0RvbSA9IEZ1bGxDYWxlbmRhclZEb20uZmx1c2hUb0RvbTtcbiJdLCJtYXBwaW5ncyI6IkFBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/common/vdom.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/core/main.css":
/*!**************************************************!*\
  !*** ./node_modules/@fullcalendar/core/main.css ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"\\n/* classes attached to <body> */\\n\\n.fc-not-allowed,\\n.fc-not-allowed .fc-event { /* override events' custom cursors */\\n  cursor: not-allowed;\\n}\\n\\n.fc-unselectable {\\n  user-select: none;\\n  -webkit-touch-callout: none;\\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\\n}\\n.fc {\\n  /* layout of immediate children */\\n  display: flex;\\n  flex-direction: column;\\n\\n  font-size: 1em\\n}\\n.fc,\\n  .fc *,\\n  .fc *:before,\\n  .fc *:after {\\n    box-sizing: border-box;\\n  }\\n.fc table {\\n    border-collapse: collapse;\\n    border-spacing: 0;\\n    font-size: 1em; /* normalize cross-browser */\\n  }\\n.fc th {\\n    text-align: center;\\n  }\\n.fc th,\\n  .fc td {\\n    vertical-align: top;\\n    padding: 0;\\n  }\\n.fc a[data-navlink] {\\n    cursor: pointer;\\n  }\\n.fc a[data-navlink]:hover {\\n    text-decoration: underline;\\n  }\\n.fc-direction-ltr {\\n  direction: ltr;\\n  text-align: left;\\n}\\n.fc-direction-rtl {\\n  direction: rtl;\\n  text-align: right;\\n}\\n.fc-theme-standard td,\\n  .fc-theme-standard th {\\n    border: 1px solid #ddd;\\n    border: 1px solid var(--fc-border-color, #ddd);\\n  }\\n/* for FF, which doesn't expand a 100% div within a table cell. use absolute positioning */\\n/* inner-wrappers are responsible for being absolute */\\n/* TODO: best place for this? */\\n.fc-liquid-hack td,\\n  .fc-liquid-hack th {\\n    position: relative;\\n  }\\n\\n@font-face {\\n  font-family: 'fcicons';\\n  src: url(\\\"data:application/x-font-ttf;charset=utf-8;base64,AAEAAAALAIAAAwAwT1MvMg8SBfAAAAC8AAAAYGNtYXAXVtKNAAABHAAAAFRnYXNwAAAAEAAAAXAAAAAIZ2x5ZgYydxIAAAF4AAAFNGhlYWQUJ7cIAAAGrAAAADZoaGVhB20DzAAABuQAAAAkaG10eCIABhQAAAcIAAAALGxvY2ED4AU6AAAHNAAAABhtYXhwAA8AjAAAB0wAAAAgbmFtZXsr690AAAdsAAABhnBvc3QAAwAAAAAI9AAAACAAAwPAAZAABQAAApkCzAAAAI8CmQLMAAAB6wAzAQkAAAAAAAAAAAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAABAAADpBgPA/8AAQAPAAEAAAAABAAAAAAAAAAAAAAAgAAAAAAADAAAAAwAAABwAAQADAAAAHAADAAEAAAAcAAQAOAAAAAoACAACAAIAAQAg6Qb//f//AAAAAAAg6QD//f//AAH/4xcEAAMAAQAAAAAAAAAAAAAAAQAB//8ADwABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAQAAAAAAAAAAAAIAADc5AQAAAAABAWIAjQKeAskAEwAAJSc3NjQnJiIHAQYUFwEWMjc2NCcCnuLiDQ0MJAz/AA0NAQAMJAwNDcni4gwjDQwM/wANIwz/AA0NDCMNAAAAAQFiAI0CngLJABMAACUBNjQnASYiBwYUHwEHBhQXFjI3AZ4BAA0N/wAMJAwNDeLiDQ0MJAyNAQAMIw0BAAwMDSMM4uINIwwNDQAAAAIA4gC3Ax4CngATACcAACUnNzY0JyYiDwEGFB8BFjI3NjQnISc3NjQnJiIPAQYUHwEWMjc2NCcB87e3DQ0MIw3VDQ3VDSMMDQ0BK7e3DQ0MJAzVDQ3VDCQMDQ3zuLcMJAwNDdUNIwzWDAwNIwy4twwkDA0N1Q0jDNYMDA0jDAAAAgDiALcDHgKeABMAJwAAJTc2NC8BJiIHBhQfAQcGFBcWMjchNzY0LwEmIgcGFB8BBwYUFxYyNwJJ1Q0N1Q0jDA0Nt7cNDQwjDf7V1Q0N1QwkDA0Nt7cNDQwkDLfWDCMN1Q0NDCQMt7gMIw0MDNYMIw3VDQ0MJAy3uAwjDQwMAAADAFUAAAOrA1UAMwBoAHcAABMiBgcOAQcOAQcOARURFBYXHgEXHgEXHgEzITI2Nz4BNz4BNz4BNRE0JicuAScuAScuASMFITIWFx4BFx4BFx4BFREUBgcOAQcOAQcOASMhIiYnLgEnLgEnLgE1ETQ2Nz4BNz4BNz4BMxMhMjY1NCYjISIGFRQWM9UNGAwLFQkJDgUFBQUFBQ4JCRULDBgNAlYNGAwLFQkJDgUFBQUFBQ4JCRULDBgN/aoCVgQIBAQHAwMFAQIBAQIBBQMDBwQECAT9qgQIBAQHAwMFAQIBAQIBBQMDBwQECASAAVYRGRkR/qoRGRkRA1UFBAUOCQkVDAsZDf2rDRkLDBUJCA4FBQUFBQUOCQgVDAsZDQJVDRkLDBUJCQ4FBAVVAgECBQMCBwQECAX9qwQJAwQHAwMFAQICAgIBBQMDBwQDCQQCVQUIBAQHAgMFAgEC/oAZEhEZGRESGQAAAAADAFUAAAOrA1UAMwBoAIkAABMiBgcOAQcOAQcOARURFBYXHgEXHgEXHgEzITI2Nz4BNz4BNz4BNRE0JicuAScuAScuASMFITIWFx4BFx4BFx4BFREUBgcOAQcOAQcOASMhIiYnLgEnLgEnLgE1ETQ2Nz4BNz4BNz4BMxMzFRQWMzI2PQEzMjY1NCYrATU0JiMiBh0BIyIGFRQWM9UNGAwLFQkJDgUFBQUFBQ4JCRULDBgNAlYNGAwLFQkJDgUFBQUFBQ4JCRULDBgN/aoCVgQIBAQHAwMFAQIBAQIBBQMDBwQECAT9qgQIBAQHAwMFAQIBAQIBBQMDBwQECASAgBkSEhmAERkZEYAZEhIZgBEZGREDVQUEBQ4JCRUMCxkN/asNGQsMFQkIDgUFBQUFBQ4JCBUMCxkNAlUNGQsMFQkJDgUEBVUCAQIFAwIHBAQIBf2rBAkDBAcDAwUBAgICAgEFAwMHBAMJBAJVBQgEBAcCAwUCAQL+gIASGRkSgBkSERmAEhkZEoAZERIZAAABAOIAjQMeAskAIAAAExcHBhQXFjI/ARcWMjc2NC8BNzY0JyYiDwEnJiIHBhQX4uLiDQ0MJAzi4gwkDA0N4uINDQwkDOLiDCQMDQ0CjeLiDSMMDQ3h4Q0NDCMN4uIMIw0MDOLiDAwNIwwAAAABAAAAAQAAa5n0y18PPPUACwQAAAAAANivOVsAAAAA2K85WwAAAAADqwNVAAAACAACAAAAAAAAAAEAAAPA/8AAAAQAAAAAAAOrAAEAAAAAAAAAAAAAAAAAAAALBAAAAAAAAAAAAAAAAgAAAAQAAWIEAAFiBAAA4gQAAOIEAABVBAAAVQQAAOIAAAAAAAoAFAAeAEQAagCqAOoBngJkApoAAQAAAAsAigADAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAA4ArgABAAAAAAABAAcAAAABAAAAAAACAAcAYAABAAAAAAADAAcANgABAAAAAAAEAAcAdQABAAAAAAAFAAsAFQABAAAAAAAGAAcASwABAAAAAAAKABoAigADAAEECQABAA4ABwADAAEECQACAA4AZwADAAEECQADAA4APQADAAEECQAEAA4AfAADAAEECQAFABYAIAADAAEECQAGAA4AUgADAAEECQAKADQApGZjaWNvbnMAZgBjAGkAYwBvAG4Ac1ZlcnNpb24gMS4wAFYAZQByAHMAaQBvAG4AIAAxAC4AMGZjaWNvbnMAZgBjAGkAYwBvAG4Ac2ZjaWNvbnMAZgBjAGkAYwBvAG4Ac1JlZ3VsYXIAUgBlAGcAdQBsAGEAcmZjaWNvbnMAZgBjAGkAYwBvAG4Ac0ZvbnQgZ2VuZXJhdGVkIGJ5IEljb01vb24uAEYAbwBuAHQAIABnAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAEkAYwBvAE0AbwBvAG4ALgAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\\\") format('truetype');\\n  font-weight: normal;\\n  font-style: normal;\\n}\\n\\n.fc-icon {\\n  /* added for fc */\\n  display: inline-block;\\n  width: 1em;\\n  height: 1em;\\n  text-align: center;\\n  user-select: none;\\n\\n  /* use !important to prevent issues with browser extensions that change fonts */\\n  font-family: 'fcicons' !important;\\n  speak: none;\\n  font-style: normal;\\n  font-weight: normal;\\n  font-variant: normal;\\n  text-transform: none;\\n  line-height: 1;\\n\\n  /* Better Font Rendering =========== */\\n  -webkit-font-smoothing: antialiased;\\n  -moz-osx-font-smoothing: grayscale;\\n}\\n\\n.fc-icon-chevron-left:before {\\n  content: \\\"\\\\e900\\\";\\n}\\n\\n.fc-icon-chevron-right:before {\\n  content: \\\"\\\\e901\\\";\\n}\\n\\n.fc-icon-chevrons-left:before {\\n  content: \\\"\\\\e902\\\";\\n}\\n\\n.fc-icon-chevrons-right:before {\\n  content: \\\"\\\\e903\\\";\\n}\\n\\n.fc-icon-minus-square:before {\\n  content: \\\"\\\\e904\\\";\\n}\\n\\n.fc-icon-plus-square:before {\\n  content: \\\"\\\\e905\\\";\\n}\\n\\n.fc-icon-x:before {\\n  content: \\\"\\\\e906\\\";\\n}\\n/*\\nLots taken from Flatly (MIT): https://bootswatch.com/4/flatly/bootstrap.css\\n\\nThese styles only apply when the standard-theme is activated.\\nWhen it's NOT activated, the fc-button classes won't even be in the DOM.\\n*/\\n.fc {\\n\\n  /* reset */\\n\\n}\\n.fc .fc-button {\\n    border-radius: 0;\\n    overflow: visible;\\n    text-transform: none;\\n    margin: 0;\\n    font-family: inherit;\\n    font-size: inherit;\\n    line-height: inherit;\\n  }\\n.fc .fc-button:focus {\\n    outline: 1px dotted;\\n    outline: 5px auto -webkit-focus-ring-color;\\n  }\\n.fc .fc-button {\\n    -webkit-appearance: button;\\n  }\\n.fc .fc-button:not(:disabled) {\\n    cursor: pointer;\\n  }\\n.fc .fc-button::-moz-focus-inner {\\n    padding: 0;\\n    border-style: none;\\n  }\\n.fc {\\n\\n  /* theme */\\n\\n}\\n.fc .fc-button {\\n    display: inline-block;\\n    font-weight: 400;\\n    text-align: center;\\n    vertical-align: middle;\\n    user-select: none;\\n    background-color: transparent;\\n    border: 1px solid transparent;\\n    padding: 0.4em 0.65em;\\n    font-size: 1em;\\n    line-height: 1.5;\\n    border-radius: 0.25em;\\n  }\\n.fc .fc-button:hover {\\n    text-decoration: none;\\n  }\\n.fc .fc-button:focus {\\n    outline: 0;\\n    box-shadow: 0 0 0 0.2rem rgba(44, 62, 80, 0.25);\\n  }\\n.fc .fc-button:disabled {\\n    opacity: 0.65;\\n  }\\n.fc {\\n\\n  /* \\\"primary\\\" coloring */\\n\\n}\\n.fc .fc-button-primary {\\n    color: #fff;\\n    color: var(--fc-button-text-color, #fff);\\n    background-color: #2C3E50;\\n    background-color: var(--fc-button-bg-color, #2C3E50);\\n    border-color: #2C3E50;\\n    border-color: var(--fc-button-border-color, #2C3E50);\\n  }\\n.fc .fc-button-primary:hover {\\n    color: #fff;\\n    color: var(--fc-button-text-color, #fff);\\n    background-color: #1e2b37;\\n    background-color: var(--fc-button-hover-bg-color, #1e2b37);\\n    border-color: #1a252f;\\n    border-color: var(--fc-button-hover-border-color, #1a252f);\\n  }\\n.fc .fc-button-primary:disabled { /* not DRY */\\n    color: #fff;\\n    color: var(--fc-button-text-color, #fff);\\n    background-color: #2C3E50;\\n    background-color: var(--fc-button-bg-color, #2C3E50);\\n    border-color: #2C3E50;\\n    border-color: var(--fc-button-border-color, #2C3E50); /* overrides :hover */\\n  }\\n.fc .fc-button-primary:focus {\\n    box-shadow: 0 0 0 0.2rem rgba(76, 91, 106, 0.5);\\n  }\\n.fc .fc-button-primary:not(:disabled):active,\\n  .fc .fc-button-primary:not(:disabled).fc-button-active {\\n    color: #fff;\\n    color: var(--fc-button-text-color, #fff);\\n    background-color: #1a252f;\\n    background-color: var(--fc-button-active-bg-color, #1a252f);\\n    border-color: #151e27;\\n    border-color: var(--fc-button-active-border-color, #151e27);\\n  }\\n.fc .fc-button-primary:not(:disabled):active:focus,\\n  .fc .fc-button-primary:not(:disabled).fc-button-active:focus {\\n    box-shadow: 0 0 0 0.2rem rgba(76, 91, 106, 0.5);\\n  }\\n.fc {\\n\\n  /* icons within buttons */\\n\\n}\\n.fc .fc-button .fc-icon {\\n    vertical-align: middle;\\n    font-size: 1.5em; /* bump up the size (but don't make it bigger than line-height of button, which is 1.5em also) */\\n  }\\n.fc .fc-button-group {\\n    position: relative;\\n    display: inline-flex;\\n    vertical-align: middle;\\n  }\\n.fc .fc-button-group > .fc-button {\\n    position: relative;\\n    flex: 1 1 auto;\\n  }\\n.fc .fc-button-group > .fc-button:hover {\\n    z-index: 1;\\n  }\\n.fc .fc-button-group > .fc-button:focus,\\n  .fc .fc-button-group > .fc-button:active,\\n  .fc .fc-button-group > .fc-button.fc-button-active {\\n    z-index: 1;\\n  }\\n.fc-direction-ltr .fc-button-group > .fc-button:not(:first-child) {\\n    margin-left: -1px;\\n    border-top-left-radius: 0;\\n    border-bottom-left-radius: 0;\\n  }\\n.fc-direction-ltr .fc-button-group > .fc-button:not(:last-child) {\\n    border-top-right-radius: 0;\\n    border-bottom-right-radius: 0;\\n  }\\n.fc-direction-rtl .fc-button-group > .fc-button:not(:first-child) {\\n    margin-right: -1px;\\n    border-top-right-radius: 0;\\n    border-bottom-right-radius: 0;\\n  }\\n.fc-direction-rtl .fc-button-group > .fc-button:not(:last-child) {\\n    border-top-left-radius: 0;\\n    border-bottom-left-radius: 0;\\n  }\\n.fc .fc-toolbar {\\n    display: flex;\\n    justify-content: space-between;\\n    align-items: center;\\n  }\\n.fc .fc-toolbar.fc-header-toolbar {\\n    margin-bottom: 1.5em;\\n  }\\n.fc .fc-toolbar.fc-footer-toolbar {\\n    margin-top: 1.5em;\\n  }\\n.fc .fc-toolbar-title {\\n    font-size: 1.75em;\\n    margin: 0;\\n  }\\n.fc-direction-ltr .fc-toolbar > * > :not(:first-child) {\\n    margin-left: .75em; /* space between */\\n  }\\n.fc-direction-rtl .fc-toolbar > * > :not(:first-child) {\\n    margin-right: .75em; /* space between */\\n  }\\n.fc-direction-rtl .fc-toolbar-ltr { /* when the toolbar-chunk positioning system is explicitly left-to-right */\\n    flex-direction: row-reverse;\\n  }\\n.fc .fc-scroller {\\n    -webkit-overflow-scrolling: touch;\\n    position: relative; /* for abs-positioned elements within */\\n  }\\n.fc .fc-scroller-liquid {\\n    height: 100%;\\n  }\\n.fc .fc-scroller-liquid-absolute {\\n    position: absolute;\\n    top: 0;\\n    right: 0;\\n    left: 0;\\n    bottom: 0;\\n  }\\n.fc .fc-scroller-harness {\\n    position: relative;\\n    overflow: hidden;\\n    direction: ltr;\\n      /* hack for chrome computing the scroller's right/left wrong for rtl. undone below... */\\n      /* TODO: demonstrate in codepen */\\n  }\\n.fc .fc-scroller-harness-liquid {\\n    height: 100%;\\n  }\\n.fc-direction-rtl .fc-scroller-harness > .fc-scroller { /* undo above hack */\\n    direction: rtl;\\n  }\\n.fc-theme-standard .fc-scrollgrid {\\n    border: 1px solid #ddd;\\n    border: 1px solid var(--fc-border-color, #ddd); /* bootstrap does this. match */\\n  }\\n.fc .fc-scrollgrid,\\n    .fc .fc-scrollgrid table { /* all tables (self included) */\\n      width: 100%; /* because tables don't normally do this */\\n      table-layout: fixed;\\n    }\\n.fc .fc-scrollgrid table { /* inner tables */\\n      border-top-style: hidden;\\n      border-left-style: hidden;\\n      border-right-style: hidden;\\n    }\\n.fc .fc-scrollgrid > tbody table,\\n    .fc .fc-scrollgrid > tfoot table {\\n      border-bottom-style: hidden; /* head keeps its bottom border tho */\\n    }\\n.fc .fc-scrollgrid {\\n\\n    border-collapse: separate;\\n    border-right-width: 0;\\n    border-bottom-width: 0\\n  }\\n.fc .fc-scrollgrid > * > tr > * {\\n      border-top-width: 0;\\n      border-left-width: 0;\\n    }\\n.fc .fc-scrollgrid > thead > tr > *,\\n    .fc .fc-scrollgrid > tfoot > tr > * {\\n      border-bottom-width: 0;\\n    }\\n.fc .fc-scrollgrid-liquid {\\n    height: 100%;\\n  }\\n.fc .fc-scrollgrid-section { /* a <tr> */\\n    height: 0\\n\\n  }\\n.fc .fc-scrollgrid-section > td {\\n      height: 0; /* needs a height so inner div within grow */\\n    }\\n.fc .fc-scrollgrid-section table {\\n      height: 1px;\\n        /* for most browsers, if a height isn't set on the table, can't do liquid-height within cells */\\n        /* serves as a min-height. harmless */\\n    }\\n.fc .fc-scrollgrid-section-liquid {\\n    height: auto\\n\\n  }\\n.fc .fc-scrollgrid-section-liquid > td {\\n      height: 100%; /* FF needs this instead of auto */\\n    }\\n.fc {\\n\\n  /* stickiness */\\n\\n}\\n.fc .fc-scrollgrid-section-sticky > * {\\n    background: #fff; /* TODO: var */\\n    position: sticky;\\n    z-index: 2; /* TODO: var */\\n    /* TODO: box-shadow when sticking */\\n  }\\n.fc .fc-scrollgrid > thead > .fc-scrollgrid-section-sticky > * {\\n    top: 0; /* because border-sharing causes a gap at the top */\\n      /* TODO: give safari -1. has bug */\\n  }\\n.fc .fc-scrollgrid > tfoot > .fc-scrollgrid-section-sticky > * {\\n    bottom: 0; /* known bug: bottom-stickiness doesn't work in safari */\\n  }\\n.fc .fc-scrollgrid-sticky-shim { /* for horizontal scrollbar */\\n    height: 1px; /* needs height to create scrollbars */\\n    margin-bottom: -1px;\\n  }\\n.fc .fc-sticky {\\n    position: sticky;\\n  }\\n.fc .fc-view-harness {\\n    flex-grow: 1; /* because this harness is WITHIN the .fc's flexbox */\\n    position: relative;\\n  }\\n.fc {\\n\\n  /* when the harness controls the height, make the view liquid */\\n\\n}\\n.fc .fc-view-harness-active > .fc-view {\\n    position: absolute;\\n    top: 0;\\n    right: 0;\\n    bottom: 0;\\n    left: 0;\\n  }\\n.fc .fc-col-header-cell-cushion {\\n    display: inline-block; /* x-browser for when sticky (when multi-tier header) */\\n    padding: 2px 4px;\\n  }\\n.fc .fc-bg-event,\\n  .fc .fc-non-business,\\n  .fc .fc-highlight {\\n    /* will always have a harness with position:relative/absolute, so absolutely expand */\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    right: 0;\\n    bottom: 0;\\n  }\\n.fc .fc-non-business {\\n    background: rgba(215, 215, 215, 0.3);\\n    background: var(--fc-non-business-color, rgba(215, 215, 215, 0.3));\\n  }\\n.fc .fc-bg-event {\\n    background: rgb(143, 223, 130);\\n    background: var(--fc-bg-event-color, rgb(143, 223, 130));\\n    opacity: 0.3;\\n    opacity: var(--fc-bg-event-opacity, 0.3)\\n  }\\n.fc .fc-bg-event .fc-event-title {\\n      margin: .5em;\\n      font-size: .85em;\\n      font-size: var(--fc-small-font-size, .85em);\\n      font-style: italic;\\n    }\\n.fc .fc-highlight {\\n    background: rgba(188, 232, 241, 0.3);\\n    background: var(--fc-highlight-color, rgba(188, 232, 241, 0.3));\\n  }\\n.fc .fc-day-today {\\n    background: rgba(255, 220, 40, 0.15);\\n    background: var(--fc-today-bg-color, rgba(255, 220, 40, 0.15)); /* for all themes. bootstrap didn't provide a good semi-transparent color for this */\\n  }\\n.fc .fc-cell-shaded,\\n  .fc .fc-day-disabled {\\n    background: rgba(208, 208, 208, 0.3);\\n    background: var(--fc-neutral-bg-color, rgba(208, 208, 208, 0.3));\\n  }\\n/* link resets */\\n/* ---------------------------------------------------------------------------------------------------- */\\na.fc-event {\\n  display: block;\\n}\\na.fc-event,\\na.fc-event:hover {\\n  text-decoration: none;\\n}\\n/* cursor */\\n.fc-event[href],\\n.fc-event.fc-event-draggable {\\n  cursor: pointer;\\n}\\n/* event text content */\\n/* ---------------------------------------------------------------------------------------------------- */\\n.fc-event .fc-event-main {\\n    position: relative;\\n    z-index: 2;\\n  }\\n/* dragging */\\n/* ---------------------------------------------------------------------------------------------------- */\\n.fc-event-dragging:not(.fc-event-selected) { /* MOUSE */\\n    opacity: 0.75;\\n  }\\n.fc-event-dragging.fc-event-selected { /* TOUCH */\\n    box-shadow: 0 2px 7px rgba(0, 0, 0, 0.3);\\n  }\\n/* resizing */\\n/* ---------------------------------------------------------------------------------------------------- */\\n/* (subclasses should hone positioning for touch and non-touch) */\\n.fc-event .fc-event-resizer {\\n    display: none;\\n    position: absolute;\\n    z-index: 4;\\n  }\\n.fc-event:hover, /* MOUSE */\\n.fc-event-selected { /* TOUCH */\\n\\n}\\n.fc-event:hover .fc-event-resizer, .fc-event-selected .fc-event-resizer {\\n    display: block;\\n  }\\n.fc-event-selected .fc-event-resizer {\\n    border-radius: 4px;\\n    border-radius: calc(var(--fc-event-resizer-dot-total-width, 8px) / 2);\\n    border-width: 1px;\\n    border-width: var(--fc-event-resizer-dot-border-width, 1px);\\n    width: 8px;\\n    width: var(--fc-event-resizer-dot-total-width, 8px);\\n    height: 8px;\\n    height: var(--fc-event-resizer-dot-total-width, 8px);\\n    border-style: solid;\\n    border-color: inherit;\\n    background: #fff;\\n    background: var(--fc-page-bg-color, #fff)\\n\\n    /* expand hit area */\\n\\n  }\\n.fc-event-selected .fc-event-resizer:before {\\n      content: '';\\n      position: absolute;\\n      top: -20px;\\n      left: -20px;\\n      right: -20px;\\n      bottom: -20px;\\n    }\\n/* selecting (always TOUCH) */\\n/* ---------------------------------------------------------------------------------------------------- */\\n.fc-event-selected {\\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2)\\n\\n  /* expand hit area (subclasses should expand) */\\n\\n}\\n.fc-event-selected:before {\\n    content: \\\"\\\";\\n    position: absolute;\\n    z-index: 3;\\n    top: 0;\\n    left: 0;\\n    right: 0;\\n    bottom: 0;\\n  }\\n.fc-event-selected {\\n\\n  /* dimmer effect */\\n\\n}\\n.fc-event-selected:after {\\n    content: \\\"\\\";\\n    background: rgba(0, 0, 0, 0.25);\\n    background: var(--fc-event-selected-overlay-color, rgba(0, 0, 0, 0.25));\\n    position: absolute;\\n    z-index: 1;\\n\\n    /* assume there's a border on all sides. overcome it. */\\n    /* sometimes there's NOT a border, in which case the dimmer will go over */\\n    /* an adjacent border, which looks fine. */\\n    top: -1px;\\n    left: -1px;\\n    right: -1px;\\n    bottom: -1px;\\n  }\\n/*\\nA HORIZONTAL event\\n*/\\n.fc-h-event { /* allowed to be top-level */\\n\\n  border: 1px solid #3788d8;\\n\\n  border: 1px solid var(--fc-event-bg-color, #3788d8);\\n  background-color: #3788d8;\\n  background-color: var(--fc-event-border-color, #3788d8)\\n\\n}\\n.fc-h-event .fc-event-main {\\n    color: #fff;\\n    color: var(--fc-event-text-color, #fff);\\n    display: flex;\\n  }\\n.fc-h-event .fc-event-title-frame { /* serves as a container for the sticky cushion */\\n    flex-grow: 1;\\n    flex-shrink: 1;\\n    min-width: 0; /* important for allowing to shrink all the way */\\n  }\\n.fc-h-event .fc-event-title {\\n    display: inline-block; /* need this to be sticky cross-browser */\\n    vertical-align: top; /* for not messing up line-height */\\n    left: 0;  /* for sticky */\\n    right: 0; /* for sticky */\\n    max-width: 100%; /* clip overflow on this element */\\n    overflow: hidden;\\n  }\\n.fc-h-event.fc-event-selected:before {\\n    /* expand hit area */\\n    top: -10px;\\n    bottom: -10px;\\n  }\\n/* adjust border and border-radius (if there is any) for non-start/end */\\n.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-start),\\n.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-end) {\\n  border-top-left-radius: 0;\\n  border-bottom-left-radius: 0;\\n  border-left-width: 0;\\n}\\n.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-end),\\n.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-start) {\\n  border-top-right-radius: 0;\\n  border-bottom-right-radius: 0;\\n  border-right-width: 0;\\n}\\n/* resizers */\\n.fc-h-event:not(.fc-event-selected) .fc-event-resizer {\\n  top: 0;\\n  bottom: 0;\\n  width: 8px;\\n  width: var(--fc-event-resizer-thickness, 8px);\\n}\\n.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start,\\n.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end {\\n  cursor: w-resize;\\n  left: -4px;\\n  left: calc(var(--fc-event-resizer-thickness, 8px) / -2);\\n}\\n.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end,\\n.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start {\\n  cursor: e-resize;\\n  right: -4px;\\n  right: calc(var(--fc-event-resizer-thickness, 8px) / -2);\\n}\\n/* resizers for TOUCH */\\n.fc-h-event.fc-event-selected .fc-event-resizer {\\n  top: 50%;\\n  margin-top: -4px;\\n  margin-top: calc(var(--fc-event-resizer-dot-total-width, 8px) / -2);\\n}\\n.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-start,\\n.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-end {\\n  left: -4px;\\n  left: calc(var(--fc-event-resizer-dot-total-width, 8px) / -2);\\n}\\n.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-end,\\n.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-start {\\n  right: -4px;\\n  right: calc(var(--fc-event-resizer-dot-total-width, 8px) / -2);\\n}\\n\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL21haW4uY3NzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9tYWluLmNzcz8wZWEzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiXFxuLyogY2xhc3NlcyBhdHRhY2hlZCB0byA8Ym9keT4gKi9cXG5cXG4uZmMtbm90LWFsbG93ZWQsXFxuLmZjLW5vdC1hbGxvd2VkIC5mYy1ldmVudCB7IC8qIG92ZXJyaWRlIGV2ZW50cycgY3VzdG9tIGN1cnNvcnMgKi9cXG4gIGN1cnNvcjogbm90LWFsbG93ZWQ7XFxufVxcblxcbi5mYy11bnNlbGVjdGFibGUge1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7XFxuICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMCk7XFxufVxcbi5mYyB7XFxuICAvKiBsYXlvdXQgb2YgaW1tZWRpYXRlIGNoaWxkcmVuICovXFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG5cXG4gIGZvbnQtc2l6ZTogMWVtXFxufVxcbi5mYyxcXG4gIC5mYyAqLFxcbiAgLmZjICo6YmVmb3JlLFxcbiAgLmZjICo6YWZ0ZXIge1xcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgfVxcbi5mYyB0YWJsZSB7XFxuICAgIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxuICAgIGJvcmRlci1zcGFjaW5nOiAwO1xcbiAgICBmb250LXNpemU6IDFlbTsgLyogbm9ybWFsaXplIGNyb3NzLWJyb3dzZXIgKi9cXG4gIH1cXG4uZmMgdGgge1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICB9XFxuLmZjIHRoLFxcbiAgLmZjIHRkIHtcXG4gICAgdmVydGljYWwtYWxpZ246IHRvcDtcXG4gICAgcGFkZGluZzogMDtcXG4gIH1cXG4uZmMgYVtkYXRhLW5hdmxpbmtdIHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgfVxcbi5mYyBhW2RhdGEtbmF2bGlua106aG92ZXIge1xcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG4gIH1cXG4uZmMtZGlyZWN0aW9uLWx0ciB7XFxuICBkaXJlY3Rpb246IGx0cjtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxufVxcbi5mYy1kaXJlY3Rpb24tcnRsIHtcXG4gIGRpcmVjdGlvbjogcnRsO1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxufVxcbi5mYy10aGVtZS1zdGFuZGFyZCB0ZCxcXG4gIC5mYy10aGVtZS1zdGFuZGFyZCB0aCB7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICNkZGQ7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWZjLWJvcmRlci1jb2xvciwgI2RkZCk7XFxuICB9XFxuLyogZm9yIEZGLCB3aGljaCBkb2Vzbid0IGV4cGFuZCBhIDEwMCUgZGl2IHdpdGhpbiBhIHRhYmxlIGNlbGwuIHVzZSBhYnNvbHV0ZSBwb3NpdGlvbmluZyAqL1xcbi8qIGlubmVyLXdyYXBwZXJzIGFyZSByZXNwb25zaWJsZSBmb3IgYmVpbmcgYWJzb2x1dGUgKi9cXG4vKiBUT0RPOiBiZXN0IHBsYWNlIGZvciB0aGlzPyAqL1xcbi5mYy1saXF1aWQtaGFjayB0ZCxcXG4gIC5mYy1saXF1aWQtaGFjayB0aCB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIH1cXG5cXG5AZm9udC1mYWNlIHtcXG4gIGZvbnQtZmFtaWx5OiAnZmNpY29ucyc7XFxuICBzcmM6IHVybChcXFwiZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtdHRmO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LEFBRUFBQUFMQUlBQUF3QXdUMU12TWc4U0JmQUFBQUM4QUFBQVlHTnRZWEFYVnRLTkFBQUJIQUFBQUZSbllYTndBQUFBRUFBQUFYQUFBQUFJWjJ4NVpnWXlkeElBQUFGNEFBQUZOR2hsWVdRVUo3Y0lBQUFHckFBQUFEWm9hR1ZoQjIwRHpBQUFCdVFBQUFBa2FHMTBlQ0lBQmhRQUFBY0lBQUFBTEd4dlkyRUQ0QVU2QUFBSE5BQUFBQmh0WVhod0FBOEFqQUFBQjB3QUFBQWdibUZ0WlhzcjY5MEFBQWRzQUFBQmhuQnZjM1FBQXdBQUFBQUk5QUFBQUNBQUF3UEFBWkFBQlFBQUFwa0N6QUFBQUk4Q21RTE1BQUFCNndBekFRa0FBQUFBQUFBQUFBQUFBQUFBQUFBQkVBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBRHBCZ1BBLzhBQVFBUEFBRUFBQUFBQkFBQUFBQUFBQUFBQUFBQWdBQUFBQUFBREFBQUFBd0FBQUJ3QUFRQURBQUFBSEFBREFBRUFBQUFjQUFRQU9BQUFBQW9BQ0FBQ0FBSUFBUUFnNlFiLy9mLy9BQUFBQUFBZzZRRC8vZi8vQUFILzR4Y0VBQU1BQVFBQUFBQUFBQUFBQUFBQUFRQUIvLzhBRHdBQkFBQUFBQUFBQUFBQUFnQUFOemtCQUFBQUFBRUFBQUFBQUFBQUFBQUNBQUEzT1FFQUFBQUFBUUFBQUFBQUFBQUFBQUlBQURjNUFRQUFBQUFCQVdJQWpRS2VBc2tBRXdBQUpTYzNOalFuSmlJSEFRWVVGd0VXTWpjMk5DY0NudUxpRFEwTUpBei9BQTBOQVFBTUpBd05EY25pNGd3akRRd00vd0FOSXd6L0FBME5EQ01OQUFBQUFRRmlBSTBDbmdMSkFCTUFBQ1VCTmpRbkFTWWlCd1lVSHdFSEJoUVhGakkzQVo0QkFBME4vd0FNSkF3TkRlTGlEUTBNSkF5TkFRQU1JdzBCQUF3TURTTU00dUlOSXd3TkRRQUFBQUlBNGdDM0F4NENuZ0FUQUNjQUFDVW5OelkwSnlZaUR3RUdGQjhCRmpJM05qUW5JU2MzTmpRbkppSVBBUVlVSHdFV01qYzJOQ2NCODdlM0RRME1JdzNWRFEzVkRTTU1EUTBCSzdlM0RRME1KQXpWRFEzVkRDUU1EUTN6dUxjTUpBd05EZFVOSXd6V0RBd05Jd3k0dHd3a0RBME4xUTBqRE5ZTURBMGpEQUFBQWdEaUFMY0RIZ0tlQUJNQUp3QUFKVGMyTkM4QkppSUhCaFFmQVFjR0ZCY1dNamNoTnpZMEx3RW1JZ2NHRkI4QkJ3WVVGeFl5TndKSjFRME4xUTBqREEwTnQ3Y05EUXdqRGY3VjFRME4xUXdrREEwTnQ3Y05EUXdrRExmV0RDTU4xUTBORENRTXQ3Z01JdzBNRE5ZTUl3M1ZEUTBNSkF5M3VBd2pEUXdNQUFBREFGVUFBQU9yQTFVQU13Qm9BSGNBQUJNaUJnY09BUWNPQVFjT0FSVVJGQllYSGdFWEhnRVhIZ0V6SVRJMk56NEJOejRCTno0Qk5SRTBKaWN1QVNjdUFTY3VBU01GSVRJV0Z4NEJGeDRCRng0QkZSRVVCZ2NPQVFjT0FRY09BU01oSWlZbkxnRW5MZ0VuTGdFMUVUUTJOejRCTno0Qk56NEJNeE1oTWpZMU5DWWpJU0lHRlJRV005VU5HQXdMRlFrSkRnVUZCUVVGQlE0SkNSVUxEQmdOQWxZTkdBd0xGUWtKRGdVRkJRVUZCUTRKQ1JVTERCZ04vYW9DVmdRSUJBUUhBd01GQVFJQkFRSUJCUU1EQndRRUNBVDlxZ1FJQkFRSEF3TUZBUUlCQVFJQkJRTURCd1FFQ0FTQUFWWVJHUmtSL3FvUkdSa1JBMVVGQkFVT0NRa1ZEQXNaRGYyckRSa0xEQlVKQ0E0RkJRVUZCUVVPQ1FnVkRBc1pEUUpWRFJrTERCVUpDUTRGQkFWVkFnRUNCUU1DQndRRUNBWDlxd1FKQXdRSEF3TUZBUUlDQWdJQkJRTURCd1FEQ1FRQ1ZRVUlCQVFIQWdNRkFnRUMvb0FaRWhFWkdSRVNHUUFBQUFBREFGVUFBQU9yQTFVQU13Qm9BSWtBQUJNaUJnY09BUWNPQVFjT0FSVVJGQllYSGdFWEhnRVhIZ0V6SVRJMk56NEJOejRCTno0Qk5SRTBKaWN1QVNjdUFTY3VBU01GSVRJV0Z4NEJGeDRCRng0QkZSRVVCZ2NPQVFjT0FRY09BU01oSWlZbkxnRW5MZ0VuTGdFMUVUUTJOejRCTno0Qk56NEJNeE16RlJRV016STJQUUV6TWpZMU5DWXJBVFUwSmlNaUJoMEJJeUlHRlJRV005VU5HQXdMRlFrSkRnVUZCUVVGQlE0SkNSVUxEQmdOQWxZTkdBd0xGUWtKRGdVRkJRVUZCUTRKQ1JVTERCZ04vYW9DVmdRSUJBUUhBd01GQVFJQkFRSUJCUU1EQndRRUNBVDlxZ1FJQkFRSEF3TUZBUUlCQVFJQkJRTURCd1FFQ0FTQWdCa1NFaG1BRVJrWkVZQVpFaElaZ0JFWkdSRURWUVVFQlE0SkNSVU1DeGtOL2FzTkdRc01GUWtJRGdVRkJRVUZCUTRKQ0JVTUN4a05BbFVOR1FzTUZRa0pEZ1VFQlZVQ0FRSUZBd0lIQkFRSUJmMnJCQWtEQkFjREF3VUJBZ0lDQWdFRkF3TUhCQU1KQkFKVkJRZ0VCQWNDQXdVQ0FRTCtnSUFTR1JrU2dCa1NFUm1BRWhrWkVvQVpFUklaQUFBQkFPSUFqUU1lQXNrQUlBQUFFeGNIQmhRWEZqSS9BUmNXTWpjMk5DOEJOelkwSnlZaUR3RW5KaUlIQmhRWDR1TGlEUTBNSkF6aTRnd2tEQTBONHVJTkRRd2tET0xpRENRTURRMENqZUxpRFNNTURRM2g0UTBORENNTjR1SU1JdzBNRE9MaURBd05Jd3dBQUFBQkFBQUFBUUFBYTVuMHkxOFBQUFVBQ3dRQUFBQUFBTml2T1ZzQUFBQUEySzg1V3dBQUFBQURxd05WQUFBQUNBQUNBQUFBQUFBQUFBRUFBQVBBLzhBQUFBUUFBQUFBQUFPckFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBTEJBQUFBQUFBQUFBQUFBQUFBZ0FBQUFRQUFXSUVBQUZpQkFBQTRnUUFBT0lFQUFCVkJBQUFWUVFBQU9JQUFBQUFBQW9BRkFBZUFFUUFhZ0NxQU9vQm5nSmtBcG9BQVFBQUFBc0FpZ0FEQUFBQUFBQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTRBcmdBQkFBQUFBQUFCQUFjQUFBQUJBQUFBQUFBQ0FBY0FZQUFCQUFBQUFBQURBQWNBTmdBQkFBQUFBQUFFQUFjQWRRQUJBQUFBQUFBRkFBc0FGUUFCQUFBQUFBQUdBQWNBU3dBQkFBQUFBQUFLQUJvQWlnQURBQUVFQ1FBQkFBNEFCd0FEQUFFRUNRQUNBQTRBWndBREFBRUVDUUFEQUE0QVBRQURBQUVFQ1FBRUFBNEFmQUFEQUFFRUNRQUZBQllBSUFBREFBRUVDUUFHQUE0QVVnQURBQUVFQ1FBS0FEUUFwR1pqYVdOdmJuTUFaZ0JqQUdrQVl3QnZBRzRBYzFabGNuTnBiMjRnTVM0d0FGWUFaUUJ5QUhNQWFRQnZBRzRBSUFBeEFDNEFNR1pqYVdOdmJuTUFaZ0JqQUdrQVl3QnZBRzRBYzJaamFXTnZibk1BWmdCakFHa0FZd0J2QUc0QWMxSmxaM1ZzWVhJQVVnQmxBR2NBZFFCc0FHRUFjbVpqYVdOdmJuTUFaZ0JqQUdrQVl3QnZBRzRBYzBadmJuUWdaMlZ1WlhKaGRHVmtJR0o1SUVsamIwMXZiMjR1QUVZQWJ3QnVBSFFBSUFCbkFHVUFiZ0JsQUhJQVlRQjBBR1VBWkFBZ0FHSUFlUUFnQUVrQVl3QnZBRTBBYndCdkFHNEFMZ0FBQUFNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQT1cXFwiKSBmb3JtYXQoJ3RydWV0eXBlJyk7XFxuICBmb250LXdlaWdodDogbm9ybWFsO1xcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcbn1cXG5cXG4uZmMtaWNvbiB7XFxuICAvKiBhZGRlZCBmb3IgZmMgKi9cXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHdpZHRoOiAxZW07XFxuICBoZWlnaHQ6IDFlbTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcblxcbiAgLyogdXNlICFpbXBvcnRhbnQgdG8gcHJldmVudCBpc3N1ZXMgd2l0aCBicm93c2VyIGV4dGVuc2lvbnMgdGhhdCBjaGFuZ2UgZm9udHMgKi9cXG4gIGZvbnQtZmFtaWx5OiAnZmNpY29ucycgIWltcG9ydGFudDtcXG4gIHNwZWFrOiBub25lO1xcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gIGZvbnQtdmFyaWFudDogbm9ybWFsO1xcbiAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxuICBsaW5lLWhlaWdodDogMTtcXG5cXG4gIC8qIEJldHRlciBGb250IFJlbmRlcmluZyA9PT09PT09PT09PSAqL1xcbiAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XFxuICAtbW96LW9zeC1mb250LXNtb290aGluZzogZ3JheXNjYWxlO1xcbn1cXG5cXG4uZmMtaWNvbi1jaGV2cm9uLWxlZnQ6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcZTkwMFxcXCI7XFxufVxcblxcbi5mYy1pY29uLWNoZXZyb24tcmlnaHQ6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcZTkwMVxcXCI7XFxufVxcblxcbi5mYy1pY29uLWNoZXZyb25zLWxlZnQ6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcZTkwMlxcXCI7XFxufVxcblxcbi5mYy1pY29uLWNoZXZyb25zLXJpZ2h0OmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwiXFxcXGU5MDNcXFwiO1xcbn1cXG5cXG4uZmMtaWNvbi1taW51cy1zcXVhcmU6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcZTkwNFxcXCI7XFxufVxcblxcbi5mYy1pY29uLXBsdXMtc3F1YXJlOmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwiXFxcXGU5MDVcXFwiO1xcbn1cXG5cXG4uZmMtaWNvbi14OmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwiXFxcXGU5MDZcXFwiO1xcbn1cXG4vKlxcbkxvdHMgdGFrZW4gZnJvbSBGbGF0bHkgKE1JVCk6IGh0dHBzOi8vYm9vdHN3YXRjaC5jb20vNC9mbGF0bHkvYm9vdHN0cmFwLmNzc1xcblxcblRoZXNlIHN0eWxlcyBvbmx5IGFwcGx5IHdoZW4gdGhlIHN0YW5kYXJkLXRoZW1lIGlzIGFjdGl2YXRlZC5cXG5XaGVuIGl0J3MgTk9UIGFjdGl2YXRlZCwgdGhlIGZjLWJ1dHRvbiBjbGFzc2VzIHdvbid0IGV2ZW4gYmUgaW4gdGhlIERPTS5cXG4qL1xcbi5mYyB7XFxuXFxuICAvKiByZXNldCAqL1xcblxcbn1cXG4uZmMgLmZjLWJ1dHRvbiB7XFxuICAgIGJvcmRlci1yYWRpdXM6IDA7XFxuICAgIG92ZXJmbG93OiB2aXNpYmxlO1xcbiAgICB0ZXh0LXRyYW5zZm9ybTogbm9uZTtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBmb250LWZhbWlseTogaW5oZXJpdDtcXG4gICAgZm9udC1zaXplOiBpbmhlcml0O1xcbiAgICBsaW5lLWhlaWdodDogaW5oZXJpdDtcXG4gIH1cXG4uZmMgLmZjLWJ1dHRvbjpmb2N1cyB7XFxuICAgIG91dGxpbmU6IDFweCBkb3R0ZWQ7XFxuICAgIG91dGxpbmU6IDVweCBhdXRvIC13ZWJraXQtZm9jdXMtcmluZy1jb2xvcjtcXG4gIH1cXG4uZmMgLmZjLWJ1dHRvbiB7XFxuICAgIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uO1xcbiAgfVxcbi5mYyAuZmMtYnV0dG9uOm5vdCg6ZGlzYWJsZWQpIHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgfVxcbi5mYyAuZmMtYnV0dG9uOjotbW96LWZvY3VzLWlubmVyIHtcXG4gICAgcGFkZGluZzogMDtcXG4gICAgYm9yZGVyLXN0eWxlOiBub25lO1xcbiAgfVxcbi5mYyB7XFxuXFxuICAvKiB0aGVtZSAqL1xcblxcbn1cXG4uZmMgLmZjLWJ1dHRvbiB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgZm9udC13ZWlnaHQ6IDQwMDtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgICBwYWRkaW5nOiAwLjRlbSAwLjY1ZW07XFxuICAgIGZvbnQtc2l6ZTogMWVtO1xcbiAgICBsaW5lLWhlaWdodDogMS41O1xcbiAgICBib3JkZXItcmFkaXVzOiAwLjI1ZW07XFxuICB9XFxuLmZjIC5mYy1idXR0b246aG92ZXIge1xcbiAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICB9XFxuLmZjIC5mYy1idXR0b246Zm9jdXMge1xcbiAgICBvdXRsaW5lOiAwO1xcbiAgICBib3gtc2hhZG93OiAwIDAgMCAwLjJyZW0gcmdiYSg0NCwgNjIsIDgwLCAwLjI1KTtcXG4gIH1cXG4uZmMgLmZjLWJ1dHRvbjpkaXNhYmxlZCB7XFxuICAgIG9wYWNpdHk6IDAuNjU7XFxuICB9XFxuLmZjIHtcXG5cXG4gIC8qIFxcXCJwcmltYXJ5XFxcIiBjb2xvcmluZyAqL1xcblxcbn1cXG4uZmMgLmZjLWJ1dHRvbi1wcmltYXJ5IHtcXG4gICAgY29sb3I6ICNmZmY7XFxuICAgIGNvbG9yOiB2YXIoLS1mYy1idXR0b24tdGV4dC1jb2xvciwgI2ZmZik7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMyQzNFNTA7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWZjLWJ1dHRvbi1iZy1jb2xvciwgIzJDM0U1MCk7XFxuICAgIGJvcmRlci1jb2xvcjogIzJDM0U1MDtcXG4gICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1mYy1idXR0b24tYm9yZGVyLWNvbG9yLCAjMkMzRTUwKTtcXG4gIH1cXG4uZmMgLmZjLWJ1dHRvbi1wcmltYXJ5OmhvdmVyIHtcXG4gICAgY29sb3I6ICNmZmY7XFxuICAgIGNvbG9yOiB2YXIoLS1mYy1idXR0b24tdGV4dC1jb2xvciwgI2ZmZik7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMxZTJiMzc7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWZjLWJ1dHRvbi1ob3Zlci1iZy1jb2xvciwgIzFlMmIzNyk7XFxuICAgIGJvcmRlci1jb2xvcjogIzFhMjUyZjtcXG4gICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1mYy1idXR0b24taG92ZXItYm9yZGVyLWNvbG9yLCAjMWEyNTJmKTtcXG4gIH1cXG4uZmMgLmZjLWJ1dHRvbi1wcmltYXJ5OmRpc2FibGVkIHsgLyogbm90IERSWSAqL1xcbiAgICBjb2xvcjogI2ZmZjtcXG4gICAgY29sb3I6IHZhcigtLWZjLWJ1dHRvbi10ZXh0LWNvbG9yLCAjZmZmKTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzJDM0U1MDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZmMtYnV0dG9uLWJnLWNvbG9yLCAjMkMzRTUwKTtcXG4gICAgYm9yZGVyLWNvbG9yOiAjMkMzRTUwO1xcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWZjLWJ1dHRvbi1ib3JkZXItY29sb3IsICMyQzNFNTApOyAvKiBvdmVycmlkZXMgOmhvdmVyICovXFxuICB9XFxuLmZjIC5mYy1idXR0b24tcHJpbWFyeTpmb2N1cyB7XFxuICAgIGJveC1zaGFkb3c6IDAgMCAwIDAuMnJlbSByZ2JhKDc2LCA5MSwgMTA2LCAwLjUpO1xcbiAgfVxcbi5mYyAuZmMtYnV0dG9uLXByaW1hcnk6bm90KDpkaXNhYmxlZCk6YWN0aXZlLFxcbiAgLmZjIC5mYy1idXR0b24tcHJpbWFyeTpub3QoOmRpc2FibGVkKS5mYy1idXR0b24tYWN0aXZlIHtcXG4gICAgY29sb3I6ICNmZmY7XFxuICAgIGNvbG9yOiB2YXIoLS1mYy1idXR0b24tdGV4dC1jb2xvciwgI2ZmZik7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMxYTI1MmY7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWZjLWJ1dHRvbi1hY3RpdmUtYmctY29sb3IsICMxYTI1MmYpO1xcbiAgICBib3JkZXItY29sb3I6ICMxNTFlMjc7XFxuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tZmMtYnV0dG9uLWFjdGl2ZS1ib3JkZXItY29sb3IsICMxNTFlMjcpO1xcbiAgfVxcbi5mYyAuZmMtYnV0dG9uLXByaW1hcnk6bm90KDpkaXNhYmxlZCk6YWN0aXZlOmZvY3VzLFxcbiAgLmZjIC5mYy1idXR0b24tcHJpbWFyeTpub3QoOmRpc2FibGVkKS5mYy1idXR0b24tYWN0aXZlOmZvY3VzIHtcXG4gICAgYm94LXNoYWRvdzogMCAwIDAgMC4ycmVtIHJnYmEoNzYsIDkxLCAxMDYsIDAuNSk7XFxuICB9XFxuLmZjIHtcXG5cXG4gIC8qIGljb25zIHdpdGhpbiBidXR0b25zICovXFxuXFxufVxcbi5mYyAuZmMtYnV0dG9uIC5mYy1pY29uIHtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgZm9udC1zaXplOiAxLjVlbTsgLyogYnVtcCB1cCB0aGUgc2l6ZSAoYnV0IGRvbid0IG1ha2UgaXQgYmlnZ2VyIHRoYW4gbGluZS1oZWlnaHQgb2YgYnV0dG9uLCB3aGljaCBpcyAxLjVlbSBhbHNvKSAqL1xcbiAgfVxcbi5mYyAuZmMtYnV0dG9uLWdyb3VwIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIH1cXG4uZmMgLmZjLWJ1dHRvbi1ncm91cCA+IC5mYy1idXR0b24ge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGZsZXg6IDEgMSBhdXRvO1xcbiAgfVxcbi5mYyAuZmMtYnV0dG9uLWdyb3VwID4gLmZjLWJ1dHRvbjpob3ZlciB7XFxuICAgIHotaW5kZXg6IDE7XFxuICB9XFxuLmZjIC5mYy1idXR0b24tZ3JvdXAgPiAuZmMtYnV0dG9uOmZvY3VzLFxcbiAgLmZjIC5mYy1idXR0b24tZ3JvdXAgPiAuZmMtYnV0dG9uOmFjdGl2ZSxcXG4gIC5mYyAuZmMtYnV0dG9uLWdyb3VwID4gLmZjLWJ1dHRvbi5mYy1idXR0b24tYWN0aXZlIHtcXG4gICAgei1pbmRleDogMTtcXG4gIH1cXG4uZmMtZGlyZWN0aW9uLWx0ciAuZmMtYnV0dG9uLWdyb3VwID4gLmZjLWJ1dHRvbjpub3QoOmZpcnN0LWNoaWxkKSB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMXB4O1xcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAwO1xcbiAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAwO1xcbiAgfVxcbi5mYy1kaXJlY3Rpb24tbHRyIC5mYy1idXR0b24tZ3JvdXAgPiAuZmMtYnV0dG9uOm5vdCg6bGFzdC1jaGlsZCkge1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMDtcXG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDA7XFxuICB9XFxuLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWJ1dHRvbi1ncm91cCA+IC5mYy1idXR0b246bm90KDpmaXJzdC1jaGlsZCkge1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0xcHg7XFxuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAwO1xcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMDtcXG4gIH1cXG4uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtYnV0dG9uLWdyb3VwID4gLmZjLWJ1dHRvbjpub3QoOmxhc3QtY2hpbGQpIHtcXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMDtcXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMDtcXG4gIH1cXG4uZmMgLmZjLXRvb2xiYXIge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICB9XFxuLmZjIC5mYy10b29sYmFyLmZjLWhlYWRlci10b29sYmFyIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMS41ZW07XFxuICB9XFxuLmZjIC5mYy10b29sYmFyLmZjLWZvb3Rlci10b29sYmFyIHtcXG4gICAgbWFyZ2luLXRvcDogMS41ZW07XFxuICB9XFxuLmZjIC5mYy10b29sYmFyLXRpdGxlIHtcXG4gICAgZm9udC1zaXplOiAxLjc1ZW07XFxuICAgIG1hcmdpbjogMDtcXG4gIH1cXG4uZmMtZGlyZWN0aW9uLWx0ciAuZmMtdG9vbGJhciA+ICogPiA6bm90KDpmaXJzdC1jaGlsZCkge1xcbiAgICBtYXJnaW4tbGVmdDogLjc1ZW07IC8qIHNwYWNlIGJldHdlZW4gKi9cXG4gIH1cXG4uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtdG9vbGJhciA+ICogPiA6bm90KDpmaXJzdC1jaGlsZCkge1xcbiAgICBtYXJnaW4tcmlnaHQ6IC43NWVtOyAvKiBzcGFjZSBiZXR3ZWVuICovXFxuICB9XFxuLmZjLWRpcmVjdGlvbi1ydGwgLmZjLXRvb2xiYXItbHRyIHsgLyogd2hlbiB0aGUgdG9vbGJhci1jaHVuayBwb3NpdGlvbmluZyBzeXN0ZW0gaXMgZXhwbGljaXRseSBsZWZ0LXRvLXJpZ2h0ICovXFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3ctcmV2ZXJzZTtcXG4gIH1cXG4uZmMgLmZjLXNjcm9sbGVyIHtcXG4gICAgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoO1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7IC8qIGZvciBhYnMtcG9zaXRpb25lZCBlbGVtZW50cyB3aXRoaW4gKi9cXG4gIH1cXG4uZmMgLmZjLXNjcm9sbGVyLWxpcXVpZCB7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gIH1cXG4uZmMgLmZjLXNjcm9sbGVyLWxpcXVpZC1hYnNvbHV0ZSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgfVxcbi5mYyAuZmMtc2Nyb2xsZXItaGFybmVzcyB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgZGlyZWN0aW9uOiBsdHI7XFxuICAgICAgLyogaGFjayBmb3IgY2hyb21lIGNvbXB1dGluZyB0aGUgc2Nyb2xsZXIncyByaWdodC9sZWZ0IHdyb25nIGZvciBydGwuIHVuZG9uZSBiZWxvdy4uLiAqL1xcbiAgICAgIC8qIFRPRE86IGRlbW9uc3RyYXRlIGluIGNvZGVwZW4gKi9cXG4gIH1cXG4uZmMgLmZjLXNjcm9sbGVyLWhhcm5lc3MtbGlxdWlkIHtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgfVxcbi5mYy1kaXJlY3Rpb24tcnRsIC5mYy1zY3JvbGxlci1oYXJuZXNzID4gLmZjLXNjcm9sbGVyIHsgLyogdW5kbyBhYm92ZSBoYWNrICovXFxuICAgIGRpcmVjdGlvbjogcnRsO1xcbiAgfVxcbi5mYy10aGVtZS1zdGFuZGFyZCAuZmMtc2Nyb2xsZ3JpZCB7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICNkZGQ7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWZjLWJvcmRlci1jb2xvciwgI2RkZCk7IC8qIGJvb3RzdHJhcCBkb2VzIHRoaXMuIG1hdGNoICovXFxuICB9XFxuLmZjIC5mYy1zY3JvbGxncmlkLFxcbiAgICAuZmMgLmZjLXNjcm9sbGdyaWQgdGFibGUgeyAvKiBhbGwgdGFibGVzIChzZWxmIGluY2x1ZGVkKSAqL1xcbiAgICAgIHdpZHRoOiAxMDAlOyAvKiBiZWNhdXNlIHRhYmxlcyBkb24ndCBub3JtYWxseSBkbyB0aGlzICovXFxuICAgICAgdGFibGUtbGF5b3V0OiBmaXhlZDtcXG4gICAgfVxcbi5mYyAuZmMtc2Nyb2xsZ3JpZCB0YWJsZSB7IC8qIGlubmVyIHRhYmxlcyAqL1xcbiAgICAgIGJvcmRlci10b3Atc3R5bGU6IGhpZGRlbjtcXG4gICAgICBib3JkZXItbGVmdC1zdHlsZTogaGlkZGVuO1xcbiAgICAgIGJvcmRlci1yaWdodC1zdHlsZTogaGlkZGVuO1xcbiAgICB9XFxuLmZjIC5mYy1zY3JvbGxncmlkID4gdGJvZHkgdGFibGUsXFxuICAgIC5mYyAuZmMtc2Nyb2xsZ3JpZCA+IHRmb290IHRhYmxlIHtcXG4gICAgICBib3JkZXItYm90dG9tLXN0eWxlOiBoaWRkZW47IC8qIGhlYWQga2VlcHMgaXRzIGJvdHRvbSBib3JkZXIgdGhvICovXFxuICAgIH1cXG4uZmMgLmZjLXNjcm9sbGdyaWQge1xcblxcbiAgICBib3JkZXItY29sbGFwc2U6IHNlcGFyYXRlO1xcbiAgICBib3JkZXItcmlnaHQtd2lkdGg6IDA7XFxuICAgIGJvcmRlci1ib3R0b20td2lkdGg6IDBcXG4gIH1cXG4uZmMgLmZjLXNjcm9sbGdyaWQgPiAqID4gdHIgPiAqIHtcXG4gICAgICBib3JkZXItdG9wLXdpZHRoOiAwO1xcbiAgICAgIGJvcmRlci1sZWZ0LXdpZHRoOiAwO1xcbiAgICB9XFxuLmZjIC5mYy1zY3JvbGxncmlkID4gdGhlYWQgPiB0ciA+ICosXFxuICAgIC5mYyAuZmMtc2Nyb2xsZ3JpZCA+IHRmb290ID4gdHIgPiAqIHtcXG4gICAgICBib3JkZXItYm90dG9tLXdpZHRoOiAwO1xcbiAgICB9XFxuLmZjIC5mYy1zY3JvbGxncmlkLWxpcXVpZCB7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gIH1cXG4uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbiB7IC8qIGEgPHRyPiAqL1xcbiAgICBoZWlnaHQ6IDBcXG5cXG4gIH1cXG4uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbiA+IHRkIHtcXG4gICAgICBoZWlnaHQ6IDA7IC8qIG5lZWRzIGEgaGVpZ2h0IHNvIGlubmVyIGRpdiB3aXRoaW4gZ3JvdyAqL1xcbiAgICB9XFxuLmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24gdGFibGUge1xcbiAgICAgIGhlaWdodDogMXB4O1xcbiAgICAgICAgLyogZm9yIG1vc3QgYnJvd3NlcnMsIGlmIGEgaGVpZ2h0IGlzbid0IHNldCBvbiB0aGUgdGFibGUsIGNhbid0IGRvIGxpcXVpZC1oZWlnaHQgd2l0aGluIGNlbGxzICovXFxuICAgICAgICAvKiBzZXJ2ZXMgYXMgYSBtaW4taGVpZ2h0LiBoYXJtbGVzcyAqL1xcbiAgICB9XFxuLmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24tbGlxdWlkIHtcXG4gICAgaGVpZ2h0OiBhdXRvXFxuXFxuICB9XFxuLmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24tbGlxdWlkID4gdGQge1xcbiAgICAgIGhlaWdodDogMTAwJTsgLyogRkYgbmVlZHMgdGhpcyBpbnN0ZWFkIG9mIGF1dG8gKi9cXG4gICAgfVxcbi5mYyB7XFxuXFxuICAvKiBzdGlja2luZXNzICovXFxuXFxufVxcbi5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLXN0aWNreSA+ICoge1xcbiAgICBiYWNrZ3JvdW5kOiAjZmZmOyAvKiBUT0RPOiB2YXIgKi9cXG4gICAgcG9zaXRpb246IHN0aWNreTtcXG4gICAgei1pbmRleDogMjsgLyogVE9ETzogdmFyICovXFxuICAgIC8qIFRPRE86IGJveC1zaGFkb3cgd2hlbiBzdGlja2luZyAqL1xcbiAgfVxcbi5mYyAuZmMtc2Nyb2xsZ3JpZCA+IHRoZWFkID4gLmZjLXNjcm9sbGdyaWQtc2VjdGlvbi1zdGlja3kgPiAqIHtcXG4gICAgdG9wOiAwOyAvKiBiZWNhdXNlIGJvcmRlci1zaGFyaW5nIGNhdXNlcyBhIGdhcCBhdCB0aGUgdG9wICovXFxuICAgICAgLyogVE9ETzogZ2l2ZSBzYWZhcmkgLTEuIGhhcyBidWcgKi9cXG4gIH1cXG4uZmMgLmZjLXNjcm9sbGdyaWQgPiB0Zm9vdCA+IC5mYy1zY3JvbGxncmlkLXNlY3Rpb24tc3RpY2t5ID4gKiB7XFxuICAgIGJvdHRvbTogMDsgLyoga25vd24gYnVnOiBib3R0b20tc3RpY2tpbmVzcyBkb2Vzbid0IHdvcmsgaW4gc2FmYXJpICovXFxuICB9XFxuLmZjIC5mYy1zY3JvbGxncmlkLXN0aWNreS1zaGltIHsgLyogZm9yIGhvcml6b250YWwgc2Nyb2xsYmFyICovXFxuICAgIGhlaWdodDogMXB4OyAvKiBuZWVkcyBoZWlnaHQgdG8gY3JlYXRlIHNjcm9sbGJhcnMgKi9cXG4gICAgbWFyZ2luLWJvdHRvbTogLTFweDtcXG4gIH1cXG4uZmMgLmZjLXN0aWNreSB7XFxuICAgIHBvc2l0aW9uOiBzdGlja3k7XFxuICB9XFxuLmZjIC5mYy12aWV3LWhhcm5lc3Mge1xcbiAgICBmbGV4LWdyb3c6IDE7IC8qIGJlY2F1c2UgdGhpcyBoYXJuZXNzIGlzIFdJVEhJTiB0aGUgLmZjJ3MgZmxleGJveCAqL1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB9XFxuLmZjIHtcXG5cXG4gIC8qIHdoZW4gdGhlIGhhcm5lc3MgY29udHJvbHMgdGhlIGhlaWdodCwgbWFrZSB0aGUgdmlldyBsaXF1aWQgKi9cXG5cXG59XFxuLmZjIC5mYy12aWV3LWhhcm5lc3MtYWN0aXZlID4gLmZjLXZpZXcge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgbGVmdDogMDtcXG4gIH1cXG4uZmMgLmZjLWNvbC1oZWFkZXItY2VsbC1jdXNoaW9uIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrOyAvKiB4LWJyb3dzZXIgZm9yIHdoZW4gc3RpY2t5ICh3aGVuIG11bHRpLXRpZXIgaGVhZGVyKSAqL1xcbiAgICBwYWRkaW5nOiAycHggNHB4O1xcbiAgfVxcbi5mYyAuZmMtYmctZXZlbnQsXFxuICAuZmMgLmZjLW5vbi1idXNpbmVzcyxcXG4gIC5mYyAuZmMtaGlnaGxpZ2h0IHtcXG4gICAgLyogd2lsbCBhbHdheXMgaGF2ZSBhIGhhcm5lc3Mgd2l0aCBwb3NpdGlvbjpyZWxhdGl2ZS9hYnNvbHV0ZSwgc28gYWJzb2x1dGVseSBleHBhbmQgKi9cXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICBib3R0b206IDA7XFxuICB9XFxuLmZjIC5mYy1ub24tYnVzaW5lc3Mge1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDIxNSwgMjE1LCAyMTUsIDAuMyk7XFxuICAgIGJhY2tncm91bmQ6IHZhcigtLWZjLW5vbi1idXNpbmVzcy1jb2xvciwgcmdiYSgyMTUsIDIxNSwgMjE1LCAwLjMpKTtcXG4gIH1cXG4uZmMgLmZjLWJnLWV2ZW50IHtcXG4gICAgYmFja2dyb3VuZDogcmdiKDE0MywgMjIzLCAxMzApO1xcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1mYy1iZy1ldmVudC1jb2xvciwgcmdiKDE0MywgMjIzLCAxMzApKTtcXG4gICAgb3BhY2l0eTogMC4zO1xcbiAgICBvcGFjaXR5OiB2YXIoLS1mYy1iZy1ldmVudC1vcGFjaXR5LCAwLjMpXFxuICB9XFxuLmZjIC5mYy1iZy1ldmVudCAuZmMtZXZlbnQtdGl0bGUge1xcbiAgICAgIG1hcmdpbjogLjVlbTtcXG4gICAgICBmb250LXNpemU6IC44NWVtO1xcbiAgICAgIGZvbnQtc2l6ZTogdmFyKC0tZmMtc21hbGwtZm9udC1zaXplLCAuODVlbSk7XFxuICAgICAgZm9udC1zdHlsZTogaXRhbGljO1xcbiAgICB9XFxuLmZjIC5mYy1oaWdobGlnaHQge1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDE4OCwgMjMyLCAyNDEsIDAuMyk7XFxuICAgIGJhY2tncm91bmQ6IHZhcigtLWZjLWhpZ2hsaWdodC1jb2xvciwgcmdiYSgxODgsIDIzMiwgMjQxLCAwLjMpKTtcXG4gIH1cXG4uZmMgLmZjLWRheS10b2RheSB7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyMjAsIDQwLCAwLjE1KTtcXG4gICAgYmFja2dyb3VuZDogdmFyKC0tZmMtdG9kYXktYmctY29sb3IsIHJnYmEoMjU1LCAyMjAsIDQwLCAwLjE1KSk7IC8qIGZvciBhbGwgdGhlbWVzLiBib290c3RyYXAgZGlkbid0IHByb3ZpZGUgYSBnb29kIHNlbWktdHJhbnNwYXJlbnQgY29sb3IgZm9yIHRoaXMgKi9cXG4gIH1cXG4uZmMgLmZjLWNlbGwtc2hhZGVkLFxcbiAgLmZjIC5mYy1kYXktZGlzYWJsZWQge1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDIwOCwgMjA4LCAyMDgsIDAuMyk7XFxuICAgIGJhY2tncm91bmQ6IHZhcigtLWZjLW5ldXRyYWwtYmctY29sb3IsIHJnYmEoMjA4LCAyMDgsIDIwOCwgMC4zKSk7XFxuICB9XFxuLyogbGluayByZXNldHMgKi9cXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXFxuYS5mYy1ldmVudCB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuYS5mYy1ldmVudCxcXG5hLmZjLWV2ZW50OmhvdmVyIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG59XFxuLyogY3Vyc29yICovXFxuLmZjLWV2ZW50W2hyZWZdLFxcbi5mYy1ldmVudC5mYy1ldmVudC1kcmFnZ2FibGUge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG4vKiBldmVudCB0ZXh0IGNvbnRlbnQgKi9cXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXFxuLmZjLWV2ZW50IC5mYy1ldmVudC1tYWluIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICB6LWluZGV4OiAyO1xcbiAgfVxcbi8qIGRyYWdnaW5nICovXFxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xcbi5mYy1ldmVudC1kcmFnZ2luZzpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSB7IC8qIE1PVVNFICovXFxuICAgIG9wYWNpdHk6IDAuNzU7XFxuICB9XFxuLmZjLWV2ZW50LWRyYWdnaW5nLmZjLWV2ZW50LXNlbGVjdGVkIHsgLyogVE9VQ0ggKi9cXG4gICAgYm94LXNoYWRvdzogMCAycHggN3B4IHJnYmEoMCwgMCwgMCwgMC4zKTtcXG4gIH1cXG4vKiByZXNpemluZyAqL1xcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cXG4vKiAoc3ViY2xhc3NlcyBzaG91bGQgaG9uZSBwb3NpdGlvbmluZyBmb3IgdG91Y2ggYW5kIG5vbi10b3VjaCkgKi9cXG4uZmMtZXZlbnQgLmZjLWV2ZW50LXJlc2l6ZXIge1xcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHotaW5kZXg6IDQ7XFxuICB9XFxuLmZjLWV2ZW50OmhvdmVyLCAvKiBNT1VTRSAqL1xcbi5mYy1ldmVudC1zZWxlY3RlZCB7IC8qIFRPVUNIICovXFxuXFxufVxcbi5mYy1ldmVudDpob3ZlciAuZmMtZXZlbnQtcmVzaXplciwgLmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVyIHtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICB9XFxuLmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVyIHtcXG4gICAgYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgICBib3JkZXItcmFkaXVzOiBjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoLCA4cHgpIC8gMik7XFxuICAgIGJvcmRlci13aWR0aDogMXB4O1xcbiAgICBib3JkZXItd2lkdGg6IHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LWJvcmRlci13aWR0aCwgMXB4KTtcXG4gICAgd2lkdGg6IDhweDtcXG4gICAgd2lkdGg6IHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoLCA4cHgpO1xcbiAgICBoZWlnaHQ6IDhweDtcXG4gICAgaGVpZ2h0OiB2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCwgOHB4KTtcXG4gICAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcXG4gICAgYm9yZGVyLWNvbG9yOiBpbmhlcml0O1xcbiAgICBiYWNrZ3JvdW5kOiAjZmZmO1xcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1mYy1wYWdlLWJnLWNvbG9yLCAjZmZmKVxcblxcbiAgICAvKiBleHBhbmQgaGl0IGFyZWEgKi9cXG5cXG4gIH1cXG4uZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXI6YmVmb3JlIHtcXG4gICAgICBjb250ZW50OiAnJztcXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgdG9wOiAtMjBweDtcXG4gICAgICBsZWZ0OiAtMjBweDtcXG4gICAgICByaWdodDogLTIwcHg7XFxuICAgICAgYm90dG9tOiAtMjBweDtcXG4gICAgfVxcbi8qIHNlbGVjdGluZyAoYWx3YXlzIFRPVUNIKSAqL1xcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cXG4uZmMtZXZlbnQtc2VsZWN0ZWQge1xcbiAgYm94LXNoYWRvdzogMCAycHggNXB4IHJnYmEoMCwgMCwgMCwgMC4yKVxcblxcbiAgLyogZXhwYW5kIGhpdCBhcmVhIChzdWJjbGFzc2VzIHNob3VsZCBleHBhbmQpICovXFxuXFxufVxcbi5mYy1ldmVudC1zZWxlY3RlZDpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcIjtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB6LWluZGV4OiAzO1xcbiAgICB0b3A6IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICBib3R0b206IDA7XFxuICB9XFxuLmZjLWV2ZW50LXNlbGVjdGVkIHtcXG5cXG4gIC8qIGRpbW1lciBlZmZlY3QgKi9cXG5cXG59XFxuLmZjLWV2ZW50LXNlbGVjdGVkOmFmdGVyIHtcXG4gICAgY29udGVudDogXFxcIlxcXCI7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4yNSk7XFxuICAgIGJhY2tncm91bmQ6IHZhcigtLWZjLWV2ZW50LXNlbGVjdGVkLW92ZXJsYXktY29sb3IsIHJnYmEoMCwgMCwgMCwgMC4yNSkpO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHotaW5kZXg6IDE7XFxuXFxuICAgIC8qIGFzc3VtZSB0aGVyZSdzIGEgYm9yZGVyIG9uIGFsbCBzaWRlcy4gb3ZlcmNvbWUgaXQuICovXFxuICAgIC8qIHNvbWV0aW1lcyB0aGVyZSdzIE5PVCBhIGJvcmRlciwgaW4gd2hpY2ggY2FzZSB0aGUgZGltbWVyIHdpbGwgZ28gb3ZlciAqL1xcbiAgICAvKiBhbiBhZGphY2VudCBib3JkZXIsIHdoaWNoIGxvb2tzIGZpbmUuICovXFxuICAgIHRvcDogLTFweDtcXG4gICAgbGVmdDogLTFweDtcXG4gICAgcmlnaHQ6IC0xcHg7XFxuICAgIGJvdHRvbTogLTFweDtcXG4gIH1cXG4vKlxcbkEgSE9SSVpPTlRBTCBldmVudFxcbiovXFxuLmZjLWgtZXZlbnQgeyAvKiBhbGxvd2VkIHRvIGJlIHRvcC1sZXZlbCAqL1xcblxcbiAgYm9yZGVyOiAxcHggc29saWQgIzM3ODhkODtcXG5cXG4gIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWZjLWV2ZW50LWJnLWNvbG9yLCAjMzc4OGQ4KTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMzNzg4ZDg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1mYy1ldmVudC1ib3JkZXItY29sb3IsICMzNzg4ZDgpXFxuXFxufVxcbi5mYy1oLWV2ZW50IC5mYy1ldmVudC1tYWluIHtcXG4gICAgY29sb3I6ICNmZmY7XFxuICAgIGNvbG9yOiB2YXIoLS1mYy1ldmVudC10ZXh0LWNvbG9yLCAjZmZmKTtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gIH1cXG4uZmMtaC1ldmVudCAuZmMtZXZlbnQtdGl0bGUtZnJhbWUgeyAvKiBzZXJ2ZXMgYXMgYSBjb250YWluZXIgZm9yIHRoZSBzdGlja3kgY3VzaGlvbiAqL1xcbiAgICBmbGV4LWdyb3c6IDE7XFxuICAgIGZsZXgtc2hyaW5rOiAxO1xcbiAgICBtaW4td2lkdGg6IDA7IC8qIGltcG9ydGFudCBmb3IgYWxsb3dpbmcgdG8gc2hyaW5rIGFsbCB0aGUgd2F5ICovXFxuICB9XFxuLmZjLWgtZXZlbnQgLmZjLWV2ZW50LXRpdGxlIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrOyAvKiBuZWVkIHRoaXMgdG8gYmUgc3RpY2t5IGNyb3NzLWJyb3dzZXIgKi9cXG4gICAgdmVydGljYWwtYWxpZ246IHRvcDsgLyogZm9yIG5vdCBtZXNzaW5nIHVwIGxpbmUtaGVpZ2h0ICovXFxuICAgIGxlZnQ6IDA7ICAvKiBmb3Igc3RpY2t5ICovXFxuICAgIHJpZ2h0OiAwOyAvKiBmb3Igc3RpY2t5ICovXFxuICAgIG1heC13aWR0aDogMTAwJTsgLyogY2xpcCBvdmVyZmxvdyBvbiB0aGlzIGVsZW1lbnQgKi9cXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIH1cXG4uZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZDpiZWZvcmUge1xcbiAgICAvKiBleHBhbmQgaGl0IGFyZWEgKi9cXG4gICAgdG9wOiAtMTBweDtcXG4gICAgYm90dG9tOiAtMTBweDtcXG4gIH1cXG4vKiBhZGp1c3QgYm9yZGVyIGFuZCBib3JkZXItcmFkaXVzIChpZiB0aGVyZSBpcyBhbnkpIGZvciBub24tc3RhcnQvZW5kICovXFxuLmZjLWRpcmVjdGlvbi1sdHIgLmZjLWRheWdyaWQtYmxvY2stZXZlbnQ6bm90KC5mYy1ldmVudC1zdGFydCksXFxuLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtYmxvY2stZXZlbnQ6bm90KC5mYy1ldmVudC1lbmQpIHtcXG4gIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDA7XFxuICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAwO1xcbiAgYm9yZGVyLWxlZnQtd2lkdGg6IDA7XFxufVxcbi5mYy1kaXJlY3Rpb24tbHRyIC5mYy1kYXlncmlkLWJsb2NrLWV2ZW50Om5vdCguZmMtZXZlbnQtZW5kKSxcXG4uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC1ibG9jay1ldmVudDpub3QoLmZjLWV2ZW50LXN0YXJ0KSB7XFxuICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMDtcXG4gIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAwO1xcbiAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAwO1xcbn1cXG4vKiByZXNpemVycyAqL1xcbi5mYy1oLWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVyIHtcXG4gIHRvcDogMDtcXG4gIGJvdHRvbTogMDtcXG4gIHdpZHRoOiA4cHg7XFxuICB3aWR0aDogdmFyKC0tZmMtZXZlbnQtcmVzaXplci10aGlja25lc3MsIDhweCk7XFxufVxcbi5mYy1kaXJlY3Rpb24tbHRyIC5mYy1oLWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVyLXN0YXJ0LFxcbi5mYy1kaXJlY3Rpb24tcnRsIC5mYy1oLWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVyLWVuZCB7XFxuICBjdXJzb3I6IHctcmVzaXplO1xcbiAgbGVmdDogLTRweDtcXG4gIGxlZnQ6IGNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci10aGlja25lc3MsIDhweCkgLyAtMik7XFxufVxcbi5mYy1kaXJlY3Rpb24tbHRyIC5mYy1oLWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVyLWVuZCxcXG4uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtaC1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1zdGFydCB7XFxuICBjdXJzb3I6IGUtcmVzaXplO1xcbiAgcmlnaHQ6IC00cHg7XFxuICByaWdodDogY2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLXRoaWNrbmVzcywgOHB4KSAvIC0yKTtcXG59XFxuLyogcmVzaXplcnMgZm9yIFRPVUNIICovXFxuLmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXIge1xcbiAgdG9wOiA1MCU7XFxuICBtYXJnaW4tdG9wOiAtNHB4O1xcbiAgbWFyZ2luLXRvcDogY2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCwgOHB4KSAvIC0yKTtcXG59XFxuLmZjLWRpcmVjdGlvbi1sdHIgLmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnQsXFxuLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXItZW5kIHtcXG4gIGxlZnQ6IC00cHg7XFxuICBsZWZ0OiBjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoLCA4cHgpIC8gLTIpO1xcbn1cXG4uZmMtZGlyZWN0aW9uLWx0ciAuZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1lbmQsXFxuLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnQge1xcbiAgcmlnaHQ6IC00cHg7XFxuICByaWdodDogY2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCwgOHB4KSAvIC0yKTtcXG59XFxuXCIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/core/main.css\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/core/main.js":
/*!*************************************************!*\
  !*** ./node_modules/@fullcalendar/core/main.js ***!
  \*************************************************/
/*! exports provided: Component, createElement, render, createRef, Fragment, createContext, flushToDom, BASE_OPTION_DEFAULTS, BASE_OPTION_REFINERS, BaseComponent, BgEvent, CalendarApi, CalendarContent, CalendarDataManager, CalendarDataProvider, CalendarRoot, ContentHook, CustomContentRenderContext, DateComponent, DateEnv, DateProfileGenerator, DayCellContent, DayCellRoot, DayHeader, DaySeriesModel, DayTableModel, DelayedRunner, ElementDragging, ElementScrollController, Emitter, EventApi, EventRoot, EventSourceApi, Interaction, MountHook, NamedTimeZoneImpl, NowIndicatorRoot, NowTimer, PositionCache, RefMap, RenderHook, ScrollController, ScrollResponder, Scroller, SimpleScrollGrid, Slicer, Splitter, StandardEvent, TableDateCell, TableDowCell, Theme, ViewApi, ViewContextType, ViewRoot, WeekNumberRoot, WindowScrollController, addDays, addDurations, addMs, addWeeks, allowContextMenu, allowSelection, applyMutationToEventStore, applyStyle, applyStyleProp, asRoughMinutes, asRoughMs, asRoughSeconds, buildClassNameNormalizer, buildEventApis, buildEventRangeKey, buildHashFromArray, buildNavLinkData, buildSegCompareObj, buildSegTimeText, collectFromHash, combineEventUis, compareByFieldSpec, compareByFieldSpecs, compareNumbers, compareObjs, computeEdges, computeFallbackHeaderFormat, computeHeightAndMargins, computeInnerRect, computeRect, computeSegDraggable, computeSegEndResizable, computeSegStartResizable, computeShrinkWidth, computeSmallestCellWidth, computeVisibleDayRange, config, constrainPoint, createDuration, createEmptyEventStore, createEventInstance, createEventUi, createFormatter, createPlugin, diffDates, diffDayAndTime, diffDays, diffPoints, diffWeeks, diffWholeDays, diffWholeWeeks, disableCursor, elementClosest, elementMatches, enableCursor, eventTupleToStore, filterEventStoreDefs, filterHash, findDirectChildren, findElements, flexibleCompare, formatDate, formatDayString, formatIsoTimeString, formatRange, getAllowYScrolling, getClippingParents, getDateMeta, getDayClassNames, getDefaultEventEnd, getElSeg, getEventClassNames, getIsRtlScrollbarOnLeft, getRectCenter, getRelevantEvents, getScrollGridClassNames, getScrollbarWidths, getSectionClassNames, getSectionHasLiquidHeight, getSegMeta, getSlotClassNames, getStickyFooterScrollbar, getStickyHeaderDates, getUnequalProps, globalLocales, globalPlugins, greatestDurationDenominator, guid, hasBgRendering, hasShrinkWidth, htmlToElement, identity, interactionSettingsStore, interactionSettingsToStore, intersectRanges, intersectRects, isArraysEqual, isColPropsEqual, isDateSpansEqual, isElVisible, isInt, isInteractionValid, isMultiDayRange, isPropsEqual, isPropsValid, isSingleDay, isValidDate, listenBySelector, mapHash, memoize, memoizeArraylike, memoizeHashlike, memoizeObjArg, mergeEventStores, multiplyDuration, padStart, parseBusinessHours, parseClassNames, parseDragMeta, parseEventDef, parseFieldSpecs, parseMarker, pointInsideRect, preventContextMenu, preventDefault, preventSelection, rangeContainsMarker, rangeContainsRange, rangesEqual, rangesIntersect, refineEventDef, refineProps, removeElement, removeExact, renderChunkContent, renderFill, renderMicroColGroup, renderScrollShim, requestJson, sanitizeShrinkWidth, setElSeg, setRef, sliceEventStore, sliceEvents, sortEventSegs, startOfDay, translateRect, triggerDateSelect, unpromisify, version, whenTransitionDone, wholeDivideDurations, Calendar */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Calendar\", function() { return Calendar; });\n/* harmony import */ var _vdom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vdom */ \"./node_modules/@fullcalendar/core/vdom.js\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fullcalendar/common */ \"./node_modules/@fullcalendar/common/main.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"Component\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createElement\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"render\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createRef\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"createRef\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Fragment\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"Fragment\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createContext\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"createContext\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"flushToDom\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"flushToDom\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BASE_OPTION_DEFAULTS\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"BASE_OPTION_DEFAULTS\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BASE_OPTION_REFINERS\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"BASE_OPTION_REFINERS\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BaseComponent\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"BaseComponent\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BgEvent\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"BgEvent\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CalendarApi\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"CalendarApi\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CalendarContent\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"CalendarContent\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CalendarDataManager\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"CalendarDataManager\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CalendarDataProvider\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"CalendarDataProvider\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CalendarRoot\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"CalendarRoot\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ContentHook\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"ContentHook\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CustomContentRenderContext\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"CustomContentRenderContext\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DateComponent\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"DateComponent\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DateEnv\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"DateEnv\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DateProfileGenerator\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"DateProfileGenerator\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DayCellContent\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"DayCellContent\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DayCellRoot\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"DayCellRoot\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DayHeader\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"DayHeader\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DaySeriesModel\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"DaySeriesModel\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DayTableModel\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"DayTableModel\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DelayedRunner\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"DelayedRunner\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ElementDragging\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"ElementDragging\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ElementScrollController\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"ElementScrollController\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Emitter\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"Emitter\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EventApi\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"EventApi\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EventRoot\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"EventRoot\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EventSourceApi\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"EventSourceApi\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Interaction\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"Interaction\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MountHook\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"MountHook\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NamedTimeZoneImpl\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"NamedTimeZoneImpl\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NowIndicatorRoot\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"NowIndicatorRoot\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NowTimer\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"NowTimer\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PositionCache\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"PositionCache\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RefMap\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"RefMap\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RenderHook\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"RenderHook\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ScrollController\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"ScrollController\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ScrollResponder\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"ScrollResponder\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Scroller\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"Scroller\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"SimpleScrollGrid\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"SimpleScrollGrid\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Slicer\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"Slicer\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Splitter\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"Splitter\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"StandardEvent\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"StandardEvent\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TableDateCell\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"TableDateCell\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TableDowCell\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"TableDowCell\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Theme\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"Theme\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ViewApi\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"ViewApi\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ViewContextType\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"ViewContextType\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ViewRoot\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"ViewRoot\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"WeekNumberRoot\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"WeekNumberRoot\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"WindowScrollController\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"WindowScrollController\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"addDays\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"addDays\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"addDurations\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"addDurations\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"addMs\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"addMs\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"addWeeks\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"addWeeks\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"allowContextMenu\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"allowContextMenu\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"allowSelection\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"allowSelection\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"applyMutationToEventStore\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"applyMutationToEventStore\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"applyStyle\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"applyStyle\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"applyStyleProp\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"applyStyleProp\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"asRoughMinutes\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"asRoughMinutes\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"asRoughMs\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"asRoughMs\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"asRoughSeconds\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"asRoughSeconds\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"buildClassNameNormalizer\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"buildClassNameNormalizer\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"buildEventApis\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"buildEventApis\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"buildEventRangeKey\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"buildEventRangeKey\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"buildHashFromArray\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"buildHashFromArray\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"buildNavLinkData\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"buildNavLinkData\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"buildSegCompareObj\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"buildSegCompareObj\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"buildSegTimeText\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"buildSegTimeText\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"collectFromHash\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"collectFromHash\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"combineEventUis\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"combineEventUis\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"compareByFieldSpec\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"compareByFieldSpec\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"compareByFieldSpecs\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"compareByFieldSpecs\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"compareNumbers\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"compareNumbers\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"compareObjs\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"compareObjs\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"computeEdges\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"computeEdges\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"computeFallbackHeaderFormat\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"computeFallbackHeaderFormat\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"computeHeightAndMargins\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"computeHeightAndMargins\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"computeInnerRect\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"computeInnerRect\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"computeRect\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"computeRect\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"computeSegDraggable\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"computeSegDraggable\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"computeSegEndResizable\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"computeSegEndResizable\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"computeSegStartResizable\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"computeSegStartResizable\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"computeShrinkWidth\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"computeShrinkWidth\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"computeSmallestCellWidth\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"computeSmallestCellWidth\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"computeVisibleDayRange\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"computeVisibleDayRange\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"config\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"config\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"constrainPoint\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"constrainPoint\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createDuration\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"createDuration\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createEmptyEventStore\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"createEmptyEventStore\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createEventInstance\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"createEventInstance\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createEventUi\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"createEventUi\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createFormatter\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"createFormatter\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createPlugin\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"createPlugin\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"diffDates\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"diffDates\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"diffDayAndTime\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"diffDayAndTime\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"diffDays\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"diffDays\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"diffPoints\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"diffPoints\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"diffWeeks\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"diffWeeks\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"diffWholeDays\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"diffWholeDays\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"diffWholeWeeks\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"diffWholeWeeks\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"disableCursor\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"disableCursor\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"elementClosest\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"elementClosest\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"elementMatches\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"elementMatches\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"enableCursor\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"enableCursor\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"eventTupleToStore\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"eventTupleToStore\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"filterEventStoreDefs\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"filterEventStoreDefs\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"filterHash\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"filterHash\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"findDirectChildren\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"findDirectChildren\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"findElements\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"findElements\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"flexibleCompare\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"flexibleCompare\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"formatDate\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"formatDate\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"formatDayString\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"formatDayString\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"formatIsoTimeString\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"formatIsoTimeString\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"formatRange\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"formatRange\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getAllowYScrolling\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"getAllowYScrolling\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getClippingParents\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"getClippingParents\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getDateMeta\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"getDateMeta\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getDayClassNames\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"getDayClassNames\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getDefaultEventEnd\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"getDefaultEventEnd\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getElSeg\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"getElSeg\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getEventClassNames\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"getEventClassNames\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getIsRtlScrollbarOnLeft\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"getIsRtlScrollbarOnLeft\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getRectCenter\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"getRectCenter\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getRelevantEvents\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"getRelevantEvents\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getScrollGridClassNames\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"getScrollGridClassNames\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getScrollbarWidths\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"getScrollbarWidths\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getSectionClassNames\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"getSectionClassNames\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getSectionHasLiquidHeight\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"getSectionHasLiquidHeight\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getSegMeta\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"getSegMeta\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getSlotClassNames\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"getSlotClassNames\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getStickyFooterScrollbar\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"getStickyFooterScrollbar\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getStickyHeaderDates\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"getStickyHeaderDates\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getUnequalProps\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"getUnequalProps\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"globalLocales\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"globalLocales\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"globalPlugins\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"globalPlugins\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"greatestDurationDenominator\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"greatestDurationDenominator\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"guid\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"guid\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"hasBgRendering\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"hasBgRendering\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"hasShrinkWidth\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"hasShrinkWidth\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"htmlToElement\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"htmlToElement\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"identity\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"identity\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"interactionSettingsStore\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"interactionSettingsStore\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"interactionSettingsToStore\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"interactionSettingsToStore\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"intersectRanges\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"intersectRanges\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"intersectRects\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"intersectRects\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isArraysEqual\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"isArraysEqual\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isColPropsEqual\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"isColPropsEqual\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isDateSpansEqual\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"isDateSpansEqual\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isElVisible\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"isElVisible\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isInt\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"isInt\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isInteractionValid\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"isInteractionValid\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isMultiDayRange\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"isMultiDayRange\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isPropsEqual\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"isPropsEqual\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isPropsValid\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"isPropsValid\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isSingleDay\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"isSingleDay\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isValidDate\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"isValidDate\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"listenBySelector\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"listenBySelector\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"mapHash\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"mapHash\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"memoize\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"memoize\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"memoizeArraylike\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"memoizeArraylike\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"memoizeHashlike\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"memoizeHashlike\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"memoizeObjArg\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"memoizeObjArg\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"mergeEventStores\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"mergeEventStores\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"multiplyDuration\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"multiplyDuration\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"padStart\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"padStart\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"parseBusinessHours\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"parseBusinessHours\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"parseClassNames\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"parseClassNames\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"parseDragMeta\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"parseDragMeta\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"parseEventDef\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"parseEventDef\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"parseFieldSpecs\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"parseFieldSpecs\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"parseMarker\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"parseMarker\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"pointInsideRect\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"pointInsideRect\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"preventContextMenu\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"preventContextMenu\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"preventDefault\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"preventDefault\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"preventSelection\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"preventSelection\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"rangeContainsMarker\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"rangeContainsMarker\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"rangeContainsRange\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"rangeContainsRange\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"rangesEqual\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"rangesEqual\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"rangesIntersect\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"rangesIntersect\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"refineEventDef\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"refineEventDef\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"refineProps\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"refineProps\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"removeElement\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"removeElement\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"removeExact\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"removeExact\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"renderChunkContent\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"renderChunkContent\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"renderFill\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"renderFill\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"renderMicroColGroup\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"renderMicroColGroup\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"renderScrollShim\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"renderScrollShim\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"requestJson\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"requestJson\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"sanitizeShrinkWidth\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"sanitizeShrinkWidth\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"setElSeg\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"setElSeg\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"setRef\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"setRef\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"sliceEventStore\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"sliceEventStore\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"sliceEvents\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"sliceEvents\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"sortEventSegs\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"sortEventSegs\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"startOfDay\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"startOfDay\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"translateRect\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"translateRect\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"triggerDateSelect\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"triggerDateSelect\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"unpromisify\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"unpromisify\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"version\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"version\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"whenTransitionDone\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"whenTransitionDone\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"wholeDivideDurations\", function() { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"wholeDivideDurations\"]; });\n\n/*!\nFullCalendar v5.0.0\nDocs & License: https://fullcalendar.io/\n(c) 2020 Adam Shaw\n*/\n\n\n\n\n\nvar Calendar =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__extends\"])(Calendar, _super);\n\n  function Calendar(el, optionOverrides) {\n    if (optionOverrides === void 0) {\n      optionOverrides = {};\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.isRendering = false;\n    _this.isRendered = false;\n    _this.currentClassNames = [];\n    _this.customContentRenderId = 0; // will affect custom generated classNames?\n\n    _this.handleAction = function (action) {\n      // actions we know we want to render immediately\n      switch (action.type) {\n        case 'SET_EVENT_DRAG':\n        case 'SET_EVENT_RESIZE':\n          _this.renderRunner.tryDrain();\n\n      }\n    };\n\n    _this.handleData = function (data) {\n      _this.currentData = data;\n\n      _this.renderRunner.request(data.calendarOptions.rerenderDelay);\n    };\n\n    _this.handleRenderRequest = function () {\n      if (_this.isRendering) {\n        _this.isRendered = true;\n        var currentData_1 = _this.currentData;\n        Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"render\"])(Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"CalendarRoot\"], {\n          options: currentData_1.calendarOptions,\n          theme: currentData_1.theme,\n          emitter: currentData_1.emitter\n        }, function (classNames, height, isHeightAuto, forPrint) {\n          _this.setClassNames(classNames);\n\n          _this.setHeight(height);\n\n          return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"CustomContentRenderContext\"].Provider, {\n            value: _this.customContentRenderId\n          }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"CalendarContent\"], Object(tslib__WEBPACK_IMPORTED_MODULE_1__[\"__assign\"])({\n            isHeightAuto: isHeightAuto,\n            forPrint: forPrint\n          }, currentData_1)));\n        }), _this.el);\n      } else if (_this.isRendered) {\n        _this.isRendered = false;\n        Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"render\"])(null, _this.el);\n\n        _this.setClassNames([]);\n\n        _this.setHeight('');\n      }\n\n      Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"flushToDom\"])();\n    };\n\n    _this.el = el;\n    _this.renderRunner = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"DelayedRunner\"](_this.handleRenderRequest);\n    new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"CalendarDataManager\"]({\n      optionOverrides: optionOverrides,\n      calendarApi: _this,\n      onAction: _this.handleAction,\n      onData: _this.handleData\n    });\n    return _this;\n  }\n\n  Object.defineProperty(Calendar.prototype, \"view\", {\n    get: function get() {\n      return this.currentData.viewApi;\n    } // for public API\n    ,\n    enumerable: false,\n    configurable: true\n  });\n\n  Calendar.prototype.render = function () {\n    if (!this.isRendering) {\n      this.isRendering = true;\n    } else {\n      this.customContentRenderId++;\n    }\n\n    this.renderRunner.request();\n  };\n\n  Calendar.prototype.destroy = function () {\n    if (this.isRendering) {\n      this.isRendering = false;\n      this.renderRunner.request();\n    }\n  };\n\n  Calendar.prototype.updateSize = function () {\n    _super.prototype.updateSize.call(this);\n\n    Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"flushToDom\"])();\n  };\n\n  Calendar.prototype.batchRendering = function (func) {\n    this.renderRunner.pause('batchRendering');\n    func();\n    this.renderRunner.resume('batchRendering');\n  };\n\n  Calendar.prototype.pauseRendering = function () {\n    this.renderRunner.pause('pauseRendering');\n  };\n\n  Calendar.prototype.resumeRendering = function () {\n    this.renderRunner.resume('pauseRendering', true);\n  };\n\n  Calendar.prototype.resetOptions = function (optionOverrides, append) {\n    this.currentDataManager.resetOptions(optionOverrides, append);\n  };\n\n  Calendar.prototype.setClassNames = function (classNames) {\n    if (!Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"isArraysEqual\"])(classNames, this.currentClassNames)) {\n      var classList = this.el.classList;\n\n      for (var _i = 0, _a = this.currentClassNames; _i < _a.length; _i++) {\n        var className = _a[_i];\n        classList.remove(className);\n      }\n\n      for (var _b = 0, classNames_1 = classNames; _b < classNames_1.length; _b++) {\n        var className = classNames_1[_b];\n        classList.add(className);\n      }\n\n      this.currentClassNames = classNames;\n    }\n  };\n\n  Calendar.prototype.setHeight = function (height) {\n    Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"applyStyleProp\"])(this.el, 'height', height);\n  };\n\n  return Calendar;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[\"CalendarApi\"]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL21haW4uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL0NhbGVuZGFyLnRzeD81MDMzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENhbGVuZGFyT3B0aW9ucywgQWN0aW9uLCBDYWxlbmRhckNvbnRlbnQsIHJlbmRlciwgY3JlYXRlRWxlbWVudCwgRGVsYXllZFJ1bm5lciwgQ3NzRGltVmFsdWUsIGFwcGx5U3R5bGVQcm9wLFxuICBDYWxlbmRhckFwaSwgQ2FsZW5kYXJSb290LCBpc0FycmF5c0VxdWFsLCBDYWxlbmRhckRhdGFNYW5hZ2VyLCBDYWxlbmRhckRhdGEsXG4gIEN1c3RvbUNvbnRlbnRSZW5kZXJDb250ZXh0LCBmbHVzaFRvRG9tXG4gfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcblxuXG5leHBvcnQgY2xhc3MgQ2FsZW5kYXIgZXh0ZW5kcyBDYWxlbmRhckFwaSB7XG5cbiAgY3VycmVudERhdGE6IENhbGVuZGFyRGF0YVxuICByZW5kZXJSdW5uZXI6IERlbGF5ZWRSdW5uZXJcbiAgZWw6IEhUTUxFbGVtZW50XG4gIGlzUmVuZGVyaW5nID0gZmFsc2VcbiAgaXNSZW5kZXJlZCA9IGZhbHNlXG4gIGN1cnJlbnRDbGFzc05hbWVzOiBzdHJpbmdbXSA9IFtdXG4gIGN1c3RvbUNvbnRlbnRSZW5kZXJJZCA9IDAgLy8gd2lsbCBhZmZlY3QgY3VzdG9tIGdlbmVyYXRlZCBjbGFzc05hbWVzP1xuXG4gIGdldCB2aWV3KCkgeyByZXR1cm4gdGhpcy5jdXJyZW50RGF0YS52aWV3QXBpIH0gLy8gZm9yIHB1YmxpYyBBUElcblxuXG4gIGNvbnN0cnVjdG9yKGVsOiBIVE1MRWxlbWVudCwgb3B0aW9uT3ZlcnJpZGVzOiBDYWxlbmRhck9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMuZWwgPSBlbFxuICAgIHRoaXMucmVuZGVyUnVubmVyID0gbmV3IERlbGF5ZWRSdW5uZXIodGhpcy5oYW5kbGVSZW5kZXJSZXF1ZXN0KVxuXG4gICAgbmV3IENhbGVuZGFyRGF0YU1hbmFnZXIoe1xuICAgICAgb3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgY2FsZW5kYXJBcGk6IHRoaXMsXG4gICAgICBvbkFjdGlvbjogdGhpcy5oYW5kbGVBY3Rpb24sXG4gICAgICBvbkRhdGE6IHRoaXMuaGFuZGxlRGF0YVxuICAgIH0pXG4gIH1cblxuXG4gIGhhbmRsZUFjdGlvbiA9IChhY3Rpb246IEFjdGlvbikgPT4ge1xuICAgIC8vIGFjdGlvbnMgd2Uga25vdyB3ZSB3YW50IHRvIHJlbmRlciBpbW1lZGlhdGVseVxuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgJ1NFVF9FVkVOVF9EUkFHJzpcbiAgICAgIGNhc2UgJ1NFVF9FVkVOVF9SRVNJWkUnOlxuICAgICAgICB0aGlzLnJlbmRlclJ1bm5lci50cnlEcmFpbigpXG4gICAgfVxuICB9XG5cblxuICBoYW5kbGVEYXRhID0gKGRhdGE6IENhbGVuZGFyRGF0YSkgPT4ge1xuICAgIHRoaXMuY3VycmVudERhdGEgPSBkYXRhXG4gICAgdGhpcy5yZW5kZXJSdW5uZXIucmVxdWVzdChkYXRhLmNhbGVuZGFyT3B0aW9ucy5yZXJlbmRlckRlbGF5KVxuICB9XG5cblxuICBoYW5kbGVSZW5kZXJSZXF1ZXN0ID0gKCkgPT4ge1xuXG4gICAgaWYgKHRoaXMuaXNSZW5kZXJpbmcpIHtcbiAgICAgIHRoaXMuaXNSZW5kZXJlZCA9IHRydWVcbiAgICAgIGxldCB7IGN1cnJlbnREYXRhIH0gPSB0aGlzXG5cbiAgICAgIHJlbmRlcihcbiAgICAgICAgPENhbGVuZGFyUm9vdCBvcHRpb25zPXtjdXJyZW50RGF0YS5jYWxlbmRhck9wdGlvbnN9IHRoZW1lPXtjdXJyZW50RGF0YS50aGVtZX0gZW1pdHRlcj17Y3VycmVudERhdGEuZW1pdHRlcn0+XG4gICAgICAgICAgeyhjbGFzc05hbWVzLCBoZWlnaHQsIGlzSGVpZ2h0QXV0bywgZm9yUHJpbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q2xhc3NOYW1lcyhjbGFzc05hbWVzKVxuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQoaGVpZ2h0KVxuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICA8Q3VzdG9tQ29udGVudFJlbmRlckNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3RoaXMuY3VzdG9tQ29udGVudFJlbmRlcklkfT5cbiAgICAgICAgICAgICAgICA8Q2FsZW5kYXJDb250ZW50XG4gICAgICAgICAgICAgICAgICBpc0hlaWdodEF1dG89e2lzSGVpZ2h0QXV0b31cbiAgICAgICAgICAgICAgICAgIGZvclByaW50PXtmb3JQcmludH1cbiAgICAgICAgICAgICAgICAgIHsuLi5jdXJyZW50RGF0YX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L0N1c3RvbUNvbnRlbnRSZW5kZXJDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICAgICAgKVxuICAgICAgICAgIH19XG4gICAgICAgIDwvQ2FsZW5kYXJSb290PixcbiAgICAgICAgdGhpcy5lbFxuICAgICAgKVxuXG4gICAgfSBlbHNlIGlmICh0aGlzLmlzUmVuZGVyZWQpIHtcbiAgICAgIHRoaXMuaXNSZW5kZXJlZCA9IGZhbHNlXG4gICAgICByZW5kZXIobnVsbCwgdGhpcy5lbClcbiAgICAgIHRoaXMuc2V0Q2xhc3NOYW1lcyhbXSlcbiAgICAgIHRoaXMuc2V0SGVpZ2h0KCcnKVxuICAgIH1cblxuICAgIGZsdXNoVG9Eb20oKVxuICB9XG5cblxuICByZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLmlzUmVuZGVyaW5nKSB7XG4gICAgICB0aGlzLmlzUmVuZGVyaW5nID0gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN1c3RvbUNvbnRlbnRSZW5kZXJJZCsrXG4gICAgfVxuICAgIHRoaXMucmVuZGVyUnVubmVyLnJlcXVlc3QoKVxuICB9XG5cblxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmlzUmVuZGVyaW5nKSB7XG4gICAgICB0aGlzLmlzUmVuZGVyaW5nID0gZmFsc2VcbiAgICAgIHRoaXMucmVuZGVyUnVubmVyLnJlcXVlc3QoKVxuICAgIH1cbiAgfVxuXG5cbiAgdXBkYXRlU2l6ZSgpIHtcbiAgICBzdXBlci51cGRhdGVTaXplKClcbiAgICBmbHVzaFRvRG9tKClcbiAgfVxuXG5cbiAgYmF0Y2hSZW5kZXJpbmcoZnVuYykge1xuICAgIHRoaXMucmVuZGVyUnVubmVyLnBhdXNlKCdiYXRjaFJlbmRlcmluZycpXG4gICAgZnVuYygpXG4gICAgdGhpcy5yZW5kZXJSdW5uZXIucmVzdW1lKCdiYXRjaFJlbmRlcmluZycpXG4gIH1cblxuXG4gIHBhdXNlUmVuZGVyaW5nKCkgeyAvLyBhdmFpbGFibGUgdG8gcGx1Z2luc1xuICAgIHRoaXMucmVuZGVyUnVubmVyLnBhdXNlKCdwYXVzZVJlbmRlcmluZycpXG4gIH1cblxuXG4gIHJlc3VtZVJlbmRlcmluZygpIHsgLy8gYXZhaWxhYmxlIHRvIHBsdWdpbnNcbiAgICB0aGlzLnJlbmRlclJ1bm5lci5yZXN1bWUoJ3BhdXNlUmVuZGVyaW5nJywgdHJ1ZSlcbiAgfVxuXG5cbiAgcmVzZXRPcHRpb25zKG9wdGlvbk92ZXJyaWRlcywgYXBwZW5kPykge1xuICAgIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLnJlc2V0T3B0aW9ucyhvcHRpb25PdmVycmlkZXMsIGFwcGVuZClcbiAgfVxuXG5cbiAgc2V0Q2xhc3NOYW1lcyhjbGFzc05hbWVzOiBzdHJpbmdbXSkge1xuICAgIGlmICghaXNBcnJheXNFcXVhbChjbGFzc05hbWVzLCB0aGlzLmN1cnJlbnRDbGFzc05hbWVzKSkge1xuICAgICAgbGV0IHsgY2xhc3NMaXN0IH0gPSB0aGlzLmVsXG5cbiAgICAgIGZvciAobGV0IGNsYXNzTmFtZSBvZiB0aGlzLmN1cnJlbnRDbGFzc05hbWVzKSB7XG4gICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKVxuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBjbGFzc05hbWUgb2YgY2xhc3NOYW1lcykge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSlcbiAgICAgIH1cblxuICAgICAgdGhpcy5jdXJyZW50Q2xhc3NOYW1lcyA9IGNsYXNzTmFtZXNcbiAgICB9XG4gIH1cblxuXG4gIHNldEhlaWdodChoZWlnaHQ6IENzc0RpbVZhbHVlKSB7XG4gICAgYXBwbHlTdHlsZVByb3AodGhpcy5lbCwgJ2hlaWdodCcsIGhlaWdodClcbiAgfVxuXG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBT0E7QUFDQTtBQVlBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW1CQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBRkE7QUFPQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQS9EQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBOztBQU1BO0FBQ0E7QUFoQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwSkE7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/core/main.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/core/vdom.js":
/*!*************************************************!*\
  !*** ./node_modules/@fullcalendar/core/vdom.js ***!
  \*************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact */ \"./node_modules/preact/dist/preact.module.js\");\n\n\nwindow.FullCalendarVDom = {\n  Component: preact__WEBPACK_IMPORTED_MODULE_1__[\"Component\"],\n  createElement: preact__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"],\n  render: preact__WEBPACK_IMPORTED_MODULE_1__[\"render\"],\n  createRef: preact__WEBPACK_IMPORTED_MODULE_1__[\"createRef\"],\n  Fragment: preact__WEBPACK_IMPORTED_MODULE_1__[\"Fragment\"],\n  createContext: createContext,\n  flushToDom: flushToDom\n};\n\nfunction flushToDom() {\n  var oldDebounceRendering = preact__WEBPACK_IMPORTED_MODULE_1__[\"options\"].debounceRendering;\n  var callbackQ = [];\n\n  function execCallbackSync(callback) {\n    callbackQ.push(callback);\n  }\n\n  preact__WEBPACK_IMPORTED_MODULE_1__[\"options\"].debounceRendering = execCallbackSync;\n  preact__WEBPACK_IMPORTED_MODULE_1__[\"render\"](preact__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](FakeComponent, {}), document.createElement('div'));\n\n  while (callbackQ.length) {\n    callbackQ.shift()();\n  }\n\n  preact__WEBPACK_IMPORTED_MODULE_1__[\"options\"].debounceRendering = oldDebounceRendering;\n}\n\nvar FakeComponent =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(FakeComponent, _super);\n\n  function FakeComponent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  FakeComponent.prototype.render = function () {\n    return preact__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"]('div', {});\n  };\n\n  FakeComponent.prototype.componentDidMount = function () {\n    this.setState({});\n  };\n\n  return FakeComponent;\n}(preact__WEBPACK_IMPORTED_MODULE_1__[\"Component\"]);\n\nfunction createContext(defaultValue) {\n  var ContextType = preact__WEBPACK_IMPORTED_MODULE_1__[\"createContext\"](defaultValue);\n  var origProvider = ContextType.Provider;\n\n  ContextType.Provider = function () {\n    var _this = this;\n\n    var isNew = !this.getChildContext;\n    var children = origProvider.apply(this, arguments);\n\n    if (isNew) {\n      var subs_1 = [];\n\n      this.shouldComponentUpdate = function (_props) {\n        if (_this.props.value !== _props.value) {\n          subs_1.some(function (c) {\n            c.context = _props.value;\n            c.forceUpdate();\n          });\n        }\n      };\n\n      this.sub = function (c) {\n        subs_1.push(c);\n        var old = c.componentWillUnmount;\n\n        c.componentWillUnmount = function () {\n          subs_1.splice(subs_1.indexOf(c), 1);\n          old && old.call(c);\n        };\n      };\n    }\n\n    return children;\n  };\n\n  return ContextType;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL3Zkb20uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL3Zkb20uanM/NTU3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHByZWFjdCBmcm9tICdwcmVhY3QnO1xud2luZG93LkZ1bGxDYWxlbmRhclZEb20gPSB7XG4gICAgQ29tcG9uZW50OiBwcmVhY3QuQ29tcG9uZW50LFxuICAgIGNyZWF0ZUVsZW1lbnQ6IHByZWFjdC5jcmVhdGVFbGVtZW50LFxuICAgIHJlbmRlcjogcHJlYWN0LnJlbmRlcixcbiAgICBjcmVhdGVSZWY6IHByZWFjdC5jcmVhdGVSZWYsXG4gICAgRnJhZ21lbnQ6IHByZWFjdC5GcmFnbWVudCxcbiAgICBjcmVhdGVDb250ZXh0OiBjcmVhdGVDb250ZXh0LFxuICAgIGZsdXNoVG9Eb206IGZsdXNoVG9Eb21cbn07XG5cblxuXG5mdW5jdGlvbiBmbHVzaFRvRG9tKCkge1xuICAgIHZhciBvbGREZWJvdW5jZVJlbmRlcmluZyA9IHByZWFjdC5vcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nOyBcbiAgICB2YXIgY2FsbGJhY2tRID0gW107XG4gICAgZnVuY3Rpb24gZXhlY0NhbGxiYWNrU3luYyhjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFja1EucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICAgIHByZWFjdC5vcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nID0gZXhlY0NhbGxiYWNrU3luYztcbiAgICBwcmVhY3QucmVuZGVyKHByZWFjdC5jcmVhdGVFbGVtZW50KEZha2VDb21wb25lbnQsIHt9KSwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpO1xuICAgIHdoaWxlIChjYWxsYmFja1EubGVuZ3RoKSB7XG4gICAgICAgIGNhbGxiYWNrUS5zaGlmdCgpKCk7XG4gICAgfVxuICAgIHByZWFjdC5vcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nID0gb2xkRGVib3VuY2VSZW5kZXJpbmc7XG59XG52YXIgRmFrZUNvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRmFrZUNvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGYWtlQ29tcG9uZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEZha2VDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByZWFjdC5jcmVhdGVFbGVtZW50KCdkaXYnLCB7fSk7IH07XG4gICAgRmFrZUNvbXBvbmVudC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuc2V0U3RhdGUoe30pOyB9O1xuICAgIHJldHVybiBGYWtlQ29tcG9uZW50O1xufShwcmVhY3QuQ29tcG9uZW50KSk7XG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSkge1xuICAgIHZhciBDb250ZXh0VHlwZSA9IHByZWFjdC5jcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSk7XG4gICAgdmFyIG9yaWdQcm92aWRlciA9IENvbnRleHRUeXBlLlByb3ZpZGVyO1xuICAgIENvbnRleHRUeXBlLlByb3ZpZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaXNOZXcgPSAhdGhpcy5nZXRDaGlsZENvbnRleHQ7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG9yaWdQcm92aWRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoaXNOZXcpIHtcbiAgICAgICAgICAgIHZhciBzdWJzXzEgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gKF9wcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy52YWx1ZSAhPT0gX3Byb3BzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNfMS5zb21lKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLmNvbnRleHQgPSBfcHJvcHMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnN1YiA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgc3Vic18xLnB1c2goYyk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZCA9IGMuY29tcG9uZW50V2lsbFVubW91bnQ7XG4gICAgICAgICAgICAgICAgYy5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic18xLnNwbGljZShzdWJzXzEuaW5kZXhPZihjKSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIG9sZCAmJiBvbGQuY2FsbChjKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfTtcbiAgICByZXR1cm4gQ29udGV4dFR5cGU7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/core/vdom.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/daygrid/main.css":
/*!*****************************************************!*\
  !*** ./node_modules/@fullcalendar/daygrid/main.css ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"\\n:root {\\n  --fc-daygrid-event-dot-width: 8px;\\n}\\n.fc .fc-popover {\\n    position: fixed;\\n    top: 0; /* for when not positioned yet */\\n    box-shadow: 0 2px 6px rgba(0,0,0,.15);\\n  }\\n.fc .fc-popover-header {\\n    display: flex;\\n    flex-direction: row;\\n    justify-content: space-between;\\n    align-items: center;\\n    padding: 3px 4px;\\n  }\\n.fc .fc-popover-title {\\n    margin: 0 2px;\\n  }\\n.fc .fc-popover-close {\\n    cursor: pointer;\\n    opacity: 0.65;\\n    font-size: 1.1em;\\n  }\\n.fc-theme-standard .fc-popover {\\n    border: 1px solid #ddd;\\n    border: 1px solid var(--fc-border-color, #ddd);\\n    background: #fff;\\n  }\\n.fc-theme-standard .fc-popover-header {\\n    background: rgba(208, 208, 208, 0.3);\\n    background: var(--fc-neutral-bg-color, rgba(208, 208, 208, 0.3));\\n  }\\n/* help things clear margins of inner content */\\n.fc-daygrid-day-frame,\\n.fc-daygrid-day-events,\\n.fc-daygrid-event-harness { /* for event top/bottom margins */\\n}\\n.fc-daygrid-day-frame:before, .fc-daygrid-day-events:before, .fc-daygrid-event-harness:before {\\n  content: \\\"\\\";\\n  clear: both;\\n  display: table; }\\n.fc-daygrid-day-frame:after, .fc-daygrid-day-events:after, .fc-daygrid-event-harness:after {\\n  content: \\\"\\\";\\n  clear: both;\\n  display: table; }\\n.fc .fc-daygrid-body { /* a <div> that wraps the table */\\n    position: relative;\\n    z-index: 1; /* container inner z-index's because <tr>s can't do it */\\n  }\\n.fc .fc-daygrid-day-frame {\\n    position: relative;\\n    min-height: 100%; /* seems to work better than `height` because sets height after rows/cells naturally do it */\\n  }\\n.fc {\\n\\n  /* cell top */\\n\\n}\\n.fc .fc-daygrid-day-top {\\n    position: relative;\\n    z-index: 4;\\n    display: flex;\\n    flex-direction: row-reverse;\\n  }\\n.fc .fc-day-other .fc-daygrid-day-top {\\n    opacity: 0.3;\\n  }\\n.fc {\\n\\n  /* day number (within cell top) */\\n\\n}\\n.fc .fc-daygrid-day-number {\\n    padding: 4px;\\n  }\\n.fc {\\n\\n  /* event container */\\n\\n}\\n.fc .fc-daygrid-day-events {\\n    margin-top: 1px; /* needs to be margin, not padding, so that available cell height can be computed */\\n  }\\n.fc {\\n\\n  /* positioning for balanced vs natural */\\n\\n}\\n.fc .fc-daygrid-body-balanced .fc-daygrid-day-events {\\n      position: absolute;\\n      left: 0;\\n      right: 0;\\n    }\\n.fc .fc-daygrid-body-unbalanced .fc-daygrid-day-events {\\n      position: relative; /* for containing abs positioned event harnesses */\\n      min-height: 2em; /* in addition to being a min-height during natural height, equalizes the heights a little bit */\\n    }\\n.fc .fc-daygrid-body-natural { /* can coexist with -unbalanced */\\n  }\\n.fc .fc-daygrid-body-natural .fc-daygrid-day-events {\\n      margin-bottom: 1em;\\n    }\\n.fc {\\n\\n  /* event harness */\\n\\n}\\n.fc .fc-daygrid-event-harness {\\n    position: relative;\\n  }\\n.fc .fc-daygrid-event-harness-abs {\\n    position: absolute;\\n    top: 0; /* fallback coords for when cannot yet be computed */\\n    left: 0; /* */\\n    right: 0; /* */\\n  }\\n.fc .fc-daygrid-bg-harness {\\n    position: absolute;\\n    top: 0;\\n    bottom: 0;\\n  }\\n.fc {\\n\\n  /* bg content */\\n\\n}\\n.fc .fc-daygrid-day-bg .fc-non-business { z-index: 1 }\\n.fc .fc-daygrid-day-bg .fc-bg-event { z-index: 2 }\\n.fc .fc-daygrid-day-bg .fc-highlight { z-index: 3 }\\n.fc {\\n\\n  /* events */\\n\\n}\\n.fc .fc-daygrid-event {\\n    z-index: 6;\\n    margin-top: 1px;\\n  }\\n.fc .fc-daygrid-event.fc-event-mirror {\\n    z-index: 7;\\n  }\\n.fc {\\n\\n  /* cell bottom (within day-events) */\\n\\n}\\n.fc .fc-daygrid-day-bottom {\\n    position: relative;\\n    z-index: 4;\\n    font-size: .85em;\\n    margin: 2px 3px 0;\\n  }\\n.fc .fc-daygrid-more-link {\\n    cursor: pointer;\\n  }\\n.fc {\\n\\n  /* week number (within frame) */\\n\\n}\\n.fc .fc-daygrid-week-number {\\n    position: absolute;\\n    z-index: 5;\\n    top: 0;\\n    padding: 2px;\\n    min-width: 1.5em;\\n    text-align: center;\\n    background-color: rgba(208, 208, 208, 0.3);\\n    background-color: var(--fc-neutral-bg-color, rgba(208, 208, 208, 0.3));\\n    color: #808080;\\n    color: var(--fc-neutral-text-color, #808080);\\n  }\\n.fc {\\n\\n  /* popover */\\n\\n}\\n.fc .fc-more-popover {\\n    z-index: 8;\\n  }\\n.fc .fc-more-popover .fc-popover-body {\\n    min-width: 220px;\\n    padding: 10px;\\n  }\\n.fc-direction-ltr .fc-daygrid-event.fc-event-start,\\n.fc-direction-rtl .fc-daygrid-event.fc-event-end {\\n  margin-left: 2px;\\n}\\n.fc-direction-ltr .fc-daygrid-event.fc-event-end,\\n.fc-direction-rtl .fc-daygrid-event.fc-event-start {\\n  margin-right: 2px;\\n}\\n.fc-direction-ltr .fc-daygrid-week-number {\\n    left: 0;\\n    border-radius: 0 0 3px 0;\\n  }\\n.fc-direction-rtl .fc-daygrid-week-number {\\n    right: 0;\\n    border-radius: 0 0 0 3px;\\n  }\\n.fc-liquid-hack .fc-daygrid-day-frame {\\n    position: static; /* will cause inner absolute stuff to expand to <td> */\\n  }\\n.fc-daygrid-event { /* make root-level, because will be dragged-and-dropped outside of a component root */\\n  position: relative; /* for z-indexes assigned later */\\n  white-space: nowrap;\\n  border-radius: 3px; /* dot event needs this to when selected */\\n  font-size: .85em;\\n  font-size: var(--fc-small-font-size, .85em);\\n}\\n/* --- the rectangle (\\\"block\\\") style of event --- */\\n.fc-daygrid-block-event .fc-event-time {\\n    font-weight: bold;\\n  }\\n.fc-daygrid-block-event .fc-event-time,\\n  .fc-daygrid-block-event .fc-event-title {\\n    padding: 1px;\\n  }\\n/* --- the dot style of event --- */\\n.fc-daygrid-dot-event {\\n  padding: 2px 0;\\n  overflow: hidden\\n\\n}\\n.fc-daygrid-dot-event .fc-event-title {\\n    font-weight: bold;\\n  }\\n.fc-daygrid-dot-event .fc-event-time,\\n  .fc-daygrid-dot-event .fc-event-title {\\n    display: inline-block; /* better than inline, for sitting next to dot */\\n  }\\n.fc-daygrid-dot-event:hover,\\n  .fc-daygrid-dot-event.fc-event-mirror {\\n    background: rgba(0, 0, 0, 0.1);\\n  }\\n.fc-daygrid-event-dot { /* the actual dot */\\n  display: inline-block;\\n  margin: 0 4px;\\n  box-sizing: content-box;\\n  width: 0;\\n  height: 0;\\n  border: 4px solid #3788d8;\\n  border: calc(var(--fc-daygrid-event-dot-width, 8px) / 2) solid var(--fc-event-border-color, #3788d8);\\n  border-radius: 4px;\\n  border-radius: calc(var(--fc-daygrid-event-dot-width, 8px) / 2);\\n}\\n/* --- spacing between time and title --- */\\n.fc-direction-ltr .fc-daygrid-event .fc-event-time {\\n    margin-right: 3px;\\n  }\\n.fc-direction-rtl .fc-daygrid-event .fc-event-time {\\n    margin-left: 3px;\\n  }\\n\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9kYXlncmlkL21haW4uY3NzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvZGF5Z3JpZC9tYWluLmNzcz8xMTY4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiXFxuOnJvb3Qge1xcbiAgLS1mYy1kYXlncmlkLWV2ZW50LWRvdC13aWR0aDogOHB4O1xcbn1cXG4uZmMgLmZjLXBvcG92ZXIge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIHRvcDogMDsgLyogZm9yIHdoZW4gbm90IHBvc2l0aW9uZWQgeWV0ICovXFxuICAgIGJveC1zaGFkb3c6IDAgMnB4IDZweCByZ2JhKDAsMCwwLC4xNSk7XFxuICB9XFxuLmZjIC5mYy1wb3BvdmVyLWhlYWRlciB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgcGFkZGluZzogM3B4IDRweDtcXG4gIH1cXG4uZmMgLmZjLXBvcG92ZXItdGl0bGUge1xcbiAgICBtYXJnaW46IDAgMnB4O1xcbiAgfVxcbi5mYyAuZmMtcG9wb3Zlci1jbG9zZSB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgb3BhY2l0eTogMC42NTtcXG4gICAgZm9udC1zaXplOiAxLjFlbTtcXG4gIH1cXG4uZmMtdGhlbWUtc3RhbmRhcmQgLmZjLXBvcG92ZXIge1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjZGRkO1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1mYy1ib3JkZXItY29sb3IsICNkZGQpO1xcbiAgICBiYWNrZ3JvdW5kOiAjZmZmO1xcbiAgfVxcbi5mYy10aGVtZS1zdGFuZGFyZCAuZmMtcG9wb3Zlci1oZWFkZXIge1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDIwOCwgMjA4LCAyMDgsIDAuMyk7XFxuICAgIGJhY2tncm91bmQ6IHZhcigtLWZjLW5ldXRyYWwtYmctY29sb3IsIHJnYmEoMjA4LCAyMDgsIDIwOCwgMC4zKSk7XFxuICB9XFxuLyogaGVscCB0aGluZ3MgY2xlYXIgbWFyZ2lucyBvZiBpbm5lciBjb250ZW50ICovXFxuLmZjLWRheWdyaWQtZGF5LWZyYW1lLFxcbi5mYy1kYXlncmlkLWRheS1ldmVudHMsXFxuLmZjLWRheWdyaWQtZXZlbnQtaGFybmVzcyB7IC8qIGZvciBldmVudCB0b3AvYm90dG9tIG1hcmdpbnMgKi9cXG59XFxuLmZjLWRheWdyaWQtZGF5LWZyYW1lOmJlZm9yZSwgLmZjLWRheWdyaWQtZGF5LWV2ZW50czpiZWZvcmUsIC5mYy1kYXlncmlkLWV2ZW50LWhhcm5lc3M6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgY2xlYXI6IGJvdGg7XFxuICBkaXNwbGF5OiB0YWJsZTsgfVxcbi5mYy1kYXlncmlkLWRheS1mcmFtZTphZnRlciwgLmZjLWRheWdyaWQtZGF5LWV2ZW50czphZnRlciwgLmZjLWRheWdyaWQtZXZlbnQtaGFybmVzczphZnRlciB7XFxuICBjb250ZW50OiBcXFwiXFxcIjtcXG4gIGNsZWFyOiBib3RoO1xcbiAgZGlzcGxheTogdGFibGU7IH1cXG4uZmMgLmZjLWRheWdyaWQtYm9keSB7IC8qIGEgPGRpdj4gdGhhdCB3cmFwcyB0aGUgdGFibGUgKi9cXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICB6LWluZGV4OiAxOyAvKiBjb250YWluZXIgaW5uZXIgei1pbmRleCdzIGJlY2F1c2UgPHRyPnMgY2FuJ3QgZG8gaXQgKi9cXG4gIH1cXG4uZmMgLmZjLWRheWdyaWQtZGF5LWZyYW1lIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBtaW4taGVpZ2h0OiAxMDAlOyAvKiBzZWVtcyB0byB3b3JrIGJldHRlciB0aGFuIGBoZWlnaHRgIGJlY2F1c2Ugc2V0cyBoZWlnaHQgYWZ0ZXIgcm93cy9jZWxscyBuYXR1cmFsbHkgZG8gaXQgKi9cXG4gIH1cXG4uZmMge1xcblxcbiAgLyogY2VsbCB0b3AgKi9cXG5cXG59XFxuLmZjIC5mYy1kYXlncmlkLWRheS10b3Age1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIHotaW5kZXg6IDQ7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3ctcmV2ZXJzZTtcXG4gIH1cXG4uZmMgLmZjLWRheS1vdGhlciAuZmMtZGF5Z3JpZC1kYXktdG9wIHtcXG4gICAgb3BhY2l0eTogMC4zO1xcbiAgfVxcbi5mYyB7XFxuXFxuICAvKiBkYXkgbnVtYmVyICh3aXRoaW4gY2VsbCB0b3ApICovXFxuXFxufVxcbi5mYyAuZmMtZGF5Z3JpZC1kYXktbnVtYmVyIHtcXG4gICAgcGFkZGluZzogNHB4O1xcbiAgfVxcbi5mYyB7XFxuXFxuICAvKiBldmVudCBjb250YWluZXIgKi9cXG5cXG59XFxuLmZjIC5mYy1kYXlncmlkLWRheS1ldmVudHMge1xcbiAgICBtYXJnaW4tdG9wOiAxcHg7IC8qIG5lZWRzIHRvIGJlIG1hcmdpbiwgbm90IHBhZGRpbmcsIHNvIHRoYXQgYXZhaWxhYmxlIGNlbGwgaGVpZ2h0IGNhbiBiZSBjb21wdXRlZCAqL1xcbiAgfVxcbi5mYyB7XFxuXFxuICAvKiBwb3NpdGlvbmluZyBmb3IgYmFsYW5jZWQgdnMgbmF0dXJhbCAqL1xcblxcbn1cXG4uZmMgLmZjLWRheWdyaWQtYm9keS1iYWxhbmNlZCAuZmMtZGF5Z3JpZC1kYXktZXZlbnRzIHtcXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgbGVmdDogMDtcXG4gICAgICByaWdodDogMDtcXG4gICAgfVxcbi5mYyAuZmMtZGF5Z3JpZC1ib2R5LXVuYmFsYW5jZWQgLmZjLWRheWdyaWQtZGF5LWV2ZW50cyB7XFxuICAgICAgcG9zaXRpb246IHJlbGF0aXZlOyAvKiBmb3IgY29udGFpbmluZyBhYnMgcG9zaXRpb25lZCBldmVudCBoYXJuZXNzZXMgKi9cXG4gICAgICBtaW4taGVpZ2h0OiAyZW07IC8qIGluIGFkZGl0aW9uIHRvIGJlaW5nIGEgbWluLWhlaWdodCBkdXJpbmcgbmF0dXJhbCBoZWlnaHQsIGVxdWFsaXplcyB0aGUgaGVpZ2h0cyBhIGxpdHRsZSBiaXQgKi9cXG4gICAgfVxcbi5mYyAuZmMtZGF5Z3JpZC1ib2R5LW5hdHVyYWwgeyAvKiBjYW4gY29leGlzdCB3aXRoIC11bmJhbGFuY2VkICovXFxuICB9XFxuLmZjIC5mYy1kYXlncmlkLWJvZHktbmF0dXJhbCAuZmMtZGF5Z3JpZC1kYXktZXZlbnRzIHtcXG4gICAgICBtYXJnaW4tYm90dG9tOiAxZW07XFxuICAgIH1cXG4uZmMge1xcblxcbiAgLyogZXZlbnQgaGFybmVzcyAqL1xcblxcbn1cXG4uZmMgLmZjLWRheWdyaWQtZXZlbnQtaGFybmVzcyB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIH1cXG4uZmMgLmZjLWRheWdyaWQtZXZlbnQtaGFybmVzcy1hYnMge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDsgLyogZmFsbGJhY2sgY29vcmRzIGZvciB3aGVuIGNhbm5vdCB5ZXQgYmUgY29tcHV0ZWQgKi9cXG4gICAgbGVmdDogMDsgLyogKi9cXG4gICAgcmlnaHQ6IDA7IC8qICovXFxuICB9XFxuLmZjIC5mYy1kYXlncmlkLWJnLWhhcm5lc3Mge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgfVxcbi5mYyB7XFxuXFxuICAvKiBiZyBjb250ZW50ICovXFxuXFxufVxcbi5mYyAuZmMtZGF5Z3JpZC1kYXktYmcgLmZjLW5vbi1idXNpbmVzcyB7IHotaW5kZXg6IDEgfVxcbi5mYyAuZmMtZGF5Z3JpZC1kYXktYmcgLmZjLWJnLWV2ZW50IHsgei1pbmRleDogMiB9XFxuLmZjIC5mYy1kYXlncmlkLWRheS1iZyAuZmMtaGlnaGxpZ2h0IHsgei1pbmRleDogMyB9XFxuLmZjIHtcXG5cXG4gIC8qIGV2ZW50cyAqL1xcblxcbn1cXG4uZmMgLmZjLWRheWdyaWQtZXZlbnQge1xcbiAgICB6LWluZGV4OiA2O1xcbiAgICBtYXJnaW4tdG9wOiAxcHg7XFxuICB9XFxuLmZjIC5mYy1kYXlncmlkLWV2ZW50LmZjLWV2ZW50LW1pcnJvciB7XFxuICAgIHotaW5kZXg6IDc7XFxuICB9XFxuLmZjIHtcXG5cXG4gIC8qIGNlbGwgYm90dG9tICh3aXRoaW4gZGF5LWV2ZW50cykgKi9cXG5cXG59XFxuLmZjIC5mYy1kYXlncmlkLWRheS1ib3R0b20ge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIHotaW5kZXg6IDQ7XFxuICAgIGZvbnQtc2l6ZTogLjg1ZW07XFxuICAgIG1hcmdpbjogMnB4IDNweCAwO1xcbiAgfVxcbi5mYyAuZmMtZGF5Z3JpZC1tb3JlLWxpbmsge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICB9XFxuLmZjIHtcXG5cXG4gIC8qIHdlZWsgbnVtYmVyICh3aXRoaW4gZnJhbWUpICovXFxuXFxufVxcbi5mYyAuZmMtZGF5Z3JpZC13ZWVrLW51bWJlciB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgei1pbmRleDogNTtcXG4gICAgdG9wOiAwO1xcbiAgICBwYWRkaW5nOiAycHg7XFxuICAgIG1pbi13aWR0aDogMS41ZW07XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMDgsIDIwOCwgMjA4LCAwLjMpO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1mYy1uZXV0cmFsLWJnLWNvbG9yLCByZ2JhKDIwOCwgMjA4LCAyMDgsIDAuMykpO1xcbiAgICBjb2xvcjogIzgwODA4MDtcXG4gICAgY29sb3I6IHZhcigtLWZjLW5ldXRyYWwtdGV4dC1jb2xvciwgIzgwODA4MCk7XFxuICB9XFxuLmZjIHtcXG5cXG4gIC8qIHBvcG92ZXIgKi9cXG5cXG59XFxuLmZjIC5mYy1tb3JlLXBvcG92ZXIge1xcbiAgICB6LWluZGV4OiA4O1xcbiAgfVxcbi5mYyAuZmMtbW9yZS1wb3BvdmVyIC5mYy1wb3BvdmVyLWJvZHkge1xcbiAgICBtaW4td2lkdGg6IDIyMHB4O1xcbiAgICBwYWRkaW5nOiAxMHB4O1xcbiAgfVxcbi5mYy1kaXJlY3Rpb24tbHRyIC5mYy1kYXlncmlkLWV2ZW50LmZjLWV2ZW50LXN0YXJ0LFxcbi5mYy1kaXJlY3Rpb24tcnRsIC5mYy1kYXlncmlkLWV2ZW50LmZjLWV2ZW50LWVuZCB7XFxuICBtYXJnaW4tbGVmdDogMnB4O1xcbn1cXG4uZmMtZGlyZWN0aW9uLWx0ciAuZmMtZGF5Z3JpZC1ldmVudC5mYy1ldmVudC1lbmQsXFxuLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtZXZlbnQuZmMtZXZlbnQtc3RhcnQge1xcbiAgbWFyZ2luLXJpZ2h0OiAycHg7XFxufVxcbi5mYy1kaXJlY3Rpb24tbHRyIC5mYy1kYXlncmlkLXdlZWstbnVtYmVyIHtcXG4gICAgbGVmdDogMDtcXG4gICAgYm9yZGVyLXJhZGl1czogMCAwIDNweCAwO1xcbiAgfVxcbi5mYy1kaXJlY3Rpb24tcnRsIC5mYy1kYXlncmlkLXdlZWstbnVtYmVyIHtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGJvcmRlci1yYWRpdXM6IDAgMCAwIDNweDtcXG4gIH1cXG4uZmMtbGlxdWlkLWhhY2sgLmZjLWRheWdyaWQtZGF5LWZyYW1lIHtcXG4gICAgcG9zaXRpb246IHN0YXRpYzsgLyogd2lsbCBjYXVzZSBpbm5lciBhYnNvbHV0ZSBzdHVmZiB0byBleHBhbmQgdG8gPHRkPiAqL1xcbiAgfVxcbi5mYy1kYXlncmlkLWV2ZW50IHsgLyogbWFrZSByb290LWxldmVsLCBiZWNhdXNlIHdpbGwgYmUgZHJhZ2dlZC1hbmQtZHJvcHBlZCBvdXRzaWRlIG9mIGEgY29tcG9uZW50IHJvb3QgKi9cXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTsgLyogZm9yIHotaW5kZXhlcyBhc3NpZ25lZCBsYXRlciAqL1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIGJvcmRlci1yYWRpdXM6IDNweDsgLyogZG90IGV2ZW50IG5lZWRzIHRoaXMgdG8gd2hlbiBzZWxlY3RlZCAqL1xcbiAgZm9udC1zaXplOiAuODVlbTtcXG4gIGZvbnQtc2l6ZTogdmFyKC0tZmMtc21hbGwtZm9udC1zaXplLCAuODVlbSk7XFxufVxcbi8qIC0tLSB0aGUgcmVjdGFuZ2xlIChcXFwiYmxvY2tcXFwiKSBzdHlsZSBvZiBldmVudCAtLS0gKi9cXG4uZmMtZGF5Z3JpZC1ibG9jay1ldmVudCAuZmMtZXZlbnQtdGltZSB7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgfVxcbi5mYy1kYXlncmlkLWJsb2NrLWV2ZW50IC5mYy1ldmVudC10aW1lLFxcbiAgLmZjLWRheWdyaWQtYmxvY2stZXZlbnQgLmZjLWV2ZW50LXRpdGxlIHtcXG4gICAgcGFkZGluZzogMXB4O1xcbiAgfVxcbi8qIC0tLSB0aGUgZG90IHN0eWxlIG9mIGV2ZW50IC0tLSAqL1xcbi5mYy1kYXlncmlkLWRvdC1ldmVudCB7XFxuICBwYWRkaW5nOiAycHggMDtcXG4gIG92ZXJmbG93OiBoaWRkZW5cXG5cXG59XFxuLmZjLWRheWdyaWQtZG90LWV2ZW50IC5mYy1ldmVudC10aXRsZSB7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgfVxcbi5mYy1kYXlncmlkLWRvdC1ldmVudCAuZmMtZXZlbnQtdGltZSxcXG4gIC5mYy1kYXlncmlkLWRvdC1ldmVudCAuZmMtZXZlbnQtdGl0bGUge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IC8qIGJldHRlciB0aGFuIGlubGluZSwgZm9yIHNpdHRpbmcgbmV4dCB0byBkb3QgKi9cXG4gIH1cXG4uZmMtZGF5Z3JpZC1kb3QtZXZlbnQ6aG92ZXIsXFxuICAuZmMtZGF5Z3JpZC1kb3QtZXZlbnQuZmMtZXZlbnQtbWlycm9yIHtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjEpO1xcbiAgfVxcbi5mYy1kYXlncmlkLWV2ZW50LWRvdCB7IC8qIHRoZSBhY3R1YWwgZG90ICovXFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBtYXJnaW46IDAgNHB4O1xcbiAgYm94LXNpemluZzogY29udGVudC1ib3g7XFxuICB3aWR0aDogMDtcXG4gIGhlaWdodDogMDtcXG4gIGJvcmRlcjogNHB4IHNvbGlkICMzNzg4ZDg7XFxuICBib3JkZXI6IGNhbGModmFyKC0tZmMtZGF5Z3JpZC1ldmVudC1kb3Qtd2lkdGgsIDhweCkgLyAyKSBzb2xpZCB2YXIoLS1mYy1ldmVudC1ib3JkZXItY29sb3IsICMzNzg4ZDgpO1xcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgYm9yZGVyLXJhZGl1czogY2FsYyh2YXIoLS1mYy1kYXlncmlkLWV2ZW50LWRvdC13aWR0aCwgOHB4KSAvIDIpO1xcbn1cXG4vKiAtLS0gc3BhY2luZyBiZXR3ZWVuIHRpbWUgYW5kIHRpdGxlIC0tLSAqL1xcbi5mYy1kaXJlY3Rpb24tbHRyIC5mYy1kYXlncmlkLWV2ZW50IC5mYy1ldmVudC10aW1lIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAzcHg7XFxuICB9XFxuLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtZXZlbnQgLmZjLWV2ZW50LXRpbWUge1xcbiAgICBtYXJnaW4tbGVmdDogM3B4O1xcbiAgfVxcblwiIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/daygrid/main.css\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/daygrid/main.js":
/*!****************************************************!*\
  !*** ./node_modules/@fullcalendar/daygrid/main.js ***!
  \****************************************************/
/*! exports provided: default, DayGridView, DayTable, DayTableSlicer, Table, TableView, buildDayTableModel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DayGridView\", function() { return DayTableView; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DayTable\", function() { return DayTable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DayTableSlicer\", function() { return DayTableSlicer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Table\", function() { return Table; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TableView\", function() { return TableView; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildDayTableModel\", function() { return buildDayTableModel; });\n/* harmony import */ var _main_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main.css */ \"./node_modules/@fullcalendar/daygrid/main.css\");\n/* harmony import */ var _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fullcalendar/common */ \"./node_modules/@fullcalendar/common/main.js\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/*!\nFullCalendar v5.0.0\nDocs & License: https://fullcalendar.io/\n(c) 2020 Adam Shaw\n*/\n\n\n\n/* An abstract class for the daygrid views, as well as month view. Renders one or more rows of day cells.\n----------------------------------------------------------------------------------------------------------------------*/\n// It is a manager for a Table subcomponent, which does most of the heavy lifting.\n// It is responsible for managing width/height.\n\nvar TableView =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__extends\"])(TableView, _super);\n\n  function TableView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.headerElRef = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createRef\"])();\n    return _this;\n  }\n\n  TableView.prototype.renderSimpleLayout = function (headerRowContent, bodyContent) {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var sections = [];\n    var stickyHeaderDates = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"getStickyHeaderDates\"])(context.options);\n\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        chunk: {\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent\n        }\n      });\n    }\n\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      chunk: {\n        content: bodyContent\n      }\n    });\n    return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"ViewRoot\"], {\n      viewSpec: context.viewSpec\n    }, function (rootElRef, classNames) {\n      return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(\"div\", {\n        ref: rootElRef,\n        className: ['fc-daygrid'].concat(classNames).join(' ')\n      }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"SimpleScrollGrid\"], {\n        liquid: !props.isHeightAuto && !props.forPrint,\n        cols: []\n        /* TODO: make optional? */\n        ,\n        sections: sections\n      }));\n    });\n  };\n\n  TableView.prototype.renderHScrollLayout = function (headerRowContent, bodyContent, colCnt, dayMinWidth) {\n    var ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n\n    if (!ScrollGrid) {\n      throw new Error('No ScrollGrid implementation');\n    }\n\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var stickyHeaderDates = !props.forPrint && Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"getStickyHeaderDates\"])(context.options);\n    var stickyFooterScrollbar = !props.forPrint && Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"getStickyFooterScrollbar\"])(context.options);\n    var sections = [];\n\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        chunks: [{\n          key: 'main',\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent\n        }]\n      });\n    }\n\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      chunks: [{\n        key: 'main',\n        content: bodyContent\n      }]\n    });\n\n    if (stickyFooterScrollbar) {\n      sections.push({\n        type: 'footer',\n        key: 'footer',\n        isSticky: true,\n        chunks: [{\n          key: 'main',\n          content: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"renderScrollShim\"]\n        }]\n      });\n    }\n\n    return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"ViewRoot\"], {\n      viewSpec: context.viewSpec\n    }, function (rootElRef, classNames) {\n      return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(\"div\", {\n        ref: rootElRef,\n        className: ['fc-daygrid'].concat(classNames).join(' ')\n      }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(ScrollGrid, {\n        liquid: !props.isHeightAuto && !props.forPrint,\n        colGroups: [{\n          cols: [{\n            span: colCnt,\n            minWidth: dayMinWidth\n          }]\n        }],\n        sections: sections\n      }));\n    });\n  };\n\n  return TableView;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"DateComponent\"]);\n\nfunction splitSegsByRow(segs, rowCnt) {\n  var byRow = [];\n\n  for (var i = 0; i < rowCnt; i++) {\n    byRow[i] = [];\n  }\n\n  for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n    var seg = segs_1[_i];\n    byRow[seg.row].push(seg);\n  }\n\n  return byRow;\n}\n\nfunction splitSegsByFirstCol(segs, colCnt) {\n  var byCol = [];\n\n  for (var i = 0; i < colCnt; i++) {\n    byCol[i] = [];\n  }\n\n  for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n    var seg = segs_2[_i];\n    byCol[seg.firstCol].push(seg);\n  }\n\n  return byCol;\n}\n\nfunction splitInteractionByRow(ui, rowCnt) {\n  var byRow = [];\n\n  if (!ui) {\n    for (var i = 0; i < rowCnt; i++) {\n      byRow[i] = null;\n    }\n  } else {\n    for (var i = 0; i < rowCnt; i++) {\n      byRow[i] = {\n        affectedInstances: ui.affectedInstances,\n        isEvent: ui.isEvent,\n        segs: []\n      };\n    }\n\n    for (var _i = 0, _a = ui.segs; _i < _a.length; _i++) {\n      var seg = _a[_i];\n      byRow[seg.row].segs.push(seg);\n    }\n  }\n\n  return byRow;\n}\n\nvar DEFAULT_WEEK_NUM_FORMAT = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createFormatter\"])({\n  week: 'narrow'\n});\n\nvar TableCell =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__extends\"])(TableCell, _super);\n\n  function TableCell() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.handleRootEl = function (el) {\n      _this.rootEl = el;\n      Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"setRef\"])(_this.props.elRef, el);\n    };\n\n    _this.handleMoreLinkClick = function (ev) {\n      var props = _this.props;\n\n      if (props.onMoreClick) {\n        var allSegs = props.segsByEachCol;\n        var hiddenSegs = allSegs.filter(function (seg) {\n          return props.segIsHidden[seg.eventRange.instance.instanceId];\n        });\n        props.onMoreClick({\n          date: props.date,\n          allSegs: allSegs,\n          hiddenSegs: hiddenSegs,\n          moreCnt: props.moreCnt,\n          dayEl: _this.rootEl,\n          ev: ev\n        });\n      }\n    };\n\n    return _this;\n  }\n\n  TableCell.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.context,\n        options = _a.options,\n        viewApi = _a.viewApi;\n    var props = this.props;\n    var date = props.date,\n        dateProfile = props.dateProfile;\n    var hookProps = {\n      num: props.moreCnt,\n      text: props.buildMoreLinkText(props.moreCnt),\n      view: viewApi\n    };\n    var navLinkAttrs = options.navLinks ? {\n      'data-navlink': Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"buildNavLinkData\"])(date, 'week'),\n      tabIndex: 0\n    } : {};\n    return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"DayCellRoot\"], {\n      date: date,\n      dateProfile: dateProfile,\n      todayRange: props.todayRange,\n      showDayNumber: props.showDayNumber,\n      extraHookProps: props.extraHookProps,\n      elRef: this.handleRootEl\n    }, function (rootElRef, classNames, rootDataAttrs, isDisabled) {\n      return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(\"td\", Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__assign\"])({\n        ref: rootElRef,\n        className: ['fc-daygrid-day'].concat(classNames, props.extraClassNames || []).join(' ')\n      }, rootDataAttrs, props.extraDataAttrs), Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(\"div\", {\n        className: 'fc-daygrid-day-frame fc-scrollgrid-sync-inner',\n        ref: props.innerElRef\n        /* different from hook system! RENAME */\n\n      }, props.showWeekNumber && Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"WeekNumberRoot\"], {\n        date: date,\n        defaultFormat: DEFAULT_WEEK_NUM_FORMAT\n      }, function (rootElRef, classNames, innerElRef, innerContent) {\n        return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(\"a\", Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__assign\"])({\n          ref: rootElRef,\n          className: ['fc-daygrid-week-number'].concat(classNames).join(' ')\n        }, navLinkAttrs), innerContent);\n      }), !isDisabled && Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(TableCellTop, {\n        date: date,\n        dateProfile: dateProfile,\n        showDayNumber: props.showDayNumber,\n        todayRange: props.todayRange,\n        extraHookProps: props.extraHookProps\n      }), Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(\"div\", {\n        className: 'fc-daygrid-day-events',\n        ref: props.fgContentElRef,\n        style: {\n          paddingBottom: props.fgPaddingBottom\n        }\n      }, props.fgContent, Boolean(props.moreCnt) && Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(\"div\", {\n        className: 'fc-daygrid-day-bottom',\n        style: {\n          marginTop: props.moreMarginTop\n        }\n      }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"RenderHook\"], {\n        hookProps: hookProps,\n        classNames: options.moreLinkClassNames,\n        content: options.moreLinkContent,\n        defaultContent: renderMoreLinkInner,\n        didMount: options.moreLinkDidMount,\n        willUnmount: options.moreLinkWillUnmount\n      }, function (rootElRef, classNames, innerElRef, innerContent) {\n        return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(\"a\", {\n          onClick: _this.handleMoreLinkClick,\n          ref: rootElRef,\n          className: ['fc-daygrid-more-link'].concat(classNames).join(' ')\n        }, innerContent);\n      }))), Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(\"div\", {\n        className: 'fc-daygrid-day-bg'\n      }, props.bgContent)));\n    });\n  };\n\n  return TableCell;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"DateComponent\"]);\n\nfunction renderTopInner(props) {\n  return props.dayNumberText;\n}\n\nfunction renderMoreLinkInner(props) {\n  return props.text;\n}\n\nvar TableCellTop =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__extends\"])(TableCellTop, _super);\n\n  function TableCellTop() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableCellTop.prototype.render = function () {\n    var props = this.props;\n    var navLinkAttrs = this.context.options.navLinks ? {\n      'data-navlink': Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"buildNavLinkData\"])(props.date),\n      tabIndex: 0\n    } : {};\n    return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"DayCellContent\"], {\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      showDayNumber: props.showDayNumber,\n      extraHookProps: props.extraHookProps,\n      defaultContent: renderTopInner\n    }, function (innerElRef, innerContent) {\n      return innerContent && Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(\"div\", {\n        className: 'fc-daygrid-day-top',\n        ref: innerElRef\n      }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(\"a\", Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__assign\"])({\n        className: 'fc-daygrid-day-number'\n      }, navLinkAttrs), innerContent));\n    });\n  };\n\n  return TableCellTop;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"BaseComponent\"]);\n\nvar DEFAULT_TABLE_EVENT_TIME_FORMAT = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createFormatter\"])({\n  hour: 'numeric',\n  minute: '2-digit',\n  omitZeroMinute: true,\n  meridiem: 'narrow'\n});\n\nfunction hasListItemDisplay(seg) {\n  var display = seg.eventRange.ui.display;\n  return display === 'list-item' || display === 'auto' && !seg.eventRange.def.allDay && seg.firstCol === seg.lastCol // can't be multi-day\n  ;\n}\n\nvar TableListItemEvent =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__extends\"])(TableListItemEvent, _super);\n\n  function TableListItemEvent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableListItemEvent.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var timeFormat = context.options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;\n    var timeText = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"buildSegTimeText\"])(props.seg, timeFormat, context, true, props.defaultDisplayEventEnd);\n    return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"EventRoot\"], {\n      seg: props.seg,\n      timeText: timeText,\n      defaultContent: renderInnerContent,\n      isDragging: props.isDragging,\n      isResizing: false,\n      isDateSelecting: false,\n      isSelected: props.isSelected,\n      isPast: props.isPast,\n      isFuture: props.isFuture,\n      isToday: props.isToday\n    }, function (rootElRef, classNames, innerElRef, innerContent) {\n      return (// we don't use styles!\n        Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(\"a\", Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__assign\"])({\n          className: ['fc-daygrid-event', 'fc-daygrid-dot-event'].concat(classNames).join(' '),\n          ref: rootElRef\n        }, getSegAnchorAttrs(props.seg)), innerContent)\n      );\n    });\n  };\n\n  return TableListItemEvent;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"BaseComponent\"]);\n\nfunction renderInnerContent(innerProps) {\n  return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"Fragment\"], null, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(\"div\", {\n    className: 'fc-daygrid-event-dot',\n    style: {\n      borderColor: innerProps.borderColor || innerProps.backgroundColor\n    }\n  }), innerProps.timeText && Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(\"div\", {\n    className: 'fc-event-time'\n  }, innerProps.timeText), Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(\"div\", {\n    className: 'fc-event-title'\n  }, innerProps.event.title || Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"Fragment\"], null, \"\\xA0\")));\n}\n\nfunction getSegAnchorAttrs(seg) {\n  var url = seg.eventRange.def.url;\n  return url ? {\n    href: url\n  } : {};\n}\n\nvar TableBlockEvent =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__extends\"])(TableBlockEvent, _super);\n\n  function TableBlockEvent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableBlockEvent.prototype.render = function () {\n    var props = this.props;\n    return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"StandardEvent\"], Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__assign\"])({}, props, {\n      extraClassNames: ['fc-daygrid-event', 'fc-daygrid-block-event', 'fc-h-event'],\n      defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT,\n      defaultDisplayEventEnd: props.defaultDisplayEventEnd,\n      disableResizing: !props.seg.eventRange.def.allDay\n    }));\n  };\n\n  return TableBlockEvent;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"BaseComponent\"]);\n\nfunction computeFgSegPlacement( // for one row. TODO: print mode?\ncellModels, segs, dayMaxEvents, dayMaxEventRows, eventHeights, maxContentHeight, colCnt, eventOrderSpecs) {\n  var colPlacements = []; // if event spans multiple cols, its present in each col\n\n  var moreCnts = []; // by-col\n\n  var segIsHidden = {};\n  var segTops = {}; // always populated for each seg\n\n  var segMarginTops = {}; // simetimes populated for each seg\n\n  var moreTops = {};\n  var paddingBottoms = {}; // for each cell's inner-wrapper div\n\n  for (var i = 0; i < colCnt; i++) {\n    colPlacements.push([]);\n    moreCnts.push(0);\n  }\n\n  segs = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"sortEventSegs\"])(segs, eventOrderSpecs);\n\n  for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n    var seg = segs_1[_i];\n    var instanceId = seg.eventRange.instance.instanceId;\n    var eventHeight = eventHeights[instanceId + ':' + seg.firstCol];\n    placeSeg(seg, eventHeight || 0); // will keep colPlacements sorted by top\n  }\n\n  if (dayMaxEvents === true || dayMaxEventRows === true) {\n    limitByMaxHeight(moreCnts, segIsHidden, colPlacements, maxContentHeight); // populates moreCnts/segIsHidden\n  } else if (typeof dayMaxEvents === 'number') {\n    limitByMaxEvents(moreCnts, segIsHidden, colPlacements, dayMaxEvents); // populates moreCnts/segIsHidden\n  } else if (typeof dayMaxEventRows === 'number') {\n    limitByMaxRows(moreCnts, segIsHidden, colPlacements, dayMaxEventRows); // populates moreCnts/segIsHidden\n  } // computes segTops/segMarginTops/moreTops/paddingBottoms\n\n\n  for (var col = 0; col < colCnt; col++) {\n    var placements = colPlacements[col];\n    var currentNonAbsBottom = 0;\n    var runningAbsHeight = 0;\n\n    for (var _a = 0, placements_1 = placements; _a < placements_1.length; _a++) {\n      var placement = placements_1[_a];\n      var seg = placement.seg;\n\n      if (!segIsHidden[seg.eventRange.instance.instanceId]) {\n        segTops[seg.eventRange.instance.instanceId] = placement.top; // from top of container\n\n        if (seg.firstCol === seg.lastCol && seg.isStart && seg.isEnd) {\n          // TODO: simpler way? NOT DRY\n          segMarginTops[seg.eventRange.instance.instanceId] = placement.top - currentNonAbsBottom; // from previous seg bottom\n\n          runningAbsHeight = 0;\n          currentNonAbsBottom = placement.bottom;\n        } else {\n          // multi-col event, abs positioned\n          runningAbsHeight += placement.bottom - placement.top;\n        }\n      }\n    }\n\n    if (runningAbsHeight) {\n      if (moreCnts[col]) {\n        moreTops[col] = runningAbsHeight;\n      } else {\n        paddingBottoms[col] = runningAbsHeight;\n      }\n    }\n  }\n\n  function placeSeg(seg, segHeight) {\n    if (!tryPlaceSegAt(seg, segHeight, 0)) {\n      for (var col = seg.firstCol; col <= seg.lastCol; col++) {\n        for (var _i = 0, _a = colPlacements[col]; _i < _a.length; _i++) {\n          // will repeat multi-day segs!!!!!!! bad!!!!!!\n          var placement = _a[_i];\n\n          if (tryPlaceSegAt(seg, segHeight, placement.bottom)) {\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  function tryPlaceSegAt(seg, segHeight, top) {\n    if (canPlaceSegAt(seg, segHeight, top)) {\n      for (var col = seg.firstCol; col <= seg.lastCol; col++) {\n        var placements = colPlacements[col];\n        var insertionIndex = 0;\n\n        while (insertionIndex < placements.length && top >= placements[insertionIndex].top) {\n          insertionIndex++;\n        }\n\n        placements.splice(insertionIndex, 0, {\n          seg: seg,\n          top: top,\n          bottom: top + segHeight\n        });\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function canPlaceSegAt(seg, segHeight, top) {\n    for (var col = seg.firstCol; col <= seg.lastCol; col++) {\n      for (var _i = 0, _a = colPlacements[col]; _i < _a.length; _i++) {\n        var placement = _a[_i];\n\n        if (top < placement.bottom && top + segHeight > placement.top) {\n          // collide?\n          return false;\n        }\n      }\n    }\n\n    return true;\n  } // what does this do!?\n\n\n  for (var instanceIdAndFirstCol in eventHeights) {\n    if (!eventHeights[instanceIdAndFirstCol]) {\n      segIsHidden[instanceIdAndFirstCol.split(':')[0]] = true;\n    }\n  }\n\n  var segsByFirstCol = colPlacements.map(extractFirstColSegs); // operates on the sorted cols\n\n  var segsByEachCol = colPlacements.map(function (placements, col) {\n    var segs = extractAllColSegs(placements);\n    segs = resliceDaySegs(segs, cellModels[col].date, col);\n    return segs;\n  });\n  return {\n    segsByFirstCol: segsByFirstCol,\n    segsByEachCol: segsByEachCol,\n    segIsHidden: segIsHidden,\n    segTops: segTops,\n    segMarginTops: segMarginTops,\n    moreCnts: moreCnts,\n    moreTops: moreTops,\n    paddingBottoms: paddingBottoms\n  };\n}\n\nfunction extractFirstColSegs(oneColPlacements, col) {\n  var segs = [];\n\n  for (var _i = 0, oneColPlacements_1 = oneColPlacements; _i < oneColPlacements_1.length; _i++) {\n    var placement = oneColPlacements_1[_i];\n\n    if (placement.seg.firstCol === col) {\n      segs.push(placement.seg);\n    }\n  }\n\n  return segs;\n}\n\nfunction extractAllColSegs(oneColPlacements) {\n  var segs = [];\n\n  for (var _i = 0, oneColPlacements_2 = oneColPlacements; _i < oneColPlacements_2.length; _i++) {\n    var placement = oneColPlacements_2[_i];\n    segs.push(placement.seg);\n  }\n\n  return segs;\n}\n\nfunction limitByMaxHeight(hiddenCnts, segIsHidden, colPlacements, maxContentHeight) {\n  limitEvents(hiddenCnts, segIsHidden, colPlacements, true, function (placement) {\n    return placement.bottom <= maxContentHeight;\n  });\n}\n\nfunction limitByMaxEvents(hiddenCnts, segIsHidden, colPlacements, dayMaxEvents) {\n  limitEvents(hiddenCnts, segIsHidden, colPlacements, false, function (placement, levelIndex) {\n    return levelIndex < dayMaxEvents;\n  });\n}\n\nfunction limitByMaxRows(hiddenCnts, segIsHidden, colPlacements, dayMaxEventRows) {\n  limitEvents(hiddenCnts, segIsHidden, colPlacements, true, function (placement, levelIndex) {\n    return levelIndex < dayMaxEventRows;\n  });\n}\n/*\npopulates the given hiddenCnts/segIsHidden, which are supplied empty.\nTODO: return them instead\n*/\n\n\nfunction limitEvents(hiddenCnts, segIsHidden, colPlacements, moreLinkConsumesLevel, isPlacementInBounds) {\n  var colCnt = hiddenCnts.length;\n  var segIsVisible = {}; // TODO: instead, use segIsHidden with true/false?\n\n  var visibleColPlacements = []; // will mirror colPlacements\n\n  for (var col = 0; col < colCnt; col++) {\n    visibleColPlacements.push([]);\n  }\n\n  for (var col = 0; col < colCnt; col++) {\n    var placements = colPlacements[col];\n    var level = 0;\n\n    for (var _i = 0, placements_2 = placements; _i < placements_2.length; _i++) {\n      var placement = placements_2[_i];\n\n      if (isPlacementInBounds(placement, level)) {\n        recordVisible(placement);\n      } else {\n        recordHidden(placement);\n      } // only considered a level if the seg had height\n\n\n      if (placement.top !== placement.bottom) {\n        level++;\n      }\n    }\n  }\n\n  function recordVisible(placement) {\n    var seg = placement.seg;\n    var instanceId = seg.eventRange.instance.instanceId;\n\n    if (!segIsVisible[instanceId]) {\n      segIsVisible[instanceId] = true;\n\n      for (var col = seg.firstCol; col <= seg.lastCol; col++) {\n        visibleColPlacements[col].push(placement);\n      }\n    }\n  }\n\n  function recordHidden(placement) {\n    var seg = placement.seg;\n    var instanceId = seg.eventRange.instance.instanceId;\n\n    if (!segIsHidden[instanceId]) {\n      segIsHidden[instanceId] = true;\n\n      for (var col = seg.firstCol; col <= seg.lastCol; col++) {\n        var hiddenCnt = ++hiddenCnts[col];\n\n        if (moreLinkConsumesLevel && hiddenCnt === 1) {\n          var lastVisiblePlacement = visibleColPlacements[col].pop();\n\n          if (lastVisiblePlacement) {\n            recordHidden(lastVisiblePlacement);\n          }\n        }\n      }\n    }\n  }\n} // Given the events within an array of segment objects, reslice them to be in a single day\n\n\nfunction resliceDaySegs(segs, dayDate, colIndex) {\n  var dayStart = dayDate;\n  var dayEnd = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"addDays\"])(dayStart, 1);\n  var dayRange = {\n    start: dayStart,\n    end: dayEnd\n  };\n  var newSegs = [];\n\n  for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n    var seg = segs_2[_i];\n    var eventRange = seg.eventRange;\n    var origRange = eventRange.range;\n    var slicedRange = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"intersectRanges\"])(origRange, dayRange);\n\n    if (slicedRange) {\n      newSegs.push(Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__assign\"])({}, seg), {\n        firstCol: colIndex,\n        lastCol: colIndex,\n        eventRange: {\n          def: eventRange.def,\n          ui: Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__assign\"])({}, eventRange.ui), {\n            durationEditable: false\n          }),\n          instance: eventRange.instance,\n          range: slicedRange\n        },\n        isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(),\n        isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf()\n      }));\n    }\n  }\n\n  return newSegs;\n}\n\nvar TableRow =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__extends\"])(TableRow, _super);\n\n  function TableRow() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.cellElRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"RefMap\"](); // the <td>\n\n    _this.frameElRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"RefMap\"](); // the fc-daygrid-day-frame\n\n    _this.fgElRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"RefMap\"](); // the fc-daygrid-day-events\n\n    _this.segHarnessRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"RefMap\"](); // indexed by \"instanceId:firstCol\"\n\n    _this.rootElRef = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createRef\"])();\n    _this.state = {\n      framePositions: null,\n      maxContentHeight: null,\n      segHeights: {}\n    };\n    return _this;\n  }\n\n  TableRow.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        state = _a.state,\n        context = _a.context;\n\n    var colCnt = props.cells.length;\n    var businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);\n    var bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);\n    var highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);\n    var mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);\n\n    var _b = computeFgSegPlacement(props.cells, props.fgEventSegs, props.dayMaxEvents, props.dayMaxEventRows, state.segHeights, state.maxContentHeight, colCnt, context.options.eventOrder),\n        paddingBottoms = _b.paddingBottoms,\n        segsByFirstCol = _b.segsByFirstCol,\n        segsByEachCol = _b.segsByEachCol,\n        segIsHidden = _b.segIsHidden,\n        segTops = _b.segTops,\n        segMarginTops = _b.segMarginTops,\n        moreCnts = _b.moreCnts,\n        moreTops = _b.moreTops;\n\n    var selectedInstanceHash = // TODO: messy way to compute this\n    props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};\n    return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(\"tr\", {\n      ref: this.rootElRef\n    }, props.renderIntro && props.renderIntro(), props.cells.map(function (cell, col) {\n      var normalFgNodes = _this.renderFgSegs(segsByFirstCol[col], segIsHidden, segTops, segMarginTops, selectedInstanceHash, props.todayRange);\n\n      var mirrorFgNodes = _this.renderFgSegs(mirrorSegsByCol[col], {}, segTops, // use same tops as real rendering\n      {}, {}, props.todayRange, Boolean(props.eventDrag), Boolean(props.eventResize), false // date-selecting (because mirror is never drawn for date selection)\n      );\n\n      var showWeekNumber = props.showWeekNumbers && col === 0;\n      return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(TableCell, {\n        key: cell.key,\n        elRef: _this.cellElRefs.createRef(cell.key),\n        innerElRef: _this.frameElRefs.createRef(cell.key)\n        /* FF <td> problem, but okay to use for left/right. TODO: rename prop */\n        ,\n        dateProfile: props.dateProfile,\n        date: cell.date,\n        showDayNumber: props.showDayNumbers || showWeekNumber\n        /* for spacing, we need to force day-numbers if week numbers */\n        ,\n        showWeekNumber: showWeekNumber,\n        todayRange: props.todayRange,\n        extraHookProps: cell.extraHookProps,\n        extraDataAttrs: cell.extraDataAttrs,\n        extraClassNames: cell.extraClassNames,\n        moreCnt: moreCnts[col],\n        buildMoreLinkText: props.buildMoreLinkText,\n        onMoreClick: props.onMoreClick,\n        segIsHidden: segIsHidden,\n        moreMarginTop: moreTops[col]\n        /* rename */\n        ,\n        segsByEachCol: segsByEachCol[col],\n        fgPaddingBottom: paddingBottoms[col],\n        fgContentElRef: _this.fgElRefs.createRef(cell.key),\n        fgContent: // Fragment scopes the keys\n        Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"Fragment\"], null, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"Fragment\"], null, normalFgNodes), Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"Fragment\"], null, mirrorFgNodes)),\n        bgContent: // Fragment scopes the keys\n        Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"Fragment\"], null, _this.renderFillSegs(highlightSegsByCol[col], 'highlight'), _this.renderFillSegs(businessHoursByCol[col], 'non-business'), _this.renderFillSegs(bgEventSegsByCol[col], 'bg-event'))\n      });\n    }));\n  };\n\n  TableRow.prototype.componentDidMount = function () {\n    this.updateSizing(true);\n  };\n\n  TableRow.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var currentProps = this.props;\n    this.updateSizing(!Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"isPropsEqual\"])(prevProps, currentProps));\n  };\n\n  TableRow.prototype.getHighlightSegs = function () {\n    var props = this.props;\n\n    if (props.eventDrag && props.eventDrag.segs.length) {\n      // messy check\n      return props.eventDrag.segs;\n    } else if (props.eventResize && props.eventResize.segs.length) {\n      // messy check\n      return props.eventResize.segs;\n    } else {\n      return props.dateSelectionSegs;\n    }\n  };\n\n  TableRow.prototype.getMirrorSegs = function () {\n    var props = this.props;\n\n    if (props.eventResize && props.eventResize.segs.length) {\n      // messy check\n      return props.eventResize.segs;\n    } else {\n      return [];\n    }\n  };\n\n  TableRow.prototype.renderFgSegs = function (segs, segIsHidden, // does NOT mean display:hidden\n  segTops, segMarginTops, selectedInstanceHash, todayRange, isDragging, isResizing, isDateSelecting) {\n    var context = this.context;\n    var eventSelection = this.props.eventSelection;\n    var framePositions = this.state.framePositions;\n    var defaultDisplayEventEnd = this.props.cells.length === 1; // colCnt === 1\n\n    var nodes = [];\n\n    if (framePositions) {\n      for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n        var seg = segs_1[_i];\n        var instanceId = seg.eventRange.instance.instanceId;\n        var isMirror = isDragging || isResizing || isDateSelecting;\n        var isSelected = selectedInstanceHash[instanceId];\n        var isInvisible = segIsHidden[instanceId] || isSelected;\n        var isAbsolute = segIsHidden[instanceId] || isMirror || seg.firstCol !== seg.lastCol || !seg.isStart || !seg.isEnd; // TODO: simpler way? NOT DRY\n\n        var marginTop = void 0;\n        var top_1 = void 0;\n        var left = void 0;\n        var right = void 0;\n\n        if (isAbsolute) {\n          top_1 = segTops[instanceId];\n\n          if (context.isRtl) {\n            right = 0;\n            left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];\n          } else {\n            left = 0;\n            right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];\n          }\n        } else {\n          marginTop = segMarginTops[instanceId];\n        }\n        /*\n        known bug: events that are force to be list-item but span multiple days still take up space in later columns\n        */\n\n\n        nodes.push(Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(\"div\", {\n          className: 'fc-daygrid-event-harness' + (isAbsolute ? ' fc-daygrid-event-harness-abs' : ''),\n          key: instanceId,\n          ref: isMirror ? null : this.segHarnessRefs.createRef(instanceId + ':' + seg.firstCol)\n          /* in print mode when in mult cols, could collide */\n          ,\n          style: {\n            visibility: isInvisible ? 'hidden' : '',\n            marginTop: marginTop || '',\n            top: top_1 || '',\n            left: left || '',\n            right: right || ''\n          }\n        }, hasListItemDisplay(seg) ? Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(TableListItemEvent, Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__assign\"])({\n          seg: seg,\n          isDragging: isDragging,\n          isSelected: instanceId === eventSelection,\n          defaultDisplayEventEnd: defaultDisplayEventEnd\n        }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"getSegMeta\"])(seg, todayRange))) : Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(TableBlockEvent, Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__assign\"])({\n          seg: seg,\n          isDragging: isDragging,\n          isResizing: isResizing,\n          isDateSelecting: isDateSelecting,\n          isSelected: instanceId === eventSelection,\n          defaultDisplayEventEnd: defaultDisplayEventEnd\n        }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"getSegMeta\"])(seg, todayRange)))));\n      }\n    }\n\n    return nodes;\n  };\n\n  TableRow.prototype.renderFillSegs = function (segs, fillType) {\n    var isRtl = this.context.isRtl;\n    var todayRange = this.props.todayRange;\n    var framePositions = this.state.framePositions;\n    var nodes = [];\n\n    if (framePositions) {\n      for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n        var seg = segs_2[_i];\n        var leftRightCss = isRtl ? {\n          right: 0,\n          left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol]\n        } : {\n          left: 0,\n          right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol]\n        };\n        nodes.push(Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(\"div\", {\n          key: Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"buildEventRangeKey\"])(seg.eventRange),\n          className: 'fc-daygrid-bg-harness',\n          style: leftRightCss\n        }, fillType === 'bg-event' ? Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"BgEvent\"], Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__assign\"])({\n          seg: seg\n        }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"getSegMeta\"])(seg, todayRange))) : Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"renderFill\"])(fillType)));\n      }\n    }\n\n    return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"].apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__spreadArrays\"])([_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"Fragment\"], {}], nodes));\n  };\n\n  TableRow.prototype.updateSizing = function (isExternalSizingChange) {\n    var _a = this,\n        props = _a.props,\n        frameElRefs = _a.frameElRefs;\n\n    if (props.clientWidth !== null) {\n      // positioning ready?\n      if (isExternalSizingChange) {\n        var frameEls = props.cells.map(function (cell) {\n          return frameElRefs.currentMap[cell.key];\n        });\n\n        if (frameEls.length) {\n          var originEl = this.rootElRef.current;\n          this.setState({\n            framePositions: new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"PositionCache\"](originEl, frameEls, true, // isHorizontal\n            false)\n          });\n        }\n      }\n\n      var limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;\n      this.setState({\n        segHeights: this.computeSegHeights(),\n        maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null\n      });\n    }\n  };\n\n  TableRow.prototype.computeSegHeights = function () {\n    return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"mapHash\"])(this.segHarnessRefs.currentMap, function (eventHarnessEl) {\n      return eventHarnessEl.getBoundingClientRect().height;\n    });\n  };\n\n  TableRow.prototype.computeMaxContentHeight = function () {\n    var firstKey = this.props.cells[0].key;\n    var cellEl = this.cellElRefs.currentMap[firstKey];\n    var fcContainerEl = this.fgElRefs.currentMap[firstKey];\n    return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;\n  };\n\n  TableRow.prototype.getCellEls = function () {\n    var elMap = this.cellElRefs.currentMap;\n    return this.props.cells.map(function (cell) {\n      return elMap[cell.key];\n    });\n  };\n\n  return TableRow;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"DateComponent\"]);\n\nTableRow.addStateEquality({\n  segHeights: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"isPropsEqual\"]\n});\nvar PADDING_FROM_VIEWPORT = 10;\nvar SCROLL_DEBOUNCE = 10;\n\nvar Popover =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__extends\"])(Popover, _super);\n\n  function Popover() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.repositioner = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"DelayedRunner\"](_this.updateSize.bind(_this));\n\n    _this.handleRootEl = function (el) {\n      _this.rootEl = el;\n\n      if (_this.props.elRef) {\n        Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"setRef\"])(_this.props.elRef, el);\n      }\n    }; // Triggered when the user clicks *anywhere* in the document, for the autoHide feature\n\n\n    _this.handleDocumentMousedown = function (ev) {\n      var onClose = _this.props.onClose; // only hide the popover if the click happened outside the popover\n\n      if (onClose && !_this.rootEl.contains(ev.target)) {\n        onClose();\n      }\n    };\n\n    _this.handleDocumentScroll = function () {\n      _this.repositioner.request(SCROLL_DEBOUNCE);\n    };\n\n    _this.handleCloseClick = function () {\n      var onClose = _this.props.onClose;\n\n      if (onClose) {\n        onClose();\n      }\n    };\n\n    return _this;\n  }\n\n  Popover.prototype.render = function () {\n    var theme = this.context.theme;\n    var props = this.props;\n    var classNames = ['fc-popover', theme.getClass('popover')].concat(props.extraClassNames || []);\n    return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(\"div\", Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__assign\"])({\n      className: classNames.join(' ')\n    }, props.extraAttrs, {\n      ref: this.handleRootEl\n    }), Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(\"div\", {\n      className: 'fc-popover-header ' + theme.getClass('popoverHeader')\n    }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(\"span\", {\n      className: 'fc-popover-title'\n    }, props.title), Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(\"span\", {\n      className: 'fc-popover-close ' + theme.getIconClass('close'),\n      onClick: this.handleCloseClick\n    })), Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(\"div\", {\n      className: 'fc-popover-body ' + theme.getClass('popoverContent')\n    }, props.children));\n  };\n\n  Popover.prototype.componentDidMount = function () {\n    document.addEventListener('mousedown', this.handleDocumentMousedown);\n    document.addEventListener('scroll', this.handleDocumentScroll);\n    this.updateSize();\n  };\n\n  Popover.prototype.componentWillUnmount = function () {\n    document.removeEventListener('mousedown', this.handleDocumentMousedown);\n    document.removeEventListener('scroll', this.handleDocumentScroll);\n  }; // TODO: adjust on window resize\n\n  /*\n  NOTE: the popover is position:fixed, so coordinates are relative to the viewport\n  NOTE: the PARENT calls this as well, on window resize. we would have wanted to use the repositioner,\n        but need to ensure that all other components have updated size first (for alignmentEl)\n  */\n\n\n  Popover.prototype.updateSize = function () {\n    var _a = this.props,\n        alignmentEl = _a.alignmentEl,\n        topAlignmentEl = _a.topAlignmentEl;\n    var rootEl = this.rootEl;\n\n    if (!rootEl) {\n      return; // not sure why this was null, but we shouldn't let external components call updateSize() anyway\n    }\n\n    var dims = rootEl.getBoundingClientRect(); // only used for width,height\n\n    var alignment = alignmentEl.getBoundingClientRect();\n    var top = topAlignmentEl ? topAlignmentEl.getBoundingClientRect().top : alignment.top;\n    top = Math.min(top, window.innerHeight - dims.height - PADDING_FROM_VIEWPORT);\n    top = Math.max(top, PADDING_FROM_VIEWPORT);\n    var left;\n\n    if (this.context.isRtl) {\n      left = alignment.right - dims.width;\n    } else {\n      left = alignment.left;\n    }\n\n    left = Math.min(left, window.innerWidth - dims.width - PADDING_FROM_VIEWPORT);\n    left = Math.max(left, PADDING_FROM_VIEWPORT);\n    Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"applyStyle\"])(rootEl, {\n      top: top,\n      left: left\n    });\n  };\n\n  return Popover;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"BaseComponent\"]);\n\nvar MorePopover =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__extends\"])(MorePopover, _super);\n\n  function MorePopover() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.handlePopoverEl = function (popoverEl) {\n      _this.popoverEl = popoverEl;\n\n      if (popoverEl) {\n        _this.context.registerInteractiveComponent(_this, {\n          el: popoverEl,\n          useEventCenter: false\n        });\n      } else {\n        _this.context.unregisterInteractiveComponent(_this);\n      }\n    };\n\n    return _this;\n  }\n\n  MorePopover.prototype.render = function () {\n    var _a = this.context,\n        options = _a.options,\n        dateEnv = _a.dateEnv;\n    var props = this.props;\n    var date = props.date,\n        hiddenInstances = props.hiddenInstances,\n        todayRange = props.todayRange,\n        dateProfile = props.dateProfile,\n        selectedInstanceId = props.selectedInstanceId;\n    var title = dateEnv.format(date, options.dayPopoverFormat);\n    return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"DayCellRoot\"], {\n      date: date,\n      dateProfile: dateProfile,\n      todayRange: todayRange,\n      elRef: this.handlePopoverEl\n    }, function (rootElRef, dayClassNames, dataAttrs) {\n      return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(Popover, {\n        elRef: rootElRef,\n        title: title,\n        extraClassNames: ['fc-more-popover'].concat(dayClassNames),\n        extraAttrs: dataAttrs,\n        onClose: props.onCloseClick,\n        alignmentEl: props.alignmentEl,\n        topAlignmentEl: props.topAlignmentEl\n      }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"DayCellContent\"], {\n        date: date,\n        dateProfile: dateProfile,\n        todayRange: todayRange\n      }, function (innerElRef, innerContent) {\n        return innerContent && Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(\"div\", {\n          className: 'fc-more-popover-misc',\n          ref: innerElRef\n        }, innerContent);\n      }), props.segs.map(function (seg) {\n        var instanceId = seg.eventRange.instance.instanceId;\n        return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(\"div\", {\n          className: 'fc-daygrid-event-harness',\n          key: instanceId,\n          style: {\n            visibility: hiddenInstances[instanceId] ? 'hidden' : ''\n          }\n        }, hasListItemDisplay(seg) ? Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(TableListItemEvent, Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__assign\"])({\n          seg: seg,\n          isDragging: false,\n          isSelected: instanceId === selectedInstanceId,\n          defaultDisplayEventEnd: false\n        }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"getSegMeta\"])(seg, todayRange))) : Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(TableBlockEvent, Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__assign\"])({\n          seg: seg,\n          isDragging: false,\n          isResizing: false,\n          isDateSelecting: false,\n          isSelected: instanceId === selectedInstanceId,\n          defaultDisplayEventEnd: false\n        }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"getSegMeta\"])(seg, todayRange))));\n      }));\n    });\n  };\n\n  MorePopover.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {\n    var date = this.props.date;\n\n    if (positionLeft < elWidth && positionTop < elHeight) {\n      return {\n        component: this,\n        dateSpan: {\n          allDay: true,\n          range: {\n            start: date,\n            end: Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"addDays\"])(date, 1)\n          }\n        },\n        dayEl: this.popoverEl,\n        rect: {\n          left: 0,\n          top: 0,\n          right: elWidth,\n          bottom: elHeight\n        },\n        layer: 1\n      };\n    }\n  };\n\n  MorePopover.prototype.isPopover = function () {\n    return true; // gross\n  };\n\n  return MorePopover;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"DateComponent\"]);\n\nvar Table =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__extends\"])(Table, _super);\n\n  function Table() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.splitBusinessHourSegs = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"memoize\"])(splitSegsByRow);\n    _this.splitBgEventSegs = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"memoize\"])(splitSegsByRow);\n    _this.splitFgEventSegs = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"memoize\"])(splitSegsByRow);\n    _this.splitDateSelectionSegs = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"memoize\"])(splitSegsByRow);\n    _this.splitEventDrag = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"memoize\"])(splitInteractionByRow);\n    _this.splitEventResize = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"memoize\"])(splitInteractionByRow);\n    _this.buildBuildMoreLinkText = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"memoize\"])(buildBuildMoreLinkText);\n    _this.rowRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"RefMap\"]();\n    _this.state = {\n      morePopoverState: null\n    };\n\n    _this.handleRootEl = function (rootEl) {\n      _this.rootEl = rootEl;\n      Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"setRef\"])(_this.props.elRef, rootEl);\n    };\n\n    _this.handleMoreLinkClick = function (arg) {\n      var context = _this.context;\n      var dateEnv = context.dateEnv;\n      var clickOption = context.options.moreLinkClick;\n\n      function segForPublic(seg) {\n        var _a = seg.eventRange,\n            def = _a.def,\n            instance = _a.instance,\n            range = _a.range;\n        return {\n          event: new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"EventApi\"](context, def, instance),\n          start: dateEnv.toDate(range.start),\n          end: dateEnv.toDate(range.end),\n          isStart: seg.isStart,\n          isEnd: seg.isEnd\n        };\n      }\n\n      if (typeof clickOption === 'function') {\n        clickOption = clickOption({\n          date: dateEnv.toDate(arg.date),\n          allDay: true,\n          allSegs: arg.allSegs.map(segForPublic),\n          hiddenSegs: arg.hiddenSegs.map(segForPublic),\n          jsEvent: arg.ev,\n          view: context.viewApi\n        }); // hack to handle void\n      }\n\n      if (!clickOption || clickOption === 'popover') {\n        _this.setState({\n          morePopoverState: Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__assign\"])({}, arg), {\n            currentFgEventSegs: _this.props.fgEventSegs\n          })\n        });\n      } else if (typeof clickOption === 'string') {\n        // a view name\n        context.calendarApi.zoomTo(arg.date, clickOption);\n      }\n    };\n\n    _this.handleMorePopoverClose = function () {\n      _this.setState({\n        morePopoverState: null\n      });\n    };\n\n    return _this;\n  }\n\n  Table.prototype.render = function () {\n    var _this = this;\n\n    var props = this.props;\n    var dateProfile = props.dateProfile,\n        dayMaxEventRows = props.dayMaxEventRows,\n        dayMaxEvents = props.dayMaxEvents,\n        expandRows = props.expandRows;\n    var morePopoverState = this.state.morePopoverState;\n    var rowCnt = props.cells.length;\n    var businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);\n    var bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);\n    var fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);\n    var dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);\n    var eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);\n    var eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);\n    var buildMoreLinkText = this.buildBuildMoreLinkText(this.context.options.moreLinkText);\n    var limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true; // if rows can't expand to fill fixed height, can't do balanced-height event limit\n    // TODO: best place to normalize these options?\n\n    if (limitViaBalanced && !expandRows) {\n      limitViaBalanced = false;\n      dayMaxEventRows = null;\n      dayMaxEvents = null;\n    }\n\n    var classNames = ['fc-daygrid-body', limitViaBalanced ? 'fc-daygrid-body-balanced' : 'fc-daygrid-body-unbalanced', expandRows ? '' : 'fc-daygrid-body-natural' // will height of one row depend on the others?\n    ];\n    return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(\"div\", {\n      className: classNames.join(' '),\n      ref: this.handleRootEl,\n      style: {\n        // these props are important to give this wrapper correct dimensions for interactions\n        // TODO: if we set it here, can we avoid giving to inner tables?\n        width: props.clientWidth,\n        minWidth: props.tableMinWidth\n      }\n    }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"NowTimer\"], {\n      unit: 'day'\n    }, function (nowDate, todayRange) {\n      return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"Fragment\"], null, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(\"table\", {\n        className: 'fc-scrollgrid-sync-table',\n        style: {\n          width: props.clientWidth,\n          minWidth: props.tableMinWidth,\n          height: expandRows ? props.clientHeight : ''\n        }\n      }, props.colGroupNode, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(\"tbody\", null, props.cells.map(function (cells, row) {\n        return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(TableRow, {\n          ref: _this.rowRefs.createRef(row),\n          key: cells.length ? cells[0].date.toISOString()\n          /* best? or put key on cell? or use diff formatter? */\n          : row // in case there are no cells (like when resource view is loading)\n          ,\n          showDayNumbers: rowCnt > 1,\n          showWeekNumbers: props.showWeekNumbers,\n          todayRange: todayRange,\n          dateProfile: dateProfile,\n          cells: cells,\n          renderIntro: props.renderRowIntro,\n          businessHourSegs: businessHourSegsByRow[row],\n          eventSelection: props.eventSelection,\n          bgEventSegs: bgEventSegsByRow[row],\n          fgEventSegs: fgEventSegsByRow[row],\n          dateSelectionSegs: dateSelectionSegsByRow[row],\n          eventDrag: eventDragByRow[row],\n          eventResize: eventResizeByRow[row],\n          dayMaxEvents: dayMaxEvents,\n          dayMaxEventRows: dayMaxEventRows,\n          clientWidth: props.clientWidth,\n          clientHeight: props.clientHeight,\n          buildMoreLinkText: buildMoreLinkText,\n          onMoreClick: _this.handleMoreLinkClick\n        });\n      }))), !props.forPrint && morePopoverState && morePopoverState.currentFgEventSegs === props.fgEventSegs && // clear popover on event mod\n      Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(MorePopover, {\n        date: morePopoverState.date,\n        dateProfile: dateProfile,\n        segs: morePopoverState.allSegs,\n        alignmentEl: morePopoverState.dayEl,\n        topAlignmentEl: rowCnt === 1 ? props.headerAlignElRef.current : null,\n        onCloseClick: _this.handleMorePopoverClose,\n        selectedInstanceId: props.eventSelection,\n        hiddenInstances: // yuck\n        (props.eventDrag ? props.eventDrag.affectedInstances : null) || (props.eventResize ? props.eventResize.affectedInstances : null) || {},\n        todayRange: todayRange\n      }));\n    }));\n  }; // Hit System\n  // ----------------------------------------------------------------------------------------------------\n\n\n  Table.prototype.prepareHits = function () {\n    this.rowPositions = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"PositionCache\"](this.rootEl, this.rowRefs.collect().map(function (rowObj) {\n      return rowObj.getCellEls()[0];\n    }), // first cell el in each row. TODO: not optimal\n    false, true // vertical\n    );\n    this.colPositions = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"PositionCache\"](this.rootEl, this.rowRefs.currentMap[0].getCellEls(), // cell els in first row\n    true, // horizontal\n    false);\n  };\n\n  Table.prototype.positionToHit = function (leftPosition, topPosition) {\n    var _a = this,\n        colPositions = _a.colPositions,\n        rowPositions = _a.rowPositions;\n\n    var col = colPositions.leftToIndex(leftPosition);\n    var row = rowPositions.topToIndex(topPosition);\n\n    if (row != null && col != null) {\n      return {\n        row: row,\n        col: col,\n        dateSpan: {\n          range: this.getCellRange(row, col),\n          allDay: true\n        },\n        dayEl: this.getCellEl(row, col),\n        relativeRect: {\n          left: colPositions.lefts[col],\n          right: colPositions.rights[col],\n          top: rowPositions.tops[row],\n          bottom: rowPositions.bottoms[row]\n        }\n      };\n    }\n  };\n\n  Table.prototype.getCellEl = function (row, col) {\n    return this.rowRefs.currentMap[row].getCellEls()[col]; // TODO: not optimal\n  };\n\n  Table.prototype.getCellRange = function (row, col) {\n    var start = this.props.cells[row][col].date;\n    var end = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"addDays\"])(start, 1);\n    return {\n      start: start,\n      end: end\n    };\n  };\n\n  return Table;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"DateComponent\"]);\n\nfunction buildBuildMoreLinkText(moreLinkTextInput) {\n  if (typeof moreLinkTextInput === 'function') {\n    return moreLinkTextInput;\n  } else {\n    return function (num) {\n      return \"+\" + num + \" \" + moreLinkTextInput;\n    };\n  }\n}\n\nvar DayTable =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__extends\"])(DayTable, _super);\n\n  function DayTable() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.slicer = new DayTableSlicer();\n    _this.tableRef = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createRef\"])();\n\n    _this.handleRootEl = function (rootEl) {\n      if (rootEl) {\n        _this.context.registerInteractiveComponent(_this, {\n          el: rootEl\n        });\n      } else {\n        _this.context.unregisterInteractiveComponent(_this);\n      }\n    };\n\n    return _this;\n  }\n\n  DayTable.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(Table, Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__assign\"])({\n      ref: this.tableRef,\n      elRef: this.handleRootEl\n    }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), {\n      dateProfile: props.dateProfile,\n      cells: props.dayTableModel.cells,\n      colGroupNode: props.colGroupNode,\n      tableMinWidth: props.tableMinWidth,\n      renderRowIntro: props.renderRowIntro,\n      dayMaxEvents: props.dayMaxEvents,\n      dayMaxEventRows: props.dayMaxEventRows,\n      showWeekNumbers: props.showWeekNumbers,\n      expandRows: props.expandRows,\n      headerAlignElRef: props.headerAlignElRef,\n      clientWidth: props.clientWidth,\n      clientHeight: props.clientHeight,\n      forPrint: props.forPrint\n    }));\n  };\n\n  DayTable.prototype.prepareHits = function () {\n    this.tableRef.current.prepareHits();\n  };\n\n  DayTable.prototype.queryHit = function (positionLeft, positionTop) {\n    var rawHit = this.tableRef.current.positionToHit(positionLeft, positionTop);\n\n    if (rawHit) {\n      return {\n        component: this,\n        dateSpan: rawHit.dateSpan,\n        dayEl: rawHit.dayEl,\n        rect: {\n          left: rawHit.relativeRect.left,\n          right: rawHit.relativeRect.right,\n          top: rawHit.relativeRect.top,\n          bottom: rawHit.relativeRect.bottom\n        },\n        layer: 0\n      };\n    }\n  };\n\n  return DayTable;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"DateComponent\"]);\n\nvar DayTableSlicer =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__extends\"])(DayTableSlicer, _super);\n\n  function DayTableSlicer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.forceDayIfListItem = true;\n    return _this;\n  }\n\n  DayTableSlicer.prototype.sliceRange = function (dateRange, dayTableModel) {\n    return dayTableModel.sliceRange(dateRange);\n  };\n\n  return DayTableSlicer;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"Slicer\"]);\n\nvar DayTableView =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__extends\"])(DayTableView, _super);\n\n  function DayTableView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.buildDayTableModel = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"memoize\"])(buildDayTableModel);\n    _this.headerRef = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createRef\"])();\n    _this.tableRef = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createRef\"])();\n    return _this;\n  }\n\n  DayTableView.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.context,\n        options = _a.options,\n        dateProfileGenerator = _a.dateProfileGenerator;\n    var props = this.props;\n    var dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);\n    var headerContent = options.dayHeaders && Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"DayHeader\"], {\n      ref: this.headerRef,\n      dateProfile: props.dateProfile,\n      dates: dayTableModel.headerDates,\n      datesRepDistinctDays: dayTableModel.rowCnt === 1\n    });\n\n    var bodyContent = function bodyContent(contentArg) {\n      return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(DayTable, {\n        ref: _this.tableRef,\n        dateProfile: props.dateProfile,\n        dayTableModel: dayTableModel,\n        businessHours: props.businessHours,\n        dateSelection: props.dateSelection,\n        eventStore: props.eventStore,\n        eventUiBases: props.eventUiBases,\n        eventSelection: props.eventSelection,\n        eventDrag: props.eventDrag,\n        eventResize: props.eventResize,\n        nextDayThreshold: options.nextDayThreshold,\n        colGroupNode: contentArg.tableColGroupNode,\n        tableMinWidth: contentArg.tableMinWidth,\n        dayMaxEvents: options.dayMaxEvents,\n        dayMaxEventRows: options.dayMaxEventRows,\n        showWeekNumbers: options.weekNumbers,\n        expandRows: !props.isHeightAuto,\n        headerAlignElRef: _this.headerElRef,\n        clientWidth: contentArg.clientWidth,\n        clientHeight: contentArg.clientHeight,\n        forPrint: props.forPrint\n      });\n    };\n\n    return options.dayMinWidth ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth) : this.renderSimpleLayout(headerContent, bodyContent);\n  };\n\n  return DayTableView;\n}(TableView);\n\nfunction buildDayTableModel(dateProfile, dateProfileGenerator) {\n  var daySeries = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"DaySeriesModel\"](dateProfile.renderRange, dateProfileGenerator);\n  return new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"DayTableModel\"](daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));\n}\n\nvar TableDateProfileGenerator =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_2__[\"__extends\"])(TableDateProfileGenerator, _super);\n\n  function TableDateProfileGenerator() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  } // Computes the date range that will be rendered.\n\n\n  TableDateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {\n    var dateEnv = this.props.dateEnv;\n\n    var renderRange = _super.prototype.buildRenderRange.call(this, currentRange, currentRangeUnit, isRangeAllDay);\n\n    var start = renderRange.start;\n    var end = renderRange.end;\n    var endOfWeek; // year and month views should be aligned with weeks. this is already done for week\n\n    if (/^(year|month)$/.test(currentRangeUnit)) {\n      start = dateEnv.startOfWeek(start); // make end-of-week if not already\n\n      endOfWeek = dateEnv.startOfWeek(end);\n\n      if (endOfWeek.valueOf() !== end.valueOf()) {\n        end = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"addWeeks\"])(endOfWeek, 1);\n      }\n    } // ensure 6 weeks\n\n\n    if (this.props.monthMode && this.props.fixedWeekCount) {\n      var rowCnt = Math.ceil( // could be partial weeks due to hiddenDays\n      Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"diffWeeks\"])(start, end));\n      end = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"addWeeks\"])(end, 6 - rowCnt);\n    }\n\n    return {\n      start: start,\n      end: end\n    };\n  };\n\n  return TableDateProfileGenerator;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"DateProfileGenerator\"]);\n\nvar OPTION_REFINERS = {\n  moreLinkClick: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"identity\"],\n  moreLinkClassNames: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"identity\"],\n  moreLinkContent: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"identity\"],\n  moreLinkDidMount: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"identity\"],\n  moreLinkWillUnmount: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"identity\"]\n};\nvar main = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__[\"createPlugin\"])({\n  initialView: 'dayGridMonth',\n  optionRefiners: OPTION_REFINERS,\n  views: {\n    dayGrid: {\n      component: DayTableView,\n      dateProfileGeneratorClass: TableDateProfileGenerator\n    },\n    dayGridDay: {\n      type: 'dayGrid',\n      duration: {\n        days: 1\n      }\n    },\n    dayGridWeek: {\n      type: 'dayGrid',\n      duration: {\n        weeks: 1\n      }\n    },\n    dayGridMonth: {\n      type: 'dayGrid',\n      duration: {\n        months: 1\n      },\n      monthMode: true,\n      fixedWeekCount: true\n    }\n  }\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (main);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9kYXlncmlkL21haW4uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL1RhYmxlVmlldy50c3g/YzY0MCIsIndlYnBhY2s6Ly8vc3JjL1RhYmxlU2VnLnRzP2UzYzkiLCJ3ZWJwYWNrOi8vL3NyYy9UYWJsZUNlbGwudHN4PzE0M2MiLCJ3ZWJwYWNrOi8vL3NyYy9ldmVudC1yZW5kZXJpbmcudHM/YmNiYSIsIndlYnBhY2s6Ly8vc3JjL1RhYmxlTGlzdEl0ZW1FdmVudC50c3g/MGUyZCIsIndlYnBhY2s6Ly8vc3JjL1RhYmxlQmxvY2tFdmVudC50c3g/MzIwZiIsIndlYnBhY2s6Ly8vc3JjL2V2ZW50LXBsYWNlbWVudC50cz82OTU3Iiwid2VicGFjazovLy9zcmMvVGFibGVSb3cudHN4Pzk0NmMiLCJ3ZWJwYWNrOi8vL3NyYy9Qb3BvdmVyLnRzeD85NzlkIiwid2VicGFjazovLy9zcmMvTW9yZVBvcG92ZXIudHN4PzJmOWYiLCJ3ZWJwYWNrOi8vL3NyYy9UYWJsZS50c3g/NTQxNyIsIndlYnBhY2s6Ly8vc3JjL0RheVRhYmxlLnRzeD8yODQ2Iiwid2VicGFjazovLy9zcmMvRGF5VGFibGVWaWV3LnRzeD83NjY5Iiwid2VicGFjazovLy9zcmMvVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvci50cz9jZGRiIiwid2VicGFjazovLy9zcmMvb3B0aW9ucy50cz85MTgxIiwid2VicGFjazovLy9zcmMvbWFpbi50cz9iOTljIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIFZOb2RlLCBjcmVhdGVFbGVtZW50LFxuICBTaW1wbGVTY3JvbGxHcmlkLFxuICBTaW1wbGVTY3JvbGxHcmlkU2VjdGlvbixcbiAgQ2h1bmtDb250ZW50Q2FsbGJhY2tBcmdzLFxuICBjcmVhdGVSZWYsXG4gIFNjcm9sbEdyaWRTZWN0aW9uQ29uZmlnLFxuICBWaWV3Um9vdCxcbiAgRGF0ZUNvbXBvbmVudCxcbiAgVmlld1Byb3BzLFxuICBSZWZPYmplY3QsXG4gIHJlbmRlclNjcm9sbFNoaW0sXG4gIGdldFN0aWNreUhlYWRlckRhdGVzLFxuICBnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIsXG4gIENodW5rQ29uZmlnUm93Q29udGVudCxcbiAgRGljdGlvbmFyeVxufSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcblxuXG4vKiBBbiBhYnN0cmFjdCBjbGFzcyBmb3IgdGhlIGRheWdyaWQgdmlld3MsIGFzIHdlbGwgYXMgbW9udGggdmlldy4gUmVuZGVycyBvbmUgb3IgbW9yZSByb3dzIG9mIGRheSBjZWxscy5cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLy8gSXQgaXMgYSBtYW5hZ2VyIGZvciBhIFRhYmxlIHN1YmNvbXBvbmVudCwgd2hpY2ggZG9lcyBtb3N0IG9mIHRoZSBoZWF2eSBsaWZ0aW5nLlxuLy8gSXQgaXMgcmVzcG9uc2libGUgZm9yIG1hbmFnaW5nIHdpZHRoL2hlaWdodC5cblxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVGFibGVWaWV3PFN0YXRlPURpY3Rpb25hcnk+IGV4dGVuZHMgRGF0ZUNvbXBvbmVudDxWaWV3UHJvcHMsIFN0YXRlPiB7XG5cbiAgcHJvdGVjdGVkIGhlYWRlckVsUmVmOiBSZWZPYmplY3Q8SFRNTFRhYmxlQ2VsbEVsZW1lbnQ+ID0gY3JlYXRlUmVmPEhUTUxUYWJsZUNlbGxFbGVtZW50PigpXG5cblxuICByZW5kZXJTaW1wbGVMYXlvdXQoXG4gICAgaGVhZGVyUm93Q29udGVudDogQ2h1bmtDb25maWdSb3dDb250ZW50LFxuICAgIGJvZHlDb250ZW50OiAoY29udGVudEFyZzogQ2h1bmtDb250ZW50Q2FsbGJhY2tBcmdzKSA9PiBWTm9kZVxuICApIHtcbiAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpc1xuICAgIGxldCBzZWN0aW9uczogU2ltcGxlU2Nyb2xsR3JpZFNlY3Rpb25bXSA9IFtdXG4gICAgbGV0IHN0aWNreUhlYWRlckRhdGVzID0gZ2V0U3RpY2t5SGVhZGVyRGF0ZXMoY29udGV4dC5vcHRpb25zKVxuXG4gICAgaWYgKGhlYWRlclJvd0NvbnRlbnQpIHtcbiAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICB0eXBlOiAnaGVhZGVyJyxcbiAgICAgICAga2V5OiAnaGVhZGVyJyxcbiAgICAgICAgaXNTdGlja3k6IHN0aWNreUhlYWRlckRhdGVzLFxuICAgICAgICBjaHVuazoge1xuICAgICAgICAgIGVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLFxuICAgICAgICAgIHRhYmxlQ2xhc3NOYW1lOiAnZmMtY29sLWhlYWRlcicsXG4gICAgICAgICAgcm93Q29udGVudDogaGVhZGVyUm93Q29udGVudFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgdHlwZTogJ2JvZHknLFxuICAgICAga2V5OiAnYm9keScsXG4gICAgICBsaXF1aWQ6IHRydWUsXG4gICAgICBjaHVuazogeyBjb250ZW50OiBib2R5Q29udGVudCB9XG4gICAgfSlcblxuICAgIHJldHVybiAoXG4gICAgICA8Vmlld1Jvb3Qgdmlld1NwZWM9e2NvbnRleHQudmlld1NwZWN9PlxuICAgICAgICB7KHJvb3RFbFJlZiwgY2xhc3NOYW1lcykgPT4gKFxuICAgICAgICAgIDxkaXYgcmVmPXtyb290RWxSZWZ9IGNsYXNzTmFtZT17WyAnZmMtZGF5Z3JpZCcgXS5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpfT5cbiAgICAgICAgICAgIDxTaW1wbGVTY3JvbGxHcmlkXG4gICAgICAgICAgICAgIGxpcXVpZD17IXByb3BzLmlzSGVpZ2h0QXV0byAmJiAhcHJvcHMuZm9yUHJpbnR9XG4gICAgICAgICAgICAgIGNvbHM9e1tdIC8qIFRPRE86IG1ha2Ugb3B0aW9uYWw/ICovfVxuICAgICAgICAgICAgICBzZWN0aW9ucz17c2VjdGlvbnN9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApfVxuICAgICAgPC9WaWV3Um9vdD5cbiAgICApXG4gIH1cblxuXG4gIHJlbmRlckhTY3JvbGxMYXlvdXQoXG4gICAgaGVhZGVyUm93Q29udGVudDogQ2h1bmtDb25maWdSb3dDb250ZW50LFxuICAgIGJvZHlDb250ZW50OiAoY29udGVudEFyZzogQ2h1bmtDb250ZW50Q2FsbGJhY2tBcmdzKSA9PiBWTm9kZSxcbiAgICBjb2xDbnQ6IG51bWJlcixcbiAgICBkYXlNaW5XaWR0aDogbnVtYmVyXG4gICkge1xuICAgIGxldCBTY3JvbGxHcmlkID0gdGhpcy5jb250ZXh0LnBsdWdpbkhvb2tzLnNjcm9sbEdyaWRJbXBsXG5cbiAgICBpZiAoIVNjcm9sbEdyaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gU2Nyb2xsR3JpZCBpbXBsZW1lbnRhdGlvbicpXG4gICAgfVxuXG4gICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXNcbiAgICBsZXQgc3RpY2t5SGVhZGVyRGF0ZXMgPSAhcHJvcHMuZm9yUHJpbnQgJiYgZ2V0U3RpY2t5SGVhZGVyRGF0ZXMoY29udGV4dC5vcHRpb25zKVxuICAgIGxldCBzdGlja3lGb290ZXJTY3JvbGxiYXIgPSAhcHJvcHMuZm9yUHJpbnQgJiYgZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKGNvbnRleHQub3B0aW9ucylcbiAgICBsZXQgc2VjdGlvbnM6IFNjcm9sbEdyaWRTZWN0aW9uQ29uZmlnW10gPSBbXVxuXG4gICAgaWYgKGhlYWRlclJvd0NvbnRlbnQpIHtcbiAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICB0eXBlOiAnaGVhZGVyJyxcbiAgICAgICAga2V5OiAnaGVhZGVyJyxcbiAgICAgICAgaXNTdGlja3k6IHN0aWNreUhlYWRlckRhdGVzLFxuICAgICAgICBjaHVua3M6IFt7XG4gICAgICAgICAga2V5OiAnbWFpbicsXG4gICAgICAgICAgZWxSZWY6IHRoaXMuaGVhZGVyRWxSZWYsXG4gICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcbiAgICAgICAgICByb3dDb250ZW50OiBoZWFkZXJSb3dDb250ZW50XG4gICAgICAgIH1dXG4gICAgICB9KVxuICAgIH1cblxuICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgdHlwZTogJ2JvZHknLFxuICAgICAga2V5OiAnYm9keScsXG4gICAgICBsaXF1aWQ6IHRydWUsXG4gICAgICBjaHVua3M6IFt7XG4gICAgICAgIGtleTogJ21haW4nLFxuICAgICAgICBjb250ZW50OiBib2R5Q29udGVudFxuICAgICAgfV1cbiAgICB9KVxuXG4gICAgaWYgKHN0aWNreUZvb3RlclNjcm9sbGJhcikge1xuICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdmb290ZXInLFxuICAgICAgICBrZXk6ICdmb290ZXInLFxuICAgICAgICBpc1N0aWNreTogdHJ1ZSxcbiAgICAgICAgY2h1bmtzOiBbe1xuICAgICAgICAgIGtleTogJ21haW4nLFxuICAgICAgICAgIGNvbnRlbnQ6IHJlbmRlclNjcm9sbFNoaW1cbiAgICAgICAgfV1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxWaWV3Um9vdCB2aWV3U3BlYz17Y29udGV4dC52aWV3U3BlY30+XG4gICAgICAgIHsocm9vdEVsUmVmLCBjbGFzc05hbWVzKSA9PiAoXG4gICAgICAgICAgPGRpdiByZWY9e3Jvb3RFbFJlZn0gY2xhc3NOYW1lPXtbICdmYy1kYXlncmlkJyBdLmNvbmNhdChjbGFzc05hbWVzKS5qb2luKCcgJyl9PlxuICAgICAgICAgICAgPFNjcm9sbEdyaWRcbiAgICAgICAgICAgICAgbGlxdWlkPXshcHJvcHMuaXNIZWlnaHRBdXRvICYmICFwcm9wcy5mb3JQcmludH1cbiAgICAgICAgICAgICAgY29sR3JvdXBzPXtbIHsgY29sczogWyB7IHNwYW46IGNvbENudCwgbWluV2lkdGg6IGRheU1pbldpZHRoIH0gXSB9IF19XG4gICAgICAgICAgICAgIHNlY3Rpb25zPXtzZWN0aW9uc31cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG4gICAgICA8L1ZpZXdSb290PlxuICAgIClcbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBFdmVudFNlZ1VpSW50ZXJhY3Rpb25TdGF0ZSwgU2VnIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5cblxuLy8gdGhpcyBpcyBhIERBVEEgU1RSVUNUVVJFLCBub3QgYSBjb21wb25lbnRcblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZVNlZyBleHRlbmRzIFNlZyB7XG4gIHJvdzogbnVtYmVyXG4gIGZpcnN0Q29sOiBudW1iZXJcbiAgbGFzdENvbDogbnVtYmVyXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0U2Vnc0J5Um93KHNlZ3M6IFRhYmxlU2VnW10sIHJvd0NudDogbnVtYmVyKSB7XG4gIGxldCBieVJvdzogVGFibGVTZWdbXVtdID0gW11cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd0NudDsgaSsrKSB7XG4gICAgYnlSb3dbaV0gPSBbXVxuICB9XG5cbiAgZm9yIChsZXQgc2VnIG9mIHNlZ3MpIHtcbiAgICBieVJvd1tzZWcucm93XS5wdXNoKHNlZylcbiAgfVxuXG4gIHJldHVybiBieVJvd1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdFNlZ3NCeUZpcnN0Q29sKHNlZ3M6IFRhYmxlU2VnW10sIGNvbENudDogbnVtYmVyKSB7XG4gIGxldCBieUNvbDogVGFibGVTZWdbXVtdID0gW11cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbENudDsgaSsrKSB7XG4gICAgYnlDb2xbaV0gPSBbXVxuICB9XG5cbiAgZm9yIChsZXQgc2VnIG9mIHNlZ3MpIHtcbiAgICBieUNvbFtzZWcuZmlyc3RDb2xdLnB1c2goc2VnKVxuICB9XG5cbiAgcmV0dXJuIGJ5Q29sXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0SW50ZXJhY3Rpb25CeVJvdyh1aTogRXZlbnRTZWdVaUludGVyYWN0aW9uU3RhdGUgfCBudWxsLCByb3dDbnQ6IG51bWJlcikge1xuICBsZXQgYnlSb3c6IEV2ZW50U2VnVWlJbnRlcmFjdGlvblN0YXRlW10gPSBbXVxuXG4gIGlmICghdWkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd0NudDsgaSsrKSB7XG4gICAgICBieVJvd1tpXSA9IG51bGxcbiAgICB9XG5cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd0NudDsgaSsrKSB7XG4gICAgICBieVJvd1tpXSA9IHtcbiAgICAgICAgYWZmZWN0ZWRJbnN0YW5jZXM6IHVpLmFmZmVjdGVkSW5zdGFuY2VzLFxuICAgICAgICBpc0V2ZW50OiB1aS5pc0V2ZW50LFxuICAgICAgICBzZWdzOiBbXVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IHNlZyBvZiB1aS5zZWdzKSB7XG4gICAgICBieVJvd1tzZWcucm93XS5zZWdzLnB1c2goc2VnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieVJvd1xufVxuIiwiaW1wb3J0IHtcbiAgUmVmLFxuICBDb21wb25lbnRDaGlsZHJlbixcbiAgY3JlYXRlRWxlbWVudCxcbiAgRGF0ZU1hcmtlcixcbiAgRGF0ZUNvbXBvbmVudCxcbiAgQ3NzRGltVmFsdWUsXG4gIERhdGVSYW5nZSxcbiAgYnVpbGROYXZMaW5rRGF0YSxcbiAgRGF5Q2VsbENvbnRlbnRBcmcsXG4gIFJlbmRlckhvb2ssXG4gIFdlZWtOdW1iZXJSb290LFxuICBEYXlDZWxsUm9vdCxcbiAgRGF5Q2VsbENvbnRlbnQsXG4gIEJhc2VDb21wb25lbnQsXG4gIERhdGVQcm9maWxlLFxuICBWVUlFdmVudCxcbiAgc2V0UmVmLFxuICBjcmVhdGVGb3JtYXR0ZXIsXG4gIFZpZXdBcGksXG4gIERpY3Rpb25hcnksXG4gIE1vdW50QXJnLFxufSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcbmltcG9ydCB7IFRhYmxlU2VnIH0gZnJvbSAnLi9UYWJsZVNlZydcblxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlQ2VsbFByb3BzIHtcbiAgZGF0ZTogRGF0ZU1hcmtlclxuICBkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGVcbiAgZXh0cmFIb29rUHJvcHM/OiBEaWN0aW9uYXJ5XG4gIGV4dHJhRGF0YUF0dHJzPzogRGljdGlvbmFyeVxuICBleHRyYUNsYXNzTmFtZXM/OiBzdHJpbmdbXVxuICBlbFJlZj86IFJlZjxIVE1MVGFibGVDZWxsRWxlbWVudD5cbiAgaW5uZXJFbFJlZj86IFJlZjxIVE1MRGl2RWxlbWVudD5cbiAgYmdDb250ZW50OiBDb21wb25lbnRDaGlsZHJlblxuICBmZ0NvbnRlbnRFbFJlZj86IFJlZjxIVE1MRGl2RWxlbWVudD4gLy8gVE9ETzogcmVuYW1lISEhIGNsYXNzbmFtZSBjb25mdXNpb24uIGlzIHRoZSBcImV2ZW50XCIgZGl2XG4gIGZnQ29udGVudDogQ29tcG9uZW50Q2hpbGRyZW5cbiAgZmdQYWRkaW5nQm90dG9tOiBDc3NEaW1WYWx1ZVxuICAvLyBoYXNFdmVudHM6IGJvb2xlYW4gLy8gVE9ETzogd2hlbiByZXZpdmluZywgZXZlbnQgc2hvdWxkIFwiaGF2ZSBldmVudHNcIiBldmVuIHdoZW4gbm9uZSAqc3RhcnQqIG9uIHRoZSBjZWxsXG4gIG1vcmVDbnQ6IG51bWJlclxuICBtb3JlTWFyZ2luVG9wOiBudW1iZXJcbiAgc2hvd0RheU51bWJlcjogYm9vbGVhblxuICBzaG93V2Vla051bWJlcjogYm9vbGVhblxuICB0b2RheVJhbmdlOiBEYXRlUmFuZ2VcbiAgYnVpbGRNb3JlTGlua1RleHQ6IChudW06IG51bWJlcikgPT4gc3RyaW5nXG4gIG9uTW9yZUNsaWNrPzogKGFyZzogTW9yZUxpbmtBcmcpID0+IHZvaWRcbiAgc2Vnc0J5RWFjaENvbDogVGFibGVTZWdbXSAvLyBmb3IgbW9yZS1wb3BvdmVyLiBpbmNsdWRlcyBzZWdzIHRoYXQgYXJlbid0IHJvb3RlZCBpbiB0aGlzIGNlbGwgYnV0IHRoYXQgcGFzcyBvdmVyIGl0XG4gIHNlZ0lzSGlkZGVuOiB7IFtpbnN0YW5jZUlkOiBzdHJpbmddOiBib29sZWFuIH0gLy8gZm9yIG1vcmUtcG9wb3Zlci4gVE9ETzogcmVuYW1lIHRvIGJlIGFib3V0IHNlbGVjdGVkIGluc3RhbmNlc1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlQ2VsbE1vZGVsIHsgLy8gVE9ETzogbW92ZSBzb21ld2hlcmUgZWxzZS4gY29tYmluZSB3aXRoIERheVRhYmxlQ2VsbD9cbiAga2V5OiBzdHJpbmdcbiAgZGF0ZTogRGF0ZU1hcmtlclxuICBleHRyYUhvb2tQcm9wcz86IERpY3Rpb25hcnlcbiAgZXh0cmFEYXRhQXR0cnM/OiBEaWN0aW9uYXJ5XG4gIGV4dHJhQ2xhc3NOYW1lcz86IHN0cmluZ1tdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9yZUxpbmtBcmcge1xuICBkYXRlOiBEYXRlTWFya2VyXG4gIGFsbFNlZ3M6IFRhYmxlU2VnW11cbiAgaGlkZGVuU2VnczogVGFibGVTZWdbXVxuICBtb3JlQ250OiBudW1iZXJcbiAgZGF5RWw6IEhUTUxFbGVtZW50XG4gIGV2OiBWVUlFdmVudFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhvb2tQcm9wcyB7XG4gIGRhdGU6IERhdGVcbiAgaXNQYXN0OiBib29sZWFuXG4gIGlzRnV0dXJlOiBib29sZWFuXG4gIGlzVG9kYXk6IGJvb2xlYW5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBNb3JlTGlua0NvbnRlbnRBcmcge1xuICBudW06IG51bWJlclxuICB0ZXh0OiBzdHJpbmdcbiAgdmlldzogVmlld0FwaVxufVxuXG5leHBvcnQgdHlwZSBNb3JlTGlua01vdW50QXJnID0gTW91bnRBcmc8TW9yZUxpbmtDb250ZW50QXJnPlxuXG5jb25zdCBERUZBVUxUX1dFRUtfTlVNX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7IHdlZWs6ICduYXJyb3cnIH0pXG5cblxuZXhwb3J0IGNsYXNzIFRhYmxlQ2VsbCBleHRlbmRzIERhdGVDb21wb25lbnQ8VGFibGVDZWxsUHJvcHM+IHtcblxuICBwcml2YXRlIHJvb3RFbDogSFRNTEVsZW1lbnRcblxuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBvcHRpb25zLCB2aWV3QXBpIH0gPSB0aGlzLmNvbnRleHRcbiAgICBsZXQgeyBwcm9wcyB9ID0gdGhpc1xuICAgIGxldCB7IGRhdGUsIGRhdGVQcm9maWxlIH0gPSBwcm9wc1xuXG4gICAgbGV0IGhvb2tQcm9wczogTW9yZUxpbmtDb250ZW50QXJnID0ge1xuICAgICAgbnVtOiBwcm9wcy5tb3JlQ250LFxuICAgICAgdGV4dDogcHJvcHMuYnVpbGRNb3JlTGlua1RleHQocHJvcHMubW9yZUNudCksXG4gICAgICB2aWV3OiB2aWV3QXBpXG4gICAgfVxuXG4gICAgbGV0IG5hdkxpbmtBdHRycyA9IG9wdGlvbnMubmF2TGlua3NcbiAgICAgID8geyAnZGF0YS1uYXZsaW5rJzogYnVpbGROYXZMaW5rRGF0YShkYXRlLCAnd2VlaycpLCB0YWJJbmRleDogMCB9XG4gICAgICA6IHt9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPERheUNlbGxSb290XG4gICAgICAgIGRhdGU9e2RhdGV9XG4gICAgICAgIGRhdGVQcm9maWxlPXtkYXRlUHJvZmlsZX1cbiAgICAgICAgdG9kYXlSYW5nZT17cHJvcHMudG9kYXlSYW5nZX1cbiAgICAgICAgc2hvd0RheU51bWJlcj17cHJvcHMuc2hvd0RheU51bWJlcn1cbiAgICAgICAgZXh0cmFIb29rUHJvcHM9e3Byb3BzLmV4dHJhSG9va1Byb3BzfVxuICAgICAgICBlbFJlZj17dGhpcy5oYW5kbGVSb290RWx9XG4gICAgICA+XG4gICAgICAgIHsocm9vdEVsUmVmLCBjbGFzc05hbWVzLCByb290RGF0YUF0dHJzLCBpc0Rpc2FibGVkKSA9PiAoXG4gICAgICAgICAgPHRkXG4gICAgICAgICAgICByZWY9e3Jvb3RFbFJlZn1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17WyAnZmMtZGF5Z3JpZC1kYXknIF0uY29uY2F0KGNsYXNzTmFtZXMsIHByb3BzLmV4dHJhQ2xhc3NOYW1lcyB8fCBbXSkuam9pbignICcpfVxuICAgICAgICAgICAgey4uLnJvb3REYXRhQXR0cnN9XG4gICAgICAgICAgICB7Li4ucHJvcHMuZXh0cmFEYXRhQXR0cnN9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2ZjLWRheWdyaWQtZGF5LWZyYW1lIGZjLXNjcm9sbGdyaWQtc3luYy1pbm5lcicgcmVmPXtwcm9wcy5pbm5lckVsUmVmIC8qIGRpZmZlcmVudCBmcm9tIGhvb2sgc3lzdGVtISBSRU5BTUUgKi99PlxuICAgICAgICAgICAgICB7cHJvcHMuc2hvd1dlZWtOdW1iZXIgJiZcbiAgICAgICAgICAgICAgICA8V2Vla051bWJlclJvb3QgZGF0ZT17ZGF0ZX0gZGVmYXVsdEZvcm1hdD17REVGQVVMVF9XRUVLX05VTV9GT1JNQVR9PlxuICAgICAgICAgICAgICAgICAgeyhyb290RWxSZWYsIGNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgPT4gKFxuICAgICAgICAgICAgICAgICAgICA8YVxuICAgICAgICAgICAgICAgICAgICAgIHJlZj17cm9vdEVsUmVmfVxuICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17WyAnZmMtZGF5Z3JpZC13ZWVrLW51bWJlcicgXS5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpfVxuICAgICAgICAgICAgICAgICAgICAgIHsuLi5uYXZMaW5rQXR0cnN9XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICB7aW5uZXJDb250ZW50fVxuICAgICAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgIDwvV2Vla051bWJlclJvb3Q+XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgeyFpc0Rpc2FibGVkICYmXG4gICAgICAgICAgICAgICAgPFRhYmxlQ2VsbFRvcFxuICAgICAgICAgICAgICAgICAgZGF0ZT17ZGF0ZX1cbiAgICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlPXtkYXRlUHJvZmlsZX1cbiAgICAgICAgICAgICAgICAgIHNob3dEYXlOdW1iZXI9e3Byb3BzLnNob3dEYXlOdW1iZXJ9XG4gICAgICAgICAgICAgICAgICB0b2RheVJhbmdlPXtwcm9wcy50b2RheVJhbmdlfVxuICAgICAgICAgICAgICAgICAgZXh0cmFIb29rUHJvcHM9e3Byb3BzLmV4dHJhSG9va1Byb3BzfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT0nZmMtZGF5Z3JpZC1kYXktZXZlbnRzJ1xuICAgICAgICAgICAgICAgIHJlZj17cHJvcHMuZmdDb250ZW50RWxSZWZ9XG4gICAgICAgICAgICAgICAgc3R5bGU9e3sgcGFkZGluZ0JvdHRvbTogcHJvcHMuZmdQYWRkaW5nQm90dG9tIH19XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7cHJvcHMuZmdDb250ZW50fVxuICAgICAgICAgICAgICAgIHtCb29sZWFuKHByb3BzLm1vcmVDbnQpICYmXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nZmMtZGF5Z3JpZC1kYXktYm90dG9tJyBzdHlsZT17eyBtYXJnaW5Ub3A6IHByb3BzLm1vcmVNYXJnaW5Ub3AgfX0+XG4gICAgICAgICAgICAgICAgICAgIDxSZW5kZXJIb29rPE1vcmVMaW5rQ29udGVudEFyZz4gLy8gbmVlZGVkP1xuICAgICAgICAgICAgICAgICAgICAgIGhvb2tQcm9wcz17aG9va1Byb3BzfVxuICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXM9e29wdGlvbnMubW9yZUxpbmtDbGFzc05hbWVzfVxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ9e29wdGlvbnMubW9yZUxpbmtDb250ZW50fVxuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDb250ZW50PXtyZW5kZXJNb3JlTGlua0lubmVyfVxuICAgICAgICAgICAgICAgICAgICAgIGRpZE1vdW50PXtvcHRpb25zLm1vcmVMaW5rRGlkTW91bnR9XG4gICAgICAgICAgICAgICAgICAgICAgd2lsbFVubW91bnQ9e29wdGlvbnMubW9yZUxpbmtXaWxsVW5tb3VudH1cbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgIHsocm9vdEVsUmVmLCBjbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpID0+IChcbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIG9uQ2xpY2s9e3RoaXMuaGFuZGxlTW9yZUxpbmtDbGlja30gcmVmPXtyb290RWxSZWZ9IGNsYXNzTmFtZT17WyAnZmMtZGF5Z3JpZC1tb3JlLWxpbmsnIF0uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHtpbm5lckNvbnRlbnR9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgPC9SZW5kZXJIb29rPlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2ZjLWRheWdyaWQtZGF5LWJnJz5cbiAgICAgICAgICAgICAgICB7cHJvcHMuYmdDb250ZW50fVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvdGQ+XG4gICAgICAgICl9XG4gICAgICA8L0RheUNlbGxSb290PlxuICAgIClcbiAgfVxuXG5cbiAgaGFuZGxlUm9vdEVsID0gKGVsOiBIVE1MRWxlbWVudCkgPT4ge1xuICAgIHRoaXMucm9vdEVsID0gZWxcblxuICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBlbClcbiAgfVxuXG5cbiAgaGFuZGxlTW9yZUxpbmtDbGljayA9IChldjogVlVJRXZlbnQpID0+IHtcbiAgICBsZXQgeyBwcm9wcyB9ID0gdGhpc1xuXG4gICAgaWYgKHByb3BzLm9uTW9yZUNsaWNrKSB7XG4gICAgICBsZXQgYWxsU2VncyA9IHByb3BzLnNlZ3NCeUVhY2hDb2xcbiAgICAgIGxldCBoaWRkZW5TZWdzID0gYWxsU2Vncy5maWx0ZXIoXG4gICAgICAgIChzZWc6IFRhYmxlU2VnKSA9PiBwcm9wcy5zZWdJc0hpZGRlbltzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkXVxuICAgICAgKVxuXG4gICAgICBwcm9wcy5vbk1vcmVDbGljayh7XG4gICAgICAgIGRhdGU6IHByb3BzLmRhdGUsXG4gICAgICAgIGFsbFNlZ3MsXG4gICAgICAgIGhpZGRlblNlZ3MsXG4gICAgICAgIG1vcmVDbnQ6IHByb3BzLm1vcmVDbnQsXG4gICAgICAgIGRheUVsOiB0aGlzLnJvb3RFbCxcbiAgICAgICAgZXZcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbn1cblxuXG5mdW5jdGlvbiByZW5kZXJUb3BJbm5lcihwcm9wczogRGF5Q2VsbENvbnRlbnRBcmcpIHtcbiAgcmV0dXJuIHByb3BzLmRheU51bWJlclRleHRcbn1cblxuXG5mdW5jdGlvbiByZW5kZXJNb3JlTGlua0lubmVyKHByb3BzKSB7XG4gIHJldHVybiBwcm9wcy50ZXh0XG59XG5cblxuaW50ZXJmYWNlIFRhYmxlQ2VsbFRvcFByb3BzIHtcbiAgZGF0ZTogRGF0ZU1hcmtlclxuICBkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGVcbiAgc2hvd0RheU51bWJlcjogYm9vbGVhblxuICB0b2RheVJhbmdlOiBEYXRlUmFuZ2VcbiAgZXh0cmFIb29rUHJvcHM/OiBEaWN0aW9uYXJ5XG59XG5cbmNsYXNzIFRhYmxlQ2VsbFRvcCBleHRlbmRzIEJhc2VDb21wb25lbnQ8VGFibGVDZWxsVG9wUHJvcHM+IHtcblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcblxuICAgIGxldCBuYXZMaW5rQXR0cnMgPSB0aGlzLmNvbnRleHQub3B0aW9ucy5uYXZMaW5rc1xuICAgICAgPyB7ICdkYXRhLW5hdmxpbmsnOiBidWlsZE5hdkxpbmtEYXRhKHByb3BzLmRhdGUpLCB0YWJJbmRleDogMCB9XG4gICAgICA6IHt9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPERheUNlbGxDb250ZW50XG4gICAgICAgIGRhdGU9e3Byb3BzLmRhdGV9XG4gICAgICAgIGRhdGVQcm9maWxlPXtwcm9wcy5kYXRlUHJvZmlsZX1cbiAgICAgICAgdG9kYXlSYW5nZT17cHJvcHMudG9kYXlSYW5nZX1cbiAgICAgICAgc2hvd0RheU51bWJlcj17cHJvcHMuc2hvd0RheU51bWJlcn1cbiAgICAgICAgZXh0cmFIb29rUHJvcHM9e3Byb3BzLmV4dHJhSG9va1Byb3BzfVxuICAgICAgICBkZWZhdWx0Q29udGVudD17cmVuZGVyVG9wSW5uZXJ9XG4gICAgICA+XG4gICAgICAgIHsoaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSA9PiAoXG4gICAgICAgICAgaW5uZXJDb250ZW50ICYmXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nZmMtZGF5Z3JpZC1kYXktdG9wJyByZWY9e2lubmVyRWxSZWZ9PlxuICAgICAgICAgICAgICA8YSBjbGFzc05hbWU9J2ZjLWRheWdyaWQtZGF5LW51bWJlcicgey4uLm5hdkxpbmtBdHRyc30+XG4gICAgICAgICAgICAgICAge2lubmVyQ29udGVudH1cbiAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG4gICAgICA8L0RheUNlbGxDb250ZW50PlxuICAgIClcbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBjcmVhdGVGb3JtYXR0ZXIgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcbmltcG9ydCB7IFRhYmxlU2VnIH0gZnJvbSAnLi9UYWJsZVNlZydcblxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7XG4gIGhvdXI6ICdudW1lcmljJyxcbiAgbWludXRlOiAnMi1kaWdpdCcsXG4gIG9taXRaZXJvTWludXRlOiB0cnVlLFxuICBtZXJpZGllbTogJ25hcnJvdydcbn0pXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0xpc3RJdGVtRGlzcGxheShzZWc6IFRhYmxlU2VnKSB7XG4gIGxldCB7IGRpc3BsYXkgfSA9IHNlZy5ldmVudFJhbmdlLnVpXG5cbiAgcmV0dXJuIGRpc3BsYXkgPT09ICdsaXN0LWl0ZW0nIHx8IChcbiAgICBkaXNwbGF5ID09PSAnYXV0bycgJiZcbiAgICAhc2VnLmV2ZW50UmFuZ2UuZGVmLmFsbERheSAmJlxuICAgIHNlZy5maXJzdENvbCA9PT0gc2VnLmxhc3RDb2wgLy8gY2FuJ3QgYmUgbXVsdGktZGF5XG4gIClcbn1cbiIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIEJhc2VDb21wb25lbnQsIFNlZywgRXZlbnRSb290LCBidWlsZFNlZ1RpbWVUZXh0LCBFdmVudENvbnRlbnRBcmcsIEZyYWdtZW50IH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5pbXBvcnQgeyBERUZBVUxUX1RBQkxFX0VWRU5UX1RJTUVfRk9STUFUIH0gZnJvbSAnLi9ldmVudC1yZW5kZXJpbmcnXG5cblxuZXhwb3J0IGludGVyZmFjZSBEb3RUYWJsZUV2ZW50UHJvcHMge1xuICBzZWc6IFNlZ1xuICBpc0RyYWdnaW5nOiBib29sZWFuXG4gIGlzU2VsZWN0ZWQ6IGJvb2xlYW5cbiAgaXNQYXN0OiBib29sZWFuXG4gIGlzRnV0dXJlOiBib29sZWFuXG4gIGlzVG9kYXk6IGJvb2xlYW5cbiAgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogYm9vbGVhblxufVxuXG5leHBvcnQgY2xhc3MgVGFibGVMaXN0SXRlbUV2ZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudDxEb3RUYWJsZUV2ZW50UHJvcHM+IHtcblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXNcbiAgICBsZXQgdGltZUZvcm1hdCA9IGNvbnRleHQub3B0aW9ucy5ldmVudFRpbWVGb3JtYXQgfHwgREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVFxuICAgIGxldCB0aW1lVGV4dCA9IGJ1aWxkU2VnVGltZVRleHQocHJvcHMuc2VnLCB0aW1lRm9ybWF0LCBjb250ZXh0LCB0cnVlLCBwcm9wcy5kZWZhdWx0RGlzcGxheUV2ZW50RW5kKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxFdmVudFJvb3RcbiAgICAgICAgc2VnPXtwcm9wcy5zZWd9XG4gICAgICAgIHRpbWVUZXh0PXt0aW1lVGV4dH1cbiAgICAgICAgZGVmYXVsdENvbnRlbnQ9e3JlbmRlcklubmVyQ29udGVudH1cbiAgICAgICAgaXNEcmFnZ2luZz17cHJvcHMuaXNEcmFnZ2luZ31cbiAgICAgICAgaXNSZXNpemluZz17ZmFsc2V9XG4gICAgICAgIGlzRGF0ZVNlbGVjdGluZz17ZmFsc2V9XG4gICAgICAgIGlzU2VsZWN0ZWQ9e3Byb3BzLmlzU2VsZWN0ZWR9XG4gICAgICAgIGlzUGFzdD17cHJvcHMuaXNQYXN0fVxuICAgICAgICBpc0Z1dHVyZT17cHJvcHMuaXNGdXR1cmV9XG4gICAgICAgIGlzVG9kYXk9e3Byb3BzLmlzVG9kYXl9XG4gICAgICA+XG4gICAgICAgIHsocm9vdEVsUmVmLCBjbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpID0+ICggLy8gd2UgZG9uJ3QgdXNlIHN0eWxlcyFcbiAgICAgICAgICA8YVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtbICdmYy1kYXlncmlkLWV2ZW50JywgJ2ZjLWRheWdyaWQtZG90LWV2ZW50JyBdLmNvbmNhdChjbGFzc05hbWVzKS5qb2luKCcgJyl9XG4gICAgICAgICAgICByZWY9e3Jvb3RFbFJlZn1cbiAgICAgICAgICAgIHsuLi5nZXRTZWdBbmNob3JBdHRycyhwcm9wcy5zZWcpfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtpbm5lckNvbnRlbnR9XG4gICAgICAgICAgPC9hPlxuICAgICAgICApfVxuICAgICAgPC9FdmVudFJvb3Q+XG4gICAgKVxuICB9XG5cbn1cblxuXG5mdW5jdGlvbiByZW5kZXJJbm5lckNvbnRlbnQoaW5uZXJQcm9wczogRXZlbnRDb250ZW50QXJnKSB7XG4gIHJldHVybiAoXG4gICAgPEZyYWdtZW50PlxuICAgICAgPGRpdlxuICAgICAgICBjbGFzc05hbWU9J2ZjLWRheWdyaWQtZXZlbnQtZG90J1xuICAgICAgICBzdHlsZT17eyBib3JkZXJDb2xvcjogaW5uZXJQcm9wcy5ib3JkZXJDb2xvciB8fCBpbm5lclByb3BzLmJhY2tncm91bmRDb2xvciB9fVxuICAgICAgLz5cbiAgICAgIHtpbm5lclByb3BzLnRpbWVUZXh0ICYmXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPSdmYy1ldmVudC10aW1lJz57aW5uZXJQcm9wcy50aW1lVGV4dH08L2Rpdj5cbiAgICAgIH1cbiAgICAgIDxkaXYgY2xhc3NOYW1lPSdmYy1ldmVudC10aXRsZSc+XG4gICAgICAgIHtpbm5lclByb3BzLmV2ZW50LnRpdGxlIHx8IDxGcmFnbWVudD4mbmJzcDs8L0ZyYWdtZW50Pn1cbiAgICAgIDwvZGl2PlxuICAgIDwvRnJhZ21lbnQ+XG4gIClcbn1cblxuXG5mdW5jdGlvbiBnZXRTZWdBbmNob3JBdHRycyhzZWc6IFNlZykgeyAvLyBub3QgZHJ5LiBpbiBTdGFuZGFyZEV2ZW50IHRvb1xuICBsZXQgdXJsID0gc2VnLmV2ZW50UmFuZ2UuZGVmLnVybFxuICByZXR1cm4gdXJsID8geyBocmVmOiB1cmwgfSA6IHt9XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBTdGFuZGFyZEV2ZW50LCBCYXNlQ29tcG9uZW50LCBNaW5pbWFsRXZlbnRQcm9wcyB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuaW1wb3J0IHsgREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVCB9IGZyb20gJy4vZXZlbnQtcmVuZGVyaW5nJ1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVCbG9ja0V2ZW50UHJvcHMgZXh0ZW5kcyBNaW5pbWFsRXZlbnRQcm9wcyB7XG4gIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQ6IGJvb2xlYW5cbn1cblxuZXhwb3J0IGNsYXNzIFRhYmxlQmxvY2tFdmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQ8VGFibGVCbG9ja0V2ZW50UHJvcHM+IHtcblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcblxuICAgIHJldHVybiAoXG4gICAgICA8U3RhbmRhcmRFdmVudFxuICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgIGV4dHJhQ2xhc3NOYW1lcz17WyAnZmMtZGF5Z3JpZC1ldmVudCcsICdmYy1kYXlncmlkLWJsb2NrLWV2ZW50JywgJ2ZjLWgtZXZlbnQnIF19XG4gICAgICAgIGRlZmF1bHRUaW1lRm9ybWF0PXtERUZBVUxUX1RBQkxFX0VWRU5UX1RJTUVfRk9STUFUfVxuICAgICAgICBkZWZhdWx0RGlzcGxheUV2ZW50RW5kPXtwcm9wcy5kZWZhdWx0RGlzcGxheUV2ZW50RW5kfVxuICAgICAgICBkaXNhYmxlUmVzaXppbmc9eyFwcm9wcy5zZWcuZXZlbnRSYW5nZS5kZWYuYWxsRGF5fVxuICAgICAgLz5cbiAgICApXG4gIH1cblxufVxuIiwiaW1wb3J0IHtcbiAgc29ydEV2ZW50U2VncyxcbiAgT3JkZXJTcGVjLFxuICBFdmVudEFwaSxcbiAgRXZlbnRSZW5kZXJSYW5nZSxcbiAgYWRkRGF5cyxcbiAgaW50ZXJzZWN0UmFuZ2VzLFxuICBEYXRlTWFya2VyXG59IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuaW1wb3J0IHsgVGFibGVTZWcgfSBmcm9tICcuL1RhYmxlU2VnJ1xuaW1wb3J0IHsgVGFibGVDZWxsTW9kZWwgfSBmcm9tICcuL1RhYmxlQ2VsbCdcblxuXG5pbnRlcmZhY2UgVGFibGVTZWdQbGFjZW1lbnQge1xuICBzZWc6IFRhYmxlU2VnXG4gIHRvcDogbnVtYmVyXG4gIGJvdHRvbTogbnVtYmVyXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVGZ1NlZ1BsYWNlbWVudCggLy8gZm9yIG9uZSByb3cuIFRPRE86IHByaW50IG1vZGU/XG4gIGNlbGxNb2RlbHM6IFRhYmxlQ2VsbE1vZGVsW10sXG4gIHNlZ3M6IFRhYmxlU2VnW10sXG4gIGRheU1heEV2ZW50czogYm9vbGVhbiB8IG51bWJlcixcbiAgZGF5TWF4RXZlbnRSb3dzOiBib29sZWFuIHwgbnVtYmVyLFxuICBldmVudEhlaWdodHM6IHsgW2luc3RhbmNlSWRBbmRGaXJzdENvbDogc3RyaW5nXTogbnVtYmVyIH0sXG4gIG1heENvbnRlbnRIZWlnaHQ6IG51bWJlciB8IG51bGwsXG4gIGNvbENudDogbnVtYmVyLFxuICBldmVudE9yZGVyU3BlY3M6IE9yZGVyU3BlYzxFdmVudEFwaT5bXVxuKSB7XG4gIGxldCBjb2xQbGFjZW1lbnRzOiBUYWJsZVNlZ1BsYWNlbWVudFtdW10gPSBbXSAvLyBpZiBldmVudCBzcGFucyBtdWx0aXBsZSBjb2xzLCBpdHMgcHJlc2VudCBpbiBlYWNoIGNvbFxuICBsZXQgbW9yZUNudHM6IG51bWJlcltdID0gW10gLy8gYnktY29sXG4gIGxldCBzZWdJc0hpZGRlbjogeyBbaW5zdGFuY2VJZDogc3RyaW5nXTogYm9vbGVhbiB9ID0ge31cbiAgbGV0IHNlZ1RvcHM6IHsgW2luc3RhbmNlSWQ6IHN0cmluZ106IG51bWJlciB9ID0ge30gLy8gYWx3YXlzIHBvcHVsYXRlZCBmb3IgZWFjaCBzZWdcbiAgbGV0IHNlZ01hcmdpblRvcHM6IHsgW2luc3RhbmNlSWQ6IHN0cmluZ106IG51bWJlciB9ID0ge30gLy8gc2ltZXRpbWVzIHBvcHVsYXRlZCBmb3IgZWFjaCBzZWdcbiAgbGV0IG1vcmVUb3BzOiB7IFtjb2w6IHN0cmluZ106IG51bWJlciB9ID0ge31cbiAgbGV0IHBhZGRpbmdCb3R0b21zOiB7IFtjb2w6IHN0cmluZ106IG51bWJlciB9ID0ge30gLy8gZm9yIGVhY2ggY2VsbCdzIGlubmVyLXdyYXBwZXIgZGl2XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xDbnQ7IGkrKykge1xuICAgIGNvbFBsYWNlbWVudHMucHVzaChbXSlcbiAgICBtb3JlQ250cy5wdXNoKDApXG4gIH1cblxuICBzZWdzID0gc29ydEV2ZW50U2VncyhzZWdzLCBldmVudE9yZGVyU3BlY3MpIGFzIFRhYmxlU2VnW11cblxuICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xuICAgIGxldCB7IGluc3RhbmNlSWQgfSA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlXG4gICAgbGV0IGV2ZW50SGVpZ2h0ID0gZXZlbnRIZWlnaHRzW2luc3RhbmNlSWQgKyAnOicgKyBzZWcuZmlyc3RDb2xdXG5cbiAgICBwbGFjZVNlZyhzZWcsIGV2ZW50SGVpZ2h0IHx8IDApIC8vIHdpbGwga2VlcCBjb2xQbGFjZW1lbnRzIHNvcnRlZCBieSB0b3BcbiAgfVxuXG4gIGlmIChkYXlNYXhFdmVudHMgPT09IHRydWUgfHwgZGF5TWF4RXZlbnRSb3dzID09PSB0cnVlKSB7XG4gICAgbGltaXRCeU1heEhlaWdodChtb3JlQ250cywgc2VnSXNIaWRkZW4sIGNvbFBsYWNlbWVudHMsIG1heENvbnRlbnRIZWlnaHQpIC8vIHBvcHVsYXRlcyBtb3JlQ250cy9zZWdJc0hpZGRlblxuXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRheU1heEV2ZW50cyA9PT0gJ251bWJlcicpIHtcbiAgICBsaW1pdEJ5TWF4RXZlbnRzKG1vcmVDbnRzLCBzZWdJc0hpZGRlbiwgY29sUGxhY2VtZW50cywgZGF5TWF4RXZlbnRzKSAvLyBwb3B1bGF0ZXMgbW9yZUNudHMvc2VnSXNIaWRkZW5cblxuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXlNYXhFdmVudFJvd3MgPT09ICdudW1iZXInKSB7XG4gICAgbGltaXRCeU1heFJvd3MobW9yZUNudHMsIHNlZ0lzSGlkZGVuLCBjb2xQbGFjZW1lbnRzLCBkYXlNYXhFdmVudFJvd3MpIC8vIHBvcHVsYXRlcyBtb3JlQ250cy9zZWdJc0hpZGRlblxuICB9XG5cbiAgLy8gY29tcHV0ZXMgc2VnVG9wcy9zZWdNYXJnaW5Ub3BzL21vcmVUb3BzL3BhZGRpbmdCb3R0b21zXG4gIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbENudDsgY29sKyspIHtcbiAgICBsZXQgcGxhY2VtZW50cyA9IGNvbFBsYWNlbWVudHNbY29sXVxuICAgIGxldCBjdXJyZW50Tm9uQWJzQm90dG9tID0gMFxuICAgIGxldCBydW5uaW5nQWJzSGVpZ2h0ID0gMFxuXG4gICAgZm9yIChsZXQgcGxhY2VtZW50IG9mIHBsYWNlbWVudHMpIHtcbiAgICAgIGxldCBzZWcgPSBwbGFjZW1lbnQuc2VnXG5cbiAgICAgIGlmICghc2VnSXNIaWRkZW5bc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZF0pIHtcblxuICAgICAgICBzZWdUb3BzW3NlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWRdID0gcGxhY2VtZW50LnRvcCAvLyBmcm9tIHRvcCBvZiBjb250YWluZXJcblxuICAgICAgICBpZiAoc2VnLmZpcnN0Q29sID09PSBzZWcubGFzdENvbCAmJiBzZWcuaXNTdGFydCAmJiBzZWcuaXNFbmQpIHsgLy8gVE9ETzogc2ltcGxlciB3YXk/IE5PVCBEUllcblxuICAgICAgICAgIHNlZ01hcmdpblRvcHNbc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZF0gPVxuICAgICAgICAgICAgcGxhY2VtZW50LnRvcCAtIGN1cnJlbnROb25BYnNCb3R0b20gLy8gZnJvbSBwcmV2aW91cyBzZWcgYm90dG9tXG5cbiAgICAgICAgICBydW5uaW5nQWJzSGVpZ2h0ID0gMFxuICAgICAgICAgIGN1cnJlbnROb25BYnNCb3R0b20gPSBwbGFjZW1lbnQuYm90dG9tXG5cbiAgICAgICAgfSBlbHNlIHsgLy8gbXVsdGktY29sIGV2ZW50LCBhYnMgcG9zaXRpb25lZFxuICAgICAgICAgIHJ1bm5pbmdBYnNIZWlnaHQgKz0gcGxhY2VtZW50LmJvdHRvbSAtIHBsYWNlbWVudC50b3BcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChydW5uaW5nQWJzSGVpZ2h0KSB7XG4gICAgICBpZiAobW9yZUNudHNbY29sXSkge1xuICAgICAgICBtb3JlVG9wc1tjb2xdID0gcnVubmluZ0Fic0hlaWdodFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFkZGluZ0JvdHRvbXNbY29sXSA9IHJ1bm5pbmdBYnNIZWlnaHRcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwbGFjZVNlZyhzZWcsIHNlZ0hlaWdodCkge1xuICAgIGlmICghdHJ5UGxhY2VTZWdBdChzZWcsIHNlZ0hlaWdodCwgMCkpIHtcbiAgICAgIGZvciAobGV0IGNvbCA9IHNlZy5maXJzdENvbDsgY29sIDw9IHNlZy5sYXN0Q29sOyBjb2wrKykge1xuICAgICAgICBmb3IgKGxldCBwbGFjZW1lbnQgb2YgY29sUGxhY2VtZW50c1tjb2xdKSB7IC8vIHdpbGwgcmVwZWF0IG11bHRpLWRheSBzZWdzISEhISEhISBiYWQhISEhISFcbiAgICAgICAgICBpZiAodHJ5UGxhY2VTZWdBdChzZWcsIHNlZ0hlaWdodCwgcGxhY2VtZW50LmJvdHRvbSkpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeVBsYWNlU2VnQXQoc2VnLCBzZWdIZWlnaHQsIHRvcCkge1xuICAgIGlmIChjYW5QbGFjZVNlZ0F0KHNlZywgc2VnSGVpZ2h0LCB0b3ApKSB7XG4gICAgICBmb3IgKGxldCBjb2wgPSBzZWcuZmlyc3RDb2w7IGNvbCA8PSBzZWcubGFzdENvbDsgY29sKyspIHtcbiAgICAgICAgbGV0IHBsYWNlbWVudHMgPSBjb2xQbGFjZW1lbnRzW2NvbF1cbiAgICAgICAgbGV0IGluc2VydGlvbkluZGV4ID0gMFxuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgaW5zZXJ0aW9uSW5kZXggPCBwbGFjZW1lbnRzLmxlbmd0aCAmJlxuICAgICAgICAgIHRvcCA+PSBwbGFjZW1lbnRzW2luc2VydGlvbkluZGV4XS50b3BcbiAgICAgICAgKSB7XG4gICAgICAgICAgaW5zZXJ0aW9uSW5kZXgrK1xuICAgICAgICB9XG4gICAgICAgIHBsYWNlbWVudHMuc3BsaWNlKGluc2VydGlvbkluZGV4LCAwLCB7IC8vIHdpbGwga2VlcCBpdCBzb3J0ZWQgYnkgdG9wXG4gICAgICAgICAgc2VnLFxuICAgICAgICAgIHRvcCxcbiAgICAgICAgICBib3R0b206IHRvcCArIHNlZ0hlaWdodFxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2FuUGxhY2VTZWdBdChzZWcsIHNlZ0hlaWdodCwgdG9wKSB7XG4gICAgZm9yIChsZXQgY29sID0gc2VnLmZpcnN0Q29sOyBjb2wgPD0gc2VnLmxhc3RDb2w7IGNvbCsrKSB7XG4gICAgICBmb3IgKGxldCBwbGFjZW1lbnQgb2YgY29sUGxhY2VtZW50c1tjb2xdKSB7XG4gICAgICAgIGlmICh0b3AgPCBwbGFjZW1lbnQuYm90dG9tICYmIHRvcCArIHNlZ0hlaWdodCA+IHBsYWNlbWVudC50b3ApIHsgLy8gY29sbGlkZT9cbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gd2hhdCBkb2VzIHRoaXMgZG8hP1xuICBmb3IgKGxldCBpbnN0YW5jZUlkQW5kRmlyc3RDb2wgaW4gZXZlbnRIZWlnaHRzKSB7XG4gICAgaWYgKCFldmVudEhlaWdodHNbaW5zdGFuY2VJZEFuZEZpcnN0Q29sXSkge1xuICAgICAgc2VnSXNIaWRkZW5baW5zdGFuY2VJZEFuZEZpcnN0Q29sLnNwbGl0KCc6JylbMF1dID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGxldCBzZWdzQnlGaXJzdENvbCA9IGNvbFBsYWNlbWVudHMubWFwKGV4dHJhY3RGaXJzdENvbFNlZ3MpIC8vIG9wZXJhdGVzIG9uIHRoZSBzb3J0ZWQgY29sc1xuICBsZXQgc2Vnc0J5RWFjaENvbCA9IGNvbFBsYWNlbWVudHMubWFwKChwbGFjZW1lbnRzLCBjb2wpID0+IHtcbiAgICBsZXQgc2VncyA9IGV4dHJhY3RBbGxDb2xTZWdzKHBsYWNlbWVudHMpXG4gICAgc2VncyA9IHJlc2xpY2VEYXlTZWdzKHNlZ3MsIGNlbGxNb2RlbHNbY29sXS5kYXRlLCBjb2wpXG4gICAgcmV0dXJuIHNlZ3NcbiAgfSlcblxuICByZXR1cm4ge1xuICAgIHNlZ3NCeUZpcnN0Q29sLFxuICAgIHNlZ3NCeUVhY2hDb2wsXG4gICAgc2VnSXNIaWRkZW4sXG4gICAgc2VnVG9wcyxcbiAgICBzZWdNYXJnaW5Ub3BzLFxuICAgIG1vcmVDbnRzLFxuICAgIG1vcmVUb3BzLFxuICAgIHBhZGRpbmdCb3R0b21zXG4gIH1cbn1cblxuXG5mdW5jdGlvbiBleHRyYWN0Rmlyc3RDb2xTZWdzKG9uZUNvbFBsYWNlbWVudHM6IFRhYmxlU2VnUGxhY2VtZW50W10sIGNvbDogbnVtYmVyKSB7XG4gIGxldCBzZWdzOiBUYWJsZVNlZ1tdID0gW11cblxuICBmb3IgKGxldCBwbGFjZW1lbnQgb2Ygb25lQ29sUGxhY2VtZW50cykge1xuICAgIGlmIChwbGFjZW1lbnQuc2VnLmZpcnN0Q29sID09PSBjb2wpIHtcbiAgICAgIHNlZ3MucHVzaChwbGFjZW1lbnQuc2VnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWdzXG59XG5cblxuZnVuY3Rpb24gZXh0cmFjdEFsbENvbFNlZ3Mob25lQ29sUGxhY2VtZW50czogVGFibGVTZWdQbGFjZW1lbnRbXSkge1xuICBsZXQgc2VnczogVGFibGVTZWdbXSA9IFtdXG5cbiAgZm9yIChsZXQgcGxhY2VtZW50IG9mIG9uZUNvbFBsYWNlbWVudHMpIHtcbiAgICBzZWdzLnB1c2gocGxhY2VtZW50LnNlZylcbiAgfVxuXG4gIHJldHVybiBzZWdzXG59XG5cblxuZnVuY3Rpb24gbGltaXRCeU1heEhlaWdodChoaWRkZW5DbnRzLCBzZWdJc0hpZGRlbiwgY29sUGxhY2VtZW50cywgbWF4Q29udGVudEhlaWdodCkge1xuICBsaW1pdEV2ZW50cyhoaWRkZW5DbnRzLCBzZWdJc0hpZGRlbiwgY29sUGxhY2VtZW50cywgdHJ1ZSwgKHBsYWNlbWVudCkgPT4ge1xuICAgIHJldHVybiBwbGFjZW1lbnQuYm90dG9tIDw9IG1heENvbnRlbnRIZWlnaHRcbiAgfSlcbn1cblxuXG5mdW5jdGlvbiBsaW1pdEJ5TWF4RXZlbnRzKGhpZGRlbkNudHMsIHNlZ0lzSGlkZGVuLCBjb2xQbGFjZW1lbnRzLCBkYXlNYXhFdmVudHMpIHtcbiAgbGltaXRFdmVudHMoaGlkZGVuQ250cywgc2VnSXNIaWRkZW4sIGNvbFBsYWNlbWVudHMsIGZhbHNlLCAocGxhY2VtZW50LCBsZXZlbEluZGV4KSA9PiB7XG4gICAgcmV0dXJuIGxldmVsSW5kZXggPCBkYXlNYXhFdmVudHNcbiAgfSlcbn1cblxuXG5mdW5jdGlvbiBsaW1pdEJ5TWF4Um93cyhoaWRkZW5DbnRzLCBzZWdJc0hpZGRlbiwgY29sUGxhY2VtZW50cywgZGF5TWF4RXZlbnRSb3dzKSB7XG4gIGxpbWl0RXZlbnRzKGhpZGRlbkNudHMsIHNlZ0lzSGlkZGVuLCBjb2xQbGFjZW1lbnRzLCB0cnVlLCAocGxhY2VtZW50LCBsZXZlbEluZGV4KSA9PiB7XG4gICAgcmV0dXJuIGxldmVsSW5kZXggPCBkYXlNYXhFdmVudFJvd3NcbiAgfSlcbn1cblxuXG4vKlxucG9wdWxhdGVzIHRoZSBnaXZlbiBoaWRkZW5DbnRzL3NlZ0lzSGlkZGVuLCB3aGljaCBhcmUgc3VwcGxpZWQgZW1wdHkuXG5UT0RPOiByZXR1cm4gdGhlbSBpbnN0ZWFkXG4qL1xuZnVuY3Rpb24gbGltaXRFdmVudHMoaGlkZGVuQ250cywgc2VnSXNIaWRkZW4sIGNvbFBsYWNlbWVudHMsIG1vcmVMaW5rQ29uc3VtZXNMZXZlbCwgaXNQbGFjZW1lbnRJbkJvdW5kcykge1xuICBsZXQgY29sQ250ID0gaGlkZGVuQ250cy5sZW5ndGhcbiAgbGV0IHNlZ0lzVmlzaWJsZSA9IHt9IGFzIGFueSAvLyBUT0RPOiBpbnN0ZWFkLCB1c2Ugc2VnSXNIaWRkZW4gd2l0aCB0cnVlL2ZhbHNlP1xuICBsZXQgdmlzaWJsZUNvbFBsYWNlbWVudHMgPSBbXSAvLyB3aWxsIG1pcnJvciBjb2xQbGFjZW1lbnRzXG5cbiAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sQ250OyBjb2wrKykge1xuICAgIHZpc2libGVDb2xQbGFjZW1lbnRzLnB1c2goW10pXG4gIH1cblxuICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xDbnQ7IGNvbCsrKSB7XG4gICAgbGV0IHBsYWNlbWVudHMgPSBjb2xQbGFjZW1lbnRzW2NvbF1cbiAgICBsZXQgbGV2ZWwgPSAwXG5cbiAgICBmb3IgKGxldCBwbGFjZW1lbnQgb2YgcGxhY2VtZW50cykge1xuXG4gICAgICBpZiAoaXNQbGFjZW1lbnRJbkJvdW5kcyhwbGFjZW1lbnQsIGxldmVsKSkge1xuICAgICAgICByZWNvcmRWaXNpYmxlKHBsYWNlbWVudClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlY29yZEhpZGRlbihwbGFjZW1lbnQpXG4gICAgICB9XG5cbiAgICAgIC8vIG9ubHkgY29uc2lkZXJlZCBhIGxldmVsIGlmIHRoZSBzZWcgaGFkIGhlaWdodFxuICAgICAgaWYgKHBsYWNlbWVudC50b3AgIT09IHBsYWNlbWVudC5ib3R0b20pIHtcbiAgICAgICAgbGV2ZWwrK1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29yZFZpc2libGUocGxhY2VtZW50KSB7XG4gICAgbGV0IHsgc2VnIH0gPSBwbGFjZW1lbnRcbiAgICBsZXQgeyBpbnN0YW5jZUlkIH0gPSBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZVxuXG4gICAgaWYgKCFzZWdJc1Zpc2libGVbaW5zdGFuY2VJZF0pIHtcbiAgICAgIHNlZ0lzVmlzaWJsZVtpbnN0YW5jZUlkXSA9IHRydWVcblxuICAgICAgZm9yIChsZXQgY29sID0gc2VnLmZpcnN0Q29sOyBjb2wgPD0gc2VnLmxhc3RDb2w7IGNvbCsrKSB7XG4gICAgICAgIHZpc2libGVDb2xQbGFjZW1lbnRzW2NvbF0ucHVzaChwbGFjZW1lbnQpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkSGlkZGVuKHBsYWNlbWVudCkge1xuICAgIGxldCB7IHNlZyB9ID0gcGxhY2VtZW50XG4gICAgbGV0IHsgaW5zdGFuY2VJZCB9ID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2VcblxuICAgIGlmICghc2VnSXNIaWRkZW5baW5zdGFuY2VJZF0pIHtcbiAgICAgIHNlZ0lzSGlkZGVuW2luc3RhbmNlSWRdID0gdHJ1ZVxuXG4gICAgICBmb3IgKGxldCBjb2wgPSBzZWcuZmlyc3RDb2w7IGNvbCA8PSBzZWcubGFzdENvbDsgY29sKyspIHtcbiAgICAgICAgbGV0IGhpZGRlbkNudCA9ICsraGlkZGVuQ250c1tjb2xdXG5cbiAgICAgICAgaWYgKG1vcmVMaW5rQ29uc3VtZXNMZXZlbCAmJiBoaWRkZW5DbnQgPT09IDEpIHtcbiAgICAgICAgICBsZXQgbGFzdFZpc2libGVQbGFjZW1lbnQgPSB2aXNpYmxlQ29sUGxhY2VtZW50c1tjb2xdLnBvcCgpXG5cbiAgICAgICAgICBpZiAobGFzdFZpc2libGVQbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIHJlY29yZEhpZGRlbihsYXN0VmlzaWJsZVBsYWNlbWVudClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG4vLyBHaXZlbiB0aGUgZXZlbnRzIHdpdGhpbiBhbiBhcnJheSBvZiBzZWdtZW50IG9iamVjdHMsIHJlc2xpY2UgdGhlbSB0byBiZSBpbiBhIHNpbmdsZSBkYXlcbmZ1bmN0aW9uIHJlc2xpY2VEYXlTZWdzKHNlZ3M6IFRhYmxlU2VnW10sIGRheURhdGU6IERhdGVNYXJrZXIsIGNvbEluZGV4OiBudW1iZXIpIHtcbiAgbGV0IGRheVN0YXJ0ID0gZGF5RGF0ZVxuICBsZXQgZGF5RW5kID0gYWRkRGF5cyhkYXlTdGFydCwgMSlcbiAgbGV0IGRheVJhbmdlID0geyBzdGFydDogZGF5U3RhcnQsIGVuZDogZGF5RW5kIH1cbiAgbGV0IG5ld1NlZ3MgPSBbXVxuXG4gIGZvciAobGV0IHNlZyBvZiBzZWdzKSB7XG4gICAgbGV0IGV2ZW50UmFuZ2UgPSBzZWcuZXZlbnRSYW5nZVxuICAgIGxldCBvcmlnUmFuZ2UgPSBldmVudFJhbmdlLnJhbmdlXG4gICAgbGV0IHNsaWNlZFJhbmdlID0gaW50ZXJzZWN0UmFuZ2VzKG9yaWdSYW5nZSwgZGF5UmFuZ2UpXG5cbiAgICBpZiAoc2xpY2VkUmFuZ2UpIHtcbiAgICAgIG5ld1NlZ3MucHVzaCh7XG4gICAgICAgIC4uLnNlZyxcbiAgICAgICAgZmlyc3RDb2w6IGNvbEluZGV4LFxuICAgICAgICBsYXN0Q29sOiBjb2xJbmRleCxcbiAgICAgICAgZXZlbnRSYW5nZToge1xuICAgICAgICAgIGRlZjogZXZlbnRSYW5nZS5kZWYsXG4gICAgICAgICAgdWk6IHsgLi4uZXZlbnRSYW5nZS51aSwgZHVyYXRpb25FZGl0YWJsZTogZmFsc2UgfSwgLy8gaGFjayB0byBkaXNhYmxlIHJlc2l6aW5nXG4gICAgICAgICAgaW5zdGFuY2U6IGV2ZW50UmFuZ2UuaW5zdGFuY2UsXG4gICAgICAgICAgcmFuZ2U6IHNsaWNlZFJhbmdlXG4gICAgICAgIH0gYXMgRXZlbnRSZW5kZXJSYW5nZSxcbiAgICAgICAgaXNTdGFydDogc2VnLmlzU3RhcnQgJiYgc2xpY2VkUmFuZ2Uuc3RhcnQudmFsdWVPZigpID09PSBvcmlnUmFuZ2Uuc3RhcnQudmFsdWVPZigpLFxuICAgICAgICBpc0VuZDogc2VnLmlzRW5kICYmIHNsaWNlZFJhbmdlLmVuZC52YWx1ZU9mKCkgPT09IG9yaWdSYW5nZS5lbmQudmFsdWVPZigpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdTZWdzXG59XG4iLCJpbXBvcnQge1xuICBFdmVudFNlZ1VpSW50ZXJhY3Rpb25TdGF0ZSxcbiAgVk5vZGUsXG4gIERhdGVDb21wb25lbnQsXG4gIGNyZWF0ZUVsZW1lbnQsXG4gIFBvc2l0aW9uQ2FjaGUsXG4gIFJlZk1hcCxcbiAgbWFwSGFzaCxcbiAgQ3NzRGltVmFsdWUsXG4gIERhdGVSYW5nZSxcbiAgZ2V0U2VnTWV0YSxcbiAgRGF0ZVByb2ZpbGUsXG4gIEZyYWdtZW50LFxuICBCZ0V2ZW50LFxuICByZW5kZXJGaWxsLFxuICBpc1Byb3BzRXF1YWwsXG4gIGNyZWF0ZVJlZixcbiAgYnVpbGRFdmVudFJhbmdlS2V5XG59IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuaW1wb3J0IHsgVGFibGVTZWcsIHNwbGl0U2Vnc0J5Rmlyc3RDb2wgfSBmcm9tICcuL1RhYmxlU2VnJ1xuaW1wb3J0IHsgVGFibGVDZWxsLCBUYWJsZUNlbGxNb2RlbCwgTW9yZUxpbmtBcmcgfSBmcm9tICcuL1RhYmxlQ2VsbCdcbmltcG9ydCB7IFRhYmxlTGlzdEl0ZW1FdmVudCB9IGZyb20gJy4vVGFibGVMaXN0SXRlbUV2ZW50J1xuaW1wb3J0IHsgVGFibGVCbG9ja0V2ZW50IH0gZnJvbSAnLi9UYWJsZUJsb2NrRXZlbnQnXG5pbXBvcnQgeyBjb21wdXRlRmdTZWdQbGFjZW1lbnQgfSBmcm9tICcuL2V2ZW50LXBsYWNlbWVudCdcbmltcG9ydCB7IGhhc0xpc3RJdGVtRGlzcGxheSB9IGZyb20gJy4vZXZlbnQtcmVuZGVyaW5nJ1xuXG5cbi8vIFRPRE86IGF0dGFjaCB0byB3aW5kb3cgcmVzaXplP1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVSb3dQcm9wcyB7XG4gIGNlbGxzOiBUYWJsZUNlbGxNb2RlbFtdXG4gIHJlbmRlckludHJvPzogKCkgPT4gVk5vZGVcbiAgYnVzaW5lc3NIb3VyU2VnczogVGFibGVTZWdbXVxuICBiZ0V2ZW50U2VnczogVGFibGVTZWdbXVxuICBmZ0V2ZW50U2VnczogVGFibGVTZWdbXVxuICBkYXRlU2VsZWN0aW9uU2VnczogVGFibGVTZWdbXVxuICBldmVudFNlbGVjdGlvbjogc3RyaW5nXG4gIGV2ZW50RHJhZzogRXZlbnRTZWdVaUludGVyYWN0aW9uU3RhdGUgfCBudWxsXG4gIGV2ZW50UmVzaXplOiBFdmVudFNlZ1VpSW50ZXJhY3Rpb25TdGF0ZSB8IG51bGxcbiAgZGF5TWF4RXZlbnRzOiBib29sZWFuIHwgbnVtYmVyXG4gIGRheU1heEV2ZW50Um93czogYm9vbGVhbiB8IG51bWJlclxuICBjbGllbnRXaWR0aDogbnVtYmVyIHwgbnVsbFxuICBjbGllbnRIZWlnaHQ6IG51bWJlciB8IG51bGwgLy8gc2ltcGx5IGZvciBjYXVzaW5nIGFuIHVwZGF0ZVNpemUsIGZvciB3aGVuIGxpcXVpZCBoZWlnaHRcbiAgb25Nb3JlQ2xpY2s/OiAoYXJnOiBNb3JlTGlua0FyZykgPT4gdm9pZFxuICBkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGVcbiAgdG9kYXlSYW5nZTogRGF0ZVJhbmdlXG4gIHNob3dEYXlOdW1iZXJzOiBib29sZWFuXG4gIHNob3dXZWVrTnVtYmVyczogYm9vbGVhblxuICBidWlsZE1vcmVMaW5rVGV4dDogKG51bTogbnVtYmVyKSA9PiBzdHJpbmdcbn1cblxuaW50ZXJmYWNlIFRhYmxlUm93U3RhdGUge1xuICBmcmFtZVBvc2l0aW9uczogUG9zaXRpb25DYWNoZVxuICBtYXhDb250ZW50SGVpZ2h0OiBudW1iZXIgfCBudWxsXG4gIHNlZ0hlaWdodHM6IHsgW2luc3RhbmNlSWRBbmRGaXJzdENvbDogc3RyaW5nXTogbnVtYmVyIH0gfCBudWxsXG59XG5cblxuZXhwb3J0IGNsYXNzIFRhYmxlUm93IGV4dGVuZHMgRGF0ZUNvbXBvbmVudDxUYWJsZVJvd1Byb3BzLCBUYWJsZVJvd1N0YXRlPiB7XG5cbiAgcHJpdmF0ZSBjZWxsRWxSZWZzID0gbmV3IFJlZk1hcDxIVE1MVGFibGVDZWxsRWxlbWVudD4oKSAvLyB0aGUgPHRkPlxuICBwcml2YXRlIGZyYW1lRWxSZWZzID0gbmV3IFJlZk1hcDxIVE1MRWxlbWVudD4oKSAvLyB0aGUgZmMtZGF5Z3JpZC1kYXktZnJhbWVcbiAgcHJpdmF0ZSBmZ0VsUmVmcyA9IG5ldyBSZWZNYXA8SFRNTERpdkVsZW1lbnQ+KCkgLy8gdGhlIGZjLWRheWdyaWQtZGF5LWV2ZW50c1xuICBwcml2YXRlIHNlZ0hhcm5lc3NSZWZzID0gbmV3IFJlZk1hcDxIVE1MRGl2RWxlbWVudD4oKSAvLyBpbmRleGVkIGJ5IFwiaW5zdGFuY2VJZDpmaXJzdENvbFwiXG4gIHByaXZhdGUgcm9vdEVsUmVmID0gY3JlYXRlUmVmPEhUTUxUYWJsZVJvd0VsZW1lbnQ+KClcblxuICBzdGF0ZTogVGFibGVSb3dTdGF0ZSA9IHtcbiAgICBmcmFtZVBvc2l0aW9uczogbnVsbCxcbiAgICBtYXhDb250ZW50SGVpZ2h0OiBudWxsLFxuICAgIHNlZ0hlaWdodHM6IHt9XG4gIH1cblxuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBwcm9wcywgc3RhdGUsIGNvbnRleHQgfSA9IHRoaXNcbiAgICBsZXQgY29sQ250ID0gcHJvcHMuY2VsbHMubGVuZ3RoXG5cbiAgICBsZXQgYnVzaW5lc3NIb3Vyc0J5Q29sID0gc3BsaXRTZWdzQnlGaXJzdENvbChwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCBjb2xDbnQpXG4gICAgbGV0IGJnRXZlbnRTZWdzQnlDb2wgPSBzcGxpdFNlZ3NCeUZpcnN0Q29sKHByb3BzLmJnRXZlbnRTZWdzLCBjb2xDbnQpXG4gICAgbGV0IGhpZ2hsaWdodFNlZ3NCeUNvbCA9IHNwbGl0U2Vnc0J5Rmlyc3RDb2wodGhpcy5nZXRIaWdobGlnaHRTZWdzKCksIGNvbENudClcbiAgICBsZXQgbWlycm9yU2Vnc0J5Q29sID0gc3BsaXRTZWdzQnlGaXJzdENvbCh0aGlzLmdldE1pcnJvclNlZ3MoKSwgY29sQ250KVxuXG4gICAgbGV0IHsgcGFkZGluZ0JvdHRvbXMsIHNlZ3NCeUZpcnN0Q29sLCBzZWdzQnlFYWNoQ29sLCBzZWdJc0hpZGRlbiwgc2VnVG9wcywgc2VnTWFyZ2luVG9wcywgbW9yZUNudHMsIG1vcmVUb3BzIH0gPSBjb21wdXRlRmdTZWdQbGFjZW1lbnQoXG4gICAgICBwcm9wcy5jZWxscyxcbiAgICAgIHByb3BzLmZnRXZlbnRTZWdzLFxuICAgICAgcHJvcHMuZGF5TWF4RXZlbnRzLFxuICAgICAgcHJvcHMuZGF5TWF4RXZlbnRSb3dzLFxuICAgICAgc3RhdGUuc2VnSGVpZ2h0cyxcbiAgICAgIHN0YXRlLm1heENvbnRlbnRIZWlnaHQsXG4gICAgICBjb2xDbnQsXG4gICAgICBjb250ZXh0Lm9wdGlvbnMuZXZlbnRPcmRlclxuICAgIClcblxuICAgIGxldCBzZWxlY3RlZEluc3RhbmNlSGFzaCA9IC8vIFRPRE86IG1lc3N5IHdheSB0byBjb21wdXRlIHRoaXNcbiAgICAgIChwcm9wcy5ldmVudERyYWcgJiYgcHJvcHMuZXZlbnREcmFnLmFmZmVjdGVkSW5zdGFuY2VzKSB8fFxuICAgICAgKHByb3BzLmV2ZW50UmVzaXplICYmIHByb3BzLmV2ZW50UmVzaXplLmFmZmVjdGVkSW5zdGFuY2VzKSB8fFxuICAgICAge31cblxuICAgIHJldHVybiAoXG4gICAgICA8dHIgcmVmPXt0aGlzLnJvb3RFbFJlZn0+XG4gICAgICAgIHtwcm9wcy5yZW5kZXJJbnRybyAmJiBwcm9wcy5yZW5kZXJJbnRybygpfVxuICAgICAgICB7cHJvcHMuY2VsbHMubWFwKChjZWxsLCBjb2wpID0+IHtcbiAgICAgICAgICBsZXQgbm9ybWFsRmdOb2RlcyA9IHRoaXMucmVuZGVyRmdTZWdzKFxuICAgICAgICAgICAgc2Vnc0J5Rmlyc3RDb2xbY29sXSxcbiAgICAgICAgICAgIHNlZ0lzSGlkZGVuLFxuICAgICAgICAgICAgc2VnVG9wcyxcbiAgICAgICAgICAgIHNlZ01hcmdpblRvcHMsXG4gICAgICAgICAgICBzZWxlY3RlZEluc3RhbmNlSGFzaCxcbiAgICAgICAgICAgIHByb3BzLnRvZGF5UmFuZ2VcbiAgICAgICAgICApXG5cbiAgICAgICAgICBsZXQgbWlycm9yRmdOb2RlcyA9IHRoaXMucmVuZGVyRmdTZWdzKFxuICAgICAgICAgICAgbWlycm9yU2Vnc0J5Q29sW2NvbF0sXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHNlZ1RvcHMsIC8vIHVzZSBzYW1lIHRvcHMgYXMgcmVhbCByZW5kZXJpbmdcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICBwcm9wcy50b2RheVJhbmdlLFxuICAgICAgICAgICAgQm9vbGVhbihwcm9wcy5ldmVudERyYWcpLFxuICAgICAgICAgICAgQm9vbGVhbihwcm9wcy5ldmVudFJlc2l6ZSksXG4gICAgICAgICAgICBmYWxzZSAvLyBkYXRlLXNlbGVjdGluZyAoYmVjYXVzZSBtaXJyb3IgaXMgbmV2ZXIgZHJhd24gZm9yIGRhdGUgc2VsZWN0aW9uKVxuICAgICAgICAgIClcblxuICAgICAgICAgIGxldCBzaG93V2Vla051bWJlciA9IHByb3BzLnNob3dXZWVrTnVtYmVycyAmJiBjb2wgPT09IDBcblxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8VGFibGVDZWxsXG4gICAgICAgICAgICAgIGtleT17Y2VsbC5rZXl9XG4gICAgICAgICAgICAgIGVsUmVmPXt0aGlzLmNlbGxFbFJlZnMuY3JlYXRlUmVmKGNlbGwua2V5KX1cbiAgICAgICAgICAgICAgaW5uZXJFbFJlZj17dGhpcy5mcmFtZUVsUmVmcy5jcmVhdGVSZWYoY2VsbC5rZXkpIC8qIEZGIDx0ZD4gcHJvYmxlbSwgYnV0IG9rYXkgdG8gdXNlIGZvciBsZWZ0L3JpZ2h0LiBUT0RPOiByZW5hbWUgcHJvcCAqL31cbiAgICAgICAgICAgICAgZGF0ZVByb2ZpbGU9e3Byb3BzLmRhdGVQcm9maWxlfVxuICAgICAgICAgICAgICBkYXRlPXtjZWxsLmRhdGV9XG4gICAgICAgICAgICAgIHNob3dEYXlOdW1iZXI9e3Byb3BzLnNob3dEYXlOdW1iZXJzIHx8IHNob3dXZWVrTnVtYmVyIC8qIGZvciBzcGFjaW5nLCB3ZSBuZWVkIHRvIGZvcmNlIGRheS1udW1iZXJzIGlmIHdlZWsgbnVtYmVycyAqL31cbiAgICAgICAgICAgICAgc2hvd1dlZWtOdW1iZXI9e3Nob3dXZWVrTnVtYmVyfVxuICAgICAgICAgICAgICB0b2RheVJhbmdlPXtwcm9wcy50b2RheVJhbmdlfVxuICAgICAgICAgICAgICBleHRyYUhvb2tQcm9wcz17Y2VsbC5leHRyYUhvb2tQcm9wc31cbiAgICAgICAgICAgICAgZXh0cmFEYXRhQXR0cnM9e2NlbGwuZXh0cmFEYXRhQXR0cnN9XG4gICAgICAgICAgICAgIGV4dHJhQ2xhc3NOYW1lcz17Y2VsbC5leHRyYUNsYXNzTmFtZXN9XG4gICAgICAgICAgICAgIG1vcmVDbnQ9e21vcmVDbnRzW2NvbF19XG4gICAgICAgICAgICAgIGJ1aWxkTW9yZUxpbmtUZXh0PXtwcm9wcy5idWlsZE1vcmVMaW5rVGV4dH1cbiAgICAgICAgICAgICAgb25Nb3JlQ2xpY2s9e3Byb3BzLm9uTW9yZUNsaWNrfVxuICAgICAgICAgICAgICBzZWdJc0hpZGRlbj17c2VnSXNIaWRkZW59XG4gICAgICAgICAgICAgIG1vcmVNYXJnaW5Ub3A9e21vcmVUb3BzW2NvbF0gLyogcmVuYW1lICovfVxuICAgICAgICAgICAgICBzZWdzQnlFYWNoQ29sPXtzZWdzQnlFYWNoQ29sW2NvbF19XG4gICAgICAgICAgICAgIGZnUGFkZGluZ0JvdHRvbT17cGFkZGluZ0JvdHRvbXNbY29sXX1cbiAgICAgICAgICAgICAgZmdDb250ZW50RWxSZWY9e3RoaXMuZmdFbFJlZnMuY3JlYXRlUmVmKGNlbGwua2V5KX1cbiAgICAgICAgICAgICAgZmdDb250ZW50PXsoIC8vIEZyYWdtZW50IHNjb3BlcyB0aGUga2V5c1xuICAgICAgICAgICAgICAgIDxGcmFnbWVudD5cbiAgICAgICAgICAgICAgICAgIDxGcmFnbWVudD57bm9ybWFsRmdOb2Rlc308L0ZyYWdtZW50PlxuICAgICAgICAgICAgICAgICAgPEZyYWdtZW50PnttaXJyb3JGZ05vZGVzfTwvRnJhZ21lbnQ+XG4gICAgICAgICAgICAgICAgPC9GcmFnbWVudD5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgYmdDb250ZW50PXsoIC8vIEZyYWdtZW50IHNjb3BlcyB0aGUga2V5c1xuICAgICAgICAgICAgICAgIDxGcmFnbWVudD5cbiAgICAgICAgICAgICAgICAgIHt0aGlzLnJlbmRlckZpbGxTZWdzKGhpZ2hsaWdodFNlZ3NCeUNvbFtjb2xdLCAnaGlnaGxpZ2h0Jyl9XG4gICAgICAgICAgICAgICAgICB7dGhpcy5yZW5kZXJGaWxsU2VncyhidXNpbmVzc0hvdXJzQnlDb2xbY29sXSwgJ25vbi1idXNpbmVzcycpfVxuICAgICAgICAgICAgICAgICAge3RoaXMucmVuZGVyRmlsbFNlZ3MoYmdFdmVudFNlZ3NCeUNvbFtjb2xdLCAnYmctZXZlbnQnKX1cbiAgICAgICAgICAgICAgICA8L0ZyYWdtZW50PlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApXG4gICAgICAgIH0pfVxuICAgICAgPC90cj5cbiAgICApXG4gIH1cblxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMudXBkYXRlU2l6aW5nKHRydWUpXG4gIH1cblxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IFRhYmxlUm93UHJvcHMsIHByZXZTdGF0ZTogVGFibGVSb3dTdGF0ZSkge1xuICAgIGxldCBjdXJyZW50UHJvcHMgPSB0aGlzLnByb3BzXG5cbiAgICB0aGlzLnVwZGF0ZVNpemluZyhcbiAgICAgICFpc1Byb3BzRXF1YWwocHJldlByb3BzLCBjdXJyZW50UHJvcHMpXG4gICAgKVxuICB9XG5cblxuICBnZXRIaWdobGlnaHRTZWdzKCk6IFRhYmxlU2VnW10ge1xuICAgIGxldCB7IHByb3BzIH0gPSB0aGlzXG5cbiAgICBpZiAocHJvcHMuZXZlbnREcmFnICYmIHByb3BzLmV2ZW50RHJhZy5zZWdzLmxlbmd0aCkgeyAvLyBtZXNzeSBjaGVja1xuICAgICAgcmV0dXJuIHByb3BzLmV2ZW50RHJhZy5zZWdzIGFzIFRhYmxlU2VnW11cblxuICAgIH0gZWxzZSBpZiAocHJvcHMuZXZlbnRSZXNpemUgJiYgcHJvcHMuZXZlbnRSZXNpemUuc2Vncy5sZW5ndGgpIHsgLy8gbWVzc3kgY2hlY2tcbiAgICAgIHJldHVybiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzIGFzIFRhYmxlU2VnW11cblxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3NcbiAgICB9XG4gIH1cblxuXG4gIGdldE1pcnJvclNlZ3MoKTogVGFibGVTZWdbXSB7XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcblxuICAgIGlmIChwcm9wcy5ldmVudFJlc2l6ZSAmJiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzLmxlbmd0aCkgeyAvLyBtZXNzeSBjaGVja1xuICAgICAgcmV0dXJuIHByb3BzLmV2ZW50UmVzaXplLnNlZ3MgYXMgVGFibGVTZWdbXVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgfVxuXG5cbiAgcmVuZGVyRmdTZWdzKFxuICAgIHNlZ3M6IFRhYmxlU2VnW10sXG4gICAgc2VnSXNIaWRkZW46IHsgW2luc3RhbmNlSWQ6IHN0cmluZ106IGJvb2xlYW4gfSwgLy8gZG9lcyBOT1QgbWVhbiBkaXNwbGF5OmhpZGRlblxuICAgIHNlZ1RvcHM6IHsgW2luc3RhbmNlSWQ6IHN0cmluZ106IG51bWJlciB9LFxuICAgIHNlZ01hcmdpblRvcHM6IHsgW2luc3RhbmNlSWQ6IHN0cmluZ106IG51bWJlciB9LFxuICAgIHNlbGVjdGVkSW5zdGFuY2VIYXNoOiB7IFtpbnN0YW5jZUlkOiBzdHJpbmddOiBhbnkgfSxcbiAgICB0b2RheVJhbmdlOiBEYXRlUmFuZ2UsXG4gICAgaXNEcmFnZ2luZz86IGJvb2xlYW4sXG4gICAgaXNSZXNpemluZz86IGJvb2xlYW4sXG4gICAgaXNEYXRlU2VsZWN0aW5nPzogYm9vbGVhblxuICApOiBWTm9kZVtdIHtcbiAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzXG4gICAgbGV0IHsgZXZlbnRTZWxlY3Rpb24gfSA9IHRoaXMucHJvcHNcbiAgICBsZXQgeyBmcmFtZVBvc2l0aW9ucyB9ID0gdGhpcy5zdGF0ZVxuICAgIGxldCBkZWZhdWx0RGlzcGxheUV2ZW50RW5kID0gdGhpcy5wcm9wcy5jZWxscy5sZW5ndGggPT09IDEgLy8gY29sQ250ID09PSAxXG4gICAgbGV0IG5vZGVzOiBWTm9kZVtdID0gW11cblxuICAgIGlmIChmcmFtZVBvc2l0aW9ucykge1xuICAgICAgZm9yIChsZXQgc2VnIG9mIHNlZ3MpIHtcbiAgICAgICAgbGV0IGluc3RhbmNlSWQgPSBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkXG4gICAgICAgIGxldCBpc01pcnJvciA9IGlzRHJhZ2dpbmcgfHwgaXNSZXNpemluZyB8fCBpc0RhdGVTZWxlY3RpbmdcbiAgICAgICAgbGV0IGlzU2VsZWN0ZWQgPSBzZWxlY3RlZEluc3RhbmNlSGFzaFtpbnN0YW5jZUlkXVxuICAgICAgICBsZXQgaXNJbnZpc2libGUgPSBzZWdJc0hpZGRlbltpbnN0YW5jZUlkXSB8fCBpc1NlbGVjdGVkXG4gICAgICAgIGxldCBpc0Fic29sdXRlID0gc2VnSXNIaWRkZW5baW5zdGFuY2VJZF0gfHwgaXNNaXJyb3IgfHwgc2VnLmZpcnN0Q29sICE9PSBzZWcubGFzdENvbCB8fCAhc2VnLmlzU3RhcnQgfHwgIXNlZy5pc0VuZCAvLyBUT0RPOiBzaW1wbGVyIHdheT8gTk9UIERSWVxuICAgICAgICBsZXQgbWFyZ2luVG9wOiBDc3NEaW1WYWx1ZVxuICAgICAgICBsZXQgdG9wOiBDc3NEaW1WYWx1ZVxuICAgICAgICBsZXQgbGVmdDogQ3NzRGltVmFsdWVcbiAgICAgICAgbGV0IHJpZ2h0OiBDc3NEaW1WYWx1ZVxuXG4gICAgICAgIGlmIChpc0Fic29sdXRlKSB7XG4gICAgICAgICAgdG9wID0gc2VnVG9wc1tpbnN0YW5jZUlkXVxuXG4gICAgICAgICAgaWYgKGNvbnRleHQuaXNSdGwpIHtcbiAgICAgICAgICAgIHJpZ2h0ID0gMFxuICAgICAgICAgICAgbGVmdCA9IGZyYW1lUG9zaXRpb25zLmxlZnRzW3NlZy5sYXN0Q29sXSAtIGZyYW1lUG9zaXRpb25zLmxlZnRzW3NlZy5maXJzdENvbF1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVmdCA9IDBcbiAgICAgICAgICAgIHJpZ2h0ID0gZnJhbWVQb3NpdGlvbnMucmlnaHRzW3NlZy5maXJzdENvbF0gLSBmcmFtZVBvc2l0aW9ucy5yaWdodHNbc2VnLmxhc3RDb2xdXG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFyZ2luVG9wID0gc2VnTWFyZ2luVG9wc1tpbnN0YW5jZUlkXVxuICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAga25vd24gYnVnOiBldmVudHMgdGhhdCBhcmUgZm9yY2UgdG8gYmUgbGlzdC1pdGVtIGJ1dCBzcGFuIG11bHRpcGxlIGRheXMgc3RpbGwgdGFrZSB1cCBzcGFjZSBpbiBsYXRlciBjb2x1bW5zXG4gICAgICAgICovXG4gICAgICAgIG5vZGVzLnB1c2goXG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAgY2xhc3NOYW1lPXsnZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNzJyArIChpc0Fic29sdXRlID8gJyBmYy1kYXlncmlkLWV2ZW50LWhhcm5lc3MtYWJzJyA6ICcnKX1cbiAgICAgICAgICAgIGtleT17aW5zdGFuY2VJZH1cbiAgICAgICAgICAgIHJlZj17aXNNaXJyb3IgPyBudWxsIDogdGhpcy5zZWdIYXJuZXNzUmVmcy5jcmVhdGVSZWYoaW5zdGFuY2VJZCArICc6JyArIHNlZy5maXJzdENvbCkgLyogaW4gcHJpbnQgbW9kZSB3aGVuIGluIG11bHQgY29scywgY291bGQgY29sbGlkZSAqL31cbiAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgIHZpc2liaWxpdHk6IGlzSW52aXNpYmxlID8gJ2hpZGRlbicgOiAoJycgYXMgYW55KSxcbiAgICAgICAgICAgICAgbWFyZ2luVG9wOiBtYXJnaW5Ub3AgfHwgJycsXG4gICAgICAgICAgICAgIHRvcDogdG9wIHx8ICcnLFxuICAgICAgICAgICAgICBsZWZ0OiBsZWZ0IHx8ICcnLFxuICAgICAgICAgICAgICByaWdodDogcmlnaHQgfHwgJydcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2hhc0xpc3RJdGVtRGlzcGxheShzZWcpID9cbiAgICAgICAgICAgICAgPFRhYmxlTGlzdEl0ZW1FdmVudFxuICAgICAgICAgICAgICAgIHNlZz17c2VnfVxuICAgICAgICAgICAgICAgIGlzRHJhZ2dpbmc9e2lzRHJhZ2dpbmd9XG4gICAgICAgICAgICAgICAgaXNTZWxlY3RlZD17aW5zdGFuY2VJZCA9PT0gZXZlbnRTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgZGVmYXVsdERpc3BsYXlFdmVudEVuZD17ZGVmYXVsdERpc3BsYXlFdmVudEVuZH1cbiAgICAgICAgICAgICAgICB7Li4uZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UpfVxuICAgICAgICAgICAgICAvPiA6XG4gICAgICAgICAgICAgIDxUYWJsZUJsb2NrRXZlbnRcbiAgICAgICAgICAgICAgICBzZWc9e3NlZ31cbiAgICAgICAgICAgICAgICBpc0RyYWdnaW5nPXtpc0RyYWdnaW5nfVxuICAgICAgICAgICAgICAgIGlzUmVzaXppbmc9e2lzUmVzaXppbmd9XG4gICAgICAgICAgICAgICAgaXNEYXRlU2VsZWN0aW5nPXtpc0RhdGVTZWxlY3Rpbmd9XG4gICAgICAgICAgICAgICAgaXNTZWxlY3RlZD17aW5zdGFuY2VJZCA9PT0gZXZlbnRTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgZGVmYXVsdERpc3BsYXlFdmVudEVuZD17ZGVmYXVsdERpc3BsYXlFdmVudEVuZH1cbiAgICAgICAgICAgICAgICB7Li4uZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UpfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVzXG4gIH1cblxuXG4gIHJlbmRlckZpbGxTZWdzKHNlZ3M6IFRhYmxlU2VnW10sIGZpbGxUeXBlOiBzdHJpbmcpIHtcbiAgICBsZXQgeyBpc1J0bCB9ID0gdGhpcy5jb250ZXh0XG4gICAgbGV0IHsgdG9kYXlSYW5nZSB9ID0gdGhpcy5wcm9wc1xuICAgIGxldCB7IGZyYW1lUG9zaXRpb25zIH0gPSB0aGlzLnN0YXRlXG4gICAgbGV0IG5vZGVzOiBWTm9kZVtdID0gW11cblxuICAgIGlmIChmcmFtZVBvc2l0aW9ucykge1xuICAgICAgZm9yIChsZXQgc2VnIG9mIHNlZ3MpIHtcblxuICAgICAgICBsZXQgbGVmdFJpZ2h0Q3NzID0gaXNSdGwgPyB7XG4gICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgbGVmdDogZnJhbWVQb3NpdGlvbnMubGVmdHNbc2VnLmxhc3RDb2xdIC0gZnJhbWVQb3NpdGlvbnMubGVmdHNbc2VnLmZpcnN0Q29sXVxuICAgICAgICB9IDoge1xuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgcmlnaHQ6IGZyYW1lUG9zaXRpb25zLnJpZ2h0c1tzZWcuZmlyc3RDb2xdIC0gZnJhbWVQb3NpdGlvbnMucmlnaHRzW3NlZy5sYXN0Q29sXSxcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGVzLnB1c2goXG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAga2V5PXtidWlsZEV2ZW50UmFuZ2VLZXkoc2VnLmV2ZW50UmFuZ2UpfVxuICAgICAgICAgICAgY2xhc3NOYW1lPSdmYy1kYXlncmlkLWJnLWhhcm5lc3MnXG4gICAgICAgICAgICBzdHlsZT17bGVmdFJpZ2h0Q3NzfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtmaWxsVHlwZSA9PT0gJ2JnLWV2ZW50JyA/XG4gICAgICAgICAgICAgIDxCZ0V2ZW50IHNlZz17c2VnfSB7Li4uZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UpfSAvPiA6XG4gICAgICAgICAgICAgIHJlbmRlckZpbGwoZmlsbFR5cGUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChGcmFnbWVudCwge30sIC4uLm5vZGVzKVxuICB9XG5cblxuICB1cGRhdGVTaXppbmcoaXNFeHRlcm5hbFNpemluZ0NoYW5nZSkge1xuICAgIGxldCB7IHByb3BzLCBmcmFtZUVsUmVmcyB9ID0gdGhpc1xuXG4gICAgaWYgKHByb3BzLmNsaWVudFdpZHRoICE9PSBudWxsKSB7IC8vIHBvc2l0aW9uaW5nIHJlYWR5P1xuXG4gICAgICBpZiAoaXNFeHRlcm5hbFNpemluZ0NoYW5nZSkge1xuICAgICAgICBsZXQgZnJhbWVFbHMgPSBwcm9wcy5jZWxscy5tYXAoKGNlbGwpID0+IGZyYW1lRWxSZWZzLmN1cnJlbnRNYXBbY2VsbC5rZXldKVxuXG4gICAgICAgIGlmIChmcmFtZUVscy5sZW5ndGgpIHtcbiAgICAgICAgICBsZXQgb3JpZ2luRWwgPSB0aGlzLnJvb3RFbFJlZi5jdXJyZW50XG5cbiAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgLy8gd2lsbCB0cmlnZ2VyIGlzQ2VsbFBvc2l0aW9uc0NoYW5nZWQuLi5cbiAgICAgICAgICAgIGZyYW1lUG9zaXRpb25zOiBuZXcgUG9zaXRpb25DYWNoZShcbiAgICAgICAgICAgICAgb3JpZ2luRWwsXG4gICAgICAgICAgICAgIGZyYW1lRWxzLFxuICAgICAgICAgICAgICB0cnVlLCAvLyBpc0hvcml6b250YWxcbiAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBsaW1pdEJ5Q29udGVudEhlaWdodCA9IHByb3BzLmRheU1heEV2ZW50cyA9PT0gdHJ1ZSB8fCBwcm9wcy5kYXlNYXhFdmVudFJvd3MgPT09IHRydWVcblxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHNlZ0hlaWdodHM6IHRoaXMuY29tcHV0ZVNlZ0hlaWdodHMoKSxcbiAgICAgICAgbWF4Q29udGVudEhlaWdodDogbGltaXRCeUNvbnRlbnRIZWlnaHQgPyB0aGlzLmNvbXB1dGVNYXhDb250ZW50SGVpZ2h0KCkgOiBudWxsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG5cbiAgY29tcHV0ZVNlZ0hlaWdodHMoKSB7IC8vIHF1ZXJ5XG4gICAgcmV0dXJuIG1hcEhhc2godGhpcy5zZWdIYXJuZXNzUmVmcy5jdXJyZW50TWFwLCAoZXZlbnRIYXJuZXNzRWwpID0+IChcbiAgICAgIGV2ZW50SGFybmVzc0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodFxuICAgICkpXG4gIH1cblxuXG4gIGNvbXB1dGVNYXhDb250ZW50SGVpZ2h0KCkge1xuICAgIGxldCBmaXJzdEtleSA9IHRoaXMucHJvcHMuY2VsbHNbMF0ua2V5XG4gICAgbGV0IGNlbGxFbCA9IHRoaXMuY2VsbEVsUmVmcy5jdXJyZW50TWFwW2ZpcnN0S2V5XVxuICAgIGxldCBmY0NvbnRhaW5lckVsID0gdGhpcy5mZ0VsUmVmcy5jdXJyZW50TWFwW2ZpcnN0S2V5XVxuXG4gICAgcmV0dXJuIGNlbGxFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20gLSBmY0NvbnRhaW5lckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcFxuICB9XG5cblxuICBwdWJsaWMgZ2V0Q2VsbEVscygpIHtcbiAgICBsZXQgZWxNYXAgPSB0aGlzLmNlbGxFbFJlZnMuY3VycmVudE1hcFxuXG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2VsbHMubWFwKChjZWxsKSA9PiBlbE1hcFtjZWxsLmtleV0pXG4gIH1cblxufVxuXG5UYWJsZVJvdy5hZGRTdGF0ZUVxdWFsaXR5KHtcbiAgc2VnSGVpZ2h0czogaXNQcm9wc0VxdWFsXG59KVxuIiwiaW1wb3J0IHtcbiAgY3JlYXRlRWxlbWVudCwgQ29tcG9uZW50Q2hpbGRyZW4sIGFwcGx5U3R5bGUsIEJhc2VDb21wb25lbnQsIERlbGF5ZWRSdW5uZXIsIFJlZiwgc2V0UmVmLCBEaWN0aW9uYXJ5XG59IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgUG9wb3ZlclByb3BzIHtcbiAgdGl0bGU6IHN0cmluZ1xuICBleHRyYUNsYXNzTmFtZXM/OiBzdHJpbmdbXVxuICBleHRyYUF0dHJzPzogRGljdGlvbmFyeVxuICBhbGlnbm1lbnRFbDogSFRNTEVsZW1lbnRcbiAgdG9wQWxpZ25tZW50RWw/OiBIVE1MRWxlbWVudFxuICBvbkNsb3NlPzogKCkgPT4gdm9pZFxuICBlbFJlZj86IFJlZjxIVE1MRGl2RWxlbWVudD5cbiAgY2hpbGRyZW4/OiBDb21wb25lbnRDaGlsZHJlblxufVxuXG5jb25zdCBQQURESU5HX0ZST01fVklFV1BPUlQgPSAxMFxuY29uc3QgU0NST0xMX0RFQk9VTkNFID0gMTBcblxuXG5leHBvcnQgY2xhc3MgUG9wb3ZlciBleHRlbmRzIEJhc2VDb21wb25lbnQ8UG9wb3ZlclByb3BzPiB7XG5cbiAgcHJpdmF0ZSByb290RWw6IEhUTUxFbGVtZW50XG4gIHByaXZhdGUgcmVwb3NpdGlvbmVyID0gbmV3IERlbGF5ZWRSdW5uZXIodGhpcy51cGRhdGVTaXplLmJpbmQodGhpcykpXG5cblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgdGhlbWUgfSA9IHRoaXMuY29udGV4dFxuICAgIGxldCB7IHByb3BzIH0gPSB0aGlzXG4gICAgbGV0IGNsYXNzTmFtZXMgPSBbXG4gICAgICAnZmMtcG9wb3ZlcicsXG4gICAgICB0aGVtZS5nZXRDbGFzcygncG9wb3ZlcicpXG4gICAgXS5jb25jYXQoXG4gICAgICBwcm9wcy5leHRyYUNsYXNzTmFtZXMgfHwgW11cbiAgICApXG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZXMuam9pbignICcpfSB7Li4ucHJvcHMuZXh0cmFBdHRyc30gcmVmPXt0aGlzLmhhbmRsZVJvb3RFbH0+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXsnZmMtcG9wb3Zlci1oZWFkZXIgJyArIHRoZW1lLmdldENsYXNzKCdwb3BvdmVySGVhZGVyJyl9PlxuICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT0nZmMtcG9wb3Zlci10aXRsZSc+XG4gICAgICAgICAgICB7cHJvcHMudGl0bGV9XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17J2ZjLXBvcG92ZXItY2xvc2UgJyArIHRoZW1lLmdldEljb25DbGFzcygnY2xvc2UnKX0gb25DbGljaz17dGhpcy5oYW5kbGVDbG9zZUNsaWNrfT48L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17J2ZjLXBvcG92ZXItYm9keSAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3BvcG92ZXJDb250ZW50Jyl9PlxuICAgICAgICAgIHtwcm9wcy5jaGlsZHJlbn1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cblxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlRG9jdW1lbnRNb3VzZWRvd24pXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVEb2N1bWVudFNjcm9sbClcbiAgICB0aGlzLnVwZGF0ZVNpemUoKVxuICB9XG5cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZURvY3VtZW50TW91c2Vkb3duKVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlRG9jdW1lbnRTY3JvbGwpXG4gIH1cblxuXG4gIGhhbmRsZVJvb3RFbCA9IChlbDogSFRNTEVsZW1lbnQgfCBudWxsKSA9PiB7XG4gICAgdGhpcy5yb290RWwgPSBlbFxuXG4gICAgaWYgKHRoaXMucHJvcHMuZWxSZWYpIHtcbiAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBlbClcbiAgICB9XG4gIH1cblxuXG4gIC8vIFRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyAqYW55d2hlcmUqIGluIHRoZSBkb2N1bWVudCwgZm9yIHRoZSBhdXRvSGlkZSBmZWF0dXJlXG4gIGhhbmRsZURvY3VtZW50TW91c2Vkb3duID0gKGV2KSA9PiB7XG4gICAgbGV0IHsgb25DbG9zZSB9ID0gdGhpcy5wcm9wc1xuXG4gICAgLy8gb25seSBoaWRlIHRoZSBwb3BvdmVyIGlmIHRoZSBjbGljayBoYXBwZW5lZCBvdXRzaWRlIHRoZSBwb3BvdmVyXG4gICAgaWYgKG9uQ2xvc2UgJiYgIXRoaXMucm9vdEVsLmNvbnRhaW5zKGV2LnRhcmdldCkpIHtcbiAgICAgIG9uQ2xvc2UoKVxuICAgIH1cbiAgfVxuXG5cbiAgaGFuZGxlRG9jdW1lbnRTY3JvbGwgPSAoKSA9PiB7XG4gICAgdGhpcy5yZXBvc2l0aW9uZXIucmVxdWVzdChTQ1JPTExfREVCT1VOQ0UpXG4gIH1cblxuXG4gIGhhbmRsZUNsb3NlQ2xpY2sgPSAoKSA9PiB7XG4gICAgbGV0IHsgb25DbG9zZSB9ID0gdGhpcy5wcm9wc1xuXG4gICAgaWYgKG9uQ2xvc2UpIHtcbiAgICAgIG9uQ2xvc2UoKVxuICAgIH1cbiAgfVxuXG5cbiAgLy8gVE9ETzogYWRqdXN0IG9uIHdpbmRvdyByZXNpemVcblxuXG4gIC8qXG4gIE5PVEU6IHRoZSBwb3BvdmVyIGlzIHBvc2l0aW9uOmZpeGVkLCBzbyBjb29yZGluYXRlcyBhcmUgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0XG4gIE5PVEU6IHRoZSBQQVJFTlQgY2FsbHMgdGhpcyBhcyB3ZWxsLCBvbiB3aW5kb3cgcmVzaXplLiB3ZSB3b3VsZCBoYXZlIHdhbnRlZCB0byB1c2UgdGhlIHJlcG9zaXRpb25lcixcbiAgICAgICAgYnV0IG5lZWQgdG8gZW5zdXJlIHRoYXQgYWxsIG90aGVyIGNvbXBvbmVudHMgaGF2ZSB1cGRhdGVkIHNpemUgZmlyc3QgKGZvciBhbGlnbm1lbnRFbClcbiAgKi9cbiAgcHJpdmF0ZSB1cGRhdGVTaXplKCkge1xuICAgIGxldCB7IGFsaWdubWVudEVsLCB0b3BBbGlnbm1lbnRFbCB9ID0gdGhpcy5wcm9wc1xuICAgIGxldCB7IHJvb3RFbCB9ID0gdGhpc1xuXG4gICAgaWYgKCFyb290RWwpIHtcbiAgICAgIHJldHVybiAvLyBub3Qgc3VyZSB3aHkgdGhpcyB3YXMgbnVsbCwgYnV0IHdlIHNob3VsZG4ndCBsZXQgZXh0ZXJuYWwgY29tcG9uZW50cyBjYWxsIHVwZGF0ZVNpemUoKSBhbnl3YXlcbiAgICB9XG5cbiAgICBsZXQgZGltcyA9IHJvb3RFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSAvLyBvbmx5IHVzZWQgZm9yIHdpZHRoLGhlaWdodFxuICAgIGxldCBhbGlnbm1lbnQgPSBhbGlnbm1lbnRFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG4gICAgbGV0IHRvcCA9IHRvcEFsaWdubWVudEVsID8gdG9wQWxpZ25tZW50RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIDogYWxpZ25tZW50LnRvcFxuICAgIHRvcCA9IE1hdGgubWluKHRvcCwgd2luZG93LmlubmVySGVpZ2h0IC0gZGltcy5oZWlnaHQgLSBQQURESU5HX0ZST01fVklFV1BPUlQpXG4gICAgdG9wID0gTWF0aC5tYXgodG9wLCBQQURESU5HX0ZST01fVklFV1BPUlQpXG5cbiAgICBsZXQgbGVmdDogbnVtYmVyXG5cbiAgICBpZiAodGhpcy5jb250ZXh0LmlzUnRsKSB7XG4gICAgICBsZWZ0ID0gYWxpZ25tZW50LnJpZ2h0IC0gZGltcy53aWR0aFxuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0ID0gYWxpZ25tZW50LmxlZnRcbiAgICB9XG5cbiAgICBsZWZ0ID0gTWF0aC5taW4obGVmdCwgd2luZG93LmlubmVyV2lkdGggLSBkaW1zLndpZHRoIC0gUEFERElOR19GUk9NX1ZJRVdQT1JUKVxuICAgIGxlZnQgPSBNYXRoLm1heChsZWZ0LCBQQURESU5HX0ZST01fVklFV1BPUlQpXG5cbiAgICBhcHBseVN0eWxlKHJvb3RFbCwgeyB0b3AsIGxlZnQgfSlcbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBEYXRlQ29tcG9uZW50LCBEYXRlTWFya2VyLCBjcmVhdGVFbGVtZW50LCBFdmVudEluc3RhbmNlSGFzaCwgSGl0LCBhZGREYXlzLCBEYXRlUmFuZ2UsIGdldFNlZ01ldGEsIERheUNlbGxSb290LCBEYXlDZWxsQ29udGVudCwgRGF0ZVByb2ZpbGUgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcbmltcG9ydCB7IFRhYmxlU2VnIH0gZnJvbSAnLi9UYWJsZVNlZydcbmltcG9ydCB7IFRhYmxlQmxvY2tFdmVudCB9IGZyb20gJy4vVGFibGVCbG9ja0V2ZW50J1xuaW1wb3J0IHsgVGFibGVMaXN0SXRlbUV2ZW50IH0gZnJvbSAnLi9UYWJsZUxpc3RJdGVtRXZlbnQnXG5pbXBvcnQgeyBQb3BvdmVyIH0gZnJvbSAnLi9Qb3BvdmVyJ1xuaW1wb3J0IHsgaGFzTGlzdEl0ZW1EaXNwbGF5IH0gZnJvbSAnLi9ldmVudC1yZW5kZXJpbmcnXG5cblxuZXhwb3J0IGludGVyZmFjZSBNb3JlUG9wb3ZlclByb3BzIHtcbiAgZGF0ZTogRGF0ZU1hcmtlclxuICBkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGVcbiAgc2VnczogVGFibGVTZWdbXVxuICBzZWxlY3RlZEluc3RhbmNlSWQ6IHN0cmluZ1xuICBoaWRkZW5JbnN0YW5jZXM6IEV2ZW50SW5zdGFuY2VIYXNoXG4gIGFsaWdubWVudEVsOiBIVE1MRWxlbWVudFxuICB0b3BBbGlnbm1lbnRFbD86IEhUTUxFbGVtZW50XG4gIG9uQ2xvc2VDbGljaz86ICgpID0+IHZvaWRcbiAgdG9kYXlSYW5nZTogRGF0ZVJhbmdlXG59XG5cblxuZXhwb3J0IGNsYXNzIE1vcmVQb3BvdmVyIGV4dGVuZHMgRGF0ZUNvbXBvbmVudDxNb3JlUG9wb3ZlclByb3BzPiB7XG5cbiAgcHJpdmF0ZSBwb3BvdmVyRWw6IEhUTUxFbGVtZW50XG5cblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgb3B0aW9ucywgZGF0ZUVudiB9ID0gdGhpcy5jb250ZXh0XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcbiAgICBsZXQgeyBkYXRlLCBoaWRkZW5JbnN0YW5jZXMsIHRvZGF5UmFuZ2UsIGRhdGVQcm9maWxlLCBzZWxlY3RlZEluc3RhbmNlSWQgfSA9IHByb3BzXG4gICAgbGV0IHRpdGxlID0gZGF0ZUVudi5mb3JtYXQoZGF0ZSwgb3B0aW9ucy5kYXlQb3BvdmVyRm9ybWF0KVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxEYXlDZWxsUm9vdCBkYXRlPXtkYXRlfSBkYXRlUHJvZmlsZT17ZGF0ZVByb2ZpbGV9IHRvZGF5UmFuZ2U9e3RvZGF5UmFuZ2V9IGVsUmVmPXt0aGlzLmhhbmRsZVBvcG92ZXJFbH0+XG4gICAgICAgIHsocm9vdEVsUmVmLCBkYXlDbGFzc05hbWVzLCBkYXRhQXR0cnMpID0+IChcbiAgICAgICAgICA8UG9wb3ZlclxuICAgICAgICAgICAgZWxSZWY9e3Jvb3RFbFJlZn1cbiAgICAgICAgICAgIHRpdGxlPXt0aXRsZX1cbiAgICAgICAgICAgIGV4dHJhQ2xhc3NOYW1lcz17WyAnZmMtbW9yZS1wb3BvdmVyJyBdLmNvbmNhdChkYXlDbGFzc05hbWVzKX1cbiAgICAgICAgICAgIGV4dHJhQXR0cnM9e2RhdGFBdHRyc31cbiAgICAgICAgICAgIG9uQ2xvc2U9e3Byb3BzLm9uQ2xvc2VDbGlja31cbiAgICAgICAgICAgIGFsaWdubWVudEVsPXtwcm9wcy5hbGlnbm1lbnRFbH1cbiAgICAgICAgICAgIHRvcEFsaWdubWVudEVsPXtwcm9wcy50b3BBbGlnbm1lbnRFbH1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8RGF5Q2VsbENvbnRlbnQgZGF0ZT17ZGF0ZX0gZGF0ZVByb2ZpbGU9e2RhdGVQcm9maWxlfSB0b2RheVJhbmdlPXt0b2RheVJhbmdlfT5cbiAgICAgICAgICAgICAgeyhpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpID0+IChcbiAgICAgICAgICAgICAgICBpbm5lckNvbnRlbnQgJiZcbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdmYy1tb3JlLXBvcG92ZXItbWlzYycgcmVmPXtpbm5lckVsUmVmfT57aW5uZXJDb250ZW50fTwvZGl2PlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgPC9EYXlDZWxsQ29udGVudD5cbiAgICAgICAgICAgIHtwcm9wcy5zZWdzLm1hcCgoc2VnKSA9PiB7XG4gICAgICAgICAgICAgIGxldCBpbnN0YW5jZUlkID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZFxuXG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPSdmYy1kYXlncmlkLWV2ZW50LWhhcm5lc3MnXG4gICAgICAgICAgICAgICAgICBrZXk9e2luc3RhbmNlSWR9XG4gICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBoaWRkZW5JbnN0YW5jZXNbaW5zdGFuY2VJZF0gPyAnaGlkZGVuJyA6ICgnJyBhcyBhbnkpXG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIHtoYXNMaXN0SXRlbURpc3BsYXkoc2VnKSA/XG4gICAgICAgICAgICAgICAgICAgIDxUYWJsZUxpc3RJdGVtRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICBzZWc9e3NlZ31cbiAgICAgICAgICAgICAgICAgICAgICBpc0RyYWdnaW5nPXtmYWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICBpc1NlbGVjdGVkPXtpbnN0YW5jZUlkID09PSBzZWxlY3RlZEluc3RhbmNlSWR9XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdERpc3BsYXlFdmVudEVuZD17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgey4uLmdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlKX1cbiAgICAgICAgICAgICAgICAgICAgLz4gOlxuICAgICAgICAgICAgICAgICAgICA8VGFibGVCbG9ja0V2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgc2VnPXtzZWd9XG4gICAgICAgICAgICAgICAgICAgICAgaXNEcmFnZ2luZz17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgaXNSZXNpemluZz17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgaXNEYXRlU2VsZWN0aW5nPXtmYWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICBpc1NlbGVjdGVkPXtpbnN0YW5jZUlkID09PSBzZWxlY3RlZEluc3RhbmNlSWR9XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdERpc3BsYXlFdmVudEVuZD17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgey4uLmdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlKX1cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSl9XG4gICAgICAgICAgPC9Qb3BvdmVyPlxuICAgICAgICApfVxuICAgICAgPC9EYXlDZWxsUm9vdD5cbiAgICApXG4gIH1cblxuXG4gIGhhbmRsZVBvcG92ZXJFbCA9IChwb3BvdmVyRWw6IEhUTUxFbGVtZW50IHwgbnVsbCkgPT4ge1xuICAgIHRoaXMucG9wb3ZlckVsID0gcG9wb3ZlckVsXG5cbiAgICBpZiAocG9wb3ZlckVsKSB7XG4gICAgICB0aGlzLmNvbnRleHQucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzLCB7XG4gICAgICAgIGVsOiBwb3BvdmVyRWwsXG4gICAgICAgIHVzZUV2ZW50Q2VudGVyOiBmYWxzZVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb250ZXh0LnVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzKVxuICAgIH1cbiAgfVxuXG5cbiAgcXVlcnlIaXQocG9zaXRpb25MZWZ0OiBudW1iZXIsIHBvc2l0aW9uVG9wOiBudW1iZXIsIGVsV2lkdGg6IG51bWJlciwgZWxIZWlnaHQ6IG51bWJlcik6IEhpdCB8IG51bGwge1xuICAgIGxldCBkYXRlID0gdGhpcy5wcm9wcy5kYXRlXG5cbiAgICBpZiAocG9zaXRpb25MZWZ0IDwgZWxXaWR0aCAmJiBwb3NpdGlvblRvcCA8IGVsSGVpZ2h0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb21wb25lbnQ6IHRoaXMsXG4gICAgICAgIGRhdGVTcGFuOiB7XG4gICAgICAgICAgYWxsRGF5OiB0cnVlLFxuICAgICAgICAgIHJhbmdlOiB7IHN0YXJ0OiBkYXRlLCBlbmQ6IGFkZERheXMoZGF0ZSwgMSkgfVxuICAgICAgICB9LFxuICAgICAgICBkYXlFbDogdGhpcy5wb3BvdmVyRWwsXG4gICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICByaWdodDogZWxXaWR0aCxcbiAgICAgICAgICBib3R0b206IGVsSGVpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIGxheWVyOiAxXG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICBpc1BvcG92ZXIoKSB7XG4gICAgcmV0dXJuIHRydWUgLy8gZ3Jvc3NcbiAgfVxuXG59XG4iLCJpbXBvcnQge1xuICBFdmVudFNlZ1VpSW50ZXJhY3Rpb25TdGF0ZSxcbiAgVk5vZGUsXG4gIERhdGVDb21wb25lbnQsXG4gIFJlZk9iamVjdCxcbiAgQ3NzRGltVmFsdWUsXG4gIGNyZWF0ZUVsZW1lbnQsXG4gIFBvc2l0aW9uQ2FjaGUsXG4gIFJlZixcbiAgbWVtb2l6ZSxcbiAgYWRkRGF5cyxcbiAgUmVmTWFwLFxuICBzZXRSZWYsXG4gIERhdGVSYW5nZSxcbiAgTm93VGltZXIsXG4gIERhdGVNYXJrZXIsXG4gIEV2ZW50QXBpLFxuICBEYXRlUHJvZmlsZSxcbiAgRnJhZ21lbnRcbn0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5pbXBvcnQgeyBUYWJsZVNlZywgc3BsaXRTZWdzQnlSb3csIHNwbGl0SW50ZXJhY3Rpb25CeVJvdyB9IGZyb20gJy4vVGFibGVTZWcnXG5pbXBvcnQgeyBUYWJsZVJvdyB9IGZyb20gJy4vVGFibGVSb3cnXG5pbXBvcnQgeyBUYWJsZUNlbGxNb2RlbCwgTW9yZUxpbmtBcmcgfSBmcm9tICcuL1RhYmxlQ2VsbCdcbmltcG9ydCB7IE1vcmVQb3BvdmVyIH0gZnJvbSAnLi9Nb3JlUG9wb3ZlcidcbmltcG9ydCB7IE1vcmVMaW5rQWN0aW9uIH0gZnJvbSAnLi9tb3JlLWxpbmsnXG5cblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZVByb3BzIHtcbiAgZWxSZWY/OiBSZWY8SFRNTERpdkVsZW1lbnQ+XG4gIGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZVxuICBjZWxsczogVGFibGVDZWxsTW9kZWxbXVtdIC8vIGNlbGxzLUJZLVJPV1xuICByZW5kZXJSb3dJbnRybz86ICgpID0+IFZOb2RlXG4gIGNvbEdyb3VwTm9kZTogVk5vZGVcbiAgdGFibGVNaW5XaWR0aDogQ3NzRGltVmFsdWVcbiAgZXhwYW5kUm93czogYm9vbGVhblxuICBzaG93V2Vla051bWJlcnM6IGJvb2xlYW5cbiAgY2xpZW50V2lkdGg6IG51bWJlciB8IG51bGxcbiAgY2xpZW50SGVpZ2h0OiBudW1iZXIgfCBudWxsXG4gIGJ1c2luZXNzSG91clNlZ3M6IFRhYmxlU2VnW11cbiAgYmdFdmVudFNlZ3M6IFRhYmxlU2VnW11cbiAgZmdFdmVudFNlZ3M6IFRhYmxlU2VnW11cbiAgZGF0ZVNlbGVjdGlvblNlZ3M6IFRhYmxlU2VnW11cbiAgZXZlbnRTZWxlY3Rpb246IHN0cmluZ1xuICBldmVudERyYWc6IEV2ZW50U2VnVWlJbnRlcmFjdGlvblN0YXRlIHwgbnVsbFxuICBldmVudFJlc2l6ZTogRXZlbnRTZWdVaUludGVyYWN0aW9uU3RhdGUgfCBudWxsXG4gIGRheU1heEV2ZW50czogYm9vbGVhbiB8IG51bWJlclxuICBkYXlNYXhFdmVudFJvd3M6IGJvb2xlYW4gfCBudW1iZXJcbiAgaGVhZGVyQWxpZ25FbFJlZj86IFJlZk9iamVjdDxIVE1MRWxlbWVudD5cbiAgZm9yUHJpbnQ6IGJvb2xlYW5cbn1cblxuaW50ZXJmYWNlIFRhYmxlU3RhdGUge1xuICBtb3JlUG9wb3ZlclN0YXRlOiBNb3JlUG9wb3ZlclN0YXRlIHwgbnVsbFxufVxuXG5pbnRlcmZhY2UgTW9yZVBvcG92ZXJTdGF0ZSBleHRlbmRzIE1vcmVMaW5rQXJnIHtcbiAgY3VycmVudEZnRXZlbnRTZWdzOiBUYWJsZVNlZ1tdXG59XG5cblxuZXhwb3J0IGNsYXNzIFRhYmxlIGV4dGVuZHMgRGF0ZUNvbXBvbmVudDxUYWJsZVByb3BzLCBUYWJsZVN0YXRlPiB7XG5cbiAgcHJpdmF0ZSBzcGxpdEJ1c2luZXNzSG91clNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Um93KVxuICBwcml2YXRlIHNwbGl0QmdFdmVudFNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Um93KVxuICBwcml2YXRlIHNwbGl0RmdFdmVudFNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Um93KVxuICBwcml2YXRlIHNwbGl0RGF0ZVNlbGVjdGlvblNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Um93KVxuICBwcml2YXRlIHNwbGl0RXZlbnREcmFnID0gbWVtb2l6ZShzcGxpdEludGVyYWN0aW9uQnlSb3cpXG4gIHByaXZhdGUgc3BsaXRFdmVudFJlc2l6ZSA9IG1lbW9pemUoc3BsaXRJbnRlcmFjdGlvbkJ5Um93KVxuICBwcml2YXRlIGJ1aWxkQnVpbGRNb3JlTGlua1RleHQgPSBtZW1vaXplKGJ1aWxkQnVpbGRNb3JlTGlua1RleHQpXG4gIHByaXZhdGUgcm9vdEVsOiBIVE1MRWxlbWVudFxuICBwcml2YXRlIHJvd1JlZnMgPSBuZXcgUmVmTWFwPFRhYmxlUm93PigpXG4gIHByaXZhdGUgcm93UG9zaXRpb25zOiBQb3NpdGlvbkNhY2hlXG4gIHByaXZhdGUgY29sUG9zaXRpb25zOiBQb3NpdGlvbkNhY2hlXG5cbiAgc3RhdGUgPSB7XG4gICAgbW9yZVBvcG92ZXJTdGF0ZTogbnVsbFxuICB9XG5cblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcbiAgICBsZXQgeyBkYXRlUHJvZmlsZSwgZGF5TWF4RXZlbnRSb3dzLCBkYXlNYXhFdmVudHMsIGV4cGFuZFJvd3MgfSA9IHByb3BzXG4gICAgbGV0IHsgbW9yZVBvcG92ZXJTdGF0ZSB9ID0gdGhpcy5zdGF0ZVxuICAgIGxldCByb3dDbnQgPSBwcm9wcy5jZWxscy5sZW5ndGhcblxuICAgIGxldCBidXNpbmVzc0hvdXJTZWdzQnlSb3cgPSB0aGlzLnNwbGl0QnVzaW5lc3NIb3VyU2Vncyhwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCByb3dDbnQpXG4gICAgbGV0IGJnRXZlbnRTZWdzQnlSb3cgPSB0aGlzLnNwbGl0QmdFdmVudFNlZ3MocHJvcHMuYmdFdmVudFNlZ3MsIHJvd0NudClcbiAgICBsZXQgZmdFdmVudFNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRGZ0V2ZW50U2Vncyhwcm9wcy5mZ0V2ZW50U2Vncywgcm93Q250KVxuICAgIGxldCBkYXRlU2VsZWN0aW9uU2Vnc0J5Um93ID0gdGhpcy5zcGxpdERhdGVTZWxlY3Rpb25TZWdzKHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzLCByb3dDbnQpXG4gICAgbGV0IGV2ZW50RHJhZ0J5Um93ID0gdGhpcy5zcGxpdEV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcsIHJvd0NudClcbiAgICBsZXQgZXZlbnRSZXNpemVCeVJvdyA9IHRoaXMuc3BsaXRFdmVudFJlc2l6ZShwcm9wcy5ldmVudFJlc2l6ZSwgcm93Q250KVxuICAgIGxldCBidWlsZE1vcmVMaW5rVGV4dCA9IHRoaXMuYnVpbGRCdWlsZE1vcmVMaW5rVGV4dCh0aGlzLmNvbnRleHQub3B0aW9ucy5tb3JlTGlua1RleHQpXG5cbiAgICBsZXQgbGltaXRWaWFCYWxhbmNlZCA9IGRheU1heEV2ZW50cyA9PT0gdHJ1ZSB8fCBkYXlNYXhFdmVudFJvd3MgPT09IHRydWVcblxuICAgIC8vIGlmIHJvd3MgY2FuJ3QgZXhwYW5kIHRvIGZpbGwgZml4ZWQgaGVpZ2h0LCBjYW4ndCBkbyBiYWxhbmNlZC1oZWlnaHQgZXZlbnQgbGltaXRcbiAgICAvLyBUT0RPOiBiZXN0IHBsYWNlIHRvIG5vcm1hbGl6ZSB0aGVzZSBvcHRpb25zP1xuICAgIGlmIChsaW1pdFZpYUJhbGFuY2VkICYmICFleHBhbmRSb3dzKSB7XG4gICAgICBsaW1pdFZpYUJhbGFuY2VkID0gZmFsc2VcbiAgICAgIGRheU1heEV2ZW50Um93cyA9IG51bGxcbiAgICAgIGRheU1heEV2ZW50cyA9IG51bGxcbiAgICB9XG5cbiAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICdmYy1kYXlncmlkLWJvZHknLFxuICAgICAgbGltaXRWaWFCYWxhbmNlZCA/ICdmYy1kYXlncmlkLWJvZHktYmFsYW5jZWQnIDogJ2ZjLWRheWdyaWQtYm9keS11bmJhbGFuY2VkJywgLy8gd2lsbCBhbGwgcm93IGhlaWdodHMgYmUgZXF1YWw/XG4gICAgICBleHBhbmRSb3dzID8gJycgOiAnZmMtZGF5Z3JpZC1ib2R5LW5hdHVyYWwnIC8vIHdpbGwgaGVpZ2h0IG9mIG9uZSByb3cgZGVwZW5kIG9uIHRoZSBvdGhlcnM/XG4gICAgXVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWVzLmpvaW4oJyAnKX0gcmVmPXt0aGlzLmhhbmRsZVJvb3RFbH0gc3R5bGU9e3tcbiAgICAgICAgLy8gdGhlc2UgcHJvcHMgYXJlIGltcG9ydGFudCB0byBnaXZlIHRoaXMgd3JhcHBlciBjb3JyZWN0IGRpbWVuc2lvbnMgZm9yIGludGVyYWN0aW9uc1xuICAgICAgICAvLyBUT0RPOiBpZiB3ZSBzZXQgaXQgaGVyZSwgY2FuIHdlIGF2b2lkIGdpdmluZyB0byBpbm5lciB0YWJsZXM/XG4gICAgICAgIHdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCxcbiAgICAgICAgbWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGhcbiAgICAgIH19PlxuICAgICAgICA8Tm93VGltZXIgdW5pdD0nZGF5Jz5cbiAgICAgICAgICB7KG5vd0RhdGU6IERhdGVNYXJrZXIsIHRvZGF5UmFuZ2U6IERhdGVSYW5nZSkgPT4gKFxuICAgICAgICAgICAgPEZyYWdtZW50PlxuICAgICAgICAgICAgICA8dGFibGVcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9J2ZjLXNjcm9sbGdyaWQtc3luYy10YWJsZSdcbiAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgd2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsXG4gICAgICAgICAgICAgICAgICBoZWlnaHQ6IGV4cGFuZFJvd3MgPyBwcm9wcy5jbGllbnRIZWlnaHQgOiAnJ1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7cHJvcHMuY29sR3JvdXBOb2RlfVxuICAgICAgICAgICAgICAgIDx0Ym9keT5cbiAgICAgICAgICAgICAgICAgIHtwcm9wcy5jZWxscy5tYXAoKGNlbGxzLCByb3cpID0+IChcbiAgICAgICAgICAgICAgICAgICAgPFRhYmxlUm93XG4gICAgICAgICAgICAgICAgICAgICAgcmVmPXt0aGlzLnJvd1JlZnMuY3JlYXRlUmVmKHJvdyl9XG4gICAgICAgICAgICAgICAgICAgICAga2V5PXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNlbGxzWzBdLmRhdGUudG9JU09TdHJpbmcoKSAvKiBiZXN0PyBvciBwdXQga2V5IG9uIGNlbGw/IG9yIHVzZSBkaWZmIGZvcm1hdHRlcj8gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiByb3cgLy8gaW4gY2FzZSB0aGVyZSBhcmUgbm8gY2VsbHMgKGxpa2Ugd2hlbiByZXNvdXJjZSB2aWV3IGlzIGxvYWRpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHNob3dEYXlOdW1iZXJzPXtyb3dDbnQgPiAxfVxuICAgICAgICAgICAgICAgICAgICAgIHNob3dXZWVrTnVtYmVycz17cHJvcHMuc2hvd1dlZWtOdW1iZXJzfVxuICAgICAgICAgICAgICAgICAgICAgIHRvZGF5UmFuZ2U9e3RvZGF5UmFuZ2V9XG4gICAgICAgICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGU9e2RhdGVQcm9maWxlfVxuICAgICAgICAgICAgICAgICAgICAgIGNlbGxzPXtjZWxsc31cbiAgICAgICAgICAgICAgICAgICAgICByZW5kZXJJbnRybz17cHJvcHMucmVuZGVyUm93SW50cm99XG4gICAgICAgICAgICAgICAgICAgICAgYnVzaW5lc3NIb3VyU2Vncz17YnVzaW5lc3NIb3VyU2Vnc0J5Um93W3Jvd119XG4gICAgICAgICAgICAgICAgICAgICAgZXZlbnRTZWxlY3Rpb249e3Byb3BzLmV2ZW50U2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgICAgICAgIGJnRXZlbnRTZWdzPXtiZ0V2ZW50U2Vnc0J5Um93W3Jvd119XG4gICAgICAgICAgICAgICAgICAgICAgZmdFdmVudFNlZ3M9e2ZnRXZlbnRTZWdzQnlSb3dbcm93XX1cbiAgICAgICAgICAgICAgICAgICAgICBkYXRlU2VsZWN0aW9uU2Vncz17ZGF0ZVNlbGVjdGlvblNlZ3NCeVJvd1tyb3ddfVxuICAgICAgICAgICAgICAgICAgICAgIGV2ZW50RHJhZz17ZXZlbnREcmFnQnlSb3dbcm93XX1cbiAgICAgICAgICAgICAgICAgICAgICBldmVudFJlc2l6ZT17ZXZlbnRSZXNpemVCeVJvd1tyb3ddfVxuICAgICAgICAgICAgICAgICAgICAgIGRheU1heEV2ZW50cz17ZGF5TWF4RXZlbnRzfVxuICAgICAgICAgICAgICAgICAgICAgIGRheU1heEV2ZW50Um93cz17ZGF5TWF4RXZlbnRSb3dzfVxuICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFdpZHRoPXtwcm9wcy5jbGllbnRXaWR0aH1cbiAgICAgICAgICAgICAgICAgICAgICBjbGllbnRIZWlnaHQ9e3Byb3BzLmNsaWVudEhlaWdodH1cbiAgICAgICAgICAgICAgICAgICAgICBidWlsZE1vcmVMaW5rVGV4dD17YnVpbGRNb3JlTGlua1RleHR9XG4gICAgICAgICAgICAgICAgICAgICAgb25Nb3JlQ2xpY2s9e3RoaXMuaGFuZGxlTW9yZUxpbmtDbGlja31cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgICAgICAgIHsoIXByb3BzLmZvclByaW50ICYmIG1vcmVQb3BvdmVyU3RhdGUgJiYgbW9yZVBvcG92ZXJTdGF0ZS5jdXJyZW50RmdFdmVudFNlZ3MgPT09IHByb3BzLmZnRXZlbnRTZWdzKSAmJiAvLyBjbGVhciBwb3BvdmVyIG9uIGV2ZW50IG1vZFxuICAgICAgICAgICAgICAgIDxNb3JlUG9wb3ZlclxuICAgICAgICAgICAgICAgICAgZGF0ZT17bW9yZVBvcG92ZXJTdGF0ZS5kYXRlfVxuICAgICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGU9e2RhdGVQcm9maWxlfVxuICAgICAgICAgICAgICAgICAgc2Vncz17bW9yZVBvcG92ZXJTdGF0ZS5hbGxTZWdzfVxuICAgICAgICAgICAgICAgICAgYWxpZ25tZW50RWw9e21vcmVQb3BvdmVyU3RhdGUuZGF5RWx9XG4gICAgICAgICAgICAgICAgICB0b3BBbGlnbm1lbnRFbD17cm93Q250ID09PSAxID8gcHJvcHMuaGVhZGVyQWxpZ25FbFJlZi5jdXJyZW50IDogbnVsbH1cbiAgICAgICAgICAgICAgICAgIG9uQ2xvc2VDbGljaz17dGhpcy5oYW5kbGVNb3JlUG9wb3ZlckNsb3NlfVxuICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRJbnN0YW5jZUlkPXtwcm9wcy5ldmVudFNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICAgIGhpZGRlbkluc3RhbmNlcz17IC8vIHl1Y2tcbiAgICAgICAgICAgICAgICAgICAgKHByb3BzLmV2ZW50RHJhZyA/IHByb3BzLmV2ZW50RHJhZy5hZmZlY3RlZEluc3RhbmNlcyA6IG51bGwpIHx8XG4gICAgICAgICAgICAgICAgICAgIChwcm9wcy5ldmVudFJlc2l6ZSA/IHByb3BzLmV2ZW50UmVzaXplLmFmZmVjdGVkSW5zdGFuY2VzIDogbnVsbCkgfHxcbiAgICAgICAgICAgICAgICAgICAge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRvZGF5UmFuZ2U9e3RvZGF5UmFuZ2V9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgPC9GcmFnbWVudD5cbiAgICAgICAgICApfVxuICAgICAgICA8L05vd1RpbWVyPlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG5cblxuICBoYW5kbGVSb290RWwgPSAocm9vdEVsOiBIVE1MRWxlbWVudCB8IG51bGwpID0+IHtcbiAgICB0aGlzLnJvb3RFbCA9IHJvb3RFbFxuICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCByb290RWwpXG4gIH1cblxuXG4gIGhhbmRsZU1vcmVMaW5rQ2xpY2sgPSAoYXJnOiBNb3JlTGlua0FyZykgPT4geyAvLyBUT0RPOiBiYWQgbmFtZXMgXCJtb3JlIGxpbmsgY2xpY2tcIiB2ZXJzdXMgXCJtb3JlIGNsaWNrXCJcbiAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzXG4gICAgbGV0IHsgZGF0ZUVudiB9ID0gY29udGV4dFxuICAgIGxldCBjbGlja09wdGlvbiA9IGNvbnRleHQub3B0aW9ucy5tb3JlTGlua0NsaWNrXG5cbiAgICBmdW5jdGlvbiBzZWdGb3JQdWJsaWMoc2VnOiBUYWJsZVNlZykge1xuICAgICAgbGV0IHsgZGVmLCBpbnN0YW5jZSwgcmFuZ2UgfSA9IHNlZy5ldmVudFJhbmdlXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV2ZW50OiBuZXcgRXZlbnRBcGkoY29udGV4dCwgZGVmLCBpbnN0YW5jZSksXG4gICAgICAgIHN0YXJ0OiBkYXRlRW52LnRvRGF0ZShyYW5nZS5zdGFydCksXG4gICAgICAgIGVuZDogZGF0ZUVudi50b0RhdGUocmFuZ2UuZW5kKSxcbiAgICAgICAgaXNTdGFydDogc2VnLmlzU3RhcnQsXG4gICAgICAgIGlzRW5kOiBzZWcuaXNFbmRcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNsaWNrT3B0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjbGlja09wdGlvbiA9IGNsaWNrT3B0aW9uKHtcbiAgICAgICAgZGF0ZTogZGF0ZUVudi50b0RhdGUoYXJnLmRhdGUpLFxuICAgICAgICBhbGxEYXk6IHRydWUsXG4gICAgICAgIGFsbFNlZ3M6IGFyZy5hbGxTZWdzLm1hcChzZWdGb3JQdWJsaWMpLFxuICAgICAgICBoaWRkZW5TZWdzOiBhcmcuaGlkZGVuU2Vncy5tYXAoc2VnRm9yUHVibGljKSxcbiAgICAgICAganNFdmVudDogYXJnLmV2LFxuICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGlcbiAgICAgIH0pIGFzIChNb3JlTGlua0FjdGlvbiB8IHVuZGVmaW5lZCkgLy8gaGFjayB0byBoYW5kbGUgdm9pZFxuICAgIH1cblxuICAgIGlmICghY2xpY2tPcHRpb24gfHwgY2xpY2tPcHRpb24gPT09ICdwb3BvdmVyJykge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIG1vcmVQb3BvdmVyU3RhdGU6IHtcbiAgICAgICAgICAuLi5hcmcsXG4gICAgICAgICAgY3VycmVudEZnRXZlbnRTZWdzOiB0aGlzLnByb3BzLmZnRXZlbnRTZWdzXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjbGlja09wdGlvbiA9PT0gJ3N0cmluZycpIHsgLy8gYSB2aWV3IG5hbWVcbiAgICAgIGNvbnRleHQuY2FsZW5kYXJBcGkuem9vbVRvKGFyZy5kYXRlLCBjbGlja09wdGlvbilcbiAgICB9XG4gIH1cblxuXG4gIGhhbmRsZU1vcmVQb3BvdmVyQ2xvc2UgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBtb3JlUG9wb3ZlclN0YXRlOiBudWxsXG4gICAgfSlcbiAgfVxuXG5cbiAgLy8gSGl0IFN5c3RlbVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICBwcmVwYXJlSGl0cygpIHtcbiAgICB0aGlzLnJvd1Bvc2l0aW9ucyA9IG5ldyBQb3NpdGlvbkNhY2hlKFxuICAgICAgdGhpcy5yb290RWwsXG4gICAgICB0aGlzLnJvd1JlZnMuY29sbGVjdCgpLm1hcCgocm93T2JqKSA9PiByb3dPYmouZ2V0Q2VsbEVscygpWzBdKSwgLy8gZmlyc3QgY2VsbCBlbCBpbiBlYWNoIHJvdy4gVE9ETzogbm90IG9wdGltYWxcbiAgICAgIGZhbHNlLFxuICAgICAgdHJ1ZSAvLyB2ZXJ0aWNhbFxuICAgIClcblxuICAgIHRoaXMuY29sUG9zaXRpb25zID0gbmV3IFBvc2l0aW9uQ2FjaGUoXG4gICAgICB0aGlzLnJvb3RFbCxcbiAgICAgIHRoaXMucm93UmVmcy5jdXJyZW50TWFwWzBdLmdldENlbGxFbHMoKSwgLy8gY2VsbCBlbHMgaW4gZmlyc3Qgcm93XG4gICAgICB0cnVlLCAvLyBob3Jpem9udGFsXG4gICAgICBmYWxzZVxuICAgIClcbiAgfVxuXG5cbiAgcG9zaXRpb25Ub0hpdChsZWZ0UG9zaXRpb24sIHRvcFBvc2l0aW9uKSB7XG4gICAgbGV0IHsgY29sUG9zaXRpb25zLCByb3dQb3NpdGlvbnMgfSA9IHRoaXNcblxuICAgIGxldCBjb2wgPSBjb2xQb3NpdGlvbnMubGVmdFRvSW5kZXgobGVmdFBvc2l0aW9uKVxuICAgIGxldCByb3cgPSByb3dQb3NpdGlvbnMudG9wVG9JbmRleCh0b3BQb3NpdGlvbilcblxuICAgIGlmIChyb3cgIT0gbnVsbCAmJiBjb2wgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm93LFxuICAgICAgICBjb2wsXG4gICAgICAgIGRhdGVTcGFuOiB7XG4gICAgICAgICAgcmFuZ2U6IHRoaXMuZ2V0Q2VsbFJhbmdlKHJvdywgY29sKSxcbiAgICAgICAgICBhbGxEYXk6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgZGF5RWw6IHRoaXMuZ2V0Q2VsbEVsKHJvdywgY29sKSxcbiAgICAgICAgcmVsYXRpdmVSZWN0OiB7XG4gICAgICAgICAgbGVmdDogY29sUG9zaXRpb25zLmxlZnRzW2NvbF0sXG4gICAgICAgICAgcmlnaHQ6IGNvbFBvc2l0aW9ucy5yaWdodHNbY29sXSxcbiAgICAgICAgICB0b3A6IHJvd1Bvc2l0aW9ucy50b3BzW3Jvd10sXG4gICAgICAgICAgYm90dG9tOiByb3dQb3NpdGlvbnMuYm90dG9tc1tyb3ddXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIHByaXZhdGUgZ2V0Q2VsbEVsKHJvdywgY29sKSB7XG4gICAgcmV0dXJuIHRoaXMucm93UmVmcy5jdXJyZW50TWFwW3Jvd10uZ2V0Q2VsbEVscygpW2NvbF0gLy8gVE9ETzogbm90IG9wdGltYWxcbiAgfVxuXG5cbiAgcHJpdmF0ZSBnZXRDZWxsUmFuZ2Uocm93LCBjb2wpIHtcbiAgICBsZXQgc3RhcnQgPSB0aGlzLnByb3BzLmNlbGxzW3Jvd11bY29sXS5kYXRlXG4gICAgbGV0IGVuZCA9IGFkZERheXMoc3RhcnQsIDEpXG4gICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9XG4gIH1cblxufVxuXG5cbmZ1bmN0aW9uIGJ1aWxkQnVpbGRNb3JlTGlua1RleHQobW9yZUxpbmtUZXh0SW5wdXQpOiAobnVtOiBudW1iZXIpID0+IHN0cmluZyB7XG4gIGlmICh0eXBlb2YgbW9yZUxpbmtUZXh0SW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbW9yZUxpbmtUZXh0SW5wdXRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obnVtKSB7XG4gICAgICByZXR1cm4gYCske251bX0gJHttb3JlTGlua1RleHRJbnB1dH1gXG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQge1xuICBjcmVhdGVFbGVtZW50LCBjcmVhdGVSZWYsIFZOb2RlLFxuICBFdmVudFN0b3JlLFxuICBFdmVudFVpSGFzaCxcbiAgRGF0ZVNwYW4sXG4gIEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSxcbiAgRGF5VGFibGVNb2RlbCxcbiAgRHVyYXRpb24sXG4gIERhdGVDb21wb25lbnQsXG4gIERhdGVSYW5nZSxcbiAgU2xpY2VyLFxuICBWaWV3Q29udGV4dCxcbiAgUmVmT2JqZWN0LFxuICBDc3NEaW1WYWx1ZSxcbiAgSGl0LFxuICBEYXRlUHJvZmlsZVxufSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcbmltcG9ydCB7IFRhYmxlIH0gZnJvbSAnLi9UYWJsZSdcbmltcG9ydCB7IFRhYmxlU2VnIH0gZnJvbSAnLi9UYWJsZVNlZydcblxuXG5leHBvcnQgaW50ZXJmYWNlIERheVRhYmxlUHJvcHMge1xuICBkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGUsXG4gIGRheVRhYmxlTW9kZWw6IERheVRhYmxlTW9kZWxcbiAgbmV4dERheVRocmVzaG9sZDogRHVyYXRpb25cbiAgYnVzaW5lc3NIb3VyczogRXZlbnRTdG9yZVxuICBldmVudFN0b3JlOiBFdmVudFN0b3JlXG4gIGV2ZW50VWlCYXNlczogRXZlbnRVaUhhc2hcbiAgZGF0ZVNlbGVjdGlvbjogRGF0ZVNwYW4gfCBudWxsXG4gIGV2ZW50U2VsZWN0aW9uOiBzdHJpbmdcbiAgZXZlbnREcmFnOiBFdmVudEludGVyYWN0aW9uU3RhdGUgfCBudWxsXG4gIGV2ZW50UmVzaXplOiBFdmVudEludGVyYWN0aW9uU3RhdGUgfCBudWxsXG4gIGNvbEdyb3VwTm9kZTogVk5vZGVcbiAgdGFibGVNaW5XaWR0aDogQ3NzRGltVmFsdWVcbiAgcmVuZGVyUm93SW50cm8/OiAoKSA9PiBWTm9kZVxuICBkYXlNYXhFdmVudHM6IGJvb2xlYW4gfCBudW1iZXJcbiAgZGF5TWF4RXZlbnRSb3dzOiBib29sZWFuIHwgbnVtYmVyXG4gIGV4cGFuZFJvd3M6IGJvb2xlYW5cbiAgc2hvd1dlZWtOdW1iZXJzOiBib29sZWFuXG4gIGhlYWRlckFsaWduRWxSZWY/OiBSZWZPYmplY3Q8SFRNTEVsZW1lbnQ+IC8vIGZvciBtb3JlIHBvcG92ZXIgYWxpZ25tZW50XG4gIGNsaWVudFdpZHRoOiBudW1iZXIgfCBudWxsXG4gIGNsaWVudEhlaWdodDogbnVtYmVyIHwgbnVsbFxuICBmb3JQcmludDogYm9vbGVhblxufVxuXG5leHBvcnQgY2xhc3MgRGF5VGFibGUgZXh0ZW5kcyBEYXRlQ29tcG9uZW50PERheVRhYmxlUHJvcHMsIFZpZXdDb250ZXh0PiB7XG5cbiAgcHJpdmF0ZSBzbGljZXIgPSBuZXcgRGF5VGFibGVTbGljZXIoKVxuICBwcml2YXRlIHRhYmxlUmVmID0gY3JlYXRlUmVmPFRhYmxlPigpXG5cblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXNcblxuICAgIHJldHVybiAoXG4gICAgICA8VGFibGVcbiAgICAgICAgcmVmPXt0aGlzLnRhYmxlUmVmfVxuICAgICAgICBlbFJlZj17dGhpcy5oYW5kbGVSb290RWx9XG4gICAgICAgIHsgLi4udGhpcy5zbGljZXIuc2xpY2VQcm9wcyhwcm9wcywgcHJvcHMuZGF0ZVByb2ZpbGUsIHByb3BzLm5leHREYXlUaHJlc2hvbGQsIGNvbnRleHQsIHByb3BzLmRheVRhYmxlTW9kZWwpIH1cbiAgICAgICAgZGF0ZVByb2ZpbGU9e3Byb3BzLmRhdGVQcm9maWxlfVxuICAgICAgICBjZWxscz17cHJvcHMuZGF5VGFibGVNb2RlbC5jZWxsc31cbiAgICAgICAgY29sR3JvdXBOb2RlPXtwcm9wcy5jb2xHcm91cE5vZGV9XG4gICAgICAgIHRhYmxlTWluV2lkdGg9e3Byb3BzLnRhYmxlTWluV2lkdGh9XG4gICAgICAgIHJlbmRlclJvd0ludHJvPXtwcm9wcy5yZW5kZXJSb3dJbnRyb31cbiAgICAgICAgZGF5TWF4RXZlbnRzPXtwcm9wcy5kYXlNYXhFdmVudHN9XG4gICAgICAgIGRheU1heEV2ZW50Um93cz17cHJvcHMuZGF5TWF4RXZlbnRSb3dzfVxuICAgICAgICBzaG93V2Vla051bWJlcnM9e3Byb3BzLnNob3dXZWVrTnVtYmVyc31cbiAgICAgICAgZXhwYW5kUm93cz17cHJvcHMuZXhwYW5kUm93c31cbiAgICAgICAgaGVhZGVyQWxpZ25FbFJlZj17cHJvcHMuaGVhZGVyQWxpZ25FbFJlZn1cbiAgICAgICAgY2xpZW50V2lkdGg9e3Byb3BzLmNsaWVudFdpZHRofVxuICAgICAgICBjbGllbnRIZWlnaHQ9e3Byb3BzLmNsaWVudEhlaWdodH1cbiAgICAgICAgZm9yUHJpbnQ9e3Byb3BzLmZvclByaW50fVxuICAgICAgLz5cbiAgICApXG4gIH1cblxuXG4gIGhhbmRsZVJvb3RFbCA9IChyb290RWw6IEhUTUxEaXZFbGVtZW50IHwgbnVsbCkgPT4ge1xuICAgIGlmIChyb290RWwpIHtcbiAgICAgIHRoaXMuY29udGV4dC5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMsIHsgZWw6IHJvb3RFbCB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbnRleHQudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMpXG4gICAgfVxuICB9XG5cblxuICBwcmVwYXJlSGl0cygpIHtcbiAgICB0aGlzLnRhYmxlUmVmLmN1cnJlbnQucHJlcGFyZUhpdHMoKVxuICB9XG5cblxuICBxdWVyeUhpdChwb3NpdGlvbkxlZnQ6IG51bWJlciwgcG9zaXRpb25Ub3A6IG51bWJlcik6IEhpdCB7XG4gICAgbGV0IHJhd0hpdCA9IHRoaXMudGFibGVSZWYuY3VycmVudC5wb3NpdGlvblRvSGl0KHBvc2l0aW9uTGVmdCwgcG9zaXRpb25Ub3ApXG5cbiAgICBpZiAocmF3SGl0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb21wb25lbnQ6IHRoaXMsXG4gICAgICAgIGRhdGVTcGFuOiByYXdIaXQuZGF0ZVNwYW4sXG4gICAgICAgIGRheUVsOiByYXdIaXQuZGF5RWwsXG4gICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICBsZWZ0OiByYXdIaXQucmVsYXRpdmVSZWN0LmxlZnQsXG4gICAgICAgICAgcmlnaHQ6IHJhd0hpdC5yZWxhdGl2ZVJlY3QucmlnaHQsXG4gICAgICAgICAgdG9wOiByYXdIaXQucmVsYXRpdmVSZWN0LnRvcCxcbiAgICAgICAgICBib3R0b206IHJhd0hpdC5yZWxhdGl2ZVJlY3QuYm90dG9tXG4gICAgICAgIH0sXG4gICAgICAgIGxheWVyOiAwXG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cblxuXG5leHBvcnQgY2xhc3MgRGF5VGFibGVTbGljZXIgZXh0ZW5kcyBTbGljZXI8VGFibGVTZWcsIFtEYXlUYWJsZU1vZGVsXT4ge1xuXG4gIGZvcmNlRGF5SWZMaXN0SXRlbSA9IHRydWVcblxuICBzbGljZVJhbmdlKGRhdGVSYW5nZTogRGF0ZVJhbmdlLCBkYXlUYWJsZU1vZGVsOiBEYXlUYWJsZU1vZGVsKTogVGFibGVTZWdbXSB7XG4gICAgcmV0dXJuIGRheVRhYmxlTW9kZWwuc2xpY2VSYW5nZShkYXRlUmFuZ2UpXG4gIH1cblxufVxuIiwiaW1wb3J0IHtcbiAgY3JlYXRlRWxlbWVudCwgY3JlYXRlUmVmLFxuICBEYXlIZWFkZXIsXG4gIERhdGVQcm9maWxlR2VuZXJhdG9yLFxuICBEYXRlUHJvZmlsZSxcbiAgbWVtb2l6ZSxcbiAgRGF5U2VyaWVzTW9kZWwsXG4gIERheVRhYmxlTW9kZWwsXG4gIENodW5rQ29udGVudENhbGxiYWNrQXJnc1xufSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcbmltcG9ydCB7IFRhYmxlVmlldyB9IGZyb20gJy4vVGFibGVWaWV3J1xuaW1wb3J0IHsgRGF5VGFibGUgfSBmcm9tICcuL0RheVRhYmxlJ1xuXG5cbmV4cG9ydCBjbGFzcyBEYXlUYWJsZVZpZXcgZXh0ZW5kcyBUYWJsZVZpZXcge1xuXG4gIHByaXZhdGUgYnVpbGREYXlUYWJsZU1vZGVsID0gbWVtb2l6ZShidWlsZERheVRhYmxlTW9kZWwpXG4gIHByaXZhdGUgaGVhZGVyUmVmID0gY3JlYXRlUmVmPERheUhlYWRlcj4oKVxuICBwcml2YXRlIHRhYmxlUmVmID0gY3JlYXRlUmVmPERheVRhYmxlPigpXG5cblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgb3B0aW9ucywgZGF0ZVByb2ZpbGVHZW5lcmF0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGxldCB7IHByb3BzIH0gPSB0aGlzXG4gICAgbGV0IGRheVRhYmxlTW9kZWwgPSB0aGlzLmJ1aWxkRGF5VGFibGVNb2RlbChwcm9wcy5kYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpXG5cbiAgICBsZXQgaGVhZGVyQ29udGVudCA9IG9wdGlvbnMuZGF5SGVhZGVycyAmJlxuICAgICAgPERheUhlYWRlclxuICAgICAgICByZWY9e3RoaXMuaGVhZGVyUmVmfVxuICAgICAgICBkYXRlUHJvZmlsZT17cHJvcHMuZGF0ZVByb2ZpbGV9XG4gICAgICAgIGRhdGVzPXtkYXlUYWJsZU1vZGVsLmhlYWRlckRhdGVzfVxuICAgICAgICBkYXRlc1JlcERpc3RpbmN0RGF5cz17ZGF5VGFibGVNb2RlbC5yb3dDbnQgPT09IDF9XG4gICAgICAvPlxuXG4gICAgbGV0IGJvZHlDb250ZW50ID0gKGNvbnRlbnRBcmc6IENodW5rQ29udGVudENhbGxiYWNrQXJncykgPT4gKFxuICAgICAgPERheVRhYmxlXG4gICAgICAgIHJlZj17dGhpcy50YWJsZVJlZn1cbiAgICAgICAgZGF0ZVByb2ZpbGU9e3Byb3BzLmRhdGVQcm9maWxlfVxuICAgICAgICBkYXlUYWJsZU1vZGVsPXtkYXlUYWJsZU1vZGVsfVxuICAgICAgICBidXNpbmVzc0hvdXJzPXtwcm9wcy5idXNpbmVzc0hvdXJzfVxuICAgICAgICBkYXRlU2VsZWN0aW9uPXtwcm9wcy5kYXRlU2VsZWN0aW9ufVxuICAgICAgICBldmVudFN0b3JlPXtwcm9wcy5ldmVudFN0b3JlfVxuICAgICAgICBldmVudFVpQmFzZXM9e3Byb3BzLmV2ZW50VWlCYXNlc31cbiAgICAgICAgZXZlbnRTZWxlY3Rpb249e3Byb3BzLmV2ZW50U2VsZWN0aW9ufVxuICAgICAgICBldmVudERyYWc9e3Byb3BzLmV2ZW50RHJhZ31cbiAgICAgICAgZXZlbnRSZXNpemU9e3Byb3BzLmV2ZW50UmVzaXplfVxuICAgICAgICBuZXh0RGF5VGhyZXNob2xkPXtvcHRpb25zLm5leHREYXlUaHJlc2hvbGR9XG4gICAgICAgIGNvbEdyb3VwTm9kZT17Y29udGVudEFyZy50YWJsZUNvbEdyb3VwTm9kZX1cbiAgICAgICAgdGFibGVNaW5XaWR0aD17Y29udGVudEFyZy50YWJsZU1pbldpZHRofVxuICAgICAgICBkYXlNYXhFdmVudHM9e29wdGlvbnMuZGF5TWF4RXZlbnRzfVxuICAgICAgICBkYXlNYXhFdmVudFJvd3M9e29wdGlvbnMuZGF5TWF4RXZlbnRSb3dzfVxuICAgICAgICBzaG93V2Vla051bWJlcnM9e29wdGlvbnMud2Vla051bWJlcnN9XG4gICAgICAgIGV4cGFuZFJvd3M9eyFwcm9wcy5pc0hlaWdodEF1dG99XG4gICAgICAgIGhlYWRlckFsaWduRWxSZWY9e3RoaXMuaGVhZGVyRWxSZWZ9XG4gICAgICAgIGNsaWVudFdpZHRoPXtjb250ZW50QXJnLmNsaWVudFdpZHRofVxuICAgICAgICBjbGllbnRIZWlnaHQ9e2NvbnRlbnRBcmcuY2xpZW50SGVpZ2h0fVxuICAgICAgICBmb3JQcmludD17cHJvcHMuZm9yUHJpbnR9XG4gICAgICAvPlxuICAgIClcblxuICAgIHJldHVybiBvcHRpb25zLmRheU1pbldpZHRoXG4gICAgICA/IHRoaXMucmVuZGVySFNjcm9sbExheW91dChoZWFkZXJDb250ZW50LCBib2R5Q29udGVudCwgZGF5VGFibGVNb2RlbC5jb2xDbnQsIG9wdGlvbnMuZGF5TWluV2lkdGgpXG4gICAgICA6IHRoaXMucmVuZGVyU2ltcGxlTGF5b3V0KGhlYWRlckNvbnRlbnQsIGJvZHlDb250ZW50KVxuICB9XG5cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGREYXlUYWJsZU1vZGVsKGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3I6IERhdGVQcm9maWxlR2VuZXJhdG9yKSB7XG4gIGxldCBkYXlTZXJpZXMgPSBuZXcgRGF5U2VyaWVzTW9kZWwoZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2UsIGRhdGVQcm9maWxlR2VuZXJhdG9yKVxuXG4gIHJldHVybiBuZXcgRGF5VGFibGVNb2RlbChcbiAgICBkYXlTZXJpZXMsXG4gICAgL3llYXJ8bW9udGh8d2Vlay8udGVzdChkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KVxuICApXG59XG4iLCJpbXBvcnQge1xuICBEYXRlUHJvZmlsZUdlbmVyYXRvcixcbiAgYWRkV2Vla3MsIGRpZmZXZWVrcyxcbiAgRGF0ZVJhbmdlXG59IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuXG5leHBvcnQgY2xhc3MgVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvciBleHRlbmRzIERhdGVQcm9maWxlR2VuZXJhdG9yIHtcblxuXG4gIC8vIENvbXB1dGVzIHRoZSBkYXRlIHJhbmdlIHRoYXQgd2lsbCBiZSByZW5kZXJlZC5cbiAgYnVpbGRSZW5kZXJSYW5nZShjdXJyZW50UmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpOiBEYXRlUmFuZ2Uge1xuICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMucHJvcHNcbiAgICBsZXQgcmVuZGVyUmFuZ2UgPSBzdXBlci5idWlsZFJlbmRlclJhbmdlKGN1cnJlbnRSYW5nZSwgY3VycmVudFJhbmdlVW5pdCwgaXNSYW5nZUFsbERheSlcbiAgICBsZXQgc3RhcnQgPSByZW5kZXJSYW5nZS5zdGFydFxuICAgIGxldCBlbmQgPSByZW5kZXJSYW5nZS5lbmRcbiAgICBsZXQgZW5kT2ZXZWVrXG5cbiAgICAvLyB5ZWFyIGFuZCBtb250aCB2aWV3cyBzaG91bGQgYmUgYWxpZ25lZCB3aXRoIHdlZWtzLiB0aGlzIGlzIGFscmVhZHkgZG9uZSBmb3Igd2Vla1xuICAgIGlmICgvXih5ZWFyfG1vbnRoKSQvLnRlc3QoY3VycmVudFJhbmdlVW5pdCkpIHtcbiAgICAgIHN0YXJ0ID0gZGF0ZUVudi5zdGFydE9mV2VlayhzdGFydClcblxuICAgICAgLy8gbWFrZSBlbmQtb2Ytd2VlayBpZiBub3QgYWxyZWFkeVxuICAgICAgZW5kT2ZXZWVrID0gZGF0ZUVudi5zdGFydE9mV2VlayhlbmQpXG4gICAgICBpZiAoZW5kT2ZXZWVrLnZhbHVlT2YoKSAhPT0gZW5kLnZhbHVlT2YoKSkge1xuICAgICAgICBlbmQgPSBhZGRXZWVrcyhlbmRPZldlZWssIDEpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIDYgd2Vla3NcbiAgICBpZiAoXG4gICAgICB0aGlzLnByb3BzLm1vbnRoTW9kZSAmJlxuICAgICAgdGhpcy5wcm9wcy5maXhlZFdlZWtDb3VudFxuICAgICkge1xuICAgICAgbGV0IHJvd0NudCA9IE1hdGguY2VpbCggLy8gY291bGQgYmUgcGFydGlhbCB3ZWVrcyBkdWUgdG8gaGlkZGVuRGF5c1xuICAgICAgICBkaWZmV2Vla3Moc3RhcnQsIGVuZClcbiAgICAgIClcbiAgICAgIGVuZCA9IGFkZFdlZWtzKGVuZCwgNiAtIHJvd0NudClcbiAgICB9XG5cbiAgICByZXR1cm4geyBzdGFydCwgZW5kIH1cbiAgfVxuXG59XG4iLCJpbXBvcnQge1xuICBpZGVudGl0eSwgSWRlbnRpdHksIENsYXNzTmFtZXNHZW5lcmF0b3IsIEN1c3RvbUNvbnRlbnRHZW5lcmF0b3IsIERpZE1vdW50SGFuZGxlciwgV2lsbFVubW91bnRIYW5kbGVyXG59IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuXG4vLyBwdWJsaWNcbmltcG9ydCB7XG4gIE1vcmVMaW5rQ29udGVudEFyZyxcbiAgTW9yZUxpbmtNb3VudEFyZyxcbiAgTW9yZUxpbmtBY3Rpb25cbn0gZnJvbSAnLi9hcGktdHlwZS1kZXBzJ1xuXG5leHBvcnQgY29uc3QgT1BUSU9OX1JFRklORVJTID0ge1xuICBtb3JlTGlua0NsaWNrOiBpZGVudGl0eSBhcyBJZGVudGl0eTxNb3JlTGlua0FjdGlvbj4sXG4gIG1vcmVMaW5rQ2xhc3NOYW1lczogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q2xhc3NOYW1lc0dlbmVyYXRvcjxNb3JlTGlua0NvbnRlbnRBcmc+PixcbiAgbW9yZUxpbmtDb250ZW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxDdXN0b21Db250ZW50R2VuZXJhdG9yPE1vcmVMaW5rQ29udGVudEFyZz4+LFxuICBtb3JlTGlua0RpZE1vdW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxEaWRNb3VudEhhbmRsZXI8TW9yZUxpbmtNb3VudEFyZz4+LFxuICBtb3JlTGlua1dpbGxVbm1vdW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxXaWxsVW5tb3VudEhhbmRsZXI8TW9yZUxpbmtNb3VudEFyZz4+LFxufVxuIiwiaW1wb3J0IHsgY3JlYXRlUGx1Z2luIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5pbXBvcnQgeyBEYXlUYWJsZVZpZXcgfSBmcm9tICcuL0RheVRhYmxlVmlldydcbmltcG9ydCAnLi9tYWluLmNzcydcbmltcG9ydCB7IFRhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3IgfSBmcm9tICcuL1RhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3InXG5pbXBvcnQgeyBPUFRJT05fUkVGSU5FUlMgfSBmcm9tICcuL29wdGlvbnMnXG5pbXBvcnQgJy4vb3B0aW9ucy1kZWNsYXJlJ1xuXG5leHBvcnQgKiBmcm9tICcuL2FwaS10eXBlLWRlcHMnXG5leHBvcnQgeyBEYXlUYWJsZSwgRGF5VGFibGVTbGljZXIgfSBmcm9tICcuL0RheVRhYmxlJ1xuZXhwb3J0IHsgVGFibGUgfSBmcm9tICcuL1RhYmxlJ1xuZXhwb3J0IHsgVGFibGVTZWcgfSBmcm9tICcuL1RhYmxlU2VnJ1xuZXhwb3J0IHsgVGFibGVDZWxsTW9kZWwgfSBmcm9tICcuL1RhYmxlQ2VsbCdcbmV4cG9ydCB7IFRhYmxlVmlldyB9IGZyb20gJy4vVGFibGVWaWV3J1xuZXhwb3J0IHsgYnVpbGREYXlUYWJsZU1vZGVsIH0gZnJvbSAnLi9EYXlUYWJsZVZpZXcnXG5leHBvcnQgeyBEYXlUYWJsZVZpZXcgYXMgRGF5R3JpZFZpZXcgfSAvLyBleHBvcnQgYXMgb2xkIG5hbWUhXG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVBsdWdpbih7XG4gIGluaXRpYWxWaWV3OiAnZGF5R3JpZE1vbnRoJyxcbiAgb3B0aW9uUmVmaW5lcnM6IE9QVElPTl9SRUZJTkVSUyxcbiAgdmlld3M6IHtcblxuICAgIGRheUdyaWQ6IHtcbiAgICAgIGNvbXBvbmVudDogRGF5VGFibGVWaWV3LFxuICAgICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzczogVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvclxuICAgIH0sXG5cbiAgICBkYXlHcmlkRGF5OiB7XG4gICAgICB0eXBlOiAnZGF5R3JpZCcsXG4gICAgICBkdXJhdGlvbjogeyBkYXlzOiAxIH1cbiAgICB9LFxuXG4gICAgZGF5R3JpZFdlZWs6IHtcbiAgICAgIHR5cGU6ICdkYXlHcmlkJyxcbiAgICAgIGR1cmF0aW9uOiB7IHdlZWtzOiAxIH1cbiAgICB9LFxuXG4gICAgZGF5R3JpZE1vbnRoOiB7XG4gICAgICB0eXBlOiAnZGF5R3JpZCcsXG4gICAgICBkdXJhdGlvbjogeyBtb250aHM6IDEgfSxcbiAgICAgIG1vbnRoTW9kZTogdHJ1ZSxcbiAgICAgIGZpeGVkV2Vla0NvdW50OiB0cnVlXG4gICAgfVxuXG4gIH1cbn0pXG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFFQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQ0E7O0FBbUhBO0FBQ0E7QUFqSEE7QUFJQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBSkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFKQTtBQU9BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBRkE7QUFHQTtBQUhBO0FBTUE7QUFHQTtBQUNBO0FBRUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUpBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFKQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSkE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSEE7QUFNQTtBQUdBO0FBQ0E7QUFDQTtBQXJIQTtBQUNBO0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNnQkE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBOEZBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBdEhBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUVBO0FBQ0E7QUFGQTtBQU1BO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQU9BO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUhBO0FBT0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBS0E7QUFBQTtBQUtBO0FBR0E7QUFDQTtBQTZCQTtBQTFIQTtBQUNBO0FBNEhBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFVQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7O0FBOEJBO0FBQ0E7QUE3QkE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUlBO0FBR0E7QUFDQTtBQUNBO0FBOUJBO0FBQ0E7QUNqT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFPQTtBQUNBO0FBRUE7QUFBQTtBQUtBO0FBQ0E7QUNQQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7O0FBaUNBO0FBQ0E7QUFoQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFRQTtBQUdBO0FBQ0E7QUFDQTtBQWpDQTtBQUNBO0FBbUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUZBO0FBS0E7QUFBQTtBQUVBO0FBQUE7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUNoRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBOztBQWdCQTtBQUNBO0FBZkE7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7QUFDQTtBQWhCQTtBQUNBO0FDV0E7QUFDQTtBQVNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFWQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2hRQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7QUErVEE7QUFDQTtBQXpUQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFVQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQVFBO0FBSUE7QUFKQTtBQUNBO0FBV0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBSEE7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQU5BO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQWhCQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQTNCQTtBQW1DQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUhBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFKQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUZBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBTEE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBdlVBO0FBQ0E7QUF3VUE7QUFDQTtBQURBO0FDcFhBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBeUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBdUNBO0FBQ0E7QUEvR0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBNENBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQXBIQTtBQUNBO0FDQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQW1FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUE2QkE7QUFDQTtBQXpHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFIQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVlBO0FBRUE7QUFHQTtBQUNBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQWJBO0FBZUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTdHQTtBQUNBOzs7O0FDc0NBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQURBO0FBQ0E7QUE4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBREE7QUFGQTtBQU9BO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTs7QUE0REE7QUFDQTtBQTVOQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQUE7QUFBQTs7O0FBR0E7QUFDQTtBQUpBO0FBQUE7QUFNQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFGQTtBQVVBO0FBRUE7QUFDQTtBQUVBO0FBREE7QUFIQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBekJBO0FBMkJBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQWJBO0FBaUJBO0FBSUE7Ozs7QUE4REE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUhBO0FBT0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFSQTtBQWVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUE5T0E7QUFDQTtBQWdQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pRQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNEJBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTBCQTtBQUNBO0FBNURBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFnQkE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBVkE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQWpFQTtBQUNBOzs7O0FBbUVBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFDQTs7QUFNQTtBQUNBO0FBTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBQ0E7Ozs7QUNwR0E7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUErQ0E7QUFDQTtBQTdDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckJBO0FBdUJBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQW5EQTtBQUNBO0FBcURBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUN0RUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBOztBQW9DQTtBQUNBO0FBQ0E7QUFsQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBcENBO0FBQ0E7QUNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQ0tBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUpBO0FBakJBO0FBSEE7OyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/daygrid/main.js\n");

/***/ }),

/***/ "./node_modules/@material/mwc-base/form-element.js":
/*!*********************************************************!*\
  !*** ./node_modules/@material/mwc-base/form-element.js ***!
  \*********************************************************/
/*! exports provided: addHasRemoveClass, BaseElement, FormElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FormElement\", function() { return FormElement; });\n/* harmony import */ var _base_element_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base-element.js */ \"./node_modules/@material/mwc-base/base-element.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"addHasRemoveClass\", function() { return _base_element_js__WEBPACK_IMPORTED_MODULE_0__[\"addHasRemoveClass\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BaseElement\", function() { return _base_element_js__WEBPACK_IMPORTED_MODULE_0__[\"BaseElement\"]; });\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n@license\nCopyright 2018 Google Inc. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n\n/** @soyCompatible */\n\nvar FormElement = /*#__PURE__*/function (_BaseElement) {\n  _inherits(FormElement, _BaseElement);\n\n  var _super = _createSuper(FormElement);\n\n  function FormElement() {\n    _classCallCheck(this, FormElement);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(FormElement, [{\n    key: \"createRenderRoot\",\n    value: function createRenderRoot() {\n      return this.attachShadow({\n        mode: 'open',\n        delegatesFocus: true\n      });\n    }\n  }, {\n    key: \"click\",\n    value: function click() {\n      if (this.formElement) {\n        this.formElement.focus();\n        this.formElement.click();\n      }\n    }\n  }, {\n    key: \"setAriaLabel\",\n    value: function setAriaLabel(label) {\n      if (this.formElement) {\n        this.formElement.setAttribute('aria-label', label);\n      }\n    }\n  }, {\n    key: \"firstUpdated\",\n    value: function firstUpdated() {\n      var _this = this;\n\n      _get(_getPrototypeOf(FormElement.prototype), \"firstUpdated\", this).call(this);\n\n      this.mdcRoot.addEventListener('change', function (e) {\n        _this.dispatchEvent(new Event('change', e));\n      });\n    }\n  }]);\n\n  return FormElement;\n}(_base_element_js__WEBPACK_IMPORTED_MODULE_0__[\"BaseElement\"]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL213Yy1iYXNlL2Zvcm0tZWxlbWVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvZm9ybS1lbGVtZW50LnRzPzRjNmYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQge2FkZEhhc1JlbW92ZUNsYXNzLCBCYXNlRWxlbWVudCwgQ3VzdG9tRXZlbnRMaXN0ZW5lciwgRXZlbnRUeXBlLCBTcGVjaWZpY0V2ZW50TGlzdGVuZXJ9IGZyb20gJy4vYmFzZS1lbGVtZW50LmpzJztcbmltcG9ydCB7SFRNTEVsZW1lbnRXaXRoUmlwcGxlLCBSaXBwbGVJbnRlcmZhY2V9IGZyb20gJy4vdXRpbHMuanMnO1xuXG5leHBvcnQge1xuICBhZGRIYXNSZW1vdmVDbGFzcyxcbiAgQmFzZUVsZW1lbnQsXG4gIEN1c3RvbUV2ZW50TGlzdGVuZXIsXG4gIEV2ZW50VHlwZSxcbiAgSFRNTEVsZW1lbnRXaXRoUmlwcGxlLFxuICBSaXBwbGVJbnRlcmZhY2UsXG4gIFNwZWNpZmljRXZlbnRMaXN0ZW5lcixcbn07XG5cbi8qKiBAc295Q29tcGF0aWJsZSAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEZvcm1FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuICAvKipcbiAgICogRm9ybS1jYXBhYmxlIGVsZW1lbnQgaW4gdGhlIGNvbXBvbmVudCBTaGFkb3dSb290LlxuICAgKlxuICAgKiBEZWZpbmUgaW4geW91ciBjb21wb25lbnQgd2l0aCB0aGUgYEBxdWVyeWAgZGVjb3JhdG9yXG4gICAqL1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZm9ybUVsZW1lbnQ6IEhUTUxFbGVtZW50O1xuXG4gIHByb3RlY3RlZCBjcmVhdGVSZW5kZXJSb290KCkge1xuICAgIHJldHVybiB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nLCBkZWxlZ2F0ZXNGb2N1czogdHJ1ZX0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudCByaXBwbGUgZ2V0dGVyIGZvciBSaXBwbGUgaW50ZWdyYXRpb24gd2l0aCBtd2MtZm9ybWZpZWxkXG4gICAqL1xuICByZWFkb25seSByaXBwbGU/OiBSaXBwbGVJbnRlcmZhY2V8UHJvbWlzZTxSaXBwbGVJbnRlcmZhY2V8bnVsbD47XG5cbiAgY2xpY2soKSB7XG4gICAgaWYgKHRoaXMuZm9ybUVsZW1lbnQpIHtcbiAgICAgIHRoaXMuZm9ybUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgIHRoaXMuZm9ybUVsZW1lbnQuY2xpY2soKTtcbiAgICB9XG4gIH1cblxuICBzZXRBcmlhTGFiZWwobGFiZWw6IHN0cmluZykge1xuICAgIGlmICh0aGlzLmZvcm1FbGVtZW50KSB7XG4gICAgICB0aGlzLmZvcm1FbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGxhYmVsKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgZmlyc3RVcGRhdGVkKCkge1xuICAgIHN1cGVyLmZpcnN0VXBkYXRlZCgpO1xuICAgIHRoaXMubWRjUm9vdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZSkgPT4ge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJywgZSkpO1xuICAgIH0pO1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBR0E7QUFVQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQVNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFWQTtBQUFBO0FBQUE7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRCQTtBQUFBO0FBQUE7QUF5QkE7QUFDQTtBQUNBO0FBQ0E7QUE1QkE7QUFBQTtBQUFBO0FBOEJBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFuQ0E7QUFDQTtBQURBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@material/mwc-base/form-element.js\n");

/***/ }),

/***/ "./node_modules/@material/mwc-base/observer.js":
/*!*****************************************************!*\
  !*** ./node_modules/@material/mwc-base/observer.js ***!
  \*****************************************************/
/*! exports provided: observer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"observer\", function() { return observer; });\nvar observer = function observer(_observer) {\n  return (// eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function (proto, propName) {\n      // if we haven't wrapped `updated` in this class, do so\n      if (!proto.constructor._observers) {\n        proto.constructor._observers = new Map();\n        var userUpdated = proto.updated;\n\n        proto.updated = function (changedProperties) {\n          var _this = this;\n\n          userUpdated.call(this, changedProperties);\n          changedProperties.forEach(function (v, k) {\n            var observer = _this.constructor._observers.get(k);\n\n            if (observer !== undefined) {\n              observer.call(_this, _this[k], v);\n            }\n          });\n        }; // clone any existing observers (superclasses)\n\n      } else if (!proto.constructor.hasOwnProperty('_observers')) {\n        var observers = proto.constructor._observers;\n        proto.constructor._observers = new Map();\n        observers.forEach( // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        function (v, k) {\n          return proto.constructor._observers.set(k, v);\n        });\n      } // set this method\n\n\n      proto.constructor._observers.set(propName, _observer);\n    }\n  );\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL213Yy1iYXNlL29ic2VydmVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9vYnNlcnZlci50cz9kNDU4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7UHJvcGVydHlWYWx1ZXN9IGZyb20gJ2xpdC1lbGVtZW50L2xpYi91cGRhdGluZy1lbGVtZW50JztcblxuZXhwb3J0IGludGVyZmFjZSBPYnNlcnZlciB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICh2YWx1ZTogYW55LCBvbGQ6IGFueSk6IHZvaWQ7XG59XG5cbmV4cG9ydCBjb25zdCBvYnNlcnZlciA9IChvYnNlcnZlcjogT2JzZXJ2ZXIpID0+XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAocHJvdG86IGFueSwgcHJvcE5hbWU6IFByb3BlcnR5S2V5KSA9PiB7XG4gICAgICAvLyBpZiB3ZSBoYXZlbid0IHdyYXBwZWQgYHVwZGF0ZWRgIGluIHRoaXMgY2xhc3MsIGRvIHNvXG4gICAgICBpZiAoIXByb3RvLmNvbnN0cnVjdG9yLl9vYnNlcnZlcnMpIHtcbiAgICAgICAgcHJvdG8uY29uc3RydWN0b3IuX29ic2VydmVycyA9IG5ldyBNYXA8UHJvcGVydHlLZXksIE9ic2VydmVyPigpO1xuICAgICAgICBjb25zdCB1c2VyVXBkYXRlZCA9IHByb3RvLnVwZGF0ZWQ7XG4gICAgICAgIHByb3RvLnVwZGF0ZWQgPSBmdW5jdGlvbihjaGFuZ2VkUHJvcGVydGllczogUHJvcGVydHlWYWx1ZXMpIHtcbiAgICAgICAgICB1c2VyVXBkYXRlZC5jYWxsKHRoaXMsIGNoYW5nZWRQcm9wZXJ0aWVzKTtcbiAgICAgICAgICBjaGFuZ2VkUHJvcGVydGllcy5mb3JFYWNoKCh2LCBrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMuY29uc3RydWN0b3IuX29ic2VydmVycy5nZXQoayk7XG4gICAgICAgICAgICBpZiAob2JzZXJ2ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBvYnNlcnZlci5jYWxsKHRoaXMsIHRoaXNba10sIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvLyBjbG9uZSBhbnkgZXhpc3Rpbmcgb2JzZXJ2ZXJzIChzdXBlcmNsYXNzZXMpXG4gICAgICB9IGVsc2UgaWYgKCFwcm90by5jb25zdHJ1Y3Rvci5oYXNPd25Qcm9wZXJ0eSgnX29ic2VydmVycycpKSB7XG4gICAgICAgIGNvbnN0IG9ic2VydmVycyA9IHByb3RvLmNvbnN0cnVjdG9yLl9vYnNlcnZlcnM7XG4gICAgICAgIHByb3RvLmNvbnN0cnVjdG9yLl9vYnNlcnZlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIG9ic2VydmVycy5mb3JFYWNoKFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICh2OiBhbnksIGs6IFByb3BlcnR5S2V5KSA9PiBwcm90by5jb25zdHJ1Y3Rvci5fb2JzZXJ2ZXJzLnNldChrLCB2KSk7XG4gICAgICB9XG4gICAgICAvLyBzZXQgdGhpcyBtZXRob2RcbiAgICAgIHByb3RvLmNvbnN0cnVjdG9yLl9vYnNlcnZlcnMuc2V0KHByb3BOYW1lLCBvYnNlcnZlcik7XG4gICAgfTtcbiJdLCJtYXBwaW5ncyI6IkFBdUJBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUExQkE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@material/mwc-base/observer.js\n");

/***/ }),

/***/ "./node_modules/@polymer/app-layout/app-header-layout/app-header-layout.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@polymer/app-layout/app-header-layout/app-header-layout.js ***!
  \*********************************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _polymer_polymer_polymer_legacy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/polymer-legacy.js */ \"./node_modules/@polymer/polymer/polymer-legacy.js\");\n/* harmony import */ var _polymer_iron_flex_layout_iron_flex_layout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @polymer/iron-flex-layout/iron-flex-layout.js */ \"./node_modules/@polymer/iron-flex-layout/iron-flex-layout.js\");\n/* harmony import */ var _polymer_polymer_lib_legacy_polymer_fn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @polymer/polymer/lib/legacy/polymer-fn.js */ \"./node_modules/@polymer/polymer/lib/legacy/polymer-fn.js\");\n/* harmony import */ var _polymer_polymer_lib_legacy_polymer_dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @polymer/polymer/lib/legacy/polymer.dom.js */ \"./node_modules/@polymer/polymer/lib/legacy/polymer.dom.js\");\n/* harmony import */ var _polymer_polymer_lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @polymer/polymer/lib/utils/html-tag.js */ \"./node_modules/@polymer/polymer/lib/utils/html-tag.js\");\n/* harmony import */ var _app_layout_behavior_app_layout_behavior_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../app-layout-behavior/app-layout-behavior.js */ \"./node_modules/@polymer/app-layout/app-layout-behavior/app-layout-behavior.js\");\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n    <style>\\n      :host {\\n        display: block;\\n        /**\\n         * Force app-header-layout to have its own stacking context so that its parent can\\n         * control the stacking of it relative to other elements (e.g. app-drawer-layout).\\n         * This could be done using `isolation: isolate`, but that's not well supported\\n         * across browsers.\\n         */\\n        position: relative;\\n        z-index: 0;\\n      }\\n\\n      #wrapper ::slotted([slot=header]) {\\n        @apply --layout-fixed-top;\\n        z-index: 1;\\n      }\\n\\n      #wrapper.initializing ::slotted([slot=header]) {\\n        position: relative;\\n      }\\n\\n      :host([has-scrolling-region]) {\\n        height: 100%;\\n      }\\n\\n      :host([has-scrolling-region]) #wrapper ::slotted([slot=header]) {\\n        position: absolute;\\n      }\\n\\n      :host([has-scrolling-region]) #wrapper.initializing ::slotted([slot=header]) {\\n        position: relative;\\n      }\\n\\n      :host([has-scrolling-region]) #wrapper #contentContainer {\\n        @apply --layout-fit;\\n        overflow-y: auto;\\n        -webkit-overflow-scrolling: touch;\\n      }\\n\\n      :host([has-scrolling-region]) #wrapper.initializing #contentContainer {\\n        position: relative;\\n      }\\n\\n      :host([fullbleed]) {\\n        @apply --layout-vertical;\\n        @apply --layout-fit;\\n      }\\n\\n      :host([fullbleed]) #wrapper,\\n      :host([fullbleed]) #wrapper #contentContainer {\\n        @apply --layout-vertical;\\n        @apply --layout-flex;\\n      }\\n\\n      #contentContainer {\\n        /* Create a stacking context here so that all children appear below the header. */\\n        position: relative;\\n        z-index: 0;\\n      }\\n\\n      @media print {\\n        :host([has-scrolling-region]) #wrapper #contentContainer {\\n          overflow-y: visible;\\n        }\\n      }\\n\\n    </style>\\n\\n    <div id=\\\"wrapper\\\" class=\\\"initializing\\\">\\n      <slot id=\\\"headerSlot\\\" name=\\\"header\\\"></slot>\\n\\n      <div id=\\\"contentContainer\\\">\\n        <slot></slot>\\n      </div>\\n    </div>\\n\"], [\"\\n    <style>\\n      :host {\\n        display: block;\\n        /**\\n         * Force app-header-layout to have its own stacking context so that its parent can\\n         * control the stacking of it relative to other elements (e.g. app-drawer-layout).\\n         * This could be done using \\\\`isolation: isolate\\\\`, but that's not well supported\\n         * across browsers.\\n         */\\n        position: relative;\\n        z-index: 0;\\n      }\\n\\n      #wrapper ::slotted([slot=header]) {\\n        @apply --layout-fixed-top;\\n        z-index: 1;\\n      }\\n\\n      #wrapper.initializing ::slotted([slot=header]) {\\n        position: relative;\\n      }\\n\\n      :host([has-scrolling-region]) {\\n        height: 100%;\\n      }\\n\\n      :host([has-scrolling-region]) #wrapper ::slotted([slot=header]) {\\n        position: absolute;\\n      }\\n\\n      :host([has-scrolling-region]) #wrapper.initializing ::slotted([slot=header]) {\\n        position: relative;\\n      }\\n\\n      :host([has-scrolling-region]) #wrapper #contentContainer {\\n        @apply --layout-fit;\\n        overflow-y: auto;\\n        -webkit-overflow-scrolling: touch;\\n      }\\n\\n      :host([has-scrolling-region]) #wrapper.initializing #contentContainer {\\n        position: relative;\\n      }\\n\\n      :host([fullbleed]) {\\n        @apply --layout-vertical;\\n        @apply --layout-fit;\\n      }\\n\\n      :host([fullbleed]) #wrapper,\\n      :host([fullbleed]) #wrapper #contentContainer {\\n        @apply --layout-vertical;\\n        @apply --layout-flex;\\n      }\\n\\n      #contentContainer {\\n        /* Create a stacking context here so that all children appear below the header. */\\n        position: relative;\\n        z-index: 0;\\n      }\\n\\n      @media print {\\n        :host([has-scrolling-region]) #wrapper #contentContainer {\\n          overflow-y: visible;\\n        }\\n      }\\n\\n    </style>\\n\\n    <div id=\\\"wrapper\\\" class=\\\"initializing\\\">\\n      <slot id=\\\"headerSlot\\\" name=\\\"header\\\"></slot>\\n\\n      <div id=\\\"contentContainer\\\">\\n        <slot></slot>\\n      </div>\\n    </div>\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n\n/**\napp-header-layout is a wrapper element that positions an app-header and other\ncontent. This element uses the document scroll by default, but it can also\ndefine its own scrolling region.\n\nUsing the document scroll:\n\n```html\n<app-header-layout>\n  <app-header slot=\"header\" fixed condenses effects=\"waterfall\">\n    <app-toolbar>\n      <div main-title>App name</div>\n    </app-toolbar>\n  </app-header>\n  <div>\n    main content\n  </div>\n</app-header-layout>\n```\n\nUsing an own scrolling region:\n\n```html\n<app-header-layout has-scrolling-region style=\"width: 300px; height: 400px;\">\n  <app-header slot=\"header\" fixed condenses effects=\"waterfall\">\n    <app-toolbar>\n      <div main-title>App name</div>\n    </app-toolbar>\n  </app-header>\n  <div>\n    main content\n  </div>\n</app-header-layout>\n```\n\nAdd the `fullbleed` attribute to app-header-layout to make it fit the size of\nits container:\n\n```html\n<app-header-layout fullbleed>\n ...\n</app-header-layout>\n```\n\n@element app-header-layout\n@demo app-header-layout/demo/simple.html Simple Demo\n@demo app-header-layout/demo/scrolling-region.html Scrolling Region\n@demo app-header-layout/demo/music.html Music Demo\n@demo app-header-layout/demo/footer.html Footer Demo\n*/\n\nObject(_polymer_polymer_lib_legacy_polymer_fn_js__WEBPACK_IMPORTED_MODULE_2__[\"Polymer\"])({\n  /** @override */\n  _template: Object(_polymer_polymer_lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_4__[\"html\"])(_templateObject()),\n  is: 'app-header-layout',\n  behaviors: [_app_layout_behavior_app_layout_behavior_js__WEBPACK_IMPORTED_MODULE_5__[\"AppLayoutBehavior\"]],\n  properties: {\n    /**\n     * If true, the current element will have its own scrolling region.\n     * Otherwise, it will use the document scroll to control the header.\n     */\n    hasScrollingRegion: {\n      type: Boolean,\n      value: false,\n      reflectToAttribute: true\n    }\n  },\n  observers: ['resetLayout(isAttached, hasScrollingRegion)'],\n\n  /**\n   * A reference to the app-header element.\n   *\n   * @property header\n   */\n  get header() {\n    return Object(_polymer_polymer_lib_legacy_polymer_dom_js__WEBPACK_IMPORTED_MODULE_3__[\"dom\"])(this.$.headerSlot).getDistributedNodes()[0];\n  },\n\n  _updateLayoutStates: function _updateLayoutStates() {\n    var header = this.header;\n\n    if (!this.isAttached || !header) {\n      return;\n    } // Remove the initializing class, which staticly positions the header and\n    // the content until the height of the header can be read.\n\n\n    this.$.wrapper.classList.remove('initializing'); // Update scroll target.\n\n    header.scrollTarget = this.hasScrollingRegion ? this.$.contentContainer : this.ownerDocument.documentElement; // Get header height here so that style reads are batched together before\n    // style writes (i.e. getBoundingClientRect() below).\n\n    var headerHeight = header.offsetHeight; // Update the header position.\n\n    if (!this.hasScrollingRegion) {\n      requestAnimationFrame(function () {\n        var rect = this.getBoundingClientRect();\n        var rightOffset = document.documentElement.clientWidth - rect.right;\n        header.style.left = rect.left + 'px';\n        header.style.right = rightOffset + 'px';\n      }.bind(this));\n    } else {\n      header.style.left = '';\n      header.style.right = '';\n    } // Update the content container position.\n\n\n    var containerStyle = this.$.contentContainer.style;\n\n    if (header.fixed && !header.condenses && this.hasScrollingRegion) {\n      // If the header size does not change and we're using a scrolling region,\n      // exclude the header area from the scrolling region so that the header\n      // doesn't overlap the scrollbar.\n      containerStyle.marginTop = headerHeight + 'px';\n      containerStyle.paddingTop = '';\n    } else {\n      containerStyle.paddingTop = headerHeight + 'px';\n      containerStyle.marginTop = '';\n    }\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvYXBwLWxheW91dC9hcHAtaGVhZGVyLWxheW91dC9hcHAtaGVhZGVyLWxheW91dC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9hcHAtbGF5b3V0L2FwcC1oZWFkZXItbGF5b3V0L2FwcC1oZWFkZXItbGF5b3V0LmpzP2MzYTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0IFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbmh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dCBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmVcbmZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0IENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzXG5wYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzbyBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50XG5mb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5pbXBvcnQgJ0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci1sZWdhY3kuanMnO1xuaW1wb3J0ICdAcG9seW1lci9pcm9uLWZsZXgtbGF5b3V0L2lyb24tZmxleC1sYXlvdXQuanMnO1xuXG5pbXBvcnQge1BvbHltZXJ9IGZyb20gJ0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmpzJztcbmltcG9ydCB7ZG9tfSBmcm9tICdAcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci5kb20uanMnO1xuaW1wb3J0IHtodG1sfSBmcm9tICdAcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9odG1sLXRhZy5qcyc7XG5cbmltcG9ydCB7QXBwTGF5b3V0QmVoYXZpb3J9IGZyb20gJy4uL2FwcC1sYXlvdXQtYmVoYXZpb3IvYXBwLWxheW91dC1iZWhhdmlvci5qcyc7XG5cbi8qKlxuYXBwLWhlYWRlci1sYXlvdXQgaXMgYSB3cmFwcGVyIGVsZW1lbnQgdGhhdCBwb3NpdGlvbnMgYW4gYXBwLWhlYWRlciBhbmQgb3RoZXJcbmNvbnRlbnQuIFRoaXMgZWxlbWVudCB1c2VzIHRoZSBkb2N1bWVudCBzY3JvbGwgYnkgZGVmYXVsdCwgYnV0IGl0IGNhbiBhbHNvXG5kZWZpbmUgaXRzIG93biBzY3JvbGxpbmcgcmVnaW9uLlxuXG5Vc2luZyB0aGUgZG9jdW1lbnQgc2Nyb2xsOlxuXG5gYGBodG1sXG48YXBwLWhlYWRlci1sYXlvdXQ+XG4gIDxhcHAtaGVhZGVyIHNsb3Q9XCJoZWFkZXJcIiBmaXhlZCBjb25kZW5zZXMgZWZmZWN0cz1cIndhdGVyZmFsbFwiPlxuICAgIDxhcHAtdG9vbGJhcj5cbiAgICAgIDxkaXYgbWFpbi10aXRsZT5BcHAgbmFtZTwvZGl2PlxuICAgIDwvYXBwLXRvb2xiYXI+XG4gIDwvYXBwLWhlYWRlcj5cbiAgPGRpdj5cbiAgICBtYWluIGNvbnRlbnRcbiAgPC9kaXY+XG48L2FwcC1oZWFkZXItbGF5b3V0PlxuYGBgXG5cblVzaW5nIGFuIG93biBzY3JvbGxpbmcgcmVnaW9uOlxuXG5gYGBodG1sXG48YXBwLWhlYWRlci1sYXlvdXQgaGFzLXNjcm9sbGluZy1yZWdpb24gc3R5bGU9XCJ3aWR0aDogMzAwcHg7IGhlaWdodDogNDAwcHg7XCI+XG4gIDxhcHAtaGVhZGVyIHNsb3Q9XCJoZWFkZXJcIiBmaXhlZCBjb25kZW5zZXMgZWZmZWN0cz1cIndhdGVyZmFsbFwiPlxuICAgIDxhcHAtdG9vbGJhcj5cbiAgICAgIDxkaXYgbWFpbi10aXRsZT5BcHAgbmFtZTwvZGl2PlxuICAgIDwvYXBwLXRvb2xiYXI+XG4gIDwvYXBwLWhlYWRlcj5cbiAgPGRpdj5cbiAgICBtYWluIGNvbnRlbnRcbiAgPC9kaXY+XG48L2FwcC1oZWFkZXItbGF5b3V0PlxuYGBgXG5cbkFkZCB0aGUgYGZ1bGxibGVlZGAgYXR0cmlidXRlIHRvIGFwcC1oZWFkZXItbGF5b3V0IHRvIG1ha2UgaXQgZml0IHRoZSBzaXplIG9mXG5pdHMgY29udGFpbmVyOlxuXG5gYGBodG1sXG48YXBwLWhlYWRlci1sYXlvdXQgZnVsbGJsZWVkPlxuIC4uLlxuPC9hcHAtaGVhZGVyLWxheW91dD5cbmBgYFxuXG5AZWxlbWVudCBhcHAtaGVhZGVyLWxheW91dFxuQGRlbW8gYXBwLWhlYWRlci1sYXlvdXQvZGVtby9zaW1wbGUuaHRtbCBTaW1wbGUgRGVtb1xuQGRlbW8gYXBwLWhlYWRlci1sYXlvdXQvZGVtby9zY3JvbGxpbmctcmVnaW9uLmh0bWwgU2Nyb2xsaW5nIFJlZ2lvblxuQGRlbW8gYXBwLWhlYWRlci1sYXlvdXQvZGVtby9tdXNpYy5odG1sIE11c2ljIERlbW9cbkBkZW1vIGFwcC1oZWFkZXItbGF5b3V0L2RlbW8vZm9vdGVyLmh0bWwgRm9vdGVyIERlbW9cbiovXG5Qb2x5bWVyKHtcbiAgLyoqIEBvdmVycmlkZSAqL1xuICBfdGVtcGxhdGU6IGh0bWxgXG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvcmNlIGFwcC1oZWFkZXItbGF5b3V0IHRvIGhhdmUgaXRzIG93biBzdGFja2luZyBjb250ZXh0IHNvIHRoYXQgaXRzIHBhcmVudCBjYW5cbiAgICAgICAgICogY29udHJvbCB0aGUgc3RhY2tpbmcgb2YgaXQgcmVsYXRpdmUgdG8gb3RoZXIgZWxlbWVudHMgKGUuZy4gYXBwLWRyYXdlci1sYXlvdXQpLlxuICAgICAgICAgKiBUaGlzIGNvdWxkIGJlIGRvbmUgdXNpbmcgXFxgaXNvbGF0aW9uOiBpc29sYXRlXFxgLCBidXQgdGhhdCdzIG5vdCB3ZWxsIHN1cHBvcnRlZFxuICAgICAgICAgKiBhY3Jvc3MgYnJvd3NlcnMuXG4gICAgICAgICAqL1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHotaW5kZXg6IDA7XG4gICAgICB9XG5cbiAgICAgICN3cmFwcGVyIDo6c2xvdHRlZChbc2xvdD1oZWFkZXJdKSB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1maXhlZC10b3A7XG4gICAgICAgIHotaW5kZXg6IDE7XG4gICAgICB9XG5cbiAgICAgICN3cmFwcGVyLmluaXRpYWxpemluZyA6OnNsb3R0ZWQoW3Nsb3Q9aGVhZGVyXSkge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtoYXMtc2Nyb2xsaW5nLXJlZ2lvbl0pIHtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbaGFzLXNjcm9sbGluZy1yZWdpb25dKSAjd3JhcHBlciA6OnNsb3R0ZWQoW3Nsb3Q9aGVhZGVyXSkge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtoYXMtc2Nyb2xsaW5nLXJlZ2lvbl0pICN3cmFwcGVyLmluaXRpYWxpemluZyA6OnNsb3R0ZWQoW3Nsb3Q9aGVhZGVyXSkge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtoYXMtc2Nyb2xsaW5nLXJlZ2lvbl0pICN3cmFwcGVyICNjb250ZW50Q29udGFpbmVyIHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWZpdDtcbiAgICAgICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICAgICAgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbaGFzLXNjcm9sbGluZy1yZWdpb25dKSAjd3JhcHBlci5pbml0aWFsaXppbmcgI2NvbnRlbnRDb250YWluZXIge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtmdWxsYmxlZWRdKSB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC12ZXJ0aWNhbDtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWZpdDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2Z1bGxibGVlZF0pICN3cmFwcGVyLFxuICAgICAgOmhvc3QoW2Z1bGxibGVlZF0pICN3cmFwcGVyICNjb250ZW50Q29udGFpbmVyIHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LXZlcnRpY2FsO1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtZmxleDtcbiAgICAgIH1cblxuICAgICAgI2NvbnRlbnRDb250YWluZXIge1xuICAgICAgICAvKiBDcmVhdGUgYSBzdGFja2luZyBjb250ZXh0IGhlcmUgc28gdGhhdCBhbGwgY2hpbGRyZW4gYXBwZWFyIGJlbG93IHRoZSBoZWFkZXIuICovXG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgei1pbmRleDogMDtcbiAgICAgIH1cblxuICAgICAgQG1lZGlhIHByaW50IHtcbiAgICAgICAgOmhvc3QoW2hhcy1zY3JvbGxpbmctcmVnaW9uXSkgI3dyYXBwZXIgI2NvbnRlbnRDb250YWluZXIge1xuICAgICAgICAgIG92ZXJmbG93LXk6IHZpc2libGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIDwvc3R5bGU+XG5cbiAgICA8ZGl2IGlkPVwid3JhcHBlclwiIGNsYXNzPVwiaW5pdGlhbGl6aW5nXCI+XG4gICAgICA8c2xvdCBpZD1cImhlYWRlclNsb3RcIiBuYW1lPVwiaGVhZGVyXCI+PC9zbG90PlxuXG4gICAgICA8ZGl2IGlkPVwiY29udGVudENvbnRhaW5lclwiPlxuICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbmAsXG5cbiAgaXM6ICdhcHAtaGVhZGVyLWxheW91dCcsXG4gIGJlaGF2aW9yczogW0FwcExheW91dEJlaGF2aW9yXSxcblxuICBwcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIGN1cnJlbnQgZWxlbWVudCB3aWxsIGhhdmUgaXRzIG93biBzY3JvbGxpbmcgcmVnaW9uLlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGRvY3VtZW50IHNjcm9sbCB0byBjb250cm9sIHRoZSBoZWFkZXIuXG4gICAgICovXG4gICAgaGFzU2Nyb2xsaW5nUmVnaW9uOiB7dHlwZTogQm9vbGVhbiwgdmFsdWU6IGZhbHNlLCByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWV9XG4gIH0sXG5cbiAgb2JzZXJ2ZXJzOiBbJ3Jlc2V0TGF5b3V0KGlzQXR0YWNoZWQsIGhhc1Njcm9sbGluZ1JlZ2lvbiknXSxcblxuICAvKipcbiAgICogQSByZWZlcmVuY2UgdG8gdGhlIGFwcC1oZWFkZXIgZWxlbWVudC5cbiAgICpcbiAgICogQHByb3BlcnR5IGhlYWRlclxuICAgKi9cbiAgZ2V0IGhlYWRlcigpIHtcbiAgICByZXR1cm4gZG9tKHRoaXMuJC5oZWFkZXJTbG90KS5nZXREaXN0cmlidXRlZE5vZGVzKClbMF07XG4gIH0sXG5cbiAgX3VwZGF0ZUxheW91dFN0YXRlczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhlYWRlciA9IHRoaXMuaGVhZGVyO1xuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkIHx8ICFoZWFkZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRoZSBpbml0aWFsaXppbmcgY2xhc3MsIHdoaWNoIHN0YXRpY2x5IHBvc2l0aW9ucyB0aGUgaGVhZGVyIGFuZFxuICAgIC8vIHRoZSBjb250ZW50IHVudGlsIHRoZSBoZWlnaHQgb2YgdGhlIGhlYWRlciBjYW4gYmUgcmVhZC5cbiAgICB0aGlzLiQud3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKCdpbml0aWFsaXppbmcnKTtcbiAgICAvLyBVcGRhdGUgc2Nyb2xsIHRhcmdldC5cbiAgICBoZWFkZXIuc2Nyb2xsVGFyZ2V0ID0gdGhpcy5oYXNTY3JvbGxpbmdSZWdpb24gP1xuICAgICAgICB0aGlzLiQuY29udGVudENvbnRhaW5lciA6XG4gICAgICAgIHRoaXMub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgLy8gR2V0IGhlYWRlciBoZWlnaHQgaGVyZSBzbyB0aGF0IHN0eWxlIHJlYWRzIGFyZSBiYXRjaGVkIHRvZ2V0aGVyIGJlZm9yZVxuICAgIC8vIHN0eWxlIHdyaXRlcyAoaS5lLiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBiZWxvdykuXG4gICAgdmFyIGhlYWRlckhlaWdodCA9IGhlYWRlci5vZmZzZXRIZWlnaHQ7XG4gICAgLy8gVXBkYXRlIHRoZSBoZWFkZXIgcG9zaXRpb24uXG4gICAgaWYgKCF0aGlzLmhhc1Njcm9sbGluZ1JlZ2lvbikge1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciByaWdodE9mZnNldCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCAtIHJlY3QucmlnaHQ7XG4gICAgICAgIGhlYWRlci5zdHlsZS5sZWZ0ID0gcmVjdC5sZWZ0ICsgJ3B4JztcbiAgICAgICAgaGVhZGVyLnN0eWxlLnJpZ2h0ID0gcmlnaHRPZmZzZXQgKyAncHgnO1xuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZGVyLnN0eWxlLmxlZnQgPSAnJztcbiAgICAgIGhlYWRlci5zdHlsZS5yaWdodCA9ICcnO1xuICAgIH1cbiAgICAvLyBVcGRhdGUgdGhlIGNvbnRlbnQgY29udGFpbmVyIHBvc2l0aW9uLlxuICAgIHZhciBjb250YWluZXJTdHlsZSA9IHRoaXMuJC5jb250ZW50Q29udGFpbmVyLnN0eWxlO1xuICAgIGlmIChoZWFkZXIuZml4ZWQgJiYgIWhlYWRlci5jb25kZW5zZXMgJiYgdGhpcy5oYXNTY3JvbGxpbmdSZWdpb24pIHtcbiAgICAgIC8vIElmIHRoZSBoZWFkZXIgc2l6ZSBkb2VzIG5vdCBjaGFuZ2UgYW5kIHdlJ3JlIHVzaW5nIGEgc2Nyb2xsaW5nIHJlZ2lvbixcbiAgICAgIC8vIGV4Y2x1ZGUgdGhlIGhlYWRlciBhcmVhIGZyb20gdGhlIHNjcm9sbGluZyByZWdpb24gc28gdGhhdCB0aGUgaGVhZGVyXG4gICAgICAvLyBkb2Vzbid0IG92ZXJsYXAgdGhlIHNjcm9sbGJhci5cbiAgICAgIGNvbnRhaW5lclN0eWxlLm1hcmdpblRvcCA9IGhlYWRlckhlaWdodCArICdweCc7XG4gICAgICBjb250YWluZXJTdHlsZS5wYWRkaW5nVG9wID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRhaW5lclN0eWxlLnBhZGRpbmdUb3AgPSBoZWFkZXJIZWlnaHQgKyAncHgnO1xuICAgICAgY29udGFpbmVyU3R5bGUubWFyZ2luVG9wID0gJyc7XG4gICAgfVxuICB9XG59KTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtEQTtBQUNBO0FBQ0E7QUErRUE7QUFDQTtBQUVBO0FBQ0E7Ozs7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTEE7QUFRQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE5SUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@polymer/app-layout/app-header-layout/app-header-layout.js\n");

/***/ }),

/***/ "./node_modules/@polymer/iron-icon/iron-icon.js":
/*!******************************************************!*\
  !*** ./node_modules/@polymer/iron-icon/iron-icon.js ***!
  \******************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _polymer_iron_flex_layout_iron_flex_layout_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/iron-flex-layout/iron-flex-layout.js */ \"./node_modules/@polymer/iron-flex-layout/iron-flex-layout.js\");\n/* harmony import */ var _polymer_iron_meta_iron_meta_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @polymer/iron-meta/iron-meta.js */ \"./node_modules/@polymer/iron-meta/iron-meta.js\");\n/* harmony import */ var _polymer_polymer_lib_legacy_polymer_fn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @polymer/polymer/lib/legacy/polymer-fn.js */ \"./node_modules/@polymer/polymer/lib/legacy/polymer-fn.js\");\n/* harmony import */ var _polymer_polymer_lib_legacy_polymer_dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @polymer/polymer/lib/legacy/polymer.dom.js */ \"./node_modules/@polymer/polymer/lib/legacy/polymer.dom.js\");\n/* harmony import */ var _polymer_polymer_lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @polymer/polymer/lib/utils/html-tag.js */ \"./node_modules/@polymer/polymer/lib/utils/html-tag.js\");\n/* harmony import */ var _polymer_polymer_polymer_legacy_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @polymer/polymer/polymer-legacy.js */ \"./node_modules/@polymer/polymer/polymer-legacy.js\");\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n    <style>\\n      :host {\\n        @apply --layout-inline;\\n        @apply --layout-center-center;\\n        position: relative;\\n\\n        vertical-align: middle;\\n\\n        fill: var(--iron-icon-fill-color, currentcolor);\\n        stroke: var(--iron-icon-stroke-color, none);\\n\\n        width: var(--iron-icon-width, 24px);\\n        height: var(--iron-icon-height, 24px);\\n        @apply --iron-icon;\\n      }\\n\\n      :host([hidden]) {\\n        display: none;\\n      }\\n    </style>\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n\n/**\n\nThe `iron-icon` element displays an icon. By default an icon renders as a 24px\nsquare.\n\nExample using src:\n\n    <iron-icon src=\"star.png\"></iron-icon>\n\nExample setting size to 32px x 32px:\n\n    <iron-icon class=\"big\" src=\"big_star.png\"></iron-icon>\n\n    <style is=\"custom-style\">\n      .big {\n        --iron-icon-height: 32px;\n        --iron-icon-width: 32px;\n      }\n    </style>\n\nThe iron elements include several sets of icons. To use the default set of\nicons, import `iron-icons.js` and use the `icon` attribute to specify an icon:\n\n    <script type=\"module\">\n      import \"@polymer/iron-icons/iron-icons.js\";\n    </script>\n\n    <iron-icon icon=\"menu\"></iron-icon>\n\nTo use a different built-in set of icons, import the specific\n`iron-icons/<iconset>-icons.js`, and specify the icon as `<iconset>:<icon>`.\nFor example, to use a communication icon, you would use:\n\n    <script type=\"module\">\n      import \"@polymer/iron-icons/communication-icons.js\";\n    </script>\n\n    <iron-icon icon=\"communication:email\"></iron-icon>\n\nYou can also create custom icon sets of bitmap or SVG icons.\n\nExample of using an icon named `cherry` from a custom iconset with the ID\n`fruit`:\n\n    <iron-icon icon=\"fruit:cherry\"></iron-icon>\n\nSee `<iron-iconset>` and `<iron-iconset-svg>` for more information about how to\ncreate a custom iconset.\n\nSee the `iron-icons` demo to see the icons available in the various iconsets.\n\n### Styling\n\nThe following custom properties are available for styling:\n\nCustom property | Description | Default\n----------------|-------------|----------\n`--iron-icon` | Mixin applied to the icon | {}\n`--iron-icon-width` | Width of the icon | `24px`\n`--iron-icon-height` | Height of the icon | `24px`\n`--iron-icon-fill-color` | Fill color of the svg icon | `currentcolor`\n`--iron-icon-stroke-color` | Stroke color of the svg icon | none\n\n@group Iron Elements\n@element iron-icon\n@demo demo/index.html\n@hero hero.svg\n@homepage polymer.github.io\n*/\n\nObject(_polymer_polymer_lib_legacy_polymer_fn_js__WEBPACK_IMPORTED_MODULE_2__[\"Polymer\"])({\n  _template: Object(_polymer_polymer_lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_4__[\"html\"])(_templateObject()),\n  is: 'iron-icon',\n  properties: {\n    /**\n     * The name of the icon to use. The name should be of the form:\n     * `iconset_name:icon_name`.\n     */\n    icon: {\n      type: String\n    },\n\n    /**\n     * The name of the theme to used, if one is specified by the\n     * iconset.\n     */\n    theme: {\n      type: String\n    },\n\n    /**\n     * If using iron-icon without an iconset, you can set the src to be\n     * the URL of an individual icon image file. Note that this will take\n     * precedence over a given icon attribute.\n     */\n    src: {\n      type: String\n    },\n\n    /**\n     * @type {!IronMeta}\n     */\n    _meta: {\n      value: _polymer_polymer_polymer_legacy_js__WEBPACK_IMPORTED_MODULE_5__[\"Base\"].create('iron-meta', {\n        type: 'iconset'\n      })\n    }\n  },\n  observers: ['_updateIcon(_meta, isAttached)', '_updateIcon(theme, isAttached)', '_srcChanged(src, isAttached)', '_iconChanged(icon, isAttached)'],\n  _DEFAULT_ICONSET: 'icons',\n  _iconChanged: function _iconChanged(icon) {\n    var parts = (icon || '').split(':');\n    this._iconName = parts.pop();\n    this._iconsetName = parts.pop() || this._DEFAULT_ICONSET;\n\n    this._updateIcon();\n  },\n  _srcChanged: function _srcChanged(src) {\n    this._updateIcon();\n  },\n  _usesIconset: function _usesIconset() {\n    return this.icon || !this.src;\n  },\n\n  /** @suppress {visibility} */\n  _updateIcon: function _updateIcon() {\n    if (this._usesIconset()) {\n      if (this._img && this._img.parentNode) {\n        Object(_polymer_polymer_lib_legacy_polymer_dom_js__WEBPACK_IMPORTED_MODULE_3__[\"dom\"])(this.root).removeChild(this._img);\n      }\n\n      if (this._iconName === '') {\n        if (this._iconset) {\n          this._iconset.removeIcon(this);\n        }\n      } else if (this._iconsetName && this._meta) {\n        this._iconset =\n        /** @type {?Polymer.Iconset} */\n        this._meta.byKey(this._iconsetName);\n\n        if (this._iconset) {\n          this._iconset.applyIcon(this, this._iconName, this.theme);\n\n          this.unlisten(window, 'iron-iconset-added', '_updateIcon');\n        } else {\n          this.listen(window, 'iron-iconset-added', '_updateIcon');\n        }\n      }\n    } else {\n      if (this._iconset) {\n        this._iconset.removeIcon(this);\n      }\n\n      if (!this._img) {\n        this._img = document.createElement('img');\n        this._img.style.width = '100%';\n        this._img.style.height = '100%';\n        this._img.draggable = false;\n      }\n\n      this._img.src = this.src;\n      Object(_polymer_polymer_lib_legacy_polymer_dom_js__WEBPACK_IMPORTED_MODULE_3__[\"dom\"])(this.root).appendChild(this._img);\n    }\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1pY29uL2lyb24taWNvbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWljb24vaXJvbi1pY29uLmpzPzQ0MDgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0IFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbmh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dCBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmVcbmZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0IENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzXG5wYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzbyBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50XG5mb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5pbXBvcnQgJ0Bwb2x5bWVyL2lyb24tZmxleC1sYXlvdXQvaXJvbi1mbGV4LWxheW91dC5qcyc7XG5cbmltcG9ydCB7SXJvbk1ldGF9IGZyb20gJ0Bwb2x5bWVyL2lyb24tbWV0YS9pcm9uLW1ldGEuanMnO1xuaW1wb3J0IHtQb2x5bWVyfSBmcm9tICdAcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyc7XG5pbXBvcnQge2RvbX0gZnJvbSAnQHBvbHltZXIvcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXIuZG9tLmpzJztcbmltcG9ydCB7aHRtbH0gZnJvbSAnQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvaHRtbC10YWcuanMnO1xuaW1wb3J0IHtCYXNlfSBmcm9tICdAcG9seW1lci9wb2x5bWVyL3BvbHltZXItbGVnYWN5LmpzJztcblxuLyoqXG5cblRoZSBgaXJvbi1pY29uYCBlbGVtZW50IGRpc3BsYXlzIGFuIGljb24uIEJ5IGRlZmF1bHQgYW4gaWNvbiByZW5kZXJzIGFzIGEgMjRweFxuc3F1YXJlLlxuXG5FeGFtcGxlIHVzaW5nIHNyYzpcblxuICAgIDxpcm9uLWljb24gc3JjPVwic3Rhci5wbmdcIj48L2lyb24taWNvbj5cblxuRXhhbXBsZSBzZXR0aW5nIHNpemUgdG8gMzJweCB4IDMycHg6XG5cbiAgICA8aXJvbi1pY29uIGNsYXNzPVwiYmlnXCIgc3JjPVwiYmlnX3N0YXIucG5nXCI+PC9pcm9uLWljb24+XG5cbiAgICA8c3R5bGUgaXM9XCJjdXN0b20tc3R5bGVcIj5cbiAgICAgIC5iaWcge1xuICAgICAgICAtLWlyb24taWNvbi1oZWlnaHQ6IDMycHg7XG4gICAgICAgIC0taXJvbi1pY29uLXdpZHRoOiAzMnB4O1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG5cblRoZSBpcm9uIGVsZW1lbnRzIGluY2x1ZGUgc2V2ZXJhbCBzZXRzIG9mIGljb25zLiBUbyB1c2UgdGhlIGRlZmF1bHQgc2V0IG9mXG5pY29ucywgaW1wb3J0IGBpcm9uLWljb25zLmpzYCBhbmQgdXNlIHRoZSBgaWNvbmAgYXR0cmlidXRlIHRvIHNwZWNpZnkgYW4gaWNvbjpcblxuICAgIDxzY3JpcHQgdHlwZT1cIm1vZHVsZVwiPlxuICAgICAgaW1wb3J0IFwiQHBvbHltZXIvaXJvbi1pY29ucy9pcm9uLWljb25zLmpzXCI7XG4gICAgPC9zY3JpcHQ+XG5cbiAgICA8aXJvbi1pY29uIGljb249XCJtZW51XCI+PC9pcm9uLWljb24+XG5cblRvIHVzZSBhIGRpZmZlcmVudCBidWlsdC1pbiBzZXQgb2YgaWNvbnMsIGltcG9ydCB0aGUgc3BlY2lmaWNcbmBpcm9uLWljb25zLzxpY29uc2V0Pi1pY29ucy5qc2AsIGFuZCBzcGVjaWZ5IHRoZSBpY29uIGFzIGA8aWNvbnNldD46PGljb24+YC5cbkZvciBleGFtcGxlLCB0byB1c2UgYSBjb21tdW5pY2F0aW9uIGljb24sIHlvdSB3b3VsZCB1c2U6XG5cbiAgICA8c2NyaXB0IHR5cGU9XCJtb2R1bGVcIj5cbiAgICAgIGltcG9ydCBcIkBwb2x5bWVyL2lyb24taWNvbnMvY29tbXVuaWNhdGlvbi1pY29ucy5qc1wiO1xuICAgIDwvc2NyaXB0PlxuXG4gICAgPGlyb24taWNvbiBpY29uPVwiY29tbXVuaWNhdGlvbjplbWFpbFwiPjwvaXJvbi1pY29uPlxuXG5Zb3UgY2FuIGFsc28gY3JlYXRlIGN1c3RvbSBpY29uIHNldHMgb2YgYml0bWFwIG9yIFNWRyBpY29ucy5cblxuRXhhbXBsZSBvZiB1c2luZyBhbiBpY29uIG5hbWVkIGBjaGVycnlgIGZyb20gYSBjdXN0b20gaWNvbnNldCB3aXRoIHRoZSBJRFxuYGZydWl0YDpcblxuICAgIDxpcm9uLWljb24gaWNvbj1cImZydWl0OmNoZXJyeVwiPjwvaXJvbi1pY29uPlxuXG5TZWUgYDxpcm9uLWljb25zZXQ+YCBhbmQgYDxpcm9uLWljb25zZXQtc3ZnPmAgZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgaG93IHRvXG5jcmVhdGUgYSBjdXN0b20gaWNvbnNldC5cblxuU2VlIHRoZSBgaXJvbi1pY29uc2AgZGVtbyB0byBzZWUgdGhlIGljb25zIGF2YWlsYWJsZSBpbiB0aGUgdmFyaW91cyBpY29uc2V0cy5cblxuIyMjIFN0eWxpbmdcblxuVGhlIGZvbGxvd2luZyBjdXN0b20gcHJvcGVydGllcyBhcmUgYXZhaWxhYmxlIGZvciBzdHlsaW5nOlxuXG5DdXN0b20gcHJvcGVydHkgfCBEZXNjcmlwdGlvbiB8IERlZmF1bHRcbi0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tXG5gLS1pcm9uLWljb25gIHwgTWl4aW4gYXBwbGllZCB0byB0aGUgaWNvbiB8IHt9XG5gLS1pcm9uLWljb24td2lkdGhgIHwgV2lkdGggb2YgdGhlIGljb24gfCBgMjRweGBcbmAtLWlyb24taWNvbi1oZWlnaHRgIHwgSGVpZ2h0IG9mIHRoZSBpY29uIHwgYDI0cHhgXG5gLS1pcm9uLWljb24tZmlsbC1jb2xvcmAgfCBGaWxsIGNvbG9yIG9mIHRoZSBzdmcgaWNvbiB8IGBjdXJyZW50Y29sb3JgXG5gLS1pcm9uLWljb24tc3Ryb2tlLWNvbG9yYCB8IFN0cm9rZSBjb2xvciBvZiB0aGUgc3ZnIGljb24gfCBub25lXG5cbkBncm91cCBJcm9uIEVsZW1lbnRzXG5AZWxlbWVudCBpcm9uLWljb25cbkBkZW1vIGRlbW8vaW5kZXguaHRtbFxuQGhlcm8gaGVyby5zdmdcbkBob21lcGFnZSBwb2x5bWVyLmdpdGh1Yi5pb1xuKi9cblBvbHltZXIoe1xuICBfdGVtcGxhdGU6IGh0bWxgXG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtaW5saW5lO1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtY2VudGVyLWNlbnRlcjtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuXG4gICAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG5cbiAgICAgICAgZmlsbDogdmFyKC0taXJvbi1pY29uLWZpbGwtY29sb3IsIGN1cnJlbnRjb2xvcik7XG4gICAgICAgIHN0cm9rZTogdmFyKC0taXJvbi1pY29uLXN0cm9rZS1jb2xvciwgbm9uZSk7XG5cbiAgICAgICAgd2lkdGg6IHZhcigtLWlyb24taWNvbi13aWR0aCwgMjRweCk7XG4gICAgICAgIGhlaWdodDogdmFyKC0taXJvbi1pY29uLWhlaWdodCwgMjRweCk7XG4gICAgICAgIEBhcHBseSAtLWlyb24taWNvbjtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2hpZGRlbl0pIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuYCxcblxuICBpczogJ2lyb24taWNvbicsXG5cbiAgcHJvcGVydGllczoge1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGljb24gdG8gdXNlLiBUaGUgbmFtZSBzaG91bGQgYmUgb2YgdGhlIGZvcm06XG4gICAgICogYGljb25zZXRfbmFtZTppY29uX25hbWVgLlxuICAgICAqL1xuICAgIGljb246IHt0eXBlOiBTdHJpbmd9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHRoZW1lIHRvIHVzZWQsIGlmIG9uZSBpcyBzcGVjaWZpZWQgYnkgdGhlXG4gICAgICogaWNvbnNldC5cbiAgICAgKi9cbiAgICB0aGVtZToge3R5cGU6IFN0cmluZ30sXG5cbiAgICAvKipcbiAgICAgKiBJZiB1c2luZyBpcm9uLWljb24gd2l0aG91dCBhbiBpY29uc2V0LCB5b3UgY2FuIHNldCB0aGUgc3JjIHRvIGJlXG4gICAgICogdGhlIFVSTCBvZiBhbiBpbmRpdmlkdWFsIGljb24gaW1hZ2UgZmlsZS4gTm90ZSB0aGF0IHRoaXMgd2lsbCB0YWtlXG4gICAgICogcHJlY2VkZW5jZSBvdmVyIGEgZ2l2ZW4gaWNvbiBhdHRyaWJ1dGUuXG4gICAgICovXG4gICAgc3JjOiB7dHlwZTogU3RyaW5nfSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshSXJvbk1ldGF9XG4gICAgICovXG4gICAgX21ldGE6IHt2YWx1ZTogQmFzZS5jcmVhdGUoJ2lyb24tbWV0YScsIHt0eXBlOiAnaWNvbnNldCd9KX1cblxuICB9LFxuXG4gIG9ic2VydmVyczogW1xuICAgICdfdXBkYXRlSWNvbihfbWV0YSwgaXNBdHRhY2hlZCknLFxuICAgICdfdXBkYXRlSWNvbih0aGVtZSwgaXNBdHRhY2hlZCknLFxuICAgICdfc3JjQ2hhbmdlZChzcmMsIGlzQXR0YWNoZWQpJyxcbiAgICAnX2ljb25DaGFuZ2VkKGljb24sIGlzQXR0YWNoZWQpJ1xuICBdLFxuXG4gIF9ERUZBVUxUX0lDT05TRVQ6ICdpY29ucycsXG5cbiAgX2ljb25DaGFuZ2VkOiBmdW5jdGlvbihpY29uKSB7XG4gICAgdmFyIHBhcnRzID0gKGljb24gfHwgJycpLnNwbGl0KCc6Jyk7XG4gICAgdGhpcy5faWNvbk5hbWUgPSBwYXJ0cy5wb3AoKTtcbiAgICB0aGlzLl9pY29uc2V0TmFtZSA9IHBhcnRzLnBvcCgpIHx8IHRoaXMuX0RFRkFVTFRfSUNPTlNFVDtcbiAgICB0aGlzLl91cGRhdGVJY29uKCk7XG4gIH0sXG5cbiAgX3NyY0NoYW5nZWQ6IGZ1bmN0aW9uKHNyYykge1xuICAgIHRoaXMuX3VwZGF0ZUljb24oKTtcbiAgfSxcblxuICBfdXNlc0ljb25zZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmljb24gfHwgIXRoaXMuc3JjO1xuICB9LFxuXG4gIC8qKiBAc3VwcHJlc3Mge3Zpc2liaWxpdHl9ICovXG4gIF91cGRhdGVJY29uOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fdXNlc0ljb25zZXQoKSkge1xuICAgICAgaWYgKHRoaXMuX2ltZyAmJiB0aGlzLl9pbWcucGFyZW50Tm9kZSkge1xuICAgICAgICBkb20odGhpcy5yb290KS5yZW1vdmVDaGlsZCh0aGlzLl9pbWcpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2ljb25OYW1lID09PSAnJykge1xuICAgICAgICBpZiAodGhpcy5faWNvbnNldCkge1xuICAgICAgICAgIHRoaXMuX2ljb25zZXQucmVtb3ZlSWNvbih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9pY29uc2V0TmFtZSAmJiB0aGlzLl9tZXRhKSB7XG4gICAgICAgIHRoaXMuX2ljb25zZXQgPSAvKiogQHR5cGUgez9Qb2x5bWVyLkljb25zZXR9ICovIChcbiAgICAgICAgICAgIHRoaXMuX21ldGEuYnlLZXkodGhpcy5faWNvbnNldE5hbWUpKTtcbiAgICAgICAgaWYgKHRoaXMuX2ljb25zZXQpIHtcbiAgICAgICAgICB0aGlzLl9pY29uc2V0LmFwcGx5SWNvbih0aGlzLCB0aGlzLl9pY29uTmFtZSwgdGhpcy50aGVtZSk7XG4gICAgICAgICAgdGhpcy51bmxpc3Rlbih3aW5kb3csICdpcm9uLWljb25zZXQtYWRkZWQnLCAnX3VwZGF0ZUljb24nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxpc3Rlbih3aW5kb3csICdpcm9uLWljb25zZXQtYWRkZWQnLCAnX3VwZGF0ZUljb24nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5faWNvbnNldCkge1xuICAgICAgICB0aGlzLl9pY29uc2V0LnJlbW92ZUljb24odGhpcyk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2ltZykge1xuICAgICAgICB0aGlzLl9pbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgdGhpcy5faW1nLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICB0aGlzLl9pbWcuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICB0aGlzLl9pbWcuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLl9pbWcuc3JjID0gdGhpcy5zcmM7XG4gICAgICBkb20odGhpcy5yb290KS5hcHBlbmRDaGlsZCh0aGlzLl9pbWcpO1xuICAgIH1cbiAgfVxufSk7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7OztBQVVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9FQTtBQUNBO0FBdUJBO0FBRUE7QUFFQTs7OztBQUlBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUFBO0FBQUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7OztBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUF4QkE7QUE0QkE7QUFPQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQS9HQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@polymer/iron-icon/iron-icon.js\n");

/***/ }),

/***/ "./node_modules/@polymer/iron-meta/iron-meta.js":
/*!******************************************************!*\
  !*** ./node_modules/@polymer/iron-meta/iron-meta.js ***!
  \******************************************************/
/*! exports provided: IronMeta */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IronMeta\", function() { return IronMeta; });\n/* harmony import */ var _polymer_polymer_polymer_legacy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/polymer-legacy.js */ \"./node_modules/@polymer/polymer/polymer-legacy.js\");\n/* harmony import */ var _polymer_polymer_lib_legacy_polymer_fn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @polymer/polymer/lib/legacy/polymer-fn.js */ \"./node_modules/@polymer/polymer/lib/legacy/polymer-fn.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\n\n\nvar IronMeta = /*#__PURE__*/function () {\n  /**\n   * @param {{\n   *   type: (string|null|undefined),\n   *   key: (string|null|undefined),\n   *   value: *,\n   * }=} options\n   */\n  function IronMeta(options) {\n    _classCallCheck(this, IronMeta);\n\n    IronMeta[' '](options);\n    /** @type {string} */\n\n    this.type = options && options.type || 'default';\n    /** @type {string|null|undefined} */\n\n    this.key = options && options.key;\n\n    if (options && 'value' in options) {\n      /** @type {*} */\n      this.value = options.value;\n    }\n  }\n  /** @return {*} */\n\n\n  _createClass(IronMeta, [{\n    key: \"byKey\",\n\n    /**\n     * @param {string} key\n     * @return {*}\n     */\n    value: function byKey(key) {\n      this.key = key;\n      return this.value;\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      var type = this.type;\n      var key = this.key;\n\n      if (type && key) {\n        return IronMeta.types[type] && IronMeta.types[type][key];\n      }\n    }\n    /** @param {*} value */\n    ,\n    set: function set(value) {\n      var type = this.type;\n      var key = this.key;\n\n      if (type && key) {\n        type = IronMeta.types[type] = IronMeta.types[type] || {};\n\n        if (value == null) {\n          delete type[key];\n        } else {\n          type[key] = value;\n        }\n      }\n    }\n    /** @return {!Array<*>} */\n\n  }, {\n    key: \"list\",\n    get: function get() {\n      var type = this.type;\n\n      if (type) {\n        var items = IronMeta.types[this.type];\n\n        if (!items) {\n          return [];\n        }\n\n        return Object.keys(items).map(function (key) {\n          return metaDatas[this.type][key];\n        }, this);\n      }\n    }\n  }]);\n\n  return IronMeta;\n}();\n; // This function is used to convince Closure not to remove constructor calls\n// for instances that are not held anywhere. For example, when\n// `new IronMeta({...})` is used only for the side effect of adding a value.\n\nIronMeta[' '] = function () {};\n\nIronMeta.types = {};\nvar metaDatas = IronMeta.types;\n/**\n`iron-meta` is a generic element you can use for sharing information across the\nDOM tree. It uses [monostate pattern](http://c2.com/cgi/wiki?MonostatePattern)\nsuch that any instance of iron-meta has access to the shared information. You\ncan use `iron-meta` to share whatever you want (or create an extension [like\nx-meta] for enhancements).\n\nThe `iron-meta` instances containing your actual data can be loaded in an\nimport, or constructed in any way you see fit. The only requirement is that you\ncreate them before you try to access them.\n\nExamples:\n\nIf I create an instance like this:\n\n    <iron-meta key=\"info\" value=\"foo/bar\"></iron-meta>\n\nNote that value=\"foo/bar\" is the metadata I've defined. I could define more\nattributes or use child nodes to define additional metadata.\n\nNow I can access that element (and it's metadata) from any iron-meta instance\nvia the byKey method, e.g.\n\n    meta.byKey('info');\n\nPure imperative form would be like:\n\n    document.createElement('iron-meta').byKey('info');\n\nOr, in a Polymer element, you can include a meta in your template:\n\n    <iron-meta id=\"meta\"></iron-meta>\n    ...\n    this.$.meta.byKey('info');\n\n@group Iron Elements\n@demo demo/index.html\n@element iron-meta\n*/\n\nObject(_polymer_polymer_lib_legacy_polymer_fn_js__WEBPACK_IMPORTED_MODULE_1__[\"Polymer\"])({\n  is: 'iron-meta',\n  properties: {\n    /**\n     * The type of meta-data.  All meta-data of the same type is stored\n     * together.\n     * @type {string}\n     */\n    type: {\n      type: String,\n      value: 'default'\n    },\n\n    /**\n     * The key used to store `value` under the `type` namespace.\n     * @type {?string}\n     */\n    key: {\n      type: String\n    },\n\n    /**\n     * The meta-data to store or retrieve.\n     * @type {*}\n     */\n    value: {\n      type: String,\n      notify: true\n    },\n\n    /**\n     * If true, `value` is set to the iron-meta instance itself.\n     */\n    self: {\n      type: Boolean,\n      observer: '_selfChanged'\n    },\n    __meta: {\n      type: Boolean,\n      computed: '__computeMeta(type, key, value)'\n    }\n  },\n  hostAttributes: {\n    hidden: true\n  },\n  __computeMeta: function __computeMeta(type, key, value) {\n    var meta = new IronMeta({\n      type: type,\n      key: key\n    });\n\n    if (value !== undefined && value !== meta.value) {\n      meta.value = value;\n    } else if (this.value !== meta.value) {\n      this.value = meta.value;\n    }\n\n    return meta;\n  },\n\n  get list() {\n    return this.__meta && this.__meta.list;\n  },\n\n  _selfChanged: function _selfChanged(self) {\n    if (self) {\n      this.value = this;\n    }\n  },\n\n  /**\n   * Retrieves meta data value by key.\n   *\n   * @method byKey\n   * @param {string} key The key of the meta-data to be returned.\n   * @return {*}\n   */\n  byKey: function byKey(key) {\n    return new IronMeta({\n      type: this.type,\n      key: key\n    }).value;\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1tZXRhL2lyb24tbWV0YS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLW1ldGEvaXJvbi1tZXRhLmpzP2I4OGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE1IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0IFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbmh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dCBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmVcbmZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0IENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzXG5wYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzbyBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50XG5mb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5pbXBvcnQgJ0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci1sZWdhY3kuanMnO1xuXG5pbXBvcnQge1BvbHltZXJ9IGZyb20gJ0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmpzJztcblxuZXhwb3J0IGNsYXNzIElyb25NZXRhIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7e1xuICAgKiAgIHR5cGU6IChzdHJpbmd8bnVsbHx1bmRlZmluZWQpLFxuICAgKiAgIGtleTogKHN0cmluZ3xudWxsfHVuZGVmaW5lZCksXG4gICAqICAgdmFsdWU6ICosXG4gICAqIH09fSBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgSXJvbk1ldGFbJyAnXShvcHRpb25zKTtcblxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXMudHlwZSA9IChvcHRpb25zICYmIG9wdGlvbnMudHlwZSkgfHwgJ2RlZmF1bHQnO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nfG51bGx8dW5kZWZpbmVkfSAqL1xuICAgIHRoaXMua2V5ID0gb3B0aW9ucyAmJiBvcHRpb25zLmtleTtcbiAgICBpZiAob3B0aW9ucyAmJiAndmFsdWUnIGluIG9wdGlvbnMpIHtcbiAgICAgIC8qKiBAdHlwZSB7Kn0gKi9cbiAgICAgIHRoaXMudmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHsqfSAqL1xuICBnZXQgdmFsdWUoKSB7XG4gICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgdmFyIGtleSA9IHRoaXMua2V5O1xuXG4gICAgaWYgKHR5cGUgJiYga2V5KSB7XG4gICAgICByZXR1cm4gSXJvbk1ldGEudHlwZXNbdHlwZV0gJiYgSXJvbk1ldGEudHlwZXNbdHlwZV1ba2V5XTtcbiAgICB9XG4gIH1cblxuICAvKiogQHBhcmFtIHsqfSB2YWx1ZSAqL1xuICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcbiAgICB2YXIga2V5ID0gdGhpcy5rZXk7XG5cbiAgICBpZiAodHlwZSAmJiBrZXkpIHtcbiAgICAgIHR5cGUgPSBJcm9uTWV0YS50eXBlc1t0eXBlXSA9IElyb25NZXRhLnR5cGVzW3R5cGVdIHx8IHt9O1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIHR5cGVba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshQXJyYXk8Kj59ICovXG4gIGdldCBsaXN0KCkge1xuICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIHZhciBpdGVtcyA9IElyb25NZXRhLnR5cGVzW3RoaXMudHlwZV07XG4gICAgICBpZiAoIWl0ZW1zKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGl0ZW1zKS5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBtZXRhRGF0YXNbdGhpcy50eXBlXVtrZXldO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIGJ5S2V5KGtleSkge1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG59O1xuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gY29udmluY2UgQ2xvc3VyZSBub3QgdG8gcmVtb3ZlIGNvbnN0cnVjdG9yIGNhbGxzXG4vLyBmb3IgaW5zdGFuY2VzIHRoYXQgYXJlIG5vdCBoZWxkIGFueXdoZXJlLiBGb3IgZXhhbXBsZSwgd2hlblxuLy8gYG5ldyBJcm9uTWV0YSh7Li4ufSlgIGlzIHVzZWQgb25seSBmb3IgdGhlIHNpZGUgZWZmZWN0IG9mIGFkZGluZyBhIHZhbHVlLlxuSXJvbk1ldGFbJyAnXSA9IGZ1bmN0aW9uKCkge307XG5cbklyb25NZXRhLnR5cGVzID0ge307XG5cbnZhciBtZXRhRGF0YXMgPSBJcm9uTWV0YS50eXBlcztcblxuLyoqXG5gaXJvbi1tZXRhYCBpcyBhIGdlbmVyaWMgZWxlbWVudCB5b3UgY2FuIHVzZSBmb3Igc2hhcmluZyBpbmZvcm1hdGlvbiBhY3Jvc3MgdGhlXG5ET00gdHJlZS4gSXQgdXNlcyBbbW9ub3N0YXRlIHBhdHRlcm5dKGh0dHA6Ly9jMi5jb20vY2dpL3dpa2k/TW9ub3N0YXRlUGF0dGVybilcbnN1Y2ggdGhhdCBhbnkgaW5zdGFuY2Ugb2YgaXJvbi1tZXRhIGhhcyBhY2Nlc3MgdG8gdGhlIHNoYXJlZCBpbmZvcm1hdGlvbi4gWW91XG5jYW4gdXNlIGBpcm9uLW1ldGFgIHRvIHNoYXJlIHdoYXRldmVyIHlvdSB3YW50IChvciBjcmVhdGUgYW4gZXh0ZW5zaW9uIFtsaWtlXG54LW1ldGFdIGZvciBlbmhhbmNlbWVudHMpLlxuXG5UaGUgYGlyb24tbWV0YWAgaW5zdGFuY2VzIGNvbnRhaW5pbmcgeW91ciBhY3R1YWwgZGF0YSBjYW4gYmUgbG9hZGVkIGluIGFuXG5pbXBvcnQsIG9yIGNvbnN0cnVjdGVkIGluIGFueSB3YXkgeW91IHNlZSBmaXQuIFRoZSBvbmx5IHJlcXVpcmVtZW50IGlzIHRoYXQgeW91XG5jcmVhdGUgdGhlbSBiZWZvcmUgeW91IHRyeSB0byBhY2Nlc3MgdGhlbS5cblxuRXhhbXBsZXM6XG5cbklmIEkgY3JlYXRlIGFuIGluc3RhbmNlIGxpa2UgdGhpczpcblxuICAgIDxpcm9uLW1ldGEga2V5PVwiaW5mb1wiIHZhbHVlPVwiZm9vL2JhclwiPjwvaXJvbi1tZXRhPlxuXG5Ob3RlIHRoYXQgdmFsdWU9XCJmb28vYmFyXCIgaXMgdGhlIG1ldGFkYXRhIEkndmUgZGVmaW5lZC4gSSBjb3VsZCBkZWZpbmUgbW9yZVxuYXR0cmlidXRlcyBvciB1c2UgY2hpbGQgbm9kZXMgdG8gZGVmaW5lIGFkZGl0aW9uYWwgbWV0YWRhdGEuXG5cbk5vdyBJIGNhbiBhY2Nlc3MgdGhhdCBlbGVtZW50IChhbmQgaXQncyBtZXRhZGF0YSkgZnJvbSBhbnkgaXJvbi1tZXRhIGluc3RhbmNlXG52aWEgdGhlIGJ5S2V5IG1ldGhvZCwgZS5nLlxuXG4gICAgbWV0YS5ieUtleSgnaW5mbycpO1xuXG5QdXJlIGltcGVyYXRpdmUgZm9ybSB3b3VsZCBiZSBsaWtlOlxuXG4gICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaXJvbi1tZXRhJykuYnlLZXkoJ2luZm8nKTtcblxuT3IsIGluIGEgUG9seW1lciBlbGVtZW50LCB5b3UgY2FuIGluY2x1ZGUgYSBtZXRhIGluIHlvdXIgdGVtcGxhdGU6XG5cbiAgICA8aXJvbi1tZXRhIGlkPVwibWV0YVwiPjwvaXJvbi1tZXRhPlxuICAgIC4uLlxuICAgIHRoaXMuJC5tZXRhLmJ5S2V5KCdpbmZvJyk7XG5cbkBncm91cCBJcm9uIEVsZW1lbnRzXG5AZGVtbyBkZW1vL2luZGV4Lmh0bWxcbkBlbGVtZW50IGlyb24tbWV0YVxuKi9cblBvbHltZXIoe1xuXG4gIGlzOiAnaXJvbi1tZXRhJyxcblxuICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBtZXRhLWRhdGEuICBBbGwgbWV0YS1kYXRhIG9mIHRoZSBzYW1lIHR5cGUgaXMgc3RvcmVkXG4gICAgICogdG9nZXRoZXIuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0eXBlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB2YWx1ZTogJ2RlZmF1bHQnLFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUga2V5IHVzZWQgdG8gc3RvcmUgYHZhbHVlYCB1bmRlciB0aGUgYHR5cGVgIG5hbWVzcGFjZS5cbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKi9cbiAgICBrZXk6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIG1ldGEtZGF0YSB0byBzdG9yZSBvciByZXRyaWV2ZS5cbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKi9cbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgbm90aWZ5OiB0cnVlLFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBgdmFsdWVgIGlzIHNldCB0byB0aGUgaXJvbi1tZXRhIGluc3RhbmNlIGl0c2VsZi5cbiAgICAgKi9cbiAgICBzZWxmOiB7dHlwZTogQm9vbGVhbiwgb2JzZXJ2ZXI6ICdfc2VsZkNoYW5nZWQnfSxcblxuICAgIF9fbWV0YToge3R5cGU6IEJvb2xlYW4sIGNvbXB1dGVkOiAnX19jb21wdXRlTWV0YSh0eXBlLCBrZXksIHZhbHVlKSd9XG4gIH0sXG5cbiAgaG9zdEF0dHJpYnV0ZXM6IHtoaWRkZW46IHRydWV9LFxuXG4gIF9fY29tcHV0ZU1ldGE6IGZ1bmN0aW9uKHR5cGUsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgbWV0YSA9IG5ldyBJcm9uTWV0YSh7dHlwZTogdHlwZSwga2V5OiBrZXl9KTtcblxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBtZXRhLnZhbHVlKSB7XG4gICAgICBtZXRhLnZhbHVlID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLnZhbHVlICE9PSBtZXRhLnZhbHVlKSB7XG4gICAgICB0aGlzLnZhbHVlID0gbWV0YS52YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWV0YTtcbiAgfSxcblxuICBnZXQgbGlzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fX21ldGEgJiYgdGhpcy5fX21ldGEubGlzdDtcbiAgfSxcblxuICBfc2VsZkNoYW5nZWQ6IGZ1bmN0aW9uKHNlbGYpIHtcbiAgICBpZiAoc2VsZikge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXM7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgbWV0YSBkYXRhIHZhbHVlIGJ5IGtleS5cbiAgICpcbiAgICogQG1ldGhvZCBieUtleVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGEtZGF0YSB0byBiZSByZXR1cm5lZC5cbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIGJ5S2V5OiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gbmV3IElyb25NZXRhKHt0eXBlOiB0aGlzLnR5cGUsIGtleToga2V5fSkudmFsdWU7XG4gIH1cbn0pO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7QUFVQTtBQUVBO0FBRUE7QUFDQTs7Ozs7OztBQU9BO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBdkJBO0FBQUE7QUFDQTtBQTZEQTs7OztBQTlEQTtBQW1FQTtBQUNBO0FBQ0E7QUFyRUE7QUFBQTtBQUFBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUEvQkE7QUFBQTtBQWlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUEvQ0E7QUFBQTtBQUFBO0FBZ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE1REE7QUFDQTtBQURBO0FBQUE7QUFzRUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUNBO0FBRUE7QUFFQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTs7OztBQUlBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7OztBQUdBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFsQ0E7QUFxQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQTFFQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@polymer/iron-meta/iron-meta.js\n");

/***/ }),

/***/ "./node_modules/idb-keyval/dist/idb-keyval.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/idb-keyval/dist/idb-keyval.mjs ***!
  \*****************************************************/
/*! exports provided: Store, get, set, del, clear, keys */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Store\", function() { return Store; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"get\", function() { return get; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"del\", function() { return del; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clear\", function() { return clear; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keys\", function() { return keys; });\nclass Store {\r\n    constructor(dbName = 'keyval-store', storeName = 'keyval') {\r\n        this.storeName = storeName;\r\n        this._dbp = new Promise((resolve, reject) => {\r\n            const openreq = indexedDB.open(dbName, 1);\r\n            openreq.onerror = () => reject(openreq.error);\r\n            openreq.onsuccess = () => resolve(openreq.result);\r\n            // First time setup: create an empty object store\r\n            openreq.onupgradeneeded = () => {\r\n                openreq.result.createObjectStore(storeName);\r\n            };\r\n        });\r\n    }\r\n    _withIDBStore(type, callback) {\r\n        return this._dbp.then(db => new Promise((resolve, reject) => {\r\n            const transaction = db.transaction(this.storeName, type);\r\n            transaction.oncomplete = () => resolve();\r\n            transaction.onabort = transaction.onerror = () => reject(transaction.error);\r\n            callback(transaction.objectStore(this.storeName));\r\n        }));\r\n    }\r\n}\r\nlet store;\r\nfunction getDefaultStore() {\r\n    if (!store)\r\n        store = new Store();\r\n    return store;\r\n}\r\nfunction get(key, store = getDefaultStore()) {\r\n    let req;\r\n    return store._withIDBStore('readonly', store => {\r\n        req = store.get(key);\r\n    }).then(() => req.result);\r\n}\r\nfunction set(key, value, store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.put(value, key);\r\n    });\r\n}\r\nfunction del(key, store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.delete(key);\r\n    });\r\n}\r\nfunction clear(store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.clear();\r\n    });\r\n}\r\nfunction keys(store = getDefaultStore()) {\r\n    const keys = [];\r\n    return store._withIDBStore('readonly', store => {\r\n        // This would be store.getAllKeys(), but it isn't supported by Edge or Safari.\r\n        // And openKeyCursor isn't supported by Safari.\r\n        (store.openKeyCursor || store.openCursor).call(store).onsuccess = function () {\r\n            if (!this.result)\r\n                return;\r\n            keys.push(this.result.key);\r\n            this.result.continue();\r\n        };\r\n    }).then(() => keys);\r\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaWRiLWtleXZhbC9kaXN0L2lkYi1rZXl2YWwubWpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lkYi1rZXl2YWwvZGlzdC9pZGIta2V5dmFsLm1qcz9jZWQwIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIFN0b3JlIHtcclxuICAgIGNvbnN0cnVjdG9yKGRiTmFtZSA9ICdrZXl2YWwtc3RvcmUnLCBzdG9yZU5hbWUgPSAna2V5dmFsJykge1xyXG4gICAgICAgIHRoaXMuc3RvcmVOYW1lID0gc3RvcmVOYW1lO1xyXG4gICAgICAgIHRoaXMuX2RicCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgb3BlbnJlcSA9IGluZGV4ZWREQi5vcGVuKGRiTmFtZSwgMSk7XHJcbiAgICAgICAgICAgIG9wZW5yZXEub25lcnJvciA9ICgpID0+IHJlamVjdChvcGVucmVxLmVycm9yKTtcclxuICAgICAgICAgICAgb3BlbnJlcS5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKG9wZW5yZXEucmVzdWx0KTtcclxuICAgICAgICAgICAgLy8gRmlyc3QgdGltZSBzZXR1cDogY3JlYXRlIGFuIGVtcHR5IG9iamVjdCBzdG9yZVxyXG4gICAgICAgICAgICBvcGVucmVxLm9udXBncmFkZW5lZWRlZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIG9wZW5yZXEucmVzdWx0LmNyZWF0ZU9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfd2l0aElEQlN0b3JlKHR5cGUsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RicC50aGVuKGRiID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbih0aGlzLnN0b3JlTmFtZSwgdHlwZSk7XHJcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSAoKSA9PiByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLm9uYWJvcnQgPSB0cmFuc2FjdGlvbi5vbmVycm9yID0gKCkgPT4gcmVqZWN0KHRyYW5zYWN0aW9uLmVycm9yKTtcclxuICAgICAgICAgICAgY2FsbGJhY2sodHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpKTtcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcbn1cclxubGV0IHN0b3JlO1xyXG5mdW5jdGlvbiBnZXREZWZhdWx0U3RvcmUoKSB7XHJcbiAgICBpZiAoIXN0b3JlKVxyXG4gICAgICAgIHN0b3JlID0gbmV3IFN0b3JlKCk7XHJcbiAgICByZXR1cm4gc3RvcmU7XHJcbn1cclxuZnVuY3Rpb24gZ2V0KGtleSwgc3RvcmUgPSBnZXREZWZhdWx0U3RvcmUoKSkge1xyXG4gICAgbGV0IHJlcTtcclxuICAgIHJldHVybiBzdG9yZS5fd2l0aElEQlN0b3JlKCdyZWFkb25seScsIHN0b3JlID0+IHtcclxuICAgICAgICByZXEgPSBzdG9yZS5nZXQoa2V5KTtcclxuICAgIH0pLnRoZW4oKCkgPT4gcmVxLnJlc3VsdCk7XHJcbn1cclxuZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUsIHN0b3JlID0gZ2V0RGVmYXVsdFN0b3JlKCkpIHtcclxuICAgIHJldHVybiBzdG9yZS5fd2l0aElEQlN0b3JlKCdyZWFkd3JpdGUnLCBzdG9yZSA9PiB7XHJcbiAgICAgICAgc3RvcmUucHV0KHZhbHVlLCBrZXkpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZGVsKGtleSwgc3RvcmUgPSBnZXREZWZhdWx0U3RvcmUoKSkge1xyXG4gICAgcmV0dXJuIHN0b3JlLl93aXRoSURCU3RvcmUoJ3JlYWR3cml0ZScsIHN0b3JlID0+IHtcclxuICAgICAgICBzdG9yZS5kZWxldGUoa2V5KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGNsZWFyKHN0b3JlID0gZ2V0RGVmYXVsdFN0b3JlKCkpIHtcclxuICAgIHJldHVybiBzdG9yZS5fd2l0aElEQlN0b3JlKCdyZWFkd3JpdGUnLCBzdG9yZSA9PiB7XHJcbiAgICAgICAgc3RvcmUuY2xlYXIoKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGtleXMoc3RvcmUgPSBnZXREZWZhdWx0U3RvcmUoKSkge1xyXG4gICAgY29uc3Qga2V5cyA9IFtdO1xyXG4gICAgcmV0dXJuIHN0b3JlLl93aXRoSURCU3RvcmUoJ3JlYWRvbmx5Jywgc3RvcmUgPT4ge1xyXG4gICAgICAgIC8vIFRoaXMgd291bGQgYmUgc3RvcmUuZ2V0QWxsS2V5cygpLCBidXQgaXQgaXNuJ3Qgc3VwcG9ydGVkIGJ5IEVkZ2Ugb3IgU2FmYXJpLlxyXG4gICAgICAgIC8vIEFuZCBvcGVuS2V5Q3Vyc29yIGlzbid0IHN1cHBvcnRlZCBieSBTYWZhcmkuXHJcbiAgICAgICAgKHN0b3JlLm9wZW5LZXlDdXJzb3IgfHwgc3RvcmUub3BlbkN1cnNvcikuY2FsbChzdG9yZSkub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucmVzdWx0KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBrZXlzLnB1c2godGhpcy5yZXN1bHQua2V5KTtcclxuICAgICAgICAgICAgdGhpcy5yZXN1bHQuY29udGludWUoKTtcclxuICAgICAgICB9O1xyXG4gICAgfSkudGhlbigoKSA9PiBrZXlzKTtcclxufVxuXG5leHBvcnQgeyBTdG9yZSwgZ2V0LCBzZXQsIGRlbCwgY2xlYXIsIGtleXMgfTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/idb-keyval/dist/idb-keyval.mjs\n");

/***/ }),

/***/ "./node_modules/lit-html/directives/if-defined.js":
/*!********************************************************!*\
  !*** ./node_modules/lit-html/directives/if-defined.js ***!
  \********************************************************/
/*! exports provided: ifDefined */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ifDefined\", function() { return ifDefined; });\n/* harmony import */ var _lit_html_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lit-html.js */ \"./node_modules/lit-html/lit-html.js\");\n/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nvar previousValues = new WeakMap();\n/**\n * For AttributeParts, sets the attribute if the value is defined and removes\n * the attribute if the value is undefined.\n *\n * For other part types, this directive is a no-op.\n */\n\nvar ifDefined = Object(_lit_html_js__WEBPACK_IMPORTED_MODULE_0__[\"directive\"])(function (value) {\n  return function (part) {\n    var previousValue = previousValues.get(part);\n\n    if (value === undefined && part instanceof _lit_html_js__WEBPACK_IMPORTED_MODULE_0__[\"AttributePart\"]) {\n      // If the value is undefined, remove the attribute, but only if the value\n      // was previously defined.\n      if (previousValue !== undefined || !previousValues.has(part)) {\n        var name = part.committer.name;\n        part.committer.element.removeAttribute(name);\n      }\n    } else if (value !== previousValue) {\n      part.setValue(value);\n    }\n\n    previousValues.set(part, value);\n  };\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LWh0bWwvZGlyZWN0aXZlcy9pZi1kZWZpbmVkLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL3NyYy9kaXJlY3RpdmVzL2lmLWRlZmluZWQudHM/ZDIzZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5cbmltcG9ydCB7QXR0cmlidXRlUGFydCwgZGlyZWN0aXZlLCBQYXJ0fSBmcm9tICcuLi9saXQtaHRtbC5qcyc7XG5cbmNvbnN0IHByZXZpb3VzVmFsdWVzID0gbmV3IFdlYWtNYXA8UGFydCwgdW5rbm93bj4oKTtcblxuLyoqXG4gKiBGb3IgQXR0cmlidXRlUGFydHMsIHNldHMgdGhlIGF0dHJpYnV0ZSBpZiB0aGUgdmFsdWUgaXMgZGVmaW5lZCBhbmQgcmVtb3Zlc1xuICogdGhlIGF0dHJpYnV0ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLlxuICpcbiAqIEZvciBvdGhlciBwYXJ0IHR5cGVzLCB0aGlzIGRpcmVjdGl2ZSBpcyBhIG5vLW9wLlxuICovXG5leHBvcnQgY29uc3QgaWZEZWZpbmVkID0gZGlyZWN0aXZlKCh2YWx1ZTogdW5rbm93bikgPT4gKHBhcnQ6IFBhcnQpID0+IHtcbiAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHByZXZpb3VzVmFsdWVzLmdldChwYXJ0KTtcblxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBwYXJ0IGluc3RhbmNlb2YgQXR0cmlidXRlUGFydCkge1xuICAgIC8vIElmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIHJlbW92ZSB0aGUgYXR0cmlidXRlLCBidXQgb25seSBpZiB0aGUgdmFsdWVcbiAgICAvLyB3YXMgcHJldmlvdXNseSBkZWZpbmVkLlxuICAgIGlmIChwcmV2aW91c1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgIXByZXZpb3VzVmFsdWVzLmhhcyhwYXJ0KSkge1xuICAgICAgY29uc3QgbmFtZSA9IHBhcnQuY29tbWl0dGVyLm5hbWU7XG4gICAgICBwYXJ0LmNvbW1pdHRlci5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodmFsdWUgIT09IHByZXZpb3VzVmFsdWUpIHtcbiAgICBwYXJ0LnNldFZhbHVlKHZhbHVlKTtcbiAgfVxuXG4gIHByZXZpb3VzVmFsdWVzLnNldChwYXJ0LCB2YWx1ZSk7XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUVBO0FBRUE7Ozs7Ozs7QUFNQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lit-html/directives/if-defined.js\n");

/***/ }),

/***/ "./node_modules/preact/dist/preact.module.js":
/*!***************************************************!*\
  !*** ./node_modules/preact/dist/preact.module.js ***!
  \***************************************************/
/*! exports provided: render, hydrate, createElement, h, Fragment, createRef, isValidElement, Component, cloneElement, createContext, toChildArray, _unmount, options */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return H; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hydrate\", function() { return I; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createElement\", function() { return h; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return h; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Fragment\", function() { return d; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createRef\", function() { return p; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isValidElement\", function() { return l; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return m; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cloneElement\", function() { return L; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createContext\", function() { return M; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toChildArray\", function() { return x; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_unmount\", function() { return D; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"options\", function() { return n; });\nvar n,\n    l,\n    u,\n    i,\n    t,\n    o,\n    r,\n    f,\n    e = {},\n    c = [],\n    a = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n\nfunction s(n, l) {\n  for (var u in l) {\n    n[u] = l[u];\n  }\n\n  return n;\n}\n\nfunction v(n) {\n  var l = n.parentNode;\n  l && l.removeChild(n);\n}\n\nfunction h(n, l, u) {\n  var i,\n      t = arguments,\n      o = {};\n\n  for (i in l) {\n    \"key\" !== i && \"ref\" !== i && (o[i] = l[i]);\n  }\n\n  if (arguments.length > 3) for (u = [u], i = 3; i < arguments.length; i++) {\n    u.push(t[i]);\n  }\n  if (null != u && (o.children = u), \"function\" == typeof n && null != n.defaultProps) for (i in n.defaultProps) {\n    void 0 === o[i] && (o[i] = n.defaultProps[i]);\n  }\n  return y(n, o, l && l.key, l && l.ref, null);\n}\n\nfunction y(l, u, i, t, o) {\n  var r = {\n    type: l,\n    props: u,\n    key: i,\n    ref: t,\n    __k: null,\n    __: null,\n    __b: 0,\n    __e: null,\n    __d: void 0,\n    __c: null,\n    constructor: void 0,\n    __v: o\n  };\n  return null == o && (r.__v = r), n.vnode && n.vnode(r), r;\n}\n\nfunction p() {\n  return {};\n}\n\nfunction d(n) {\n  return n.children;\n}\n\nfunction m(n, l) {\n  this.props = n, this.context = l;\n}\n\nfunction w(n, l) {\n  if (null == l) return n.__ ? w(n.__, n.__.__k.indexOf(n) + 1) : null;\n\n  for (var u; l < n.__k.length; l++) {\n    if (null != (u = n.__k[l]) && null != u.__e) return u.__e;\n  }\n\n  return \"function\" == typeof n.type ? w(n) : null;\n}\n\nfunction k(n) {\n  var l, u;\n\n  if (null != (n = n.__) && null != n.__c) {\n    for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) {\n      if (null != (u = n.__k[l]) && null != u.__e) {\n        n.__e = n.__c.base = u.__e;\n        break;\n      }\n    }\n\n    return k(n);\n  }\n}\n\nfunction g(l) {\n  (!l.__d && (l.__d = !0) && u.push(l) && !i++ || o !== n.debounceRendering) && ((o = n.debounceRendering) || t)(_);\n}\n\nfunction _() {\n  for (var n; i = u.length;) {\n    n = u.sort(function (n, l) {\n      return n.__v.__b - l.__v.__b;\n    }), u = [], n.some(function (n) {\n      var l, u, i, t, o, r, f;\n      n.__d && (r = (o = (l = n).__v).__e, (f = l.__P) && (u = [], (i = s({}, o)).__v = i, t = z(f, o, i, l.__n, void 0 !== f.ownerSVGElement, null, u, null == r ? w(o) : r), T(u, o), t != r && k(o)));\n    });\n  }\n}\n\nfunction b(n, l, u, i, t, o, r, f, a, s) {\n  var h,\n      p,\n      m,\n      k,\n      g,\n      _,\n      b,\n      x,\n      A,\n      P = i && i.__k || c,\n      C = P.length;\n\n  for (a == e && (a = null != r ? r[0] : C ? w(i, 0) : null), u.__k = [], h = 0; h < l.length; h++) {\n    if (null != (k = u.__k[h] = null == (k = l[h]) || \"boolean\" == typeof k ? null : \"string\" == typeof k || \"number\" == typeof k ? y(null, k, null, null, k) : Array.isArray(k) ? y(d, {\n      children: k\n    }, null, null, null) : null != k.__e || null != k.__c ? y(k.type, k.props, k.key, null, k.__v) : k)) {\n      if (k.__ = u, k.__b = u.__b + 1, null === (m = P[h]) || m && k.key == m.key && k.type === m.type) P[h] = void 0;else for (p = 0; p < C; p++) {\n        if ((m = P[p]) && k.key == m.key && k.type === m.type) {\n          P[p] = void 0;\n          break;\n        }\n\n        m = null;\n      }\n\n      if (g = z(n, k, m = m || e, t, o, r, f, a, s), (p = k.ref) && m.ref != p && (x || (x = []), m.ref && x.push(m.ref, null, k), x.push(p, k.__c || g, k)), null != g) {\n        if (null == b && (b = g), A = void 0, void 0 !== k.__d) A = k.__d, k.__d = void 0;else if (r == m || g != a || null == g.parentNode) {\n          n: if (null == a || a.parentNode !== n) n.appendChild(g), A = null;else {\n            for (_ = a, p = 0; (_ = _.nextSibling) && p < C; p += 2) {\n              if (_ == g) break n;\n            }\n\n            n.insertBefore(g, a), A = a;\n          }\n\n          \"option\" == u.type && (n.value = \"\");\n        }\n        a = void 0 !== A ? A : g.nextSibling, \"function\" == typeof u.type && (u.__d = a);\n      } else a && m.__e == a && a.parentNode != n && (a = w(m));\n    }\n  }\n\n  if (u.__e = b, null != r && \"function\" != typeof u.type) for (h = r.length; h--;) {\n    null != r[h] && v(r[h]);\n  }\n\n  for (h = C; h--;) {\n    null != P[h] && D(P[h], P[h]);\n  }\n\n  if (x) for (h = 0; h < x.length; h++) {\n    j(x[h], x[++h], x[++h]);\n  }\n}\n\nfunction x(n) {\n  return null == n || \"boolean\" == typeof n ? [] : Array.isArray(n) ? c.concat.apply([], n.map(x)) : [n];\n}\n\nfunction A(n, l, u, i, t) {\n  var o;\n\n  for (o in u) {\n    \"children\" === o || \"key\" === o || o in l || C(n, o, null, u[o], i);\n  }\n\n  for (o in l) {\n    t && \"function\" != typeof l[o] || \"children\" === o || \"key\" === o || \"value\" === o || \"checked\" === o || u[o] === l[o] || C(n, o, l[o], u[o], i);\n  }\n}\n\nfunction P(n, l, u) {\n  \"-\" === l[0] ? n.setProperty(l, u) : n[l] = \"number\" == typeof u && !1 === a.test(l) ? u + \"px\" : null == u ? \"\" : u;\n}\n\nfunction C(n, l, u, i, t) {\n  var o, r, f, e, c;\n  if (t ? \"className\" === l && (l = \"class\") : \"class\" === l && (l = \"className\"), \"style\" === l) {\n    if (o = n.style, \"string\" == typeof u) o.cssText = u;else {\n      if (\"string\" == typeof i && (o.cssText = \"\", i = null), i) for (e in i) {\n        u && e in u || P(o, e, \"\");\n      }\n      if (u) for (c in u) {\n        i && u[c] === i[c] || P(o, c, u[c]);\n      }\n    }\n  } else \"o\" === l[0] && \"n\" === l[1] ? (r = l !== (l = l.replace(/Capture$/, \"\")), f = l.toLowerCase(), l = (f in n ? f : l).slice(2), u ? (i || n.addEventListener(l, N, r), (n.l || (n.l = {}))[l] = u) : n.removeEventListener(l, N, r)) : \"list\" !== l && \"tagName\" !== l && \"form\" !== l && \"type\" !== l && \"size\" !== l && !t && l in n ? n[l] = null == u ? \"\" : u : \"function\" != typeof u && \"dangerouslySetInnerHTML\" !== l && (l !== (l = l.replace(/^xlink:?/, \"\")) ? null == u || !1 === u ? n.removeAttributeNS(\"http://www.w3.org/1999/xlink\", l.toLowerCase()) : n.setAttributeNS(\"http://www.w3.org/1999/xlink\", l.toLowerCase(), u) : null == u || !1 === u && !/^ar/.test(l) ? n.removeAttribute(l) : n.setAttribute(l, u));\n}\n\nfunction N(l) {\n  this.l[l.type](n.event ? n.event(l) : l);\n}\n\nfunction z(l, u, i, t, o, r, f, e, c) {\n  var a,\n      v,\n      h,\n      y,\n      p,\n      w,\n      k,\n      g,\n      _,\n      x,\n      A,\n      P = u.type;\n\n  if (void 0 !== u.constructor) return null;\n  (a = n.__b) && a(u);\n\n  try {\n    n: if (\"function\" == typeof P) {\n      if (g = u.props, _ = (a = P.contextType) && t[a.__c], x = a ? _ ? _.props.value : a.__ : t, i.__c ? k = (v = u.__c = i.__c).__ = v.__E : (\"prototype\" in P && P.prototype.render ? u.__c = v = new P(g, x) : (u.__c = v = new m(g, x), v.constructor = P, v.render = E), _ && _.sub(v), v.props = g, v.state || (v.state = {}), v.context = x, v.__n = t, h = v.__d = !0, v.__h = []), null == v.__s && (v.__s = v.state), null != P.getDerivedStateFromProps && (v.__s == v.state && (v.__s = s({}, v.__s)), s(v.__s, P.getDerivedStateFromProps(g, v.__s))), y = v.props, p = v.state, h) null == P.getDerivedStateFromProps && null != v.componentWillMount && v.componentWillMount(), null != v.componentDidMount && v.__h.push(v.componentDidMount);else {\n        if (null == P.getDerivedStateFromProps && g !== y && null != v.componentWillReceiveProps && v.componentWillReceiveProps(g, x), !v.__e && null != v.shouldComponentUpdate && !1 === v.shouldComponentUpdate(g, v.__s, x) || u.__v === i.__v) {\n          for (v.props = g, v.state = v.__s, u.__v !== i.__v && (v.__d = !1), v.__v = u, u.__e = i.__e, u.__k = i.__k, v.__h.length && f.push(v), a = 0; a < u.__k.length; a++) {\n            u.__k[a] && (u.__k[a].__ = u);\n          }\n\n          break n;\n        }\n\n        null != v.componentWillUpdate && v.componentWillUpdate(g, v.__s, x), null != v.componentDidUpdate && v.__h.push(function () {\n          v.componentDidUpdate(y, p, w);\n        });\n      }\n      v.context = x, v.props = g, v.state = v.__s, (a = n.__r) && a(u), v.__d = !1, v.__v = u, v.__P = l, a = v.render(v.props, v.state, v.context), null != v.getChildContext && (t = s(s({}, t), v.getChildContext())), h || null == v.getSnapshotBeforeUpdate || (w = v.getSnapshotBeforeUpdate(y, p)), A = null != a && a.type == d && null == a.key ? a.props.children : a, b(l, Array.isArray(A) ? A : [A], u, i, t, o, r, f, e, c), v.base = u.__e, v.__h.length && f.push(v), k && (v.__E = v.__ = null), v.__e = !1;\n    } else null == r && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = $(i.__e, u, i, t, o, r, f, c);\n\n    (a = n.diffed) && a(u);\n  } catch (l) {\n    u.__v = null, n.__e(l, u, i);\n  }\n\n  return u.__e;\n}\n\nfunction T(l, u) {\n  n.__c && n.__c(u, l), l.some(function (u) {\n    try {\n      l = u.__h, u.__h = [], l.some(function (n) {\n        n.call(u);\n      });\n    } catch (l) {\n      n.__e(l, u.__v);\n    }\n  });\n}\n\nfunction $(n, l, u, i, t, o, r, f) {\n  var a,\n      s,\n      v,\n      h,\n      y,\n      p = u.props,\n      d = l.props;\n  if (t = \"svg\" === l.type || t, null != o) for (a = 0; a < o.length; a++) {\n    if (null != (s = o[a]) && ((null === l.type ? 3 === s.nodeType : s.localName === l.type) || n == s)) {\n      n = s, o[a] = null;\n      break;\n    }\n  }\n\n  if (null == n) {\n    if (null === l.type) return document.createTextNode(d);\n    n = t ? document.createElementNS(\"http://www.w3.org/2000/svg\", l.type) : document.createElement(l.type, d.is && {\n      is: d.is\n    }), o = null, f = !1;\n  }\n\n  if (null === l.type) p !== d && n.data != d && (n.data = d);else {\n    if (null != o && (o = c.slice.call(n.childNodes)), v = (p = u.props || e).dangerouslySetInnerHTML, h = d.dangerouslySetInnerHTML, !f) {\n      if (null != o) for (p = {}, y = 0; y < n.attributes.length; y++) {\n        p[n.attributes[y].name] = n.attributes[y].value;\n      }\n      (h || v) && (h && v && h.__html == v.__html || (n.innerHTML = h && h.__html || \"\"));\n    }\n\n    A(n, d, p, t, f), h ? l.__k = [] : (a = l.props.children, b(n, Array.isArray(a) ? a : [a], l, u, i, \"foreignObject\" !== l.type && t, o, r, e, f)), f || (\"value\" in d && void 0 !== (a = d.value) && a !== n.value && C(n, \"value\", a, p.value, !1), \"checked\" in d && void 0 !== (a = d.checked) && a !== n.checked && C(n, \"checked\", a, p.checked, !1));\n  }\n  return n;\n}\n\nfunction j(l, u, i) {\n  try {\n    \"function\" == typeof l ? l(u) : l.current = u;\n  } catch (l) {\n    n.__e(l, i);\n  }\n}\n\nfunction D(l, u, i) {\n  var t, o, r;\n\n  if (n.unmount && n.unmount(l), (t = l.ref) && (t.current && t.current !== l.__e || j(t, null, u)), i || \"function\" == typeof l.type || (i = null != (o = l.__e)), l.__e = l.__d = void 0, null != (t = l.__c)) {\n    if (t.componentWillUnmount) try {\n      t.componentWillUnmount();\n    } catch (l) {\n      n.__e(l, u);\n    }\n    t.base = t.__P = null;\n  }\n\n  if (t = l.__k) for (r = 0; r < t.length; r++) {\n    t[r] && D(t[r], u, i);\n  }\n  null != o && v(o);\n}\n\nfunction E(n, l, u) {\n  return this.constructor(n, u);\n}\n\nfunction H(l, u, i) {\n  var t, o, f;\n  n.__ && n.__(l, u), o = (t = i === r) ? null : i && i.__k || u.__k, l = h(d, null, [l]), f = [], z(u, (t ? u : i || u).__k = l, o || e, e, void 0 !== u.ownerSVGElement, i && !t ? [i] : o ? null : u.childNodes.length ? c.slice.call(u.childNodes) : null, f, i || e, t), T(f, l);\n}\n\nfunction I(n, l) {\n  H(n, l, r);\n}\n\nfunction L(n, l) {\n  var u, i;\n\n  for (i in l = s(s({}, n.props), l), arguments.length > 2 && (l.children = c.slice.call(arguments, 2)), u = {}, l) {\n    \"key\" !== i && \"ref\" !== i && (u[i] = l[i]);\n  }\n\n  return y(n.type, u, l.key || n.key, l.ref || n.ref, null);\n}\n\nfunction M(n) {\n  var l = {},\n      u = {\n    __c: \"__cC\" + f++,\n    __: n,\n    Consumer: function Consumer(n, l) {\n      return n.children(l);\n    },\n    Provider: function Provider(n) {\n      var i,\n          t = this;\n      return this.getChildContext || (i = [], this.getChildContext = function () {\n        return l[u.__c] = t, l;\n      }, this.shouldComponentUpdate = function (n) {\n        t.props.value !== n.value && i.some(function (l) {\n          l.context = n.value, g(l);\n        });\n      }, this.sub = function (n) {\n        i.push(n);\n        var l = n.componentWillUnmount;\n\n        n.componentWillUnmount = function () {\n          i.splice(i.indexOf(n), 1), l && l.call(n);\n        };\n      }), n.children;\n    }\n  };\n  return u.Consumer.contextType = u, u.Provider.__ = u, u;\n}\n\nn = {\n  __e: function __e(n, l) {\n    for (var u, i; l = l.__;) {\n      if ((u = l.__c) && !u.__) try {\n        if (u.constructor && null != u.constructor.getDerivedStateFromError && (i = !0, u.setState(u.constructor.getDerivedStateFromError(n))), null != u.componentDidCatch && (i = !0, u.componentDidCatch(n)), i) return g(u.__E = u);\n      } catch (l) {\n        n = l;\n      }\n    }\n\n    throw n;\n  }\n}, l = function l(n) {\n  return null != n && void 0 === n.constructor;\n}, m.prototype.setState = function (n, l) {\n  var u;\n  u = this.__s !== this.state ? this.__s : this.__s = s({}, this.state), \"function\" == typeof n && (n = n(u, this.props)), n && s(u, n), null != n && this.__v && (l && this.__h.push(l), g(this));\n}, m.prototype.forceUpdate = function (n) {\n  this.__v && (this.__e = !0, n && this.__h.push(n), g(this));\n}, m.prototype.render = d, u = [], i = 0, t = \"function\" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, r = e, f = 0;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJlYWN0L2Rpc3QvcHJlYWN0Lm1vZHVsZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9zcmMvY29uc3RhbnRzLmpzPzQ3YzgiLCJ3ZWJwYWNrOi8vLy4uL3NyYy91dGlsLmpzPzQyMjgiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jcmVhdGUtZWxlbWVudC5qcz80NmRlIiwid2VicGFjazovLy8uLi9zcmMvY29tcG9uZW50LmpzP2RjYjIiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9kaWZmL2NoaWxkcmVuLmpzP2IwZWMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9kaWZmL3Byb3BzLmpzP2MxZGEiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9kaWZmL2luZGV4LmpzP2M5ODgiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9yZW5kZXIuanM/NTBmZiIsIndlYnBhY2s6Ly8vLi4vc3JjL2Nsb25lLWVsZW1lbnQuanM/YWVjZSIsIndlYnBhY2s6Ly8vLi4vc3JjL2NyZWF0ZS1jb250ZXh0LmpzPzNlZjIiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9vcHRpb25zLmpzPzFhZTUiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9kaWZmL2NhdGNoLWVycm9yLmpzPzg4YWUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IEVNUFRZX09CSiA9IHt9O1xuZXhwb3J0IGNvbnN0IEVNUFRZX0FSUiA9IFtdO1xuZXhwb3J0IGNvbnN0IElTX05PTl9ESU1FTlNJT05BTCA9IC9hY2l0fGV4KD86c3xnfG58cHwkKXxycGh8Z3JpZHxvd3N8bW5jfG50d3xpbmVbY2hdfHpvb3xeb3JkfGl0ZXJhL2k7XG4iLCIvKipcbiAqIEFzc2lnbiBwcm9wZXJ0aWVzIGZyb20gYHByb3BzYCB0byBgb2JqYFxuICogQHRlbXBsYXRlIE8sIFAgVGhlIG9iaiBhbmQgcHJvcHMgdHlwZXNcbiAqIEBwYXJhbSB7T30gb2JqIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvXG4gKiBAcGFyYW0ge1B9IHByb3BzIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEByZXR1cm5zIHtPICYgUH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihvYmosIHByb3BzKSB7XG5cdGZvciAobGV0IGkgaW4gcHJvcHMpIG9ialtpXSA9IHByb3BzW2ldO1xuXHRyZXR1cm4gLyoqIEB0eXBlIHtPICYgUH0gKi8gKG9iaik7XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgY2hpbGQgbm9kZSBmcm9tIGl0cyBwYXJlbnQgaWYgYXR0YWNoZWQuIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvclxuICogSUUxMSB3aGljaCBkb2Vzbid0IHN1cHBvcnQgYEVsZW1lbnQucHJvdG90eXBlLnJlbW92ZSgpYC4gVXNpbmcgdGhpcyBmdW5jdGlvblxuICogaXMgc21hbGxlciB0aGFuIGluY2x1ZGluZyBhIGRlZGljYXRlZCBwb2x5ZmlsbC5cbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byByZW1vdmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZSkge1xuXHRsZXQgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcblx0aWYgKHBhcmVudE5vZGUpIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG59XG4iLCJpbXBvcnQgb3B0aW9ucyBmcm9tICcuL29wdGlvbnMnO1xuXG4vKipcbiAqIENyZWF0ZSBhbiB2aXJ0dWFsIG5vZGUgKHVzZWQgZm9yIEpTWClcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJ0eXBlXCJdfSB0eXBlIFRoZSBub2RlIG5hbWUgb3IgQ29tcG9uZW50XG4gKiBjb25zdHJ1Y3RvciBmb3IgdGhpcyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0IHwgbnVsbCB8IHVuZGVmaW5lZH0gW3Byb3BzXSBUaGUgcHJvcGVydGllcyBvZiB0aGUgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLicpLkNvbXBvbmVudENoaWxkcmVuPn0gW2NoaWxkcmVuXSBUaGUgY2hpbGRyZW4gb2YgdGhlIHZpcnR1YWwgbm9kZVxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcblx0bGV0IG5vcm1hbGl6ZWRQcm9wcyA9IHt9LFxuXHRcdGk7XG5cdGZvciAoaSBpbiBwcm9wcykge1xuXHRcdGlmIChpICE9PSAna2V5JyAmJiBpICE9PSAncmVmJykgbm9ybWFsaXplZFByb3BzW2ldID0gcHJvcHNbaV07XG5cdH1cblxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDMpIHtcblx0XHRjaGlsZHJlbiA9IFtjaGlsZHJlbl07XG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3ByZWFjdGpzL3ByZWFjdC9pc3N1ZXMvMTkxNlxuXHRcdGZvciAoaSA9IDM7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNoaWxkcmVuLnB1c2goYXJndW1lbnRzW2ldKTtcblx0XHR9XG5cdH1cblx0aWYgKGNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRub3JtYWxpemVkUHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcblx0fVxuXG5cdC8vIElmIGEgQ29tcG9uZW50IFZOb2RlLCBjaGVjayBmb3IgYW5kIGFwcGx5IGRlZmF1bHRQcm9wc1xuXHQvLyBOb3RlOiB0eXBlIG1heSBiZSB1bmRlZmluZWQgaW4gZGV2ZWxvcG1lbnQsIG11c3QgbmV2ZXIgZXJyb3IgaGVyZS5cblx0aWYgKHR5cGVvZiB0eXBlID09ICdmdW5jdGlvbicgJiYgdHlwZS5kZWZhdWx0UHJvcHMgIT0gbnVsbCkge1xuXHRcdGZvciAoaSBpbiB0eXBlLmRlZmF1bHRQcm9wcykge1xuXHRcdFx0aWYgKG5vcm1hbGl6ZWRQcm9wc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHR5cGUuZGVmYXVsdFByb3BzW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjcmVhdGVWTm9kZShcblx0XHR0eXBlLFxuXHRcdG5vcm1hbGl6ZWRQcm9wcyxcblx0XHRwcm9wcyAmJiBwcm9wcy5rZXksXG5cdFx0cHJvcHMgJiYgcHJvcHMucmVmLFxuXHRcdG51bGxcblx0KTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBWTm9kZSAodXNlZCBpbnRlcm5hbGx5IGJ5IFByZWFjdClcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJ0eXBlXCJdfSB0eXBlIFRoZSBub2RlIG5hbWUgb3IgQ29tcG9uZW50XG4gKiBDb25zdHJ1Y3RvciBmb3IgdGhpcyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0IHwgc3RyaW5nIHwgbnVtYmVyIHwgbnVsbH0gcHJvcHMgVGhlIHByb3BlcnRpZXMgb2YgdGhpcyB2aXJ0dWFsIG5vZGUuXG4gKiBJZiB0aGlzIHZpcnR1YWwgbm9kZSByZXByZXNlbnRzIGEgdGV4dCBub2RlLCB0aGlzIGlzIHRoZSB0ZXh0IG9mIHRoZSBub2RlIChzdHJpbmcgb3IgbnVtYmVyKS5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyIHwgbnVsbH0ga2V5IFRoZSBrZXkgZm9yIHRoaXMgdmlydHVhbCBub2RlLCB1c2VkIHdoZW5cbiAqIGRpZmZpbmcgaXQgYWdhaW5zdCBpdHMgY2hpbGRyZW5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJyZWZcIl19IHJlZiBUaGUgcmVmIHByb3BlcnR5IHRoYXQgd2lsbFxuICogcmVjZWl2ZSBhIHJlZmVyZW5jZSB0byBpdHMgY3JlYXRlZCBjaGlsZFxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHMsIGtleSwgcmVmLCBvcmlnaW5hbCkge1xuXHQvLyBWOCBzZWVtcyB0byBiZSBiZXR0ZXIgYXQgZGV0ZWN0aW5nIHR5cGUgc2hhcGVzIGlmIHRoZSBvYmplY3QgaXMgYWxsb2NhdGVkIGZyb20gdGhlIHNhbWUgY2FsbCBzaXRlXG5cdC8vIERvIG5vdCBpbmxpbmUgaW50byBjcmVhdGVFbGVtZW50IGFuZCBjb2VyY2VUb1ZOb2RlIVxuXHRjb25zdCB2bm9kZSA9IHtcblx0XHR0eXBlLFxuXHRcdHByb3BzLFxuXHRcdGtleSxcblx0XHRyZWYsXG5cdFx0X2NoaWxkcmVuOiBudWxsLFxuXHRcdF9wYXJlbnQ6IG51bGwsXG5cdFx0X2RlcHRoOiAwLFxuXHRcdF9kb206IG51bGwsXG5cdFx0Ly8gX25leHREb20gbXVzdCBiZSBpbml0aWFsaXplZCB0byB1bmRlZmluZWQgYi9jIGl0IHdpbGwgZXZlbnR1YWxseVxuXHRcdC8vIGJlIHNldCB0byBkb20ubmV4dFNpYmxpbmcgd2hpY2ggY2FuIHJldHVybiBgbnVsbGAgYW5kIGl0IGlzIGltcG9ydGFudFxuXHRcdC8vIHRvIGJlIGFibGUgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBhbiB1bmluaXRpYWxpemVkIF9uZXh0RG9tIGFuZFxuXHRcdC8vIGEgX25leHREb20gdGhhdCBoYXMgYmVlbiBzZXQgdG8gYG51bGxgXG5cdFx0X25leHREb206IHVuZGVmaW5lZCxcblx0XHRfY29tcG9uZW50OiBudWxsLFxuXHRcdGNvbnN0cnVjdG9yOiB1bmRlZmluZWQsXG5cdFx0X29yaWdpbmFsOiBvcmlnaW5hbFxuXHR9O1xuXG5cdGlmIChvcmlnaW5hbCA9PSBudWxsKSB2bm9kZS5fb3JpZ2luYWwgPSB2bm9kZTtcblx0aWYgKG9wdGlvbnMudm5vZGUpIG9wdGlvbnMudm5vZGUodm5vZGUpO1xuXG5cdHJldHVybiB2bm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlZigpIHtcblx0cmV0dXJuIHt9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gRnJhZ21lbnQocHJvcHMpIHtcblx0cmV0dXJuIHByb3BzLmNoaWxkcmVuO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGhlIGFyZ3VtZW50IGlzIGEgdmFsaWQgUHJlYWN0IFZOb2RlLlxuICogQHBhcmFtIHsqfSB2bm9kZVxuICogQHJldHVybnMge3Zub2RlIGlzIGltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfVxuICovXG5leHBvcnQgY29uc3QgaXNWYWxpZEVsZW1lbnQgPSB2bm9kZSA9PlxuXHR2bm9kZSAhPSBudWxsICYmIHZub2RlLmNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQ7XG4iLCJpbXBvcnQgeyBhc3NpZ24gfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgZGlmZiwgY29tbWl0Um9vdCB9IGZyb20gJy4vZGlmZi9pbmRleCc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuL29wdGlvbnMnO1xuaW1wb3J0IHsgRnJhZ21lbnQgfSBmcm9tICcuL2NyZWF0ZS1lbGVtZW50JztcblxuLyoqXG4gKiBCYXNlIENvbXBvbmVudCBjbGFzcy4gUHJvdmlkZXMgYHNldFN0YXRlKClgIGFuZCBgZm9yY2VVcGRhdGUoKWAsIHdoaWNoXG4gKiB0cmlnZ2VyIHJlbmRlcmluZ1xuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIFRoZSBpbml0aWFsIGNvbXBvbmVudCBwcm9wc1xuICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgVGhlIGluaXRpYWwgY29udGV4dCBmcm9tIHBhcmVudCBjb21wb25lbnRzJ1xuICogZ2V0Q2hpbGRDb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQpIHtcblx0dGhpcy5wcm9wcyA9IHByb3BzO1xuXHR0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xufVxuXG4vKipcbiAqIFVwZGF0ZSBjb21wb25lbnQgc3RhdGUgYW5kIHNjaGVkdWxlIGEgcmUtcmVuZGVyLlxuICogQHBhcmFtIHtvYmplY3QgfCAoKHM6IG9iamVjdCwgcDogb2JqZWN0KSA9PiBvYmplY3QpfSB1cGRhdGUgQSBoYXNoIG9mIHN0YXRlXG4gKiBwcm9wZXJ0aWVzIHRvIHVwZGF0ZSB3aXRoIG5ldyB2YWx1ZXMgb3IgYSBmdW5jdGlvbiB0aGF0IGdpdmVuIHRoZSBjdXJyZW50XG4gKiBzdGF0ZSBhbmQgcHJvcHMgcmV0dXJucyBhIG5ldyBwYXJ0aWFsIHN0YXRlXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSBjb21wb25lbnQgc3RhdGUgaXNcbiAqIHVwZGF0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uKHVwZGF0ZSwgY2FsbGJhY2spIHtcblx0Ly8gb25seSBjbG9uZSBzdGF0ZSB3aGVuIGNvcHlpbmcgdG8gbmV4dFN0YXRlIHRoZSBmaXJzdCB0aW1lLlxuXHRsZXQgcztcblx0aWYgKHRoaXMuX25leHRTdGF0ZSAhPT0gdGhpcy5zdGF0ZSkge1xuXHRcdHMgPSB0aGlzLl9uZXh0U3RhdGU7XG5cdH0gZWxzZSB7XG5cdFx0cyA9IHRoaXMuX25leHRTdGF0ZSA9IGFzc2lnbih7fSwgdGhpcy5zdGF0ZSk7XG5cdH1cblxuXHRpZiAodHlwZW9mIHVwZGF0ZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dXBkYXRlID0gdXBkYXRlKHMsIHRoaXMucHJvcHMpO1xuXHR9XG5cblx0aWYgKHVwZGF0ZSkge1xuXHRcdGFzc2lnbihzLCB1cGRhdGUpO1xuXHR9XG5cblx0Ly8gU2tpcCB1cGRhdGUgaWYgdXBkYXRlciBmdW5jdGlvbiByZXR1cm5lZCBudWxsXG5cdGlmICh1cGRhdGUgPT0gbnVsbCkgcmV0dXJuO1xuXG5cdGlmICh0aGlzLl92bm9kZSkge1xuXHRcdGlmIChjYWxsYmFjaykgdGhpcy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXHRcdGVucXVldWVSZW5kZXIodGhpcyk7XG5cdH1cbn07XG5cbi8qKlxuICogSW1tZWRpYXRlbHkgcGVyZm9ybSBhIHN5bmNocm9ub3VzIHJlLXJlbmRlciBvZiB0aGUgY29tcG9uZW50XG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzXG4gKiByZS1yZW5kZXJlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0aWYgKHRoaXMuX3Zub2RlKSB7XG5cdFx0Ly8gU2V0IHJlbmRlciBtb2RlIHNvIHRoYXQgd2UgY2FuIGRpZmZlcmVudGlhdGUgd2hlcmUgdGhlIHJlbmRlciByZXF1ZXN0XG5cdFx0Ly8gaXMgY29taW5nIGZyb20uIFdlIG5lZWQgdGhpcyBiZWNhdXNlIGZvcmNlVXBkYXRlIHNob3VsZCBuZXZlciBjYWxsXG5cdFx0Ly8gc2hvdWxkQ29tcG9uZW50VXBkYXRlXG5cdFx0dGhpcy5fZm9yY2UgPSB0cnVlO1xuXHRcdGlmIChjYWxsYmFjaykgdGhpcy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXHRcdGVucXVldWVSZW5kZXIodGhpcyk7XG5cdH1cbn07XG5cbi8qKlxuICogQWNjZXB0cyBgcHJvcHNgIGFuZCBgc3RhdGVgLCBhbmQgcmV0dXJucyBhIG5ldyBWaXJ0dWFsIERPTSB0cmVlIHRvIGJ1aWxkLlxuICogVmlydHVhbCBET00gaXMgZ2VuZXJhbGx5IGNvbnN0cnVjdGVkIHZpYSBbSlNYXShodHRwOi8vamFzb25mb3JtYXQuY29tL3d0Zi1pcy1qc3gpLlxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIFByb3BzIChlZzogSlNYIGF0dHJpYnV0ZXMpIHJlY2VpdmVkIGZyb20gcGFyZW50XG4gKiBlbGVtZW50L2NvbXBvbmVudFxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIFRoZSBjb21wb25lbnQncyBjdXJyZW50IHN0YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCBDb250ZXh0IG9iamVjdCwgYXMgcmV0dXJuZWQgYnkgdGhlIG5lYXJlc3RcbiAqIGFuY2VzdG9yJ3MgYGdldENoaWxkQ29udGV4dCgpYFxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbmRleCcpLkNvbXBvbmVudENoaWxkcmVuIHwgdm9pZH1cbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBGcmFnbWVudDtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICogQHBhcmFtIHtudW1iZXIgfCBudWxsfSBbY2hpbGRJbmRleF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERvbVNpYmxpbmcodm5vZGUsIGNoaWxkSW5kZXgpIHtcblx0aWYgKGNoaWxkSW5kZXggPT0gbnVsbCkge1xuXHRcdC8vIFVzZSBjaGlsZEluZGV4PT1udWxsIGFzIGEgc2lnbmFsIHRvIHJlc3VtZSB0aGUgc2VhcmNoIGZyb20gdGhlIHZub2RlJ3Mgc2libGluZ1xuXHRcdHJldHVybiB2bm9kZS5fcGFyZW50XG5cdFx0XHQ/IGdldERvbVNpYmxpbmcodm5vZGUuX3BhcmVudCwgdm5vZGUuX3BhcmVudC5fY2hpbGRyZW4uaW5kZXhPZih2bm9kZSkgKyAxKVxuXHRcdFx0OiBudWxsO1xuXHR9XG5cblx0bGV0IHNpYmxpbmc7XG5cdGZvciAoOyBjaGlsZEluZGV4IDwgdm5vZGUuX2NoaWxkcmVuLmxlbmd0aDsgY2hpbGRJbmRleCsrKSB7XG5cdFx0c2libGluZyA9IHZub2RlLl9jaGlsZHJlbltjaGlsZEluZGV4XTtcblxuXHRcdGlmIChzaWJsaW5nICE9IG51bGwgJiYgc2libGluZy5fZG9tICE9IG51bGwpIHtcblx0XHRcdC8vIFNpbmNlIHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzIGtlZXBzIF9kb20gcG9pbnRlciBjb3JyZWN0LFxuXHRcdFx0Ly8gd2UgY2FuIHJlbHkgb24gX2RvbSB0byB0ZWxsIHVzIGlmIHRoaXMgc3VidHJlZSBjb250YWlucyBhXG5cdFx0XHQvLyByZW5kZXJlZCBET00gbm9kZSwgYW5kIHdoYXQgdGhlIGZpcnN0IHJlbmRlcmVkIERPTSBub2RlIGlzXG5cdFx0XHRyZXR1cm4gc2libGluZy5fZG9tO1xuXHRcdH1cblx0fVxuXG5cdC8vIElmIHdlIGdldCBoZXJlLCB3ZSBoYXZlIG5vdCBmb3VuZCBhIERPTSBub2RlIGluIHRoaXMgdm5vZGUncyBjaGlsZHJlbi5cblx0Ly8gV2UgbXVzdCByZXN1bWUgZnJvbSB0aGlzIHZub2RlJ3Mgc2libGluZyAoaW4gaXQncyBwYXJlbnQgX2NoaWxkcmVuIGFycmF5KVxuXHQvLyBPbmx5IGNsaW1iIHVwIGFuZCBzZWFyY2ggdGhlIHBhcmVudCBpZiB3ZSBhcmVuJ3Qgc2VhcmNoaW5nIHRocm91Z2ggYSBET01cblx0Ly8gVk5vZGUgKG1lYW5pbmcgd2UgcmVhY2hlZCB0aGUgRE9NIHBhcmVudCBvZiB0aGUgb3JpZ2luYWwgdm5vZGUgdGhhdCBiZWdhblxuXHQvLyB0aGUgc2VhcmNoKVxuXHRyZXR1cm4gdHlwZW9mIHZub2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJyA/IGdldERvbVNpYmxpbmcodm5vZGUpIDogbnVsbDtcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIGluLXBsYWNlIHJlLXJlbmRlcmluZyBvZiBhIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byByZXJlbmRlclxuICovXG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnQoY29tcG9uZW50KSB7XG5cdGxldCB2bm9kZSA9IGNvbXBvbmVudC5fdm5vZGUsXG5cdFx0b2xkRG9tID0gdm5vZGUuX2RvbSxcblx0XHRwYXJlbnREb20gPSBjb21wb25lbnQuX3BhcmVudERvbTtcblxuXHRpZiAocGFyZW50RG9tKSB7XG5cdFx0bGV0IGNvbW1pdFF1ZXVlID0gW107XG5cdFx0Y29uc3Qgb2xkVk5vZGUgPSBhc3NpZ24oe30sIHZub2RlKTtcblx0XHRvbGRWTm9kZS5fb3JpZ2luYWwgPSBvbGRWTm9kZTtcblxuXHRcdGxldCBuZXdEb20gPSBkaWZmKFxuXHRcdFx0cGFyZW50RG9tLFxuXHRcdFx0dm5vZGUsXG5cdFx0XHRvbGRWTm9kZSxcblx0XHRcdGNvbXBvbmVudC5fZ2xvYmFsQ29udGV4dCxcblx0XHRcdHBhcmVudERvbS5vd25lclNWR0VsZW1lbnQgIT09IHVuZGVmaW5lZCxcblx0XHRcdG51bGwsXG5cdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdG9sZERvbSA9PSBudWxsID8gZ2V0RG9tU2libGluZyh2bm9kZSkgOiBvbGREb21cblx0XHQpO1xuXHRcdGNvbW1pdFJvb3QoY29tbWl0UXVldWUsIHZub2RlKTtcblxuXHRcdGlmIChuZXdEb20gIT0gb2xkRG9tKSB7XG5cdFx0XHR1cGRhdGVQYXJlbnREb21Qb2ludGVycyh2bm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqL1xuZnVuY3Rpb24gdXBkYXRlUGFyZW50RG9tUG9pbnRlcnModm5vZGUpIHtcblx0aWYgKCh2bm9kZSA9IHZub2RlLl9wYXJlbnQpICE9IG51bGwgJiYgdm5vZGUuX2NvbXBvbmVudCAhPSBudWxsKSB7XG5cdFx0dm5vZGUuX2RvbSA9IHZub2RlLl9jb21wb25lbnQuYmFzZSA9IG51bGw7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB2bm9kZS5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxldCBjaGlsZCA9IHZub2RlLl9jaGlsZHJlbltpXTtcblx0XHRcdGlmIChjaGlsZCAhPSBudWxsICYmIGNoaWxkLl9kb20gIT0gbnVsbCkge1xuXHRcdFx0XHR2bm9kZS5fZG9tID0gdm5vZGUuX2NvbXBvbmVudC5iYXNlID0gY2hpbGQuX2RvbTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzKHZub2RlKTtcblx0fVxufVxuXG4vKipcbiAqIFRoZSByZW5kZXIgcXVldWVcbiAqIEB0eXBlIHtBcnJheTxpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fVxuICovXG5sZXQgcmVyZW5kZXJRdWV1ZSA9IFtdO1xubGV0IHJlcmVuZGVyQ291bnQgPSAwO1xuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHNjaGVkdWxlIGEgY2FsbGJhY2tcbiAqIEB0eXBlIHsoY2I6ICgpID0+IHZvaWQpID0+IHZvaWR9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vLyBOb3RlIHRoZSBmb2xsb3dpbmcgbGluZSBpc24ndCB0cmVlLXNoYWtlbiBieSByb2xsdXAgY3V6IG9mIHJvbGx1cC9yb2xsdXAjMjU2NlxuY29uc3QgZGVmZXIgPVxuXHR0eXBlb2YgUHJvbWlzZSA9PSAnZnVuY3Rpb24nXG5cdFx0PyBQcm9taXNlLnByb3RvdHlwZS50aGVuLmJpbmQoUHJvbWlzZS5yZXNvbHZlKCkpXG5cdFx0OiBzZXRUaW1lb3V0O1xuXG4vKlxuICogVGhlIHZhbHVlIG9mIGBDb21wb25lbnQuZGVib3VuY2VgIG11c3QgYXN5bmNocm9ub3VzbHkgaW52b2tlIHRoZSBwYXNzZWQgaW4gY2FsbGJhY2suIEl0IGlzXG4gKiBpbXBvcnRhbnQgdGhhdCBjb250cmlidXRvcnMgdG8gUHJlYWN0IGNhbiBjb25zaXN0ZW50bHkgcmVhc29uIGFib3V0IHdoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCwgZXRjLlxuICogZG8sIGFuZCB3aGVuIHRoZWlyIGVmZmVjdHMgd2lsbCBiZSBhcHBsaWVkLiBTZWUgdGhlIGxpbmtzIGJlbG93IGZvciBzb21lIGZ1cnRoZXIgcmVhZGluZyBvbiBkZXNpZ25pbmdcbiAqIGFzeW5jaHJvbm91cyBBUElzLlxuICogKiBbRGVzaWduaW5nIEFQSXMgZm9yIEFzeW5jaHJvbnldKGh0dHBzOi8vYmxvZy5penMubWUvMjAxMy8wOC9kZXNpZ25pbmctYXBpcy1mb3ItYXN5bmNocm9ueSlcbiAqICogW0NhbGxiYWNrcyBzeW5jaHJvbm91cyBhbmQgYXN5bmNocm9ub3VzXShodHRwczovL2Jsb2cub21ldGVyLmNvbS8yMDExLzA3LzI0L2NhbGxiYWNrcy1zeW5jaHJvbm91cy1hbmQtYXN5bmNocm9ub3VzLylcbiAqL1xuXG5sZXQgcHJldkRlYm91bmNlO1xuXG4vKipcbiAqIEVucXVldWUgYSByZXJlbmRlciBvZiBhIGNvbXBvbmVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9IGMgVGhlIGNvbXBvbmVudCB0byByZXJlbmRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5xdWV1ZVJlbmRlcihjKSB7XG5cdGlmIChcblx0XHQoIWMuX2RpcnR5ICYmXG5cdFx0XHQoYy5fZGlydHkgPSB0cnVlKSAmJlxuXHRcdFx0cmVyZW5kZXJRdWV1ZS5wdXNoKGMpICYmXG5cdFx0XHQhcmVyZW5kZXJDb3VudCsrKSB8fFxuXHRcdHByZXZEZWJvdW5jZSAhPT0gb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZ1xuXHQpIHtcblx0XHRwcmV2RGVib3VuY2UgPSBvcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nO1xuXHRcdChwcmV2RGVib3VuY2UgfHwgZGVmZXIpKHByb2Nlc3MpO1xuXHR9XG59XG5cbi8qKiBGbHVzaCB0aGUgcmVuZGVyIHF1ZXVlIGJ5IHJlcmVuZGVyaW5nIGFsbCBxdWV1ZWQgY29tcG9uZW50cyAqL1xuZnVuY3Rpb24gcHJvY2VzcygpIHtcblx0bGV0IHF1ZXVlO1xuXHR3aGlsZSAoKHJlcmVuZGVyQ291bnQgPSByZXJlbmRlclF1ZXVlLmxlbmd0aCkpIHtcblx0XHRxdWV1ZSA9IHJlcmVuZGVyUXVldWUuc29ydCgoYSwgYikgPT4gYS5fdm5vZGUuX2RlcHRoIC0gYi5fdm5vZGUuX2RlcHRoKTtcblx0XHRyZXJlbmRlclF1ZXVlID0gW107XG5cdFx0Ly8gRG9uJ3QgdXBkYXRlIGByZW5kZXJDb3VudGAgeWV0LiBLZWVwIGl0cyB2YWx1ZSBub24temVybyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5XG5cdFx0Ly8gcHJvY2VzcygpIGNhbGxzIGZyb20gZ2V0dGluZyBzY2hlZHVsZWQgd2hpbGUgYHF1ZXVlYCBpcyBzdGlsbCBiZWluZyBjb25zdW1lZC5cblx0XHRxdWV1ZS5zb21lKGMgPT4ge1xuXHRcdFx0aWYgKGMuX2RpcnR5KSByZW5kZXJDb21wb25lbnQoYyk7XG5cdFx0fSk7XG5cdH1cbn1cbiIsImltcG9ydCB7IGRpZmYsIHVubW91bnQsIGFwcGx5UmVmIH0gZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgeyBjcmVhdGVWTm9kZSwgRnJhZ21lbnQgfSBmcm9tICcuLi9jcmVhdGUtZWxlbWVudCc7XG5pbXBvcnQgeyBFTVBUWV9PQkosIEVNUFRZX0FSUiB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyByZW1vdmVOb2RlIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgeyBnZXREb21TaWJsaW5nIH0gZnJvbSAnLi4vY29tcG9uZW50JztcblxuLyoqXG4gKiBEaWZmIHRoZSBjaGlsZHJlbiBvZiBhIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50RG9tIFRoZSBET00gZWxlbWVudCB3aG9zZVxuICogY2hpbGRyZW4gYXJlIGJlaW5nIGRpZmZlZFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2luZGV4JykuQ29tcG9uZW50Q2hpbGRyZW5bXX0gcmVuZGVyUmVzdWx0XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gbmV3UGFyZW50Vk5vZGUgVGhlIG5ldyB2aXJ0dWFsXG4gKiBub2RlIHdob3NlIGNoaWxkcmVuIHNob3VsZCBiZSBkaWZmJ2VkIGFnYWluc3Qgb2xkUGFyZW50Vk5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBvbGRQYXJlbnRWTm9kZSBUaGUgb2xkIHZpcnR1YWxcbiAqIG5vZGUgd2hvc2UgY2hpbGRyZW4gc2hvdWxkIGJlIGRpZmYnZWQgYWdhaW5zdCBuZXdQYXJlbnRWTm9kZVxuICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbENvbnRleHQgVGhlIGN1cnJlbnQgY29udGV4dCBvYmplY3QgLSBtb2RpZmllZCBieSBnZXRDaGlsZENvbnRleHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBET00gbm9kZSBpcyBhbiBTVkcgbm9kZVxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudD59IGV4Y2Vzc0RvbUNoaWxkcmVuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge05vZGUgfCBUZXh0fSBvbGREb20gVGhlIGN1cnJlbnQgYXR0YWNoZWQgRE9NXG4gKiBlbGVtZW50IGFueSBuZXcgZG9tIGVsZW1lbnRzIHNob3VsZCBiZSBwbGFjZWQgYXJvdW5kLiBMaWtlbHkgYG51bGxgIG9uIGZpcnN0XG4gKiByZW5kZXIgKGV4Y2VwdCB3aGVuIGh5ZHJhdGluZykuIENhbiBiZSBhIHNpYmxpbmcgRE9NIGVsZW1lbnQgd2hlbiBkaWZmaW5nXG4gKiBGcmFnbWVudHMgdGhhdCBoYXZlIHNpYmxpbmdzLiBJbiBtb3N0IGNhc2VzLCBpdCBzdGFydHMgb3V0IGFzIGBvbGRDaGlsZHJlblswXS5fZG9tYC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNIeWRyYXRpbmcgV2hldGhlciBvciBub3Qgd2UgYXJlIGluIGh5ZHJhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlmZkNoaWxkcmVuKFxuXHRwYXJlbnREb20sXG5cdHJlbmRlclJlc3VsdCxcblx0bmV3UGFyZW50Vk5vZGUsXG5cdG9sZFBhcmVudFZOb2RlLFxuXHRnbG9iYWxDb250ZXh0LFxuXHRpc1N2Zyxcblx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdGNvbW1pdFF1ZXVlLFxuXHRvbGREb20sXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IGksIGosIG9sZFZOb2RlLCBjaGlsZFZOb2RlLCBuZXdEb20sIHNpYkRvbSwgZmlyc3RDaGlsZERvbSwgcmVmcztcblxuXHQvLyBUaGlzIGlzIGEgY29tcHJlc3Npb24gb2Ygb2xkUGFyZW50Vk5vZGUhPW51bGwgJiYgb2xkUGFyZW50Vk5vZGUgIT0gRU1QVFlfT0JKICYmIG9sZFBhcmVudFZOb2RlLl9jaGlsZHJlbiB8fCBFTVBUWV9BUlJcblx0Ly8gYXMgRU1QVFlfT0JKLl9jaGlsZHJlbiBzaG91bGQgYmUgYHVuZGVmaW5lZGAuXG5cdGxldCBvbGRDaGlsZHJlbiA9IChvbGRQYXJlbnRWTm9kZSAmJiBvbGRQYXJlbnRWTm9kZS5fY2hpbGRyZW4pIHx8IEVNUFRZX0FSUjtcblxuXHRsZXQgb2xkQ2hpbGRyZW5MZW5ndGggPSBvbGRDaGlsZHJlbi5sZW5ndGg7XG5cblx0Ly8gT25seSBpbiB2ZXJ5IHNwZWNpZmljIHBsYWNlcyBzaG91bGQgdGhpcyBsb2dpYyBiZSBpbnZva2VkICh0b3AgbGV2ZWwgYHJlbmRlcmAgYW5kIGBkaWZmRWxlbWVudE5vZGVzYCkuXG5cdC8vIEknbSB1c2luZyBgRU1QVFlfT0JKYCB0byBzaWduYWwgd2hlbiBgZGlmZkNoaWxkcmVuYCBpcyBpbnZva2VkIGluIHRoZXNlIHNpdHVhdGlvbnMuIEkgY2FuJ3QgdXNlIGBudWxsYFxuXHQvLyBmb3IgdGhpcyBwdXJwb3NlLCBiZWNhdXNlIGBudWxsYCBpcyBhIHZhbGlkIHZhbHVlIGZvciBgb2xkRG9tYCB3aGljaCBjYW4gbWVhbiB0byBza2lwIHRvIHRoaXMgbG9naWNcblx0Ly8gKGUuZy4gaWYgbW91bnRpbmcgYSBuZXcgdHJlZSBpbiB3aGljaCB0aGUgb2xkIERPTSBzaG91bGQgYmUgaWdub3JlZCAodXN1YWxseSBmb3IgRnJhZ21lbnRzKS5cblx0aWYgKG9sZERvbSA9PSBFTVBUWV9PQkopIHtcblx0XHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0b2xkRG9tID0gZXhjZXNzRG9tQ2hpbGRyZW5bMF07XG5cdFx0fSBlbHNlIGlmIChvbGRDaGlsZHJlbkxlbmd0aCkge1xuXHRcdFx0b2xkRG9tID0gZ2V0RG9tU2libGluZyhvbGRQYXJlbnRWTm9kZSwgMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9sZERvbSA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0bmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuID0gW107XG5cdGZvciAoaSA9IDA7IGkgPCByZW5kZXJSZXN1bHQubGVuZ3RoOyBpKyspIHtcblx0XHRjaGlsZFZOb2RlID0gcmVuZGVyUmVzdWx0W2ldO1xuXG5cdFx0aWYgKGNoaWxkVk5vZGUgPT0gbnVsbCB8fCB0eXBlb2YgY2hpbGRWTm9kZSA9PSAnYm9vbGVhbicpIHtcblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBudWxsO1xuXHRcdH1cblx0XHQvLyBJZiB0aGlzIG5ld1ZOb2RlIGlzIGJlaW5nIHJldXNlZCAoZS5nLiA8ZGl2PntyZXVzZX17cmV1c2V9PC9kaXY+KSBpbiB0aGUgc2FtZSBkaWZmLFxuXHRcdC8vIG9yIHdlIGFyZSByZW5kZXJpbmcgYSBjb21wb25lbnQgKGUuZy4gc2V0U3RhdGUpIGNvcHkgdGhlIG9sZFZOb2RlcyBzbyBpdCBjYW4gaGF2ZVxuXHRcdC8vIGl0J3Mgb3duIERPTSAmIGV0Yy4gcG9pbnRlcnNcblx0XHRlbHNlIGlmICh0eXBlb2YgY2hpbGRWTm9kZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGRWTm9kZSA9PSAnbnVtYmVyJykge1xuXHRcdFx0Y2hpbGRWTm9kZSA9IG5ld1BhcmVudFZOb2RlLl9jaGlsZHJlbltpXSA9IGNyZWF0ZVZOb2RlKFxuXHRcdFx0XHRudWxsLFxuXHRcdFx0XHRjaGlsZFZOb2RlLFxuXHRcdFx0XHRudWxsLFxuXHRcdFx0XHRudWxsLFxuXHRcdFx0XHRjaGlsZFZOb2RlXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjaGlsZFZOb2RlKSkge1xuXHRcdFx0Y2hpbGRWTm9kZSA9IG5ld1BhcmVudFZOb2RlLl9jaGlsZHJlbltpXSA9IGNyZWF0ZVZOb2RlKFxuXHRcdFx0XHRGcmFnbWVudCxcblx0XHRcdFx0eyBjaGlsZHJlbjogY2hpbGRWTm9kZSB9LFxuXHRcdFx0XHRudWxsLFxuXHRcdFx0XHRudWxsLFxuXHRcdFx0XHRudWxsXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSBpZiAoY2hpbGRWTm9kZS5fZG9tICE9IG51bGwgfHwgY2hpbGRWTm9kZS5fY29tcG9uZW50ICE9IG51bGwpIHtcblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBjcmVhdGVWTm9kZShcblx0XHRcdFx0Y2hpbGRWTm9kZS50eXBlLFxuXHRcdFx0XHRjaGlsZFZOb2RlLnByb3BzLFxuXHRcdFx0XHRjaGlsZFZOb2RlLmtleSxcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0Y2hpbGRWTm9kZS5fb3JpZ2luYWxcblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBjaGlsZFZOb2RlO1xuXHRcdH1cblxuXHRcdC8vIFRlcnNlciByZW1vdmVzIHRoZSBgY29udGludWVgIGhlcmUgYW5kIHdyYXBzIHRoZSBsb29wIGJvZHlcblx0XHQvLyBpbiBhIGBpZiAoY2hpbGRWTm9kZSkgeyAuLi4gfSBjb25kaXRpb25cblx0XHRpZiAoY2hpbGRWTm9kZSA9PSBudWxsKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRjaGlsZFZOb2RlLl9wYXJlbnQgPSBuZXdQYXJlbnRWTm9kZTtcblx0XHRjaGlsZFZOb2RlLl9kZXB0aCA9IG5ld1BhcmVudFZOb2RlLl9kZXB0aCArIDE7XG5cblx0XHQvLyBDaGVjayBpZiB3ZSBmaW5kIGEgY29ycmVzcG9uZGluZyBlbGVtZW50IGluIG9sZENoaWxkcmVuLlxuXHRcdC8vIElmIGZvdW5kLCBkZWxldGUgdGhlIGFycmF5IGl0ZW0gYnkgc2V0dGluZyB0byBgdW5kZWZpbmVkYC5cblx0XHQvLyBXZSB1c2UgYHVuZGVmaW5lZGAsIGFzIGBudWxsYCBpcyByZXNlcnZlZCBmb3IgZW1wdHkgcGxhY2Vob2xkZXJzXG5cdFx0Ly8gKGhvbGVzKS5cblx0XHRvbGRWTm9kZSA9IG9sZENoaWxkcmVuW2ldO1xuXG5cdFx0aWYgKFxuXHRcdFx0b2xkVk5vZGUgPT09IG51bGwgfHxcblx0XHRcdChvbGRWTm9kZSAmJlxuXHRcdFx0XHRjaGlsZFZOb2RlLmtleSA9PSBvbGRWTm9kZS5rZXkgJiZcblx0XHRcdFx0Y2hpbGRWTm9kZS50eXBlID09PSBvbGRWTm9kZS50eXBlKVxuXHRcdCkge1xuXHRcdFx0b2xkQ2hpbGRyZW5baV0gPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEVpdGhlciBvbGRWTm9kZSA9PT0gdW5kZWZpbmVkIG9yIG9sZENoaWxkcmVuTGVuZ3RoID4gMCxcblx0XHRcdC8vIHNvIGFmdGVyIHRoaXMgbG9vcCBvbGRWTm9kZSA9PSBudWxsIG9yIG9sZFZOb2RlIGlzIGEgdmFsaWQgdmFsdWUuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgb2xkQ2hpbGRyZW5MZW5ndGg7IGorKykge1xuXHRcdFx0XHRvbGRWTm9kZSA9IG9sZENoaWxkcmVuW2pdO1xuXHRcdFx0XHQvLyBJZiBjaGlsZFZOb2RlIGlzIHVua2V5ZWQsIHdlIG9ubHkgbWF0Y2ggc2ltaWxhcmx5IHVua2V5ZWQgbm9kZXMsIG90aGVyd2lzZSB3ZSBtYXRjaCBieSBrZXkuXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBtYXRjaCBieSB0eXBlIChpbiBlaXRoZXIgY2FzZSkuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRvbGRWTm9kZSAmJlxuXHRcdFx0XHRcdGNoaWxkVk5vZGUua2V5ID09IG9sZFZOb2RlLmtleSAmJlxuXHRcdFx0XHRcdGNoaWxkVk5vZGUudHlwZSA9PT0gb2xkVk5vZGUudHlwZVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRvbGRDaGlsZHJlbltqXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRvbGRWTm9kZSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0b2xkVk5vZGUgPSBvbGRWTm9kZSB8fCBFTVBUWV9PQko7XG5cblx0XHQvLyBNb3JwaCB0aGUgb2xkIGVsZW1lbnQgaW50byB0aGUgbmV3IG9uZSwgYnV0IGRvbid0IGFwcGVuZCBpdCB0byB0aGUgZG9tIHlldFxuXHRcdG5ld0RvbSA9IGRpZmYoXG5cdFx0XHRwYXJlbnREb20sXG5cdFx0XHRjaGlsZFZOb2RlLFxuXHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRnbG9iYWxDb250ZXh0LFxuXHRcdFx0aXNTdmcsXG5cdFx0XHRleGNlc3NEb21DaGlsZHJlbixcblx0XHRcdGNvbW1pdFF1ZXVlLFxuXHRcdFx0b2xkRG9tLFxuXHRcdFx0aXNIeWRyYXRpbmdcblx0XHQpO1xuXG5cdFx0aWYgKChqID0gY2hpbGRWTm9kZS5yZWYpICYmIG9sZFZOb2RlLnJlZiAhPSBqKSB7XG5cdFx0XHRpZiAoIXJlZnMpIHJlZnMgPSBbXTtcblx0XHRcdGlmIChvbGRWTm9kZS5yZWYpIHJlZnMucHVzaChvbGRWTm9kZS5yZWYsIG51bGwsIGNoaWxkVk5vZGUpO1xuXHRcdFx0cmVmcy5wdXNoKGosIGNoaWxkVk5vZGUuX2NvbXBvbmVudCB8fCBuZXdEb20sIGNoaWxkVk5vZGUpO1xuXHRcdH1cblxuXHRcdC8vIE9ubHkgcHJvY2VlZCBpZiB0aGUgdm5vZGUgaGFzIG5vdCBiZWVuIHVubW91bnRlZCBieSBgZGlmZigpYCBhYm92ZS5cblx0XHRpZiAobmV3RG9tICE9IG51bGwpIHtcblx0XHRcdGlmIChmaXJzdENoaWxkRG9tID09IG51bGwpIHtcblx0XHRcdFx0Zmlyc3RDaGlsZERvbSA9IG5ld0RvbTtcblx0XHRcdH1cblxuXHRcdFx0bGV0IG5leHREb207XG5cdFx0XHRpZiAoY2hpbGRWTm9kZS5fbmV4dERvbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8vIE9ubHkgRnJhZ21lbnRzIG9yIGNvbXBvbmVudHMgdGhhdCByZXR1cm4gRnJhZ21lbnQgbGlrZSBWTm9kZXMgd2lsbFxuXHRcdFx0XHQvLyBoYXZlIGEgbm9uLXVuZGVmaW5lZCBfbmV4dERvbS4gQ29udGludWUgdGhlIGRpZmYgZnJvbSB0aGUgc2libGluZ1xuXHRcdFx0XHQvLyBvZiBsYXN0IERPTSBjaGlsZCBvZiB0aGlzIGNoaWxkIFZOb2RlXG5cdFx0XHRcdG5leHREb20gPSBjaGlsZFZOb2RlLl9uZXh0RG9tO1xuXG5cdFx0XHRcdC8vIEVhZ2VybHkgY2xlYW51cCBfbmV4dERvbS4gV2UgZG9uJ3QgbmVlZCB0byBwZXJzaXN0IHRoZSB2YWx1ZSBiZWNhdXNlXG5cdFx0XHRcdC8vIGl0IGlzIG9ubHkgdXNlZCBieSBgZGlmZkNoaWxkcmVuYCB0byBkZXRlcm1pbmUgd2hlcmUgdG8gcmVzdW1lIHRoZSBkaWZmIGFmdGVyXG5cdFx0XHRcdC8vIGRpZmZpbmcgQ29tcG9uZW50cyBhbmQgRnJhZ21lbnRzLiBPbmNlIHdlIHN0b3JlIGl0IHRoZSBuZXh0RE9NIGxvY2FsIHZhciwgd2Vcblx0XHRcdFx0Ly8gY2FuIGNsZWFuIHVwIHRoZSBwcm9wZXJ0eVxuXHRcdFx0XHRjaGlsZFZOb2RlLl9uZXh0RG9tID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4gPT0gb2xkVk5vZGUgfHxcblx0XHRcdFx0bmV3RG9tICE9IG9sZERvbSB8fFxuXHRcdFx0XHRuZXdEb20ucGFyZW50Tm9kZSA9PSBudWxsXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gTk9URTogZXhjZXNzRG9tQ2hpbGRyZW49PW9sZFZOb2RlIGFib3ZlOlxuXHRcdFx0XHQvLyBUaGlzIGlzIGEgY29tcHJlc3Npb24gb2YgZXhjZXNzRG9tQ2hpbGRyZW49PW51bGwgJiYgb2xkVk5vZGU9PW51bGwhXG5cdFx0XHRcdC8vIFRoZSB2YWx1ZXMgb25seSBoYXZlIHRoZSBzYW1lIHR5cGUgd2hlbiBgbnVsbGAuXG5cblx0XHRcdFx0b3V0ZXI6IGlmIChvbGREb20gPT0gbnVsbCB8fCBvbGREb20ucGFyZW50Tm9kZSAhPT0gcGFyZW50RG9tKSB7XG5cdFx0XHRcdFx0cGFyZW50RG9tLmFwcGVuZENoaWxkKG5ld0RvbSk7XG5cdFx0XHRcdFx0bmV4dERvbSA9IG51bGw7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gYGo8b2xkQ2hpbGRyZW5MZW5ndGg7IGorPTJgIGlzIGFuIGFsdGVybmF0aXZlIHRvIGBqKys8b2xkQ2hpbGRyZW5MZW5ndGgvMmBcblx0XHRcdFx0XHRmb3IgKFxuXHRcdFx0XHRcdFx0c2liRG9tID0gb2xkRG9tLCBqID0gMDtcblx0XHRcdFx0XHRcdChzaWJEb20gPSBzaWJEb20ubmV4dFNpYmxpbmcpICYmIGogPCBvbGRDaGlsZHJlbkxlbmd0aDtcblx0XHRcdFx0XHRcdGogKz0gMlxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0aWYgKHNpYkRvbSA9PSBuZXdEb20pIHtcblx0XHRcdFx0XHRcdFx0YnJlYWsgb3V0ZXI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBhcmVudERvbS5pbnNlcnRCZWZvcmUobmV3RG9tLCBvbGREb20pO1xuXHRcdFx0XHRcdG5leHREb20gPSBvbGREb207XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBCcm93c2VycyB3aWxsIGluZmVyIGFuIG9wdGlvbidzIGB2YWx1ZWAgZnJvbSBgdGV4dENvbnRlbnRgIHdoZW5cblx0XHRcdFx0Ly8gbm8gdmFsdWUgaXMgcHJlc2VudC4gVGhpcyBlc3NlbnRpYWxseSBieXBhc3NlcyBvdXIgY29kZSB0byBzZXQgaXRcblx0XHRcdFx0Ly8gbGF0ZXIgaW4gYGRpZmYoKWAuIEl0IHdvcmtzIGZpbmUgaW4gYWxsIGJyb3dzZXJzIGV4Y2VwdCBmb3IgSUUxMVxuXHRcdFx0XHQvLyB3aGVyZSBpdCBicmVha3Mgc2V0dGluZyBgc2VsZWN0LnZhbHVlYC4gVGhlcmUgaXQgd2lsbCBiZSBhbHdheXMgc2V0XG5cdFx0XHRcdC8vIHRvIGFuIGVtcHR5IHN0cmluZy4gUmUtYXBwbHlpbmcgYW4gb3B0aW9ucyB2YWx1ZSB3aWxsIGZpeCB0aGF0LCBzb1xuXHRcdFx0XHQvLyB0aGVyZSBhcmUgcHJvYmFibHkgc29tZSBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZXMgdGhhdCBhcmVuJ3Rcblx0XHRcdFx0Ly8gdXBkYXRlZCBwcm9wZXJseS5cblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gVG8gZml4IGl0IHdlIG1ha2Ugc3VyZSB0byByZXNldCB0aGUgaW5mZXJyZWQgdmFsdWUsIHNvIHRoYXQgb3VyIG93blxuXHRcdFx0XHQvLyB2YWx1ZSBjaGVjayBpbiBgZGlmZigpYCB3b24ndCBiZSBza2lwcGVkLlxuXHRcdFx0XHRpZiAobmV3UGFyZW50Vk5vZGUudHlwZSA9PSAnb3B0aW9uJykge1xuXHRcdFx0XHRcdHBhcmVudERvbS52YWx1ZSA9ICcnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHdlIGhhdmUgcHJlLWNhbGN1bGF0ZWQgdGhlIG5leHRET00gbm9kZSwgdXNlIGl0LiBFbHNlIGNhbGN1bGF0ZSBpdCBub3dcblx0XHRcdC8vIFN0cmljdGx5IGNoZWNrIGZvciBgdW5kZWZpbmVkYCBoZXJlIGN1eiBgbnVsbGAgaXMgYSB2YWxpZCB2YWx1ZSBvZiBgbmV4dERvbWAuXG5cdFx0XHQvLyBTZWUgbW9yZSBkZXRhaWwgaW4gY3JlYXRlLWVsZW1lbnQuanM6Y3JlYXRlVk5vZGVcblx0XHRcdGlmIChuZXh0RG9tICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0b2xkRG9tID0gbmV4dERvbTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9sZERvbSA9IG5ld0RvbS5uZXh0U2libGluZztcblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGVvZiBuZXdQYXJlbnRWTm9kZS50eXBlID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Ly8gQmVjYXVzZSB0aGUgbmV3UGFyZW50Vk5vZGUgaXMgRnJhZ21lbnQtbGlrZSwgd2UgbmVlZCB0byBzZXQgaXQnc1xuXHRcdFx0XHQvLyBfbmV4dERvbSBwcm9wZXJ0eSB0byB0aGUgbmV4dFNpYmxpbmcgb2YgaXRzIGxhc3QgY2hpbGQgRE9NIG5vZGUuXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIGBvbGREb21gIGNvbnRhaW5zIHRoZSBjb3JyZWN0IHZhbHVlIGhlcmUgYmVjYXVzZSBpZiB0aGUgbGFzdCBjaGlsZFxuXHRcdFx0XHQvLyBpcyBhIEZyYWdtZW50LWxpa2UsIHRoZW4gb2xkRG9tIGhhcyBhbHJlYWR5IGJlZW4gc2V0IHRvIHRoYXQgY2hpbGQncyBfbmV4dERvbS5cblx0XHRcdFx0Ly8gSWYgdGhlIGxhc3QgY2hpbGQgaXMgYSBET00gVk5vZGUsIHRoZW4gb2xkRG9tIHdpbGwgYmUgc2V0IHRvIHRoYXQgRE9NXG5cdFx0XHRcdC8vIG5vZGUncyBuZXh0U2libGluZy5cblxuXHRcdFx0XHRuZXdQYXJlbnRWTm9kZS5fbmV4dERvbSA9IG9sZERvbTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0b2xkRG9tICYmXG5cdFx0XHRvbGRWTm9kZS5fZG9tID09IG9sZERvbSAmJlxuXHRcdFx0b2xkRG9tLnBhcmVudE5vZGUgIT0gcGFyZW50RG9tXG5cdFx0KSB7XG5cdFx0XHQvLyBUaGUgYWJvdmUgY29uZGl0aW9uIGlzIHRvIGhhbmRsZSBudWxsIHBsYWNlaG9sZGVycy4gU2VlIHRlc3QgaW4gcGxhY2Vob2xkZXIudGVzdC5qczpcblx0XHRcdC8vIGBlZmZpY2llbnRseSByZXBsYWNlIG51bGwgcGxhY2Vob2xkZXJzIGluIHBhcmVudCByZXJlbmRlcnNgXG5cdFx0XHRvbGREb20gPSBnZXREb21TaWJsaW5nKG9sZFZOb2RlKTtcblx0XHR9XG5cdH1cblxuXHRuZXdQYXJlbnRWTm9kZS5fZG9tID0gZmlyc3RDaGlsZERvbTtcblxuXHQvLyBSZW1vdmUgY2hpbGRyZW4gdGhhdCBhcmUgbm90IHBhcnQgb2YgYW55IHZub2RlLlxuXHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCAmJiB0eXBlb2YgbmV3UGFyZW50Vk5vZGUudHlwZSAhPSAnZnVuY3Rpb24nKSB7XG5cdFx0Zm9yIChpID0gZXhjZXNzRG9tQ2hpbGRyZW4ubGVuZ3RoOyBpLS07ICkge1xuXHRcdFx0aWYgKGV4Y2Vzc0RvbUNoaWxkcmVuW2ldICE9IG51bGwpIHJlbW92ZU5vZGUoZXhjZXNzRG9tQ2hpbGRyZW5baV0pO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSByZW1haW5pbmcgb2xkQ2hpbGRyZW4gaWYgdGhlcmUgYXJlIGFueS5cblx0Zm9yIChpID0gb2xkQ2hpbGRyZW5MZW5ndGg7IGktLTsgKSB7XG5cdFx0aWYgKG9sZENoaWxkcmVuW2ldICE9IG51bGwpIHVubW91bnQob2xkQ2hpbGRyZW5baV0sIG9sZENoaWxkcmVuW2ldKTtcblx0fVxuXG5cdC8vIFNldCByZWZzIG9ubHkgYWZ0ZXIgdW5tb3VudFxuXHRpZiAocmVmcykge1xuXHRcdGZvciAoaSA9IDA7IGkgPCByZWZzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRhcHBseVJlZihyZWZzW2ldLCByZWZzWysraV0sIHJlZnNbKytpXSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogRmxhdHRlbiBhbmQgbG9vcCB0aHJvdWdoIHRoZSBjaGlsZHJlbiBvZiBhIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2luZGV4JykuQ29tcG9uZW50Q2hpbGRyZW59IGNoaWxkcmVuIFRoZSB1bmZsYXR0ZW5lZFxuICogY2hpbGRyZW4gb2YgYSB2aXJ0dWFsIG5vZGVcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGVbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQ2hpbGRBcnJheShjaGlsZHJlbikge1xuXHRpZiAoY2hpbGRyZW4gPT0gbnVsbCB8fCB0eXBlb2YgY2hpbGRyZW4gPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG5cdFx0cmV0dXJuIEVNUFRZX0FSUi5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuLm1hcCh0b0NoaWxkQXJyYXkpKTtcblx0fVxuXG5cdHJldHVybiBbY2hpbGRyZW5dO1xufVxuIiwiaW1wb3J0IHsgSVNfTk9OX0RJTUVOU0lPTkFMIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4uL29wdGlvbnMnO1xuXG4vKipcbiAqIERpZmYgdGhlIG9sZCBhbmQgbmV3IHByb3BlcnRpZXMgb2YgYSBWTm9kZSBhbmQgYXBwbHkgY2hhbmdlcyB0byB0aGUgRE9NIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGRvbSBUaGUgRE9NIG5vZGUgdG8gYXBwbHlcbiAqIGNoYW5nZXMgdG9cbiAqIEBwYXJhbSB7b2JqZWN0fSBuZXdQcm9wcyBUaGUgbmV3IHByb3BzXG4gKiBAcGFyYW0ge29iamVjdH0gb2xkUHJvcHMgVGhlIG9sZCBwcm9wc1xuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIG5vZGUgaXMgYW4gU1ZHIG5vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaHlkcmF0ZSBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gaHlkcmF0aW9uIG1vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpZmZQcm9wcyhkb20sIG5ld1Byb3BzLCBvbGRQcm9wcywgaXNTdmcsIGh5ZHJhdGUpIHtcblx0bGV0IGk7XG5cblx0Zm9yIChpIGluIG9sZFByb3BzKSB7XG5cdFx0aWYgKGkgIT09ICdjaGlsZHJlbicgJiYgaSAhPT0gJ2tleScgJiYgIShpIGluIG5ld1Byb3BzKSkge1xuXHRcdFx0c2V0UHJvcGVydHkoZG9tLCBpLCBudWxsLCBvbGRQcm9wc1tpXSwgaXNTdmcpO1xuXHRcdH1cblx0fVxuXG5cdGZvciAoaSBpbiBuZXdQcm9wcykge1xuXHRcdGlmIChcblx0XHRcdCghaHlkcmF0ZSB8fCB0eXBlb2YgbmV3UHJvcHNbaV0gPT0gJ2Z1bmN0aW9uJykgJiZcblx0XHRcdGkgIT09ICdjaGlsZHJlbicgJiZcblx0XHRcdGkgIT09ICdrZXknICYmXG5cdFx0XHRpICE9PSAndmFsdWUnICYmXG5cdFx0XHRpICE9PSAnY2hlY2tlZCcgJiZcblx0XHRcdG9sZFByb3BzW2ldICE9PSBuZXdQcm9wc1tpXVxuXHRcdCkge1xuXHRcdFx0c2V0UHJvcGVydHkoZG9tLCBpLCBuZXdQcm9wc1tpXSwgb2xkUHJvcHNbaV0sIGlzU3ZnKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gc2V0U3R5bGUoc3R5bGUsIGtleSwgdmFsdWUpIHtcblx0aWYgKGtleVswXSA9PT0gJy0nKSB7XG5cdFx0c3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSk7XG5cdH0gZWxzZSBpZiAoXG5cdFx0dHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG5cdFx0SVNfTk9OX0RJTUVOU0lPTkFMLnRlc3Qoa2V5KSA9PT0gZmFsc2Vcblx0KSB7XG5cdFx0c3R5bGVba2V5XSA9IHZhbHVlICsgJ3B4Jztcblx0fSBlbHNlIGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdFx0c3R5bGVba2V5XSA9ICcnO1xuXHR9IGVsc2Uge1xuXHRcdHN0eWxlW2tleV0gPSB2YWx1ZTtcblx0fVxufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IHZhbHVlIG9uIGEgRE9NIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGRvbSBUaGUgRE9NIG5vZGUgdG8gbW9kaWZ5XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gc2V0XG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQgdGhlIHByb3BlcnR5IHRvXG4gKiBAcGFyYW0geyp9IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgdGhlIHByb3BlcnR5IGhhZFxuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIERPTSBub2RlIGlzIGFuIFNWRyBub2RlIG9yIG5vdFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0UHJvcGVydHkoZG9tLCBuYW1lLCB2YWx1ZSwgb2xkVmFsdWUsIGlzU3ZnKSB7XG5cdGxldCBzLCB1c2VDYXB0dXJlLCBuYW1lTG93ZXI7XG5cblx0aWYgKGlzU3ZnKSB7XG5cdFx0aWYgKG5hbWUgPT09ICdjbGFzc05hbWUnKSB7XG5cdFx0XHRuYW1lID0gJ2NsYXNzJztcblx0XHR9XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsYXNzJykge1xuXHRcdG5hbWUgPSAnY2xhc3NOYW1lJztcblx0fVxuXG5cdGlmIChuYW1lID09PSAnc3R5bGUnKSB7XG5cdFx0cyA9IGRvbS5zdHlsZTtcblxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcblx0XHRcdHMuY3NzVGV4dCA9IHZhbHVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAodHlwZW9mIG9sZFZhbHVlID09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHMuY3NzVGV4dCA9ICcnO1xuXHRcdFx0XHRvbGRWYWx1ZSA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvbGRWYWx1ZSkge1xuXHRcdFx0XHRmb3IgKGxldCBpIGluIG9sZFZhbHVlKSB7XG5cdFx0XHRcdFx0aWYgKCEodmFsdWUgJiYgaSBpbiB2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdHNldFN0eWxlKHMsIGksICcnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgaW4gdmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoIW9sZFZhbHVlIHx8IHZhbHVlW2ldICE9PSBvbGRWYWx1ZVtpXSkge1xuXHRcdFx0XHRcdFx0c2V0U3R5bGUocywgaSwgdmFsdWVbaV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvLyBCZW5jaG1hcmsgZm9yIGNvbXBhcmlzb246IGh0dHBzOi8vZXNiZW5jaC5jb20vYmVuY2gvNTc0Yzk1NGJkYjk2NWI5YTAwOTY1YWM2XG5cdGVsc2UgaWYgKG5hbWVbMF0gPT09ICdvJyAmJiBuYW1lWzFdID09PSAnbicpIHtcblx0XHR1c2VDYXB0dXJlID0gbmFtZSAhPT0gKG5hbWUgPSBuYW1lLnJlcGxhY2UoL0NhcHR1cmUkLywgJycpKTtcblx0XHRuYW1lTG93ZXIgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0bmFtZSA9IChuYW1lTG93ZXIgaW4gZG9tID8gbmFtZUxvd2VyIDogbmFtZSkuc2xpY2UoMik7XG5cblx0XHRpZiAodmFsdWUpIHtcblx0XHRcdGlmICghb2xkVmFsdWUpIGRvbS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGV2ZW50UHJveHksIHVzZUNhcHR1cmUpO1xuXHRcdFx0KGRvbS5fbGlzdGVuZXJzIHx8IChkb20uX2xpc3RlbmVycyA9IHt9KSlbbmFtZV0gPSB2YWx1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgZXZlbnRQcm94eSwgdXNlQ2FwdHVyZSk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKFxuXHRcdG5hbWUgIT09ICdsaXN0JyAmJlxuXHRcdG5hbWUgIT09ICd0YWdOYW1lJyAmJlxuXHRcdC8vIEhUTUxCdXR0b25FbGVtZW50LmZvcm0gYW5kIEhUTUxJbnB1dEVsZW1lbnQuZm9ybSBhcmUgcmVhZC1vbmx5IGJ1dCBjYW4gYmUgc2V0IHVzaW5nXG5cdFx0Ly8gc2V0QXR0cmlidXRlXG5cdFx0bmFtZSAhPT0gJ2Zvcm0nICYmXG5cdFx0bmFtZSAhPT0gJ3R5cGUnICYmXG5cdFx0bmFtZSAhPT0gJ3NpemUnICYmXG5cdFx0IWlzU3ZnICYmXG5cdFx0bmFtZSBpbiBkb21cblx0KSB7XG5cdFx0ZG9tW25hbWVdID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG5cdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9ICdmdW5jdGlvbicgJiYgbmFtZSAhPT0gJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJykge1xuXHRcdGlmIChuYW1lICE9PSAobmFtZSA9IG5hbWUucmVwbGFjZSgvXnhsaW5rOj8vLCAnJykpKSB7XG5cdFx0XHRpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0ZG9tLnJlbW92ZUF0dHJpYnV0ZU5TKFxuXHRcdFx0XHRcdCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcblx0XHRcdFx0XHRuYW1lLnRvTG93ZXJDYXNlKClcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvbS5zZXRBdHRyaWJ1dGVOUyhcblx0XHRcdFx0XHQnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG5cdFx0XHRcdFx0bmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdHZhbHVlXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdHZhbHVlID09IG51bGwgfHxcblx0XHRcdCh2YWx1ZSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0Ly8gQVJJQS1hdHRyaWJ1dGVzIGhhdmUgYSBkaWZmZXJlbnQgbm90aW9uIG9mIGJvb2xlYW4gdmFsdWVzLlxuXHRcdFx0XHQvLyBUaGUgdmFsdWUgYGZhbHNlYCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgYXR0cmlidXRlIG5vdFxuXHRcdFx0XHQvLyBleGlzdGluZyBvbiB0aGUgRE9NLCBzbyB3ZSBjYW4ndCByZW1vdmUgaXQuIEZvciBub24tYm9vbGVhblxuXHRcdFx0XHQvLyBBUklBLWF0dHJpYnV0ZXMgd2UgY291bGQgdHJlYXQgZmFsc2UgYXMgYSByZW1vdmFsLCBidXQgdGhlXG5cdFx0XHRcdC8vIGFtb3VudCBvZiBleGNlcHRpb25zIHdvdWxkIGNvc3QgdXMgdG9vIG1hbnkgYnl0ZXMuIE9uIHRvcCBvZlxuXHRcdFx0XHQvLyB0aGF0IG90aGVyIFZET00gZnJhbWV3b3JrcyBhbHNvIGFsd2F5cyBzdHJpbmdpZnkgYGZhbHNlYC5cblx0XHRcdFx0IS9eYXIvLnRlc3QobmFtZSkpXG5cdFx0KSB7XG5cdFx0XHRkb20ucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkb20uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBQcm94eSBhbiBldmVudCB0byBob29rZWQgZXZlbnQgaGFuZGxlcnNcbiAqIEBwYXJhbSB7RXZlbnR9IGUgVGhlIGV2ZW50IG9iamVjdCBmcm9tIHRoZSBicm93c2VyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBldmVudFByb3h5KGUpIHtcblx0dGhpcy5fbGlzdGVuZXJzW2UudHlwZV0ob3B0aW9ucy5ldmVudCA/IG9wdGlvbnMuZXZlbnQoZSkgOiBlKTtcbn1cbiIsImltcG9ydCB7IEVNUFRZX09CSiwgRU1QVFlfQVJSIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBGcmFnbWVudCB9IGZyb20gJy4uL2NyZWF0ZS1lbGVtZW50JztcbmltcG9ydCB7IGRpZmZDaGlsZHJlbiB9IGZyb20gJy4vY2hpbGRyZW4nO1xuaW1wb3J0IHsgZGlmZlByb3BzLCBzZXRQcm9wZXJ0eSB9IGZyb20gJy4vcHJvcHMnO1xuaW1wb3J0IHsgYXNzaWduLCByZW1vdmVOb2RlIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuLi9vcHRpb25zJztcblxuLyoqXG4gKiBEaWZmIHR3byB2aXJ0dWFsIG5vZGVzIGFuZCBhcHBseSBwcm9wZXIgY2hhbmdlcyB0byB0aGUgRE9NXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnREb20gVGhlIHBhcmVudCBvZiB0aGUgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBuZXdWTm9kZSBUaGUgbmV3IHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG9sZFZOb2RlIFRoZSBvbGQgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFsQ29udGV4dCBUaGUgY3VycmVudCBjb250ZXh0IG9iamVjdC4gTW9kaWZpZWQgYnkgZ2V0Q2hpbGRDb250ZXh0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3ZnIFdoZXRoZXIgb3Igbm90IHRoaXMgZWxlbWVudCBpcyBhbiBTVkcgbm9kZVxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudD59IGV4Y2Vzc0RvbUNoaWxkcmVuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge0VsZW1lbnQgfCBUZXh0fSBvbGREb20gVGhlIGN1cnJlbnQgYXR0YWNoZWQgRE9NXG4gKiBlbGVtZW50IGFueSBuZXcgZG9tIGVsZW1lbnRzIHNob3VsZCBiZSBwbGFjZWQgYXJvdW5kLiBMaWtlbHkgYG51bGxgIG9uIGZpcnN0XG4gKiByZW5kZXIgKGV4Y2VwdCB3aGVuIGh5ZHJhdGluZykuIENhbiBiZSBhIHNpYmxpbmcgRE9NIGVsZW1lbnQgd2hlbiBkaWZmaW5nXG4gKiBGcmFnbWVudHMgdGhhdCBoYXZlIHNpYmxpbmdzLiBJbiBtb3N0IGNhc2VzLCBpdCBzdGFydHMgb3V0IGFzIGBvbGRDaGlsZHJlblswXS5fZG9tYC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzSHlkcmF0aW5nXSBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gaHlkcmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmKFxuXHRwYXJlbnREb20sXG5cdG5ld1ZOb2RlLFxuXHRvbGRWTm9kZSxcblx0Z2xvYmFsQ29udGV4dCxcblx0aXNTdmcsXG5cdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRjb21taXRRdWV1ZSxcblx0b2xkRG9tLFxuXHRpc0h5ZHJhdGluZ1xuKSB7XG5cdGxldCB0bXAsXG5cdFx0bmV3VHlwZSA9IG5ld1ZOb2RlLnR5cGU7XG5cblx0Ly8gV2hlbiBwYXNzaW5nIHRocm91Z2ggY3JlYXRlRWxlbWVudCBpdCBhc3NpZ25zIHRoZSBvYmplY3Rcblx0Ly8gY29uc3RydWN0b3IgYXMgdW5kZWZpbmVkLiBUaGlzIHRvIHByZXZlbnQgSlNPTi1pbmplY3Rpb24uXG5cdGlmIChuZXdWTm9kZS5jb25zdHJ1Y3RvciAhPT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcblxuXHRpZiAoKHRtcCA9IG9wdGlvbnMuX2RpZmYpKSB0bXAobmV3Vk5vZGUpO1xuXG5cdHRyeSB7XG5cdFx0b3V0ZXI6IGlmICh0eXBlb2YgbmV3VHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRsZXQgYywgaXNOZXcsIG9sZFByb3BzLCBvbGRTdGF0ZSwgc25hcHNob3QsIGNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbjtcblx0XHRcdGxldCBuZXdQcm9wcyA9IG5ld1ZOb2RlLnByb3BzO1xuXG5cdFx0XHQvLyBOZWNlc3NhcnkgZm9yIGNyZWF0ZUNvbnRleHQgYXBpLiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgd2lsbCBwYXNzXG5cdFx0XHQvLyB0aGUgY29udGV4dCB2YWx1ZSBhcyBgdGhpcy5jb250ZXh0YCBqdXN0IGZvciB0aGlzIGNvbXBvbmVudC5cblx0XHRcdHRtcCA9IG5ld1R5cGUuY29udGV4dFR5cGU7XG5cdFx0XHRsZXQgcHJvdmlkZXIgPSB0bXAgJiYgZ2xvYmFsQ29udGV4dFt0bXAuX2lkXTtcblx0XHRcdGxldCBjb21wb25lbnRDb250ZXh0ID0gdG1wXG5cdFx0XHRcdD8gcHJvdmlkZXJcblx0XHRcdFx0XHQ/IHByb3ZpZGVyLnByb3BzLnZhbHVlXG5cdFx0XHRcdFx0OiB0bXAuX2RlZmF1bHRWYWx1ZVxuXHRcdFx0XHQ6IGdsb2JhbENvbnRleHQ7XG5cblx0XHRcdC8vIEdldCBjb21wb25lbnQgYW5kIHNldCBpdCB0byBgY2Bcblx0XHRcdGlmIChvbGRWTm9kZS5fY29tcG9uZW50KSB7XG5cdFx0XHRcdGMgPSBuZXdWTm9kZS5fY29tcG9uZW50ID0gb2xkVk5vZGUuX2NvbXBvbmVudDtcblx0XHRcdFx0Y2xlYXJQcm9jZXNzaW5nRXhjZXB0aW9uID0gYy5fcHJvY2Vzc2luZ0V4Y2VwdGlvbiA9IGMuX3BlbmRpbmdFcnJvcjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEluc3RhbnRpYXRlIHRoZSBuZXcgY29tcG9uZW50XG5cdFx0XHRcdGlmICgncHJvdG90eXBlJyBpbiBuZXdUeXBlICYmIG5ld1R5cGUucHJvdG90eXBlLnJlbmRlcikge1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jb21wb25lbnQgPSBjID0gbmV3IG5ld1R5cGUobmV3UHJvcHMsIGNvbXBvbmVudENvbnRleHQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRuZXdWTm9kZS5fY29tcG9uZW50ID0gYyA9IG5ldyBDb21wb25lbnQobmV3UHJvcHMsIGNvbXBvbmVudENvbnRleHQpO1xuXHRcdFx0XHRcdGMuY29uc3RydWN0b3IgPSBuZXdUeXBlO1xuXHRcdFx0XHRcdGMucmVuZGVyID0gZG9SZW5kZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHByb3ZpZGVyKSBwcm92aWRlci5zdWIoYyk7XG5cblx0XHRcdFx0Yy5wcm9wcyA9IG5ld1Byb3BzO1xuXHRcdFx0XHRpZiAoIWMuc3RhdGUpIGMuc3RhdGUgPSB7fTtcblx0XHRcdFx0Yy5jb250ZXh0ID0gY29tcG9uZW50Q29udGV4dDtcblx0XHRcdFx0Yy5fZ2xvYmFsQ29udGV4dCA9IGdsb2JhbENvbnRleHQ7XG5cdFx0XHRcdGlzTmV3ID0gYy5fZGlydHkgPSB0cnVlO1xuXHRcdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MgPSBbXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSW52b2tlIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc1xuXHRcdFx0aWYgKGMuX25leHRTdGF0ZSA9PSBudWxsKSB7XG5cdFx0XHRcdGMuX25leHRTdGF0ZSA9IGMuc3RhdGU7XG5cdFx0XHR9XG5cdFx0XHRpZiAobmV3VHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoYy5fbmV4dFN0YXRlID09IGMuc3RhdGUpIHtcblx0XHRcdFx0XHRjLl9uZXh0U3RhdGUgPSBhc3NpZ24oe30sIGMuX25leHRTdGF0ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhc3NpZ24oXG5cdFx0XHRcdFx0Yy5fbmV4dFN0YXRlLFxuXHRcdFx0XHRcdG5ld1R5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5ld1Byb3BzLCBjLl9uZXh0U3RhdGUpXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdG9sZFByb3BzID0gYy5wcm9wcztcblx0XHRcdG9sZFN0YXRlID0gYy5zdGF0ZTtcblxuXHRcdFx0Ly8gSW52b2tlIHByZS1yZW5kZXIgbGlmZWN5Y2xlIG1ldGhvZHNcblx0XHRcdGlmIChpc05ldykge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0bmV3VHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT0gbnVsbCAmJlxuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbE1vdW50ICE9IG51bGxcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsTW91bnQoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjLmNvbXBvbmVudERpZE1vdW50ICE9IG51bGwpIHtcblx0XHRcdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MucHVzaChjLmNvbXBvbmVudERpZE1vdW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdG5ld1R5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09IG51bGwgJiZcblx0XHRcdFx0XHRuZXdQcm9wcyAhPT0gb2xkUHJvcHMgJiZcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgIT0gbnVsbFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIGNvbXBvbmVudENvbnRleHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdCghYy5fZm9yY2UgJiZcblx0XHRcdFx0XHRcdGMuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9IG51bGwgJiZcblx0XHRcdFx0XHRcdGMuc2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuXHRcdFx0XHRcdFx0XHRuZXdQcm9wcyxcblx0XHRcdFx0XHRcdFx0Yy5fbmV4dFN0YXRlLFxuXHRcdFx0XHRcdFx0XHRjb21wb25lbnRDb250ZXh0XG5cdFx0XHRcdFx0XHQpID09PSBmYWxzZSkgfHxcblx0XHRcdFx0XHRuZXdWTm9kZS5fb3JpZ2luYWwgPT09IG9sZFZOb2RlLl9vcmlnaW5hbFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRjLnByb3BzID0gbmV3UHJvcHM7XG5cdFx0XHRcdFx0Yy5zdGF0ZSA9IGMuX25leHRTdGF0ZTtcblx0XHRcdFx0XHQvLyBNb3JlIGluZm8gYWJvdXQgdGhpcyBoZXJlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9Kb3ZpRGVDcm9vY2svYmVjNWYyY2U5MzU0NGQyZTYwNzBlZjhlMDAzNmU0ZThcblx0XHRcdFx0XHRpZiAobmV3Vk5vZGUuX29yaWdpbmFsICE9PSBvbGRWTm9kZS5fb3JpZ2luYWwpIGMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHRcdFx0Yy5fdm5vZGUgPSBuZXdWTm9kZTtcblx0XHRcdFx0XHRuZXdWTm9kZS5fZG9tID0gb2xkVk5vZGUuX2RvbTtcblx0XHRcdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4gPSBvbGRWTm9kZS5fY2hpbGRyZW47XG5cdFx0XHRcdFx0aWYgKGMuX3JlbmRlckNhbGxiYWNrcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGNvbW1pdFF1ZXVlLnB1c2goYyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yICh0bXAgPSAwOyB0bXAgPCBuZXdWTm9kZS5fY2hpbGRyZW4ubGVuZ3RoOyB0bXArKykge1xuXHRcdFx0XHRcdFx0aWYgKG5ld1ZOb2RlLl9jaGlsZHJlblt0bXBdKSB7XG5cdFx0XHRcdFx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlblt0bXBdLl9wYXJlbnQgPSBuZXdWTm9kZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhayBvdXRlcjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjLmNvbXBvbmVudFdpbGxVcGRhdGUgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFVwZGF0ZShuZXdQcm9wcywgYy5fbmV4dFN0YXRlLCBjb21wb25lbnRDb250ZXh0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjLmNvbXBvbmVudERpZFVwZGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goKCkgPT4ge1xuXHRcdFx0XHRcdFx0Yy5jb21wb25lbnREaWRVcGRhdGUob2xkUHJvcHMsIG9sZFN0YXRlLCBzbmFwc2hvdCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Yy5jb250ZXh0ID0gY29tcG9uZW50Q29udGV4dDtcblx0XHRcdGMucHJvcHMgPSBuZXdQcm9wcztcblx0XHRcdGMuc3RhdGUgPSBjLl9uZXh0U3RhdGU7XG5cblx0XHRcdGlmICgodG1wID0gb3B0aW9ucy5fcmVuZGVyKSkgdG1wKG5ld1ZOb2RlKTtcblxuXHRcdFx0Yy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdGMuX3Zub2RlID0gbmV3Vk5vZGU7XG5cdFx0XHRjLl9wYXJlbnREb20gPSBwYXJlbnREb207XG5cblx0XHRcdHRtcCA9IGMucmVuZGVyKGMucHJvcHMsIGMuc3RhdGUsIGMuY29udGV4dCk7XG5cblx0XHRcdGlmIChjLmdldENoaWxkQ29udGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdGdsb2JhbENvbnRleHQgPSBhc3NpZ24oYXNzaWduKHt9LCBnbG9iYWxDb250ZXh0KSwgYy5nZXRDaGlsZENvbnRleHQoKSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghaXNOZXcgJiYgYy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdHNuYXBzaG90ID0gYy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShvbGRQcm9wcywgb2xkU3RhdGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgaXNUb3BMZXZlbEZyYWdtZW50ID1cblx0XHRcdFx0dG1wICE9IG51bGwgJiYgdG1wLnR5cGUgPT0gRnJhZ21lbnQgJiYgdG1wLmtleSA9PSBudWxsO1xuXHRcdFx0bGV0IHJlbmRlclJlc3VsdCA9IGlzVG9wTGV2ZWxGcmFnbWVudCA/IHRtcC5wcm9wcy5jaGlsZHJlbiA6IHRtcDtcblxuXHRcdFx0ZGlmZkNoaWxkcmVuKFxuXHRcdFx0XHRwYXJlbnREb20sXG5cdFx0XHRcdEFycmF5LmlzQXJyYXkocmVuZGVyUmVzdWx0KSA/IHJlbmRlclJlc3VsdCA6IFtyZW5kZXJSZXN1bHRdLFxuXHRcdFx0XHRuZXdWTm9kZSxcblx0XHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRcdGdsb2JhbENvbnRleHQsXG5cdFx0XHRcdGlzU3ZnLFxuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlbixcblx0XHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRcdG9sZERvbSxcblx0XHRcdFx0aXNIeWRyYXRpbmdcblx0XHRcdCk7XG5cblx0XHRcdGMuYmFzZSA9IG5ld1ZOb2RlLl9kb207XG5cblx0XHRcdGlmIChjLl9yZW5kZXJDYWxsYmFja3MubGVuZ3RoKSB7XG5cdFx0XHRcdGNvbW1pdFF1ZXVlLnB1c2goYyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjbGVhclByb2Nlc3NpbmdFeGNlcHRpb24pIHtcblx0XHRcdFx0Yy5fcGVuZGluZ0Vycm9yID0gYy5fcHJvY2Vzc2luZ0V4Y2VwdGlvbiA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGMuX2ZvcmNlID0gZmFsc2U7XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID09IG51bGwgJiZcblx0XHRcdG5ld1ZOb2RlLl9vcmlnaW5hbCA9PT0gb2xkVk5vZGUuX29yaWdpbmFsXG5cdFx0KSB7XG5cdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4gPSBvbGRWTm9kZS5fY2hpbGRyZW47XG5cdFx0XHRuZXdWTm9kZS5fZG9tID0gb2xkVk5vZGUuX2RvbTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV3Vk5vZGUuX2RvbSA9IGRpZmZFbGVtZW50Tm9kZXMoXG5cdFx0XHRcdG9sZFZOb2RlLl9kb20sXG5cdFx0XHRcdG5ld1ZOb2RlLFxuXHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdFx0aXNTdmcsXG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRcdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdFx0aXNIeWRyYXRpbmdcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKCh0bXAgPSBvcHRpb25zLmRpZmZlZCkpIHRtcChuZXdWTm9kZSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRuZXdWTm9kZS5fb3JpZ2luYWwgPSBudWxsO1xuXHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgbmV3Vk5vZGUsIG9sZFZOb2RlKTtcblx0fVxuXG5cdHJldHVybiBuZXdWTm9kZS5fZG9tO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSByb290XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21taXRSb290KGNvbW1pdFF1ZXVlLCByb290KSB7XG5cdGlmIChvcHRpb25zLl9jb21taXQpIG9wdGlvbnMuX2NvbW1pdChyb290LCBjb21taXRRdWV1ZSk7XG5cblx0Y29tbWl0UXVldWUuc29tZShjID0+IHtcblx0XHR0cnkge1xuXHRcdFx0Y29tbWl0UXVldWUgPSBjLl9yZW5kZXJDYWxsYmFja3M7XG5cdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MgPSBbXTtcblx0XHRcdGNvbW1pdFF1ZXVlLnNvbWUoY2IgPT4ge1xuXHRcdFx0XHRjYi5jYWxsKGMpO1xuXHRcdFx0fSk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBjLl92bm9kZSk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBEaWZmIHR3byB2aXJ0dWFsIG5vZGVzIHJlcHJlc2VudGluZyBET00gZWxlbWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gZG9tIFRoZSBET00gZWxlbWVudCByZXByZXNlbnRpbmdcbiAqIHRoZSB2aXJ0dWFsIG5vZGVzIGJlaW5nIGRpZmZlZFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG5ld1ZOb2RlIFRoZSBuZXcgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gb2xkVk5vZGUgVGhlIG9sZCB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBnbG9iYWxDb250ZXh0IFRoZSBjdXJyZW50IGNvbnRleHQgb2JqZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3ZnIFdoZXRoZXIgb3Igbm90IHRoaXMgRE9NIG5vZGUgaXMgYW4gU1ZHIG5vZGVcbiAqIEBwYXJhbSB7Kn0gZXhjZXNzRG9tQ2hpbGRyZW5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNIeWRyYXRpbmcgV2hldGhlciBvciBub3Qgd2UgYXJlIGluIGh5ZHJhdGlvblxuICogQHJldHVybnMge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fVxuICovXG5mdW5jdGlvbiBkaWZmRWxlbWVudE5vZGVzKFxuXHRkb20sXG5cdG5ld1ZOb2RlLFxuXHRvbGRWTm9kZSxcblx0Z2xvYmFsQ29udGV4dCxcblx0aXNTdmcsXG5cdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRjb21taXRRdWV1ZSxcblx0aXNIeWRyYXRpbmdcbikge1xuXHRsZXQgaTtcblx0bGV0IG9sZFByb3BzID0gb2xkVk5vZGUucHJvcHM7XG5cdGxldCBuZXdQcm9wcyA9IG5ld1ZOb2RlLnByb3BzO1xuXG5cdC8vIFRyYWNrcyBlbnRlcmluZyBhbmQgZXhpdGluZyBTVkcgbmFtZXNwYWNlIHdoZW4gZGVzY2VuZGluZyB0aHJvdWdoIHRoZSB0cmVlLlxuXHRpc1N2ZyA9IG5ld1ZOb2RlLnR5cGUgPT09ICdzdmcnIHx8IGlzU3ZnO1xuXG5cdGlmIChleGNlc3NEb21DaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGV4Y2Vzc0RvbUNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBjaGlsZCA9IGV4Y2Vzc0RvbUNoaWxkcmVuW2ldO1xuXG5cdFx0XHQvLyBpZiBuZXdWTm9kZSBtYXRjaGVzIGFuIGVsZW1lbnQgaW4gZXhjZXNzRG9tQ2hpbGRyZW4gb3IgdGhlIGBkb21gXG5cdFx0XHQvLyBhcmd1bWVudCBtYXRjaGVzIGFuIGVsZW1lbnQgaW4gZXhjZXNzRG9tQ2hpbGRyZW4sIHJlbW92ZSBpdCBmcm9tXG5cdFx0XHQvLyBleGNlc3NEb21DaGlsZHJlbiBzbyBpdCBpc24ndCBsYXRlciByZW1vdmVkIGluIGRpZmZDaGlsZHJlblxuXHRcdFx0aWYgKFxuXHRcdFx0XHRjaGlsZCAhPSBudWxsICYmXG5cdFx0XHRcdCgobmV3Vk5vZGUudHlwZSA9PT0gbnVsbFxuXHRcdFx0XHRcdD8gY2hpbGQubm9kZVR5cGUgPT09IDNcblx0XHRcdFx0XHQ6IGNoaWxkLmxvY2FsTmFtZSA9PT0gbmV3Vk5vZGUudHlwZSkgfHxcblx0XHRcdFx0XHRkb20gPT0gY2hpbGQpXG5cdFx0XHQpIHtcblx0XHRcdFx0ZG9tID0gY2hpbGQ7XG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuW2ldID0gbnVsbDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKGRvbSA9PSBudWxsKSB7XG5cdFx0aWYgKG5ld1ZOb2RlLnR5cGUgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShuZXdQcm9wcyk7XG5cdFx0fVxuXG5cdFx0ZG9tID0gaXNTdmdcblx0XHRcdD8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5ld1ZOb2RlLnR5cGUpXG5cdFx0XHQ6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXG5cdFx0XHRcdFx0bmV3Vk5vZGUudHlwZSxcblx0XHRcdFx0XHRuZXdQcm9wcy5pcyAmJiB7IGlzOiBuZXdQcm9wcy5pcyB9XG5cdFx0XHQgICk7XG5cdFx0Ly8gd2UgY3JlYXRlZCBhIG5ldyBwYXJlbnQsIHNvIG5vbmUgb2YgdGhlIHByZXZpb3VzbHkgYXR0YWNoZWQgY2hpbGRyZW4gY2FuIGJlIHJldXNlZDpcblx0XHRleGNlc3NEb21DaGlsZHJlbiA9IG51bGw7XG5cdFx0Ly8gd2UgYXJlIGNyZWF0aW5nIGEgbmV3IG5vZGUsIHNvIHdlIGNhbiBhc3N1bWUgdGhpcyBpcyBhIG5ldyBzdWJ0cmVlIChpbiBjYXNlIHdlIGFyZSBoeWRyYXRpbmcpLCB0aGlzIGRlb3B0cyB0aGUgaHlkcmF0ZVxuXHRcdGlzSHlkcmF0aW5nID0gZmFsc2U7XG5cdH1cblxuXHRpZiAobmV3Vk5vZGUudHlwZSA9PT0gbnVsbCkge1xuXHRcdGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgJiYgZG9tLmRhdGEgIT0gbmV3UHJvcHMpIHtcblx0XHRcdGRvbS5kYXRhID0gbmV3UHJvcHM7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGlmIChleGNlc3NEb21DaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRleGNlc3NEb21DaGlsZHJlbiA9IEVNUFRZX0FSUi5zbGljZS5jYWxsKGRvbS5jaGlsZE5vZGVzKTtcblx0XHR9XG5cblx0XHRvbGRQcm9wcyA9IG9sZFZOb2RlLnByb3BzIHx8IEVNUFRZX09CSjtcblxuXHRcdGxldCBvbGRIdG1sID0gb2xkUHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG5cdFx0bGV0IG5ld0h0bWwgPSBuZXdQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcblxuXHRcdC8vIER1cmluZyBoeWRyYXRpb24sIHByb3BzIGFyZSBub3QgZGlmZmVkIGF0IGFsbCAoaW5jbHVkaW5nIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKVxuXHRcdC8vIEBUT0RPIHdlIHNob3VsZCB3YXJuIGluIGRlYnVnIG1vZGUgd2hlbiBwcm9wcyBkb24ndCBtYXRjaCBoZXJlLlxuXHRcdGlmICghaXNIeWRyYXRpbmcpIHtcblx0XHRcdC8vIEJ1dCwgaWYgd2UgYXJlIGluIGEgc2l0dWF0aW9uIHdoZXJlIHdlIGFyZSB1c2luZyBleGlzdGluZyBET00gKGUuZy4gcmVwbGFjZU5vZGUpXG5cdFx0XHQvLyB3ZSBzaG91bGQgcmVhZCB0aGUgZXhpc3RpbmcgRE9NIGF0dHJpYnV0ZXMgdG8gZGlmZiB0aGVtXG5cdFx0XHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0XHRvbGRQcm9wcyA9IHt9O1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGRvbS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0b2xkUHJvcHNbZG9tLmF0dHJpYnV0ZXNbaV0ubmFtZV0gPSBkb20uYXR0cmlidXRlc1tpXS52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAobmV3SHRtbCB8fCBvbGRIdG1sKSB7XG5cdFx0XHRcdC8vIEF2b2lkIHJlLWFwcGx5aW5nIHRoZSBzYW1lICdfX2h0bWwnIGlmIGl0IGRpZCBub3QgY2hhbmdlZCBiZXR3ZWVuIHJlLXJlbmRlclxuXHRcdFx0XHRpZiAoIW5ld0h0bWwgfHwgIW9sZEh0bWwgfHwgbmV3SHRtbC5fX2h0bWwgIT0gb2xkSHRtbC5fX2h0bWwpIHtcblx0XHRcdFx0XHRkb20uaW5uZXJIVE1MID0gKG5ld0h0bWwgJiYgbmV3SHRtbC5fX2h0bWwpIHx8ICcnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZGlmZlByb3BzKGRvbSwgbmV3UHJvcHMsIG9sZFByb3BzLCBpc1N2ZywgaXNIeWRyYXRpbmcpO1xuXG5cdFx0Ly8gSWYgdGhlIG5ldyB2bm9kZSBkaWRuJ3QgaGF2ZSBkYW5nZXJvdXNseVNldElubmVySFRNTCwgZGlmZiBpdHMgY2hpbGRyZW5cblx0XHRpZiAobmV3SHRtbCkge1xuXHRcdFx0bmV3Vk5vZGUuX2NoaWxkcmVuID0gW107XG5cdFx0fSBlbHNlIHtcblx0XHRcdGkgPSBuZXdWTm9kZS5wcm9wcy5jaGlsZHJlbjtcblx0XHRcdGRpZmZDaGlsZHJlbihcblx0XHRcdFx0ZG9tLFxuXHRcdFx0XHRBcnJheS5pc0FycmF5KGkpID8gaSA6IFtpXSxcblx0XHRcdFx0bmV3Vk5vZGUsXG5cdFx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0XHRnbG9iYWxDb250ZXh0LFxuXHRcdFx0XHRuZXdWTm9kZS50eXBlID09PSAnZm9yZWlnbk9iamVjdCcgPyBmYWxzZSA6IGlzU3ZnLFxuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlbixcblx0XHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRcdEVNUFRZX09CSixcblx0XHRcdFx0aXNIeWRyYXRpbmdcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gKGFzIGFib3ZlLCBkb24ndCBkaWZmIHByb3BzIGR1cmluZyBoeWRyYXRpb24pXG5cdFx0aWYgKCFpc0h5ZHJhdGluZykge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHQndmFsdWUnIGluIG5ld1Byb3BzICYmXG5cdFx0XHRcdChpID0gbmV3UHJvcHMudmFsdWUpICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0aSAhPT0gZG9tLnZhbHVlXG5cdFx0XHQpIHtcblx0XHRcdFx0c2V0UHJvcGVydHkoZG9tLCAndmFsdWUnLCBpLCBvbGRQcm9wcy52YWx1ZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKFxuXHRcdFx0XHQnY2hlY2tlZCcgaW4gbmV3UHJvcHMgJiZcblx0XHRcdFx0KGkgPSBuZXdQcm9wcy5jaGVja2VkKSAhPT0gdW5kZWZpbmVkICYmXG5cdFx0XHRcdGkgIT09IGRvbS5jaGVja2VkXG5cdFx0XHQpIHtcblx0XHRcdFx0c2V0UHJvcGVydHkoZG9tLCAnY2hlY2tlZCcsIGksIG9sZFByb3BzLmNoZWNrZWQsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZG9tO1xufVxuXG4vKipcbiAqIEludm9rZSBvciB1cGRhdGUgYSByZWYsIGRlcGVuZGluZyBvbiB3aGV0aGVyIGl0IGlzIGEgZnVuY3Rpb24gb3Igb2JqZWN0IHJlZi5cbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSByZWZcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVJlZihyZWYsIHZhbHVlLCB2bm9kZSkge1xuXHR0cnkge1xuXHRcdGlmICh0eXBlb2YgcmVmID09ICdmdW5jdGlvbicpIHJlZih2YWx1ZSk7XG5cdFx0ZWxzZSByZWYuY3VycmVudCA9IHZhbHVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCB2bm9kZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBVbm1vdW50IGEgdmlydHVhbCBub2RlIGZyb20gdGhlIHRyZWUgYW5kIGFwcGx5IERPTSBjaGFuZ2VzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVGhlIHZpcnR1YWwgbm9kZSB0byB1bm1vdW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gcGFyZW50Vk5vZGUgVGhlIHBhcmVudCBvZiB0aGUgVk5vZGUgdGhhdFxuICogaW5pdGlhdGVkIHRoZSB1bm1vdW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwUmVtb3ZlXSBGbGFnIHRoYXQgaW5kaWNhdGVzIHRoYXQgYSBwYXJlbnQgbm9kZSBvZiB0aGVcbiAqIGN1cnJlbnQgZWxlbWVudCBpcyBhbHJlYWR5IGRldGFjaGVkIGZyb20gdGhlIERPTS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVubW91bnQodm5vZGUsIHBhcmVudFZOb2RlLCBza2lwUmVtb3ZlKSB7XG5cdGxldCByO1xuXHRpZiAob3B0aW9ucy51bm1vdW50KSBvcHRpb25zLnVubW91bnQodm5vZGUpO1xuXG5cdGlmICgociA9IHZub2RlLnJlZikpIHtcblx0XHRpZiAoIXIuY3VycmVudCB8fCByLmN1cnJlbnQgPT09IHZub2RlLl9kb20pIGFwcGx5UmVmKHIsIG51bGwsIHBhcmVudFZOb2RlKTtcblx0fVxuXG5cdGxldCBkb207XG5cdGlmICghc2tpcFJlbW92ZSAmJiB0eXBlb2Ygdm5vZGUudHlwZSAhPSAnZnVuY3Rpb24nKSB7XG5cdFx0c2tpcFJlbW92ZSA9IChkb20gPSB2bm9kZS5fZG9tKSAhPSBudWxsO1xuXHR9XG5cblx0Ly8gTXVzdCBiZSBzZXQgdG8gYHVuZGVmaW5lZGAgdG8gcHJvcGVybHkgY2xlYW4gdXAgYF9uZXh0RG9tYFxuXHQvLyBmb3Igd2hpY2ggYG51bGxgIGlzIGEgdmFsaWQgdmFsdWUuIFNlZSBjb21tZW50IGluIGBjcmVhdGUtZWxlbWVudC5qc2Bcblx0dm5vZGUuX2RvbSA9IHZub2RlLl9uZXh0RG9tID0gdW5kZWZpbmVkO1xuXG5cdGlmICgociA9IHZub2RlLl9jb21wb25lbnQpICE9IG51bGwpIHtcblx0XHRpZiAoci5jb21wb25lbnRXaWxsVW5tb3VudCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ci5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIHBhcmVudFZOb2RlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyLmJhc2UgPSByLl9wYXJlbnREb20gPSBudWxsO1xuXHR9XG5cblx0aWYgKChyID0gdm5vZGUuX2NoaWxkcmVuKSkge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgci5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHJbaV0pIHVubW91bnQocltpXSwgcGFyZW50Vk5vZGUsIHNraXBSZW1vdmUpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChkb20gIT0gbnVsbCkgcmVtb3ZlTm9kZShkb20pO1xufVxuXG4vKiogVGhlIGAucmVuZGVyKClgIG1ldGhvZCBmb3IgYSBQRkMgYmFja2luZyBpbnN0YW5jZS4gKi9cbmZ1bmN0aW9uIGRvUmVuZGVyKHByb3BzLCBzdGF0ZSwgY29udGV4dCkge1xuXHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCk7XG59XG4iLCJpbXBvcnQgeyBFTVBUWV9PQkosIEVNUFRZX0FSUiB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IGNvbW1pdFJvb3QsIGRpZmYgfSBmcm9tICcuL2RpZmYvaW5kZXgnO1xuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQgfSBmcm9tICcuL2NyZWF0ZS1lbGVtZW50JztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4vb3B0aW9ucyc7XG5cbmNvbnN0IElTX0hZRFJBVEUgPSBFTVBUWV9PQko7XG5cbi8qKlxuICogUmVuZGVyIGEgUHJlYWN0IHZpcnR1YWwgbm9kZSBpbnRvIGEgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuQ29tcG9uZW50Q2hpbGR9IHZub2RlIFRoZSB2aXJ0dWFsIG5vZGUgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudERvbSBUaGUgRE9NIGVsZW1lbnQgdG9cbiAqIHJlbmRlciBpbnRvXG4gKiBAcGFyYW0ge0VsZW1lbnQgfCBUZXh0fSBbcmVwbGFjZU5vZGVdIE9wdGlvbmFsOiBBdHRlbXB0IHRvIHJlLXVzZSBhblxuICogZXhpc3RpbmcgRE9NIHRyZWUgcm9vdGVkIGF0IGByZXBsYWNlTm9kZWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcih2bm9kZSwgcGFyZW50RG9tLCByZXBsYWNlTm9kZSkge1xuXHRpZiAob3B0aW9ucy5fcm9vdCkgb3B0aW9ucy5fcm9vdCh2bm9kZSwgcGFyZW50RG9tKTtcblxuXHQvLyBXZSBhYnVzZSB0aGUgYHJlcGxhY2VOb2RlYCBwYXJhbWV0ZXIgaW4gYGh5ZHJhdGUoKWAgdG8gc2lnbmFsIGlmIHdlXG5cdC8vIGFyZSBpbiBoeWRyYXRpb24gbW9kZSBvciBub3QgYnkgcGFzc2luZyBgSVNfSFlEUkFURWAgaW5zdGVhZCBvZiBhXG5cdC8vIERPTSBlbGVtZW50LlxuXHRsZXQgaXNIeWRyYXRpbmcgPSByZXBsYWNlTm9kZSA9PT0gSVNfSFlEUkFURTtcblxuXHQvLyBUbyBiZSBhYmxlIHRvIHN1cHBvcnQgY2FsbGluZyBgcmVuZGVyKClgIG11bHRpcGxlIHRpbWVzIG9uIHRoZSBzYW1lXG5cdC8vIERPTSBub2RlLCB3ZSBuZWVkIHRvIG9idGFpbiBhIHJlZmVyZW5jZSB0byB0aGUgcHJldmlvdXMgdHJlZS4gV2UgZG9cblx0Ly8gdGhpcyBieSBhc3NpZ25pbmcgYSBuZXcgYF9jaGlsZHJlbmAgcHJvcGVydHkgdG8gRE9NIG5vZGVzIHdoaWNoIHBvaW50c1xuXHQvLyB0byB0aGUgbGFzdCByZW5kZXJlZCB0cmVlLiBCeSBkZWZhdWx0IHRoaXMgcHJvcGVydHkgaXMgbm90IHByZXNlbnQsIHdoaWNoXG5cdC8vIG1lYW5zIHRoYXQgd2UgYXJlIG1vdW50aW5nIGEgbmV3IHRyZWUgZm9yIHRoZSBmaXJzdCB0aW1lLlxuXHRsZXQgb2xkVk5vZGUgPSBpc0h5ZHJhdGluZ1xuXHRcdD8gbnVsbFxuXHRcdDogKHJlcGxhY2VOb2RlICYmIHJlcGxhY2VOb2RlLl9jaGlsZHJlbikgfHwgcGFyZW50RG9tLl9jaGlsZHJlbjtcblx0dm5vZGUgPSBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBbdm5vZGVdKTtcblxuXHQvLyBMaXN0IG9mIGVmZmVjdHMgdGhhdCBuZWVkIHRvIGJlIGNhbGxlZCBhZnRlciBkaWZmaW5nLlxuXHRsZXQgY29tbWl0UXVldWUgPSBbXTtcblx0ZGlmZihcblx0XHRwYXJlbnREb20sXG5cdFx0Ly8gRGV0ZXJtaW5lIHRoZSBuZXcgdm5vZGUgdHJlZSBhbmQgc3RvcmUgaXQgb24gdGhlIERPTSBlbGVtZW50IG9uXG5cdFx0Ly8gb3VyIGN1c3RvbSBgX2NoaWxkcmVuYCBwcm9wZXJ0eS5cblx0XHQoKGlzSHlkcmF0aW5nID8gcGFyZW50RG9tIDogcmVwbGFjZU5vZGUgfHwgcGFyZW50RG9tKS5fY2hpbGRyZW4gPSB2bm9kZSksXG5cdFx0b2xkVk5vZGUgfHwgRU1QVFlfT0JKLFxuXHRcdEVNUFRZX09CSixcblx0XHRwYXJlbnREb20ub3duZXJTVkdFbGVtZW50ICE9PSB1bmRlZmluZWQsXG5cdFx0cmVwbGFjZU5vZGUgJiYgIWlzSHlkcmF0aW5nXG5cdFx0XHQ/IFtyZXBsYWNlTm9kZV1cblx0XHRcdDogb2xkVk5vZGVcblx0XHRcdD8gbnVsbFxuXHRcdFx0OiBwYXJlbnREb20uY2hpbGROb2Rlcy5sZW5ndGhcblx0XHRcdD8gRU1QVFlfQVJSLnNsaWNlLmNhbGwocGFyZW50RG9tLmNoaWxkTm9kZXMpXG5cdFx0XHQ6IG51bGwsXG5cdFx0Y29tbWl0UXVldWUsXG5cdFx0cmVwbGFjZU5vZGUgfHwgRU1QVFlfT0JKLFxuXHRcdGlzSHlkcmF0aW5nXG5cdCk7XG5cblx0Ly8gRmx1c2ggYWxsIHF1ZXVlZCBlZmZlY3RzXG5cdGNvbW1pdFJvb3QoY29tbWl0UXVldWUsIHZub2RlKTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgYW4gZXhpc3RpbmcgRE9NIGVsZW1lbnQgd2l0aCBkYXRhIGZyb20gYSBQcmVhY3QgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbmRleCcpLkNvbXBvbmVudENoaWxkfSB2bm9kZSBUaGUgdmlydHVhbCBub2RlIHRvIHJlbmRlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnREb20gVGhlIERPTSBlbGVtZW50IHRvXG4gKiB1cGRhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGUodm5vZGUsIHBhcmVudERvbSkge1xuXHRyZW5kZXIodm5vZGUsIHBhcmVudERvbSwgSVNfSFlEUkFURSk7XG59XG4iLCJpbXBvcnQgeyBhc3NpZ24gfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgRU1QVFlfQVJSIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgY3JlYXRlVk5vZGUgfSBmcm9tICcuL2NyZWF0ZS1lbGVtZW50JztcblxuLyoqXG4gKiBDbG9uZXMgdGhlIGdpdmVuIFZOb2RlLCBvcHRpb25hbGx5IGFkZGluZyBhdHRyaWJ1dGVzL3Byb3BzIGFuZCByZXBsYWNpbmcgaXRzIGNoaWxkcmVuLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVGhlIHZpcnR1YWwgRE9NIGVsZW1lbnQgdG8gY2xvbmVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBBdHRyaWJ1dGVzL3Byb3BzIHRvIGFkZCB3aGVuIGNsb25pbmdcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuL2luZGV4JykuQ29tcG9uZW50Q2hpbGRyZW4+fSByZXN0IEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyB3aWxsIGJlIHVzZWQgYXMgcmVwbGFjZW1lbnQgY2hpbGRyZW4uXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZUVsZW1lbnQodm5vZGUsIHByb3BzKSB7XG5cdHByb3BzID0gYXNzaWduKGFzc2lnbih7fSwgdm5vZGUucHJvcHMpLCBwcm9wcyk7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikgcHJvcHMuY2hpbGRyZW4gPSBFTVBUWV9BUlIuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuXHRsZXQgbm9ybWFsaXplZFByb3BzID0ge307XG5cdGZvciAoY29uc3QgaSBpbiBwcm9wcykge1xuXHRcdGlmIChpICE9PSAna2V5JyAmJiBpICE9PSAncmVmJykgbm9ybWFsaXplZFByb3BzW2ldID0gcHJvcHNbaV07XG5cdH1cblxuXHRyZXR1cm4gY3JlYXRlVk5vZGUoXG5cdFx0dm5vZGUudHlwZSxcblx0XHRub3JtYWxpemVkUHJvcHMsXG5cdFx0cHJvcHMua2V5IHx8IHZub2RlLmtleSxcblx0XHRwcm9wcy5yZWYgfHwgdm5vZGUucmVmLFxuXHRcdG51bGxcblx0KTtcbn1cbiIsImltcG9ydCB7IGVucXVldWVSZW5kZXIgfSBmcm9tICcuL2NvbXBvbmVudCc7XG5cbmV4cG9ydCBsZXQgaSA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSkge1xuXHRjb25zdCBjdHggPSB7fTtcblxuXHRjb25zdCBjb250ZXh0ID0ge1xuXHRcdF9pZDogJ19fY0MnICsgaSsrLFxuXHRcdF9kZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZSxcblx0XHRDb25zdW1lcihwcm9wcywgY29udGV4dCkge1xuXHRcdFx0cmV0dXJuIHByb3BzLmNoaWxkcmVuKGNvbnRleHQpO1xuXHRcdH0sXG5cdFx0UHJvdmlkZXIocHJvcHMpIHtcblx0XHRcdGlmICghdGhpcy5nZXRDaGlsZENvbnRleHQpIHtcblx0XHRcdFx0Y29uc3Qgc3VicyA9IFtdO1xuXHRcdFx0XHR0aGlzLmdldENoaWxkQ29udGV4dCA9ICgpID0+IHtcblx0XHRcdFx0XHRjdHhbY29udGV4dC5faWRdID0gdGhpcztcblx0XHRcdFx0XHRyZXR1cm4gY3R4O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHRoaXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gX3Byb3BzID0+IHtcblx0XHRcdFx0XHRpZiAodGhpcy5wcm9wcy52YWx1ZSAhPT0gX3Byb3BzLnZhbHVlKSB7XG5cdFx0XHRcdFx0XHRzdWJzLnNvbWUoYyA9PiB7XG5cdFx0XHRcdFx0XHRcdGMuY29udGV4dCA9IF9wcm9wcy52YWx1ZTtcblx0XHRcdFx0XHRcdFx0ZW5xdWV1ZVJlbmRlcihjKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHR0aGlzLnN1YiA9IGMgPT4ge1xuXHRcdFx0XHRcdHN1YnMucHVzaChjKTtcblx0XHRcdFx0XHRsZXQgb2xkID0gYy5jb21wb25lbnRXaWxsVW5tb3VudDtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gKCkgPT4ge1xuXHRcdFx0XHRcdFx0c3Vicy5zcGxpY2Uoc3Vicy5pbmRleE9mKGMpLCAxKTtcblx0XHRcdFx0XHRcdG9sZCAmJiBvbGQuY2FsbChjKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcHJvcHMuY2hpbGRyZW47XG5cdFx0fVxuXHR9O1xuXG5cdGNvbnRleHQuQ29uc3VtZXIuY29udGV4dFR5cGUgPSBjb250ZXh0O1xuXG5cdC8vIERldnRvb2xzIG5lZWRzIGFjY2VzcyB0byB0aGUgY29udGV4dCBvYmplY3Qgd2hlbiBpdFxuXHQvLyBlbmNvdW50ZXJzIGEgUHJvdmlkZXIuIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIHN1cHBvcnRcblx0Ly8gc2V0dGluZyBgZGlzcGxheU5hbWVgIG9uIHRoZSBjb250ZXh0IG9iamVjdCBpbnN0ZWFkXG5cdC8vIG9mIG9uIHRoZSBjb21wb25lbnQgaXRzZWxmLiBTZWU6XG5cdC8vIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9jb250ZXh0Lmh0bWwjY29udGV4dGRpc3BsYXluYW1lXG5cdGNvbnRleHQuUHJvdmlkZXIuX2NvbnRleHRSZWYgPSBjb250ZXh0O1xuXG5cdHJldHVybiBjb250ZXh0O1xufVxuIiwiaW1wb3J0IHsgX2NhdGNoRXJyb3IgfSBmcm9tICcuL2RpZmYvY2F0Y2gtZXJyb3InO1xuXG4vKipcbiAqIFRoZSBgb3B0aW9uYCBvYmplY3QgY2FuIHBvdGVudGlhbGx5IGNvbnRhaW4gY2FsbGJhY2sgZnVuY3Rpb25zXG4gKiB0aGF0IGFyZSBjYWxsZWQgZHVyaW5nIHZhcmlvdXMgc3RhZ2VzIG9mIG91ciByZW5kZXJlci4gVGhpcyBpcyB0aGVcbiAqIGZvdW5kYXRpb24gb24gd2hpY2ggYWxsIG91ciBhZGRvbnMgbGlrZSBgcHJlYWN0L2RlYnVnYCwgYHByZWFjdC9jb21wYXRgLFxuICogYW5kIGBwcmVhY3QvaG9va3NgIGFyZSBiYXNlZCBvbi4gU2VlIHRoZSBgT3B0aW9uc2AgdHlwZSBpbiBgaW50ZXJuYWwuZC50c2BcbiAqIGZvciBhIGZ1bGwgbGlzdCBvZiBhdmFpbGFibGUgb3B0aW9uIGhvb2tzIChtb3N0IGVkaXRvcnMvSURFcyBhbGxvdyB5b3UgdG9cbiAqIGN0cmwrY2xpY2sgb3IgY21kK2NsaWNrIG9uIG1hYyB0aGUgdHlwZSBkZWZpbml0aW9uIGJlbG93KS5cbiAqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5PcHRpb25zfVxuICovXG5jb25zdCBvcHRpb25zID0ge1xuXHRfY2F0Y2hFcnJvclxufTtcblxuZXhwb3J0IGRlZmF1bHQgb3B0aW9ucztcbiIsImltcG9ydCB7IGVucXVldWVSZW5kZXIgfSBmcm9tICcuLi9jb21wb25lbnQnO1xuXG4vKipcbiAqIEZpbmQgdGhlIGNsb3Nlc3QgZXJyb3IgYm91bmRhcnkgdG8gYSB0aHJvd24gZXJyb3IgYW5kIGNhbGwgaXRcbiAqIEBwYXJhbSB7b2JqZWN0fSBlcnJvciBUaGUgdGhyb3duIHZhbHVlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVGhlIHZub2RlIHRoYXQgdGhyZXdcbiAqIHRoZSBlcnJvciB0aGF0IHdhcyBjYXVnaHQgKGV4Y2VwdCBmb3IgdW5tb3VudGluZyB3aGVuIHRoaXMgcGFyYW1ldGVyXG4gKiBpcyB0aGUgaGlnaGVzdCBwYXJlbnQgdGhhdCB3YXMgYmVpbmcgdW5tb3VudGVkKVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NhdGNoRXJyb3IoZXJyb3IsIHZub2RlKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cblx0bGV0IGNvbXBvbmVudCwgaGFzQ2F1Z2h0O1xuXG5cdGZvciAoOyAodm5vZGUgPSB2bm9kZS5fcGFyZW50KTsgKSB7XG5cdFx0aWYgKChjb21wb25lbnQgPSB2bm9kZS5fY29tcG9uZW50KSAmJiAhY29tcG9uZW50Ll9wcm9jZXNzaW5nRXhjZXB0aW9uKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0Y29tcG9uZW50LmNvbnN0cnVjdG9yICYmXG5cdFx0XHRcdFx0Y29tcG9uZW50LmNvbnN0cnVjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAhPSBudWxsXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGhhc0NhdWdodCA9IHRydWU7XG5cdFx0XHRcdFx0Y29tcG9uZW50LnNldFN0YXRlKFxuXHRcdFx0XHRcdFx0Y29tcG9uZW50LmNvbnN0cnVjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcilcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGNvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0aGFzQ2F1Z2h0ID0gdHJ1ZTtcblx0XHRcdFx0XHRjb21wb25lbnQuY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGhhc0NhdWdodClcblx0XHRcdFx0XHRyZXR1cm4gZW5xdWV1ZVJlbmRlcigoY29tcG9uZW50Ll9wZW5kaW5nRXJyb3IgPSBjb21wb25lbnQpKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0ZXJyb3IgPSBlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHRocm93IGVycm9yO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FDTUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBVUE7QUFDQTtBQURBO0FBQUE7QUFFQTtBQ1ZBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFHQTtBQUhBO0FBQ0E7QUFFQTtBQU9BO0FBSkE7QUFJQTtBQVVBO0FBREE7QUFHQTtBQTBCQTtBQUNBO0FBREE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQWhCQTtBQWdCQTtBQVNBO0FBQ0E7QUFEQTtBQUFBO0FBSUE7QUFDQTtBQURBO0FBQUE7QUMvRUE7QUFDQTtBQURBO0FBQUE7QUF1RUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUlBO0FBSUE7QUFKQTtBQUNBO0FBVUE7QUErQ0E7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUdBO0FBSEE7QUFFQTtBQUdBO0FBQUE7QUFBQTtBQUxBO0FBQ0E7QUFJQTtBQUtBO0FBcUNBO0FBQ0E7QUFEQTtBQUFBO0FBY0E7QUFDQTtBQURBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFoR0E7QUFxR0E7QUE5RUE7QUFzRUE7QUN0TEE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBaUJBO0FBaUJBO0FBb0JBO0FBQUE7QUFjQTtBQTRCQTtBQVNBO0FBQUE7QUFHQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUEwQkE7QUEwQkE7QUFHQTtBQUtBO0FBTEE7QUFDQTtBQVVBO0FBY0E7QUFDQTtBQURBO0FBU0E7QUFBQTtBQWNBO0FBU0E7QUEzTUE7QUFDQTtBQTBNQTtBQVNBO0FBRkE7QUFDQTtBQUNBO0FBTUE7QUFOQTtBQUNBO0FBS0E7QUFNQTtBQUZBO0FBYUE7QUFDQTtBQURBO0FBQUE7QUMzUUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUFBO0FBR0E7QUFIQTtBQUNBO0FBR0E7QUFNQTtBQU5BO0FBa0JBO0FBQ0E7QUFEQTtBQUNBO0FBc0JBO0FBQ0E7QUFEQTtBQUFBO0FBK0JBO0FBcEJBO0FBS0E7QUFRQTtBQUZBO0FBR0E7QUFPQTtBQUZBO0FBR0E7QUFGQTtBQXFFQTtBQUNBO0FBREE7QUFBQTtBQ3RJQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVdBO0FBSUE7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQW1FQTtBQWtCQTtBQWFBO0FBYkE7QUFDQTtBQWFBO0FBT0E7QUFDQTtBQURBO0FBTUE7QUFBQTtBQUtBO0FBQUE7QUErQ0E7QUFDQTtBQWVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQVdBO0FBQ0E7QUFEQTtBQUNBO0FBRUE7QUFFQTtBQUdBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQW1CQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVlBO0FBTUE7QUFhQTtBQUNBO0FBQUE7QUFmQTtBQUNBO0FBY0E7QUFNQTtBQUtBO0FBSUE7QUFBQTtBQUtBO0FBQ0E7QUFEQTtBQU9BO0FBWUE7QUFNQTtBQUhBO0FBR0E7QUFZQTtBQUNBO0FBREE7QUFtQ0E7QUFBQTtBQWNBO0FBQ0E7QUFEQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFZQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBNkJBO0FBYkE7QUFHQTtBQUNBO0FBQ0E7QUFJQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBS0E7QUFGQTtBQU1BO0FBSUE7QUFDQTtBQURBO0FBQUE7QUNwY0E7QUFDQTtBQURBO0FBQUE7QUFDQTtBQWlEQTtBQUNBO0FBREE7QUFDQTtBQ3ZEQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQ1pBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBSUE7QUFFQTtBQUNBO0FBQUE7QUFNQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUtBO0FBakNBO0FBaUNBO0FDN0JBO0FBQ0E7QUFEQTtBQUNBO0FDSEE7QUFJQTtBQUNBO0FBbUJBO0FBQ0E7QUFBQTtBQXpCQTtBQUNBO0FBd0JBO0FBS0E7QUQ1QkE7QVJ5RkE7QUFDQTtBQzVFQTtBQUlBO0FBa0JBO0FBVUE7QUFNQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/preact/dist/preact.module.js\n");

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __createBinding, __exportStar, __values, __read, __spread, __spreadArrays, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__extends\", function() { return __extends; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__assign\", function() { return _assign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__rest\", function() { return __rest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__decorate\", function() { return __decorate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__param\", function() { return __param; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__metadata\", function() { return __metadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__awaiter\", function() { return __awaiter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__generator\", function() { return __generator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__createBinding\", function() { return __createBinding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__exportStar\", function() { return __exportStar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__values\", function() { return __values; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__read\", function() { return __read; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__spread\", function() { return __spread; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__spreadArrays\", function() { return __spreadArrays; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__await\", function() { return __await; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__asyncGenerator\", function() { return __asyncGenerator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__asyncDelegator\", function() { return __asyncDelegator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__asyncValues\", function() { return __asyncValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__makeTemplateObject\", function() { return __makeTemplateObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__importStar\", function() { return __importStar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__importDefault\", function() { return __importDefault; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__classPrivateFieldGet\", function() { return __classPrivateFieldGet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__classPrivateFieldSet\", function() { return __classPrivateFieldSet; });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return _extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  _extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return _assign.apply(this, arguments);\n};\n\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\nfunction __param(paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n}\nfunction __metadata(metadataKey, metadataValue) {\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\nfunction __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\nvar __createBinding = Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n};\nfunction __exportStar(m, exports) {\n  for (var p in m) {\n    if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n  }\n}\nfunction __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) {\n    ar = ar.concat(__read(arguments[i]));\n  }\n\n  return ar;\n}\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n}\n;\nfunction __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []),\n      i,\n      q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i;\n\n  function verb(n) {\n    if (g[n]) i[n] = function (v) {\n      return new Promise(function (a, b) {\n        q.push([n, v, a, b]) > 1 || resume(n, v);\n      });\n    };\n  }\n\n  function resume(n, v) {\n    try {\n      step(g[n](v));\n    } catch (e) {\n      settle(q[0][3], e);\n    }\n  }\n\n  function step(r) {\n    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n  }\n\n  function fulfill(value) {\n    resume(\"next\", value);\n  }\n\n  function reject(value) {\n    resume(\"throw\", value);\n  }\n\n  function settle(f, v) {\n    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n  }\n}\nfunction __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) {\n    throw e;\n  }), verb(\"return\"), i[Symbol.iterator] = function () {\n    return this;\n  }, i;\n\n  function verb(n, f) {\n    i[n] = o[n] ? function (v) {\n      return (p = !p) ? {\n        value: __await(o[n](v)),\n        done: n === \"return\"\n      } : f ? f(v) : v;\n    } : f;\n  }\n}\nfunction __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n      i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n}\nfunction __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) {\n    Object.defineProperty(cooked, \"raw\", {\n      value: raw\n    });\n  } else {\n    cooked.raw = raw;\n  }\n\n  return cooked;\n}\n;\n\nvar __setModuleDefault = Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n};\n\nfunction __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n}\nfunction __importDefault(mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n}\nfunction __classPrivateFieldGet(receiver, privateMap) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n\n  return privateMap.get(receiver);\n}\nfunction __classPrivateFieldSet(receiver, privateMap, value) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to set private field on non-instance\");\n  }\n\n  privateMap.set(receiver, value);\n  return value;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcz85YWI0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcclxuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcclxuICAgIHJldHVybiByO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwKSB7XHJcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHByaXZhdGVNYXAsIHZhbHVlKSB7XHJcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xyXG4gICAgfVxyXG4gICAgcHJpdmF0ZU1hcC5zZXQocmVjZWl2ZXIsIHZhbHVlKTtcclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7OztBQWNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQVhBO0FBQ0E7QUFZQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWpCQTtBQUNBO0FBaUJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tslib/tslib.es6.js\n");

/***/ })

}]);