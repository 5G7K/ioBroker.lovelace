(self["webpackJsonp"] = self["webpackJsonp"] || []).push([["vendors~hui-dialog-suggest-card~panel-lovelace"],{

/***/ "./node_modules/@polymer/paper-spinner/paper-spinner.js":
/*!**************************************************************!*\
  !*** ./node_modules/@polymer/paper-spinner/paper-spinner.js ***!
  \**************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _polymer_polymer_polymer_legacy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/polymer-legacy.js */ \"./node_modules/@polymer/polymer/polymer-legacy.js\");\n/* harmony import */ var _polymer_paper_styles_color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @polymer/paper-styles/color.js */ \"./node_modules/@polymer/paper-styles/color.js\");\n/* harmony import */ var _paper_spinner_styles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./paper-spinner-styles.js */ \"./node_modules/@polymer/paper-spinner/paper-spinner-styles.js\");\n/* harmony import */ var _polymer_polymer_lib_legacy_polymer_fn_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @polymer/polymer/lib/legacy/polymer-fn.js */ \"./node_modules/@polymer/polymer/lib/legacy/polymer-fn.js\");\n/* harmony import */ var _polymer_polymer_lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @polymer/polymer/lib/utils/html-tag.js */ \"./node_modules/@polymer/polymer/lib/utils/html-tag.js\");\n/* harmony import */ var _paper_spinner_behavior_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./paper-spinner-behavior.js */ \"./node_modules/@polymer/paper-spinner/paper-spinner-behavior.js\");\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n  <style include=\\\"paper-spinner-styles\\\"></style>\\n\\n  <div id=\\\"spinnerContainer\\\" class-name=\\\"[[__computeContainerClasses(active, __coolingDown)]]\\\" on-animationend=\\\"__reset\\\" on-webkit-animation-end=\\\"__reset\\\">\\n    <div class=\\\"spinner-layer layer-1\\\">\\n      <div class=\\\"circle-clipper left\\\">\\n        <div class=\\\"circle\\\"></div>\\n      </div>\\n      <div class=\\\"circle-clipper right\\\">\\n        <div class=\\\"circle\\\"></div>\\n      </div>\\n    </div>\\n\\n    <div class=\\\"spinner-layer layer-2\\\">\\n      <div class=\\\"circle-clipper left\\\">\\n        <div class=\\\"circle\\\"></div>\\n      </div>\\n      <div class=\\\"circle-clipper right\\\">\\n        <div class=\\\"circle\\\"></div>\\n      </div>\\n    </div>\\n\\n    <div class=\\\"spinner-layer layer-3\\\">\\n      <div class=\\\"circle-clipper left\\\">\\n        <div class=\\\"circle\\\"></div>\\n      </div>\\n      <div class=\\\"circle-clipper right\\\">\\n        <div class=\\\"circle\\\"></div>\\n      </div>\\n    </div>\\n\\n    <div class=\\\"spinner-layer layer-4\\\">\\n      <div class=\\\"circle-clipper left\\\">\\n        <div class=\\\"circle\\\"></div>\\n      </div>\\n      <div class=\\\"circle-clipper right\\\">\\n        <div class=\\\"circle\\\"></div>\\n      </div>\\n    </div>\\n  </div>\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n\nvar template = Object(_polymer_polymer_lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_4__[\"html\"])(_templateObject());\ntemplate.setAttribute('strip-whitespace', '');\n/**\nMaterial design: [Progress &\nactivity](https://www.google.com/design/spec/components/progress-activity.html)\n\nElement providing a multiple color material design circular spinner.\n\n    <paper-spinner active></paper-spinner>\n\nThe default spinner cycles between four layers of colors; by default they are\nblue, red, yellow and green. It can be customized to cycle between four\ndifferent colors. Use <paper-spinner-lite> for single color spinners.\n\n### Accessibility\n\nAlt attribute should be set to provide adequate context for accessibility. If\nnot provided, it defaults to 'loading'. Empty alt can be provided to mark the\nelement as decorative if alternative content is provided in another form (e.g. a\ntext block following the spinner).\n\n    <paper-spinner alt=\"Loading contacts list\" active></paper-spinner>\n\n### Styling\n\nThe following custom properties and mixins are available for styling:\n\nCustom property | Description | Default\n----------------|-------------|----------\n`--paper-spinner-layer-1-color` | Color of the first spinner rotation | `--google-blue-500`\n`--paper-spinner-layer-2-color` | Color of the second spinner rotation | `--google-red-500`\n`--paper-spinner-layer-3-color` | Color of the third spinner rotation | `--google-yellow-500`\n`--paper-spinner-layer-4-color` | Color of the fourth spinner rotation | `--google-green-500`\n`--paper-spinner-stroke-width` | The width of the spinner stroke | 3px\n\n@group Paper Elements\n@element paper-spinner\n@hero hero.svg\n@demo demo/index.html\n*/\n\nObject(_polymer_polymer_lib_legacy_polymer_fn_js__WEBPACK_IMPORTED_MODULE_3__[\"Polymer\"])({\n  _template: template,\n  is: 'paper-spinner',\n  behaviors: [_paper_spinner_behavior_js__WEBPACK_IMPORTED_MODULE_5__[\"PaperSpinnerBehavior\"]]\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItc3Bpbm5lci9wYXBlci1zcGlubmVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLXNwaW5uZXIvcGFwZXItc3Bpbm5lci5qcz85NTEyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbmh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dCBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG5odHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHQgVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlXG5mb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dCBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhc1xucGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc28gc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudFxuZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuaW1wb3J0ICdAcG9seW1lci9wb2x5bWVyL3BvbHltZXItbGVnYWN5LmpzJztcbmltcG9ydCAnQHBvbHltZXIvcGFwZXItc3R5bGVzL2NvbG9yLmpzJztcbmltcG9ydCAnLi9wYXBlci1zcGlubmVyLXN0eWxlcy5qcyc7XG5cbmltcG9ydCB7UG9seW1lcn0gZnJvbSAnQHBvbHltZXIvcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXItZm4uanMnO1xuaW1wb3J0IHtodG1sfSBmcm9tICdAcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9odG1sLXRhZy5qcyc7XG5cbmltcG9ydCB7UGFwZXJTcGlubmVyQmVoYXZpb3J9IGZyb20gJy4vcGFwZXItc3Bpbm5lci1iZWhhdmlvci5qcyc7XG5cbmNvbnN0IHRlbXBsYXRlID0gaHRtbGBcbiAgPHN0eWxlIGluY2x1ZGU9XCJwYXBlci1zcGlubmVyLXN0eWxlc1wiPjwvc3R5bGU+XG5cbiAgPGRpdiBpZD1cInNwaW5uZXJDb250YWluZXJcIiBjbGFzcy1uYW1lPVwiW1tfX2NvbXB1dGVDb250YWluZXJDbGFzc2VzKGFjdGl2ZSwgX19jb29saW5nRG93bildXVwiIG9uLWFuaW1hdGlvbmVuZD1cIl9fcmVzZXRcIiBvbi13ZWJraXQtYW5pbWF0aW9uLWVuZD1cIl9fcmVzZXRcIj5cbiAgICA8ZGl2IGNsYXNzPVwic3Bpbm5lci1sYXllciBsYXllci0xXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiY2lyY2xlLWNsaXBwZXIgbGVmdFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2lyY2xlXCI+PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJjaXJjbGUtY2xpcHBlciByaWdodFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2lyY2xlXCI+PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJzcGlubmVyLWxheWVyIGxheWVyLTJcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJjaXJjbGUtY2xpcHBlciBsZWZ0XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjaXJjbGVcIj48L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cImNpcmNsZS1jbGlwcGVyIHJpZ2h0XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjaXJjbGVcIj48L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cInNwaW5uZXItbGF5ZXIgbGF5ZXItM1wiPlxuICAgICAgPGRpdiBjbGFzcz1cImNpcmNsZS1jbGlwcGVyIGxlZnRcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNpcmNsZVwiPjwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwiY2lyY2xlLWNsaXBwZXIgcmlnaHRcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNpcmNsZVwiPjwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwic3Bpbm5lci1sYXllciBsYXllci00XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiY2lyY2xlLWNsaXBwZXIgbGVmdFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2lyY2xlXCI+PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJjaXJjbGUtY2xpcHBlciByaWdodFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2lyY2xlXCI+PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG5gO1xudGVtcGxhdGUuc2V0QXR0cmlidXRlKCdzdHJpcC13aGl0ZXNwYWNlJywgJycpO1xuXG4vKipcbk1hdGVyaWFsIGRlc2lnbjogW1Byb2dyZXNzICZcbmFjdGl2aXR5XShodHRwczovL3d3dy5nb29nbGUuY29tL2Rlc2lnbi9zcGVjL2NvbXBvbmVudHMvcHJvZ3Jlc3MtYWN0aXZpdHkuaHRtbClcblxuRWxlbWVudCBwcm92aWRpbmcgYSBtdWx0aXBsZSBjb2xvciBtYXRlcmlhbCBkZXNpZ24gY2lyY3VsYXIgc3Bpbm5lci5cblxuICAgIDxwYXBlci1zcGlubmVyIGFjdGl2ZT48L3BhcGVyLXNwaW5uZXI+XG5cblRoZSBkZWZhdWx0IHNwaW5uZXIgY3ljbGVzIGJldHdlZW4gZm91ciBsYXllcnMgb2YgY29sb3JzOyBieSBkZWZhdWx0IHRoZXkgYXJlXG5ibHVlLCByZWQsIHllbGxvdyBhbmQgZ3JlZW4uIEl0IGNhbiBiZSBjdXN0b21pemVkIHRvIGN5Y2xlIGJldHdlZW4gZm91clxuZGlmZmVyZW50IGNvbG9ycy4gVXNlIDxwYXBlci1zcGlubmVyLWxpdGU+IGZvciBzaW5nbGUgY29sb3Igc3Bpbm5lcnMuXG5cbiMjIyBBY2Nlc3NpYmlsaXR5XG5cbkFsdCBhdHRyaWJ1dGUgc2hvdWxkIGJlIHNldCB0byBwcm92aWRlIGFkZXF1YXRlIGNvbnRleHQgZm9yIGFjY2Vzc2liaWxpdHkuIElmXG5ub3QgcHJvdmlkZWQsIGl0IGRlZmF1bHRzIHRvICdsb2FkaW5nJy4gRW1wdHkgYWx0IGNhbiBiZSBwcm92aWRlZCB0byBtYXJrIHRoZVxuZWxlbWVudCBhcyBkZWNvcmF0aXZlIGlmIGFsdGVybmF0aXZlIGNvbnRlbnQgaXMgcHJvdmlkZWQgaW4gYW5vdGhlciBmb3JtIChlLmcuIGFcbnRleHQgYmxvY2sgZm9sbG93aW5nIHRoZSBzcGlubmVyKS5cblxuICAgIDxwYXBlci1zcGlubmVyIGFsdD1cIkxvYWRpbmcgY29udGFjdHMgbGlzdFwiIGFjdGl2ZT48L3BhcGVyLXNwaW5uZXI+XG5cbiMjIyBTdHlsaW5nXG5cblRoZSBmb2xsb3dpbmcgY3VzdG9tIHByb3BlcnRpZXMgYW5kIG1peGlucyBhcmUgYXZhaWxhYmxlIGZvciBzdHlsaW5nOlxuXG5DdXN0b20gcHJvcGVydHkgfCBEZXNjcmlwdGlvbiB8IERlZmF1bHRcbi0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tXG5gLS1wYXBlci1zcGlubmVyLWxheWVyLTEtY29sb3JgIHwgQ29sb3Igb2YgdGhlIGZpcnN0IHNwaW5uZXIgcm90YXRpb24gfCBgLS1nb29nbGUtYmx1ZS01MDBgXG5gLS1wYXBlci1zcGlubmVyLWxheWVyLTItY29sb3JgIHwgQ29sb3Igb2YgdGhlIHNlY29uZCBzcGlubmVyIHJvdGF0aW9uIHwgYC0tZ29vZ2xlLXJlZC01MDBgXG5gLS1wYXBlci1zcGlubmVyLWxheWVyLTMtY29sb3JgIHwgQ29sb3Igb2YgdGhlIHRoaXJkIHNwaW5uZXIgcm90YXRpb24gfCBgLS1nb29nbGUteWVsbG93LTUwMGBcbmAtLXBhcGVyLXNwaW5uZXItbGF5ZXItNC1jb2xvcmAgfCBDb2xvciBvZiB0aGUgZm91cnRoIHNwaW5uZXIgcm90YXRpb24gfCBgLS1nb29nbGUtZ3JlZW4tNTAwYFxuYC0tcGFwZXItc3Bpbm5lci1zdHJva2Utd2lkdGhgIHwgVGhlIHdpZHRoIG9mIHRoZSBzcGlubmVyIHN0cm9rZSB8IDNweFxuXG5AZ3JvdXAgUGFwZXIgRWxlbWVudHNcbkBlbGVtZW50IHBhcGVyLXNwaW5uZXJcbkBoZXJvIGhlcm8uc3ZnXG5AZGVtbyBkZW1vL2luZGV4Lmh0bWxcbiovXG5Qb2x5bWVyKHtcbiAgX3RlbXBsYXRlOiB0ZW1wbGF0ZSxcblxuICBpczogJ3BhcGVyLXNwaW5uZXInLFxuXG4gIGJlaGF2aW9yczogW1BhcGVyU3Bpbm5lckJlaGF2aW9yXVxufSk7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBeUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNDQTtBQUNBO0FBRUE7QUFFQTtBQUxBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@polymer/paper-spinner/paper-spinner.js\n");

/***/ }),

/***/ "./node_modules/@thomasloven/round-slider/src/main.js":
/*!************************************************************!*\
  !*** ./node_modules/@thomasloven/round-slider/src/main.js ***!
  \************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var lit_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit-element */ \"./node_modules/lit-element/lit-element.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _templateObject6() {\n  var data = _taggedTemplateLiteral([\"\\n      :host {\\n        display: inline-block;\\n        width: 100%;\\n      }\\n      svg {\\n        overflow: visible;\\n        display: block;\\n      }\\n      path {\\n        transition: stroke 1s ease-out, stroke-width 200ms ease-out;\\n      }\\n      .slider {\\n        fill: none;\\n        stroke-width: var(--round-slider-path-width, 3);\\n        stroke-linecap: var(--round-slider-linecap, round);\\n      }\\n      .path {\\n        stroke: var(--round-slider-path-color, lightgray);\\n      }\\n      .bar {\\n        stroke: var(--round-slider-bar-color, deepskyblue);\\n      }\\n      svg[disabled] .bar {\\n        stroke: var(--round-slider-disabled-bar-color, darkgray);\\n      }\\n      g.handles {\\n        stroke: var(--round-slider-handle-color, var(--round-slider-bar-color, deepskyblue));\\n        stroke-linecap: round;\\n      }\\n      g.low.handle {\\n        stroke: var(--round-slider-low-handle-color);\\n      }\\n      g.high.handle {\\n        stroke: var(--round-slider-high-handle-color);\\n      }\\n      svg[disabled] g.handles {\\n        stroke: var(--round-slider-disabled-bar-color, darkgray);\\n      }\\n      .handle:focus {\\n        outline: unset;\\n      }\\n    \"]);\n\n  _templateObject6 = function _templateObject6() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject5() {\n  var data = _taggedTemplateLiteral([\"\", \"\"]);\n\n  _templateObject5 = function _templateObject5() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject4() {\n  var data = _taggedTemplateLiteral([\"\", \" \", \"\"]);\n\n  _templateObject4 = function _templateObject4() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject3() {\n  var data = _taggedTemplateLiteral([\"\", \" \", \"\"]);\n\n  _templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject2() {\n  var data = _taggedTemplateLiteral([\"\\n      <svg\\n        @mousedown=\", \"\\n        @touchstart=\", \"\\n        xmln=\\\"http://www.w3.org/2000/svg\\\"\\n        viewBox=\\\"\", \" \", \" \", \" \", \"\\\"\\n        style=\\\"margin: \", \"px;\\\"\\n        ?disabled=\", \"\\n        focusable=\\\"false\\\"\\n      >\\n        <g class=\\\"slider\\\">\\n          <path\\n            class=\\\"path\\\"\\n            d=\", \"\\n            vector-effect=\\\"non-scaling-stroke\\\"\\n          />\\n          <path\\n            class=\\\"bar\\\"\\n            vector-effect=\\\"non-scaling-stroke\\\"\\n            d=\", \"\\n          />\\n          <path\\n            class=\\\"shadowpath\\\"\\n            d=\", \"\\n            vector-effect=\\\"non-scaling-stroke\\\"\\n            stroke=\\\"rgba(0,0,0,0)\\\"\\n            stroke-width=\\\"\", \"\\\"\\n            stroke-linecap=\\\"butt\\\"\\n          />\\n\\n        </g>\\n\\n        <g class=\\\"handles\\\">\\n        \", \"\\n        </g>\\n      </svg>\\n    \"]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n      <g class=\\\"\", \" handle\\\">\\n        <path\\n          id=\", \"\\n          class=\\\"overflow\\\"\\n          d=\\\"\\n          M \", \" \", \"\\n          L \", \" \", \"\\n          \\\"\\n          vector-effect=\\\"non-scaling-stroke\\\"\\n          stroke=\\\"rgba(0,0,0,0)\\\"\\n          stroke-width=\\\"\", \"\\\"\\n          />\\n        <path\\n          id=\", \"\\n          class=\\\"handle\\\"\\n          d=\\\"\\n          M \", \" \", \"\\n          L \", \" \", \"\\n          \\\"\\n          vector-effect=\\\"non-scaling-stroke\\\"\\n          stroke-width=\\\"\", \"\\\"\\n          tabindex=\\\"0\\\"\\n          @focus=\", \"\\n          @blur=\", \"\\n          role=\\\"slider\\\"\\n          aria-valuemin=\", \"\\n          aria-valuemax=\", \"\\n          aria-valuenow=\", \"\\n          aria-disabled=\", \"\\n          aria-label=\", \"\\n          />\\n        </g>\\n      \"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar RoundSlider = /*#__PURE__*/function (_LitElement) {\n  _inherits(RoundSlider, _LitElement);\n\n  var _super = _createSuper(RoundSlider);\n\n  _createClass(RoundSlider, null, [{\n    key: \"properties\",\n    get: function get() {\n      return {\n        value: {\n          type: Number\n        },\n        high: {\n          type: Number\n        },\n        low: {\n          type: Number\n        },\n        min: {\n          type: Number\n        },\n        max: {\n          type: Number\n        },\n        step: {\n          type: Number\n        },\n        startAngle: {\n          type: Number\n        },\n        arcLength: {\n          type: Number\n        },\n        handleSize: {\n          type: Number\n        },\n        handleZoom: {\n          type: Number\n        },\n        readonly: {\n          type: Boolean\n        },\n        disabled: {\n          type: Boolean\n        },\n        dragging: {\n          type: Boolean,\n          reflect: true\n        },\n        rtl: {\n          type: Boolean\n        },\n        _scale: {\n          type: Number\n        },\n        valueLabel: {\n          type: String\n        },\n        lowLabel: {\n          type: String\n        },\n        highLabel: {\n          type: String\n        }\n      };\n    }\n  }]);\n\n  function RoundSlider() {\n    var _this;\n\n    _classCallCheck(this, RoundSlider);\n\n    _this = _super.call(this);\n    _this.min = 0;\n    _this.max = 100;\n    _this.step = 1;\n    _this.startAngle = 135;\n    _this.arcLength = 270;\n    _this.handleSize = 6;\n    _this.handleZoom = 1.5;\n    _this.readonly = false;\n    _this.disabled = false;\n    _this.dragging = false;\n    _this.rtl = false;\n    _this._scale = 1;\n    _this.attachedListeners = false;\n    return _this;\n  }\n\n  _createClass(RoundSlider, [{\n    key: \"_angleInside\",\n    value: function _angleInside(angle) {\n      // Check if an angle is on the arc\n      var a = (this.startAngle + this.arcLength / 2 - angle + 180 + 360) % 360 - 180;\n      return a < this.arcLength / 2 && a > -this.arcLength / 2;\n    }\n  }, {\n    key: \"_angle2xy\",\n    value: function _angle2xy(angle) {\n      if (this.rtl) return {\n        x: -Math.cos(angle),\n        y: Math.sin(angle)\n      };\n      return {\n        x: Math.cos(angle),\n        y: Math.sin(angle)\n      };\n    }\n  }, {\n    key: \"_xy2angle\",\n    value: function _xy2angle(x, y) {\n      if (this.rtl) x = -x;\n      return (Math.atan2(y, x) - this._start + 2 * Math.PI) % (2 * Math.PI);\n    }\n  }, {\n    key: \"_value2angle\",\n    value: function _value2angle(value) {\n      value = Math.min(this.max, Math.max(this.min, value));\n      var fraction = (value - this.min) / (this.max - this.min);\n      return this._start + fraction * this._len;\n    }\n  }, {\n    key: \"_angle2value\",\n    value: function _angle2value(angle) {\n      return Math.round((angle / this._len * (this.max - this.min) + this.min) / this.step) * this.step;\n    }\n  }, {\n    key: \"_mouse2value\",\n    value: function _mouse2value(ev) {\n      var mouseX = ev.type.startsWith(\"touch\") ? ev.touches[0].clientX : ev.clientX;\n      var mouseY = ev.type.startsWith(\"touch\") ? ev.touches[0].clientY : ev.clientY;\n      var rect = this.shadowRoot.querySelector(\"svg\").getBoundingClientRect();\n      var boundaries = this._boundaries;\n      var x = mouseX - (rect.left + boundaries.left * rect.width / boundaries.width);\n      var y = mouseY - (rect.top + boundaries.up * rect.height / boundaries.height);\n\n      var angle = this._xy2angle(x, y);\n\n      var pos = this._angle2value(angle);\n\n      return pos;\n    }\n  }, {\n    key: \"dragStart\",\n    value: function dragStart(ev) {\n      var _this2 = this;\n\n      if (!this._showHandle || this.disabled) return;\n      var handle = ev.target;\n      var cooldown = undefined; // Avoid double events mouseDown->focus\n\n      if (this._rotation && this._rotation.type !== \"focus\") return; // If the bar was touched, find the nearest handle and drag from that\n\n      if (handle.classList.contains(\"shadowpath\")) {\n        if (ev.type === \"touchstart\") cooldown = window.setTimeout(function () {\n          if (_this2._rotation) _this2._rotation.cooldown = undefined;\n        }, 200);\n\n        if (this.low == null) {\n          handle = this.shadowRoot.querySelector(\"#value\");\n        } else {\n          var mouse = this._mouse2value(ev);\n\n          if (Math.abs(mouse - this.low) < Math.abs(mouse - this.high)) {\n            handle = this.shadowRoot.querySelector(\"#low\");\n          } else {\n            handle = this.shadowRoot.querySelector(\"#high\");\n          }\n        }\n      } // If an invisible handle was clicked, switch to the visible counterpart\n\n\n      if (handle.classList.contains(\"overflow\")) handle = handle.nextElementSibling;\n      if (!handle.classList.contains(\"handle\")) return;\n      handle.setAttribute('stroke-width', 2 * this.handleSize * this.handleZoom * this._scale);\n      var min = handle.id === \"high\" ? this.low : this.min;\n      var max = handle.id === \"low\" ? this.high : this.max;\n      this._rotation = {\n        handle: handle,\n        min: min,\n        max: max,\n        start: this[handle.id],\n        type: ev.type,\n        cooldown: cooldown\n      };\n      this.dragging = true;\n    }\n  }, {\n    key: \"_cleanupRotation\",\n    value: function _cleanupRotation() {\n      var handle = this._rotation.handle;\n      handle.setAttribute('stroke-width', 2 * this.handleSize * this._scale);\n      this._rotation = false;\n      this.dragging = false;\n      handle.blur();\n    }\n  }, {\n    key: \"dragEnd\",\n    value: function dragEnd(ev) {\n      if (!this._showHandle || this.disabled) return;\n      if (!this._rotation) return;\n      var handle = this._rotation.handle;\n\n      this._cleanupRotation();\n\n      var event = new CustomEvent('value-changed', {\n        detail: _defineProperty({}, handle.id, this[handle.id])\n      });\n      this.dispatchEvent(event); // This makes the low handle render over the high handle if they both are\n      // close to the top end.  Otherwise if would be unclickable, and the high\n      // handle locked by the low.  Calcualtion is done in the dragEnd handler to\n      // avoid \"z fighting\" while dragging.\n\n      if (this.low && this.low >= 0.99 * this.max) this._reverseOrder = true;else this._reverseOrder = false;\n    }\n  }, {\n    key: \"drag\",\n    value: function drag(ev) {\n      if (!this._showHandle || this.disabled) return;\n      if (!this._rotation) return;\n\n      if (this._rotation.cooldown) {\n        window.clearTimeout(this._rotation.coldown);\n\n        this._cleanupRotation();\n\n        return;\n      }\n\n      if (this._rotation.type === \"focus\") return;\n      ev.preventDefault();\n\n      var pos = this._mouse2value(ev);\n\n      this._dragpos(pos);\n    }\n  }, {\n    key: \"_dragpos\",\n    value: function _dragpos(pos) {\n      if (pos < this._rotation.min || pos > this._rotation.max) return;\n      var handle = this._rotation.handle;\n      this[handle.id] = pos;\n      var event = new CustomEvent('value-changing', {\n        detail: _defineProperty({}, handle.id, pos)\n      });\n      this.dispatchEvent(event);\n    }\n  }, {\n    key: \"_keyStep\",\n    value: function _keyStep(ev) {\n      if (!this._showHandle || this.disabled) return;\n      if (!this._rotation) return;\n      var handle = this._rotation.handle;\n\n      if (ev.key === \"ArrowLeft\" || ev.key === \"ArrowDown\") {\n        ev.preventDefault();\n        if (this.rtl) this._dragpos(this[handle.id] + this.step);else this._dragpos(this[handle.id] - this.step);\n      }\n\n      if (ev.key === \"ArrowRight\" || ev.key === \"ArrowUp\") {\n        ev.preventDefault();\n        if (this.rtl) this._dragpos(this[handle.id] - this.step);else this._dragpos(this[handle.id] + this.step);\n      }\n\n      if (ev.key === \"Home\") {\n        ev.preventDefault();\n\n        this._dragpos(this.min);\n      }\n\n      if (ev.key === \"End\") {\n        ev.preventDefault();\n\n        this._dragpos(this.max);\n      }\n    }\n  }, {\n    key: \"firstUpdated\",\n    value: function firstUpdated() {\n      document.addEventListener('mouseup', this.dragEnd.bind(this));\n      document.addEventListener('touchend', this.dragEnd.bind(this), {\n        passive: false\n      });\n      document.addEventListener('mousemove', this.drag.bind(this));\n      document.addEventListener('touchmove', this.drag.bind(this), {\n        passive: false\n      });\n      document.addEventListener('keydown', this._keyStep.bind(this));\n    }\n  }, {\n    key: \"updated\",\n    value: function updated(changedProperties) {\n      var _this3 = this;\n\n      // Adjust margin in the bar slider stroke width is greater than the handle size\n      if (this.shadowRoot.querySelector(\".slider\")) {\n        var styles = window.getComputedStyle(this.shadowRoot.querySelector(\".slider\"));\n\n        if (styles && styles['strokeWidth']) {\n          var stroke = parseFloat(styles['strokeWidth']);\n\n          if (stroke > this.handleSize * this.handleZoom) {\n            var view = this._boundaries;\n            var margin = \"\\n          \".concat(stroke / 2 * Math.abs(view.up), \"px\\n          \").concat(stroke / 2 * Math.abs(view.right), \"px\\n          \").concat(stroke / 2 * Math.abs(view.down), \"px\\n          \").concat(stroke / 2 * Math.abs(view.left), \"px\");\n            this.shadowRoot.querySelector(\"svg\").style.margin = margin;\n          }\n        }\n      } // Workaround for vector-effect not working in IE and pre-Chromium Edge\n      // That's also why the _scale property exists\n\n\n      if (this.shadowRoot.querySelector(\"svg\") && this.shadowRoot.querySelector(\"svg\").style.vectorEffect === undefined) {\n        if (changedProperties.has(\"_scale\") && this._scale != 1) {\n          this.shadowRoot.querySelector(\"svg\").querySelectorAll(\"path\").forEach(function (e) {\n            if (e.getAttribute('stroke-width')) return;\n            var orig = parseFloat(getComputedStyle(e).getPropertyValue('stroke-width'));\n            e.style.strokeWidth = \"\".concat(orig * _this3._scale, \"px\");\n          });\n        }\n\n        var rect = this.shadowRoot.querySelector(\"svg\").getBoundingClientRect();\n        var scale = Math.max(rect.width, rect.height);\n        this._scale = 2 / scale;\n      }\n    }\n  }, {\n    key: \"_renderArc\",\n    value: function _renderArc(start, end) {\n      var diff = end - start;\n      start = this._angle2xy(start);\n      end = this._angle2xy(end + 0.001); // Safari doesn't like arcs with no length\n\n      return \"\\n      M \".concat(start.x, \" \").concat(start.y, \"\\n      A 1 1,\\n        0,\\n        \").concat(diff > Math.PI ? \"1\" : \"0\", \" \").concat(this.rtl ? \"0\" : \"1\", \",\\n        \").concat(end.x, \" \").concat(end.y, \"\\n    \");\n    }\n  }, {\n    key: \"_renderHandle\",\n    value: function _renderHandle(id) {\n      var theta = this._value2angle(this[id]);\n\n      var pos = this._angle2xy(theta);\n\n      var label = {\n        value: this.valueLabel,\n        low: this.lowLabel,\n        high: this.highLabel\n      }[id] || \"\"; // Two handles are drawn. One visible, and one invisible that's twice as\n      // big. Makes it easier to click.\n\n      return Object(lit_element__WEBPACK_IMPORTED_MODULE_0__[\"svg\"])(_templateObject(), id, id, pos.x, pos.y, pos.x + 0.001, pos.y + 0.001, 4 * this.handleSize * this._scale, id, pos.x, pos.y, pos.x + 0.001, pos.y + 0.001, 2 * this.handleSize * this._scale, this.dragStart, this.dragEnd, this.min, this.max, this[id], this.disabled, label || \"\");\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var view = this._boundaries;\n      return Object(lit_element__WEBPACK_IMPORTED_MODULE_0__[\"html\"])(_templateObject2(), this.dragStart, this.dragStart, -view.left, -view.up, view.width, view.height, this.handleSize * this.handleZoom, this.disabled, this._renderArc(this._start, this._end), this._renderArc(this._value2angle(this.low != null ? this.low : this.min), this._value2angle(this.high != null ? this.high : this.value)), this._renderArc(this._start, this._end), 3 * this.handleSize * this._scale, this._showHandle ? this.low != null ? this._reverseOrder ? Object(lit_element__WEBPACK_IMPORTED_MODULE_0__[\"html\"])(_templateObject3(), this._renderHandle(\"high\"), this._renderHandle(\"low\")) : Object(lit_element__WEBPACK_IMPORTED_MODULE_0__[\"html\"])(_templateObject4(), this._renderHandle(\"low\"), this._renderHandle(\"high\")) : Object(lit_element__WEBPACK_IMPORTED_MODULE_0__[\"html\"])(_templateObject5(), this._renderHandle(\"value\")) : \"\");\n    }\n  }, {\n    key: \"_start\",\n    get: function get() {\n      return this.startAngle * Math.PI / 180;\n    }\n  }, {\n    key: \"_len\",\n    get: function get() {\n      // Things get weird if length is more than a complete turn\n      return Math.min(this.arcLength * Math.PI / 180, 2 * Math.PI - 0.01);\n    }\n  }, {\n    key: \"_end\",\n    get: function get() {\n      return this._start + this._len;\n    }\n  }, {\n    key: \"_showHandle\",\n    get: function get() {\n      // If handle is shown\n      if (this.readonly) return false;\n      if (this.value == null && (this.high == null || this.low == null)) return false;\n      return true;\n    }\n  }, {\n    key: \"_boundaries\",\n    get: function get() {\n      // Get the maximum extents of the bar arc\n      var start = this._angle2xy(this._start);\n\n      var end = this._angle2xy(this._end);\n\n      var up = 1;\n      if (!this._angleInside(270)) up = Math.max(-start.y, -end.y);\n      var down = 1;\n      if (!this._angleInside(90)) down = Math.max(start.y, end.y);\n      var left = 1;\n      if (!this._angleInside(180)) left = Math.max(-start.x, -end.x);\n      var right = 1;\n      if (!this._angleInside(0)) right = Math.max(start.x, end.x);\n      return {\n        up: up,\n        down: down,\n        left: left,\n        right: right,\n        height: up + down,\n        width: left + right\n      };\n    }\n  }], [{\n    key: \"styles\",\n    get: function get() {\n      return Object(lit_element__WEBPACK_IMPORTED_MODULE_0__[\"css\"])(_templateObject6());\n    }\n  }]);\n\n  return RoundSlider;\n}(lit_element__WEBPACK_IMPORTED_MODULE_0__[\"LitElement\"]);\n\ncustomElements.define('round-slider', RoundSlider);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRob21hc2xvdmVuL3JvdW5kLXNsaWRlci9zcmMvbWFpbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGhvbWFzbG92ZW4vcm91bmQtc2xpZGVyL3NyYy9tYWluLmpzPzU2MzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgTGl0RWxlbWVudCxcbiAgaHRtbCxcbiAgY3NzLFxuICBzdmcsXG59IGZyb20gXCJsaXQtZWxlbWVudFwiO1xuXG5jbGFzcyBSb3VuZFNsaWRlciBleHRlbmRzIExpdEVsZW1lbnQge1xuXG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHt0eXBlOiBOdW1iZXJ9LFxuICAgICAgaGlnaDoge3R5cGU6IE51bWJlcn0sXG4gICAgICBsb3c6IHt0eXBlOiBOdW1iZXJ9LFxuICAgICAgbWluOiB7dHlwZTogTnVtYmVyfSxcbiAgICAgIG1heDoge3R5cGU6IE51bWJlcn0sXG4gICAgICBzdGVwOiB7dHlwZTogTnVtYmVyfSxcbiAgICAgIHN0YXJ0QW5nbGU6IHt0eXBlOiBOdW1iZXJ9LFxuICAgICAgYXJjTGVuZ3RoOiB7dHlwZTogTnVtYmVyfSxcbiAgICAgIGhhbmRsZVNpemU6IHt0eXBlOiBOdW1iZXJ9LFxuICAgICAgaGFuZGxlWm9vbToge3R5cGU6IE51bWJlcn0sXG4gICAgICByZWFkb25seToge3R5cGU6IEJvb2xlYW59LFxuICAgICAgZGlzYWJsZWQ6IHt0eXBlOiBCb29sZWFufSxcbiAgICAgIGRyYWdnaW5nOiB7dHlwZTogQm9vbGVhbiwgcmVmbGVjdDogdHJ1ZX0sXG4gICAgICBydGw6IHt0eXBlOiBCb29sZWFufSxcbiAgICAgIF9zY2FsZToge3R5cGU6IE51bWJlcn0sXG4gICAgICB2YWx1ZUxhYmVsOiB7dHlwZTogU3RyaW5nfSxcbiAgICAgIGxvd0xhYmVsOiB7dHlwZTogU3RyaW5nfSxcbiAgICAgIGhpZ2hMYWJlbDoge3R5cGU6IFN0cmluZ30sXG4gICAgfVxuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm1pbiA9IDA7XG4gICAgdGhpcy5tYXggPSAxMDA7XG4gICAgdGhpcy5zdGVwID0gMTtcbiAgICB0aGlzLnN0YXJ0QW5nbGUgPSAxMzU7XG4gICAgdGhpcy5hcmNMZW5ndGggPSAyNzA7XG4gICAgdGhpcy5oYW5kbGVTaXplID0gNjtcbiAgICB0aGlzLmhhbmRsZVpvb20gPSAxLjU7XG4gICAgdGhpcy5yZWFkb25seSA9IGZhbHNlO1xuICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5ydGwgPSBmYWxzZTtcbiAgICB0aGlzLl9zY2FsZSA9IDE7XG4gICAgdGhpcy5hdHRhY2hlZExpc3RlbmVycyA9IGZhbHNlO1xuICB9XG5cbiAgZ2V0IF9zdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydEFuZ2xlKk1hdGguUEkvMTgwO1xuICB9XG4gIGdldCBfbGVuKCkge1xuICAgIC8vIFRoaW5ncyBnZXQgd2VpcmQgaWYgbGVuZ3RoIGlzIG1vcmUgdGhhbiBhIGNvbXBsZXRlIHR1cm5cbiAgICByZXR1cm4gTWF0aC5taW4odGhpcy5hcmNMZW5ndGgqTWF0aC5QSS8xODAsIDIqTWF0aC5QSS0wLjAxKTtcbiAgfVxuICBnZXQgX2VuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnQgKyB0aGlzLl9sZW47XG4gIH1cblxuICBnZXQgX3Nob3dIYW5kbGUoKSB7XG4gICAgLy8gSWYgaGFuZGxlIGlzIHNob3duXG4gICAgaWYodGhpcy5yZWFkb25seSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmKHRoaXMudmFsdWUgPT0gbnVsbCAmJiAodGhpcy5oaWdoID09IG51bGwgfHwgdGhpcy5sb3cgPT0gbnVsbCkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIF9hbmdsZUluc2lkZShhbmdsZSkge1xuICAgIC8vIENoZWNrIGlmIGFuIGFuZ2xlIGlzIG9uIHRoZSBhcmNcbiAgICBsZXQgYSA9ICh0aGlzLnN0YXJ0QW5nbGUgKyB0aGlzLmFyY0xlbmd0aC8yIC0gYW5nbGUgKyAxODAgKyAzNjApICUgMzYwIC0gMTgwO1xuICAgIHJldHVybiAoYSA8IHRoaXMuYXJjTGVuZ3RoLzIgJiYgYSA+IC10aGlzLmFyY0xlbmd0aC8yKTtcbiAgfVxuICBfYW5nbGUyeHkoYW5nbGUpIHtcbiAgICBpZih0aGlzLnJ0bClcbiAgICAgIHJldHVybiB7eDogLU1hdGguY29zKGFuZ2xlKSwgeTogTWF0aC5zaW4oYW5nbGUpfVxuICAgIHJldHVybiB7eDogTWF0aC5jb3MoYW5nbGUpLCB5OiBNYXRoLnNpbihhbmdsZSl9XG4gIH1cbiAgX3h5MmFuZ2xlKHgseSkge1xuICAgIGlmKHRoaXMucnRsKVxuICAgICAgeCA9IC14O1xuICAgIHJldHVybiAoTWF0aC5hdGFuMih5LHgpIC0gdGhpcy5fc3RhcnQgKyAyKk1hdGguUEkpICUgKDIqTWF0aC5QSSk7XG4gIH1cblxuICBfdmFsdWUyYW5nbGUodmFsdWUpIHtcbiAgICB2YWx1ZSA9IE1hdGgubWluKHRoaXMubWF4LCBNYXRoLm1heCh0aGlzLm1pbiwgdmFsdWUpKTtcbiAgICBjb25zdCBmcmFjdGlvbiA9ICh2YWx1ZSAtIHRoaXMubWluKS8odGhpcy5tYXggLSB0aGlzLm1pbik7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0ICsgZnJhY3Rpb24gKiB0aGlzLl9sZW47XG4gIH1cbiAgX2FuZ2xlMnZhbHVlKGFuZ2xlKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoKGFuZ2xlL3RoaXMuX2xlbioodGhpcy5tYXggLSB0aGlzLm1pbikgKyB0aGlzLm1pbikvdGhpcy5zdGVwKSp0aGlzLnN0ZXA7XG4gIH1cblxuXG4gIGdldCBfYm91bmRhcmllcygpIHtcbiAgICAvLyBHZXQgdGhlIG1heGltdW0gZXh0ZW50cyBvZiB0aGUgYmFyIGFyY1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fYW5nbGUyeHkodGhpcy5fc3RhcnQpO1xuICAgIGNvbnN0IGVuZCA9IHRoaXMuX2FuZ2xlMnh5KHRoaXMuX2VuZCk7XG5cbiAgICBsZXQgdXAgPSAxO1xuICAgIGlmKCF0aGlzLl9hbmdsZUluc2lkZSgyNzApKVxuICAgICAgdXAgPSAgTWF0aC5tYXgoLXN0YXJ0LnksIC1lbmQueSk7XG5cbiAgICBsZXQgZG93biA9IDE7XG4gICAgaWYoIXRoaXMuX2FuZ2xlSW5zaWRlKDkwKSlcbiAgICAgIGRvd24gPSBNYXRoLm1heChzdGFydC55LCBlbmQueSk7XG5cbiAgICBsZXQgbGVmdCA9IDE7XG4gICAgaWYoIXRoaXMuX2FuZ2xlSW5zaWRlKDE4MCkpXG4gICAgICBsZWZ0ID0gTWF0aC5tYXgoLXN0YXJ0LngsIC1lbmQueCk7XG5cbiAgICBsZXQgcmlnaHQgPSAxO1xuICAgIGlmKCF0aGlzLl9hbmdsZUluc2lkZSgwKSlcbiAgICAgIHJpZ2h0ID0gTWF0aC5tYXgoc3RhcnQueCwgZW5kLngpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHVwLCBkb3duLCBsZWZ0LCByaWdodCxcbiAgICAgIGhlaWdodDogdXArZG93bixcbiAgICAgIHdpZHRoOiBsZWZ0K3JpZ2h0LFxuICAgIH07XG4gIH1cblxuICBfbW91c2UydmFsdWUoZXYpIHtcbiAgICBjb25zdCBtb3VzZVggPSAoZXYudHlwZS5zdGFydHNXaXRoKFwidG91Y2hcIikpID8gZXYudG91Y2hlc1swXS5jbGllbnRYIDogZXYuY2xpZW50WDtcbiAgICBjb25zdCBtb3VzZVkgPSAoZXYudHlwZS5zdGFydHNXaXRoKFwidG91Y2hcIikpID8gZXYudG91Y2hlc1swXS5jbGllbnRZIDogZXYuY2xpZW50WTtcblxuICAgIGNvbnN0IHJlY3QgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcInN2Z1wiKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBib3VuZGFyaWVzID0gdGhpcy5fYm91bmRhcmllcztcbiAgICBjb25zdCB4ID0gbW91c2VYIC0gKHJlY3QubGVmdCArIGJvdW5kYXJpZXMubGVmdCpyZWN0LndpZHRoL2JvdW5kYXJpZXMud2lkdGgpO1xuICAgIGNvbnN0IHkgPSBtb3VzZVkgLSAocmVjdC50b3AgKyBib3VuZGFyaWVzLnVwKnJlY3QuaGVpZ2h0L2JvdW5kYXJpZXMuaGVpZ2h0KTtcblxuICAgIGNvbnN0IGFuZ2xlID0gdGhpcy5feHkyYW5nbGUoeCx5KTtcbiAgICBjb25zdCBwb3MgPSB0aGlzLl9hbmdsZTJ2YWx1ZShhbmdsZSk7XG4gICAgcmV0dXJuIHBvcztcbiAgfVxuXG4gIGRyYWdTdGFydChldikge1xuICAgIGlmKCF0aGlzLl9zaG93SGFuZGxlIHx8IHRoaXMuZGlzYWJsZWQpIHJldHVybjtcbiAgICBsZXQgaGFuZGxlID0gZXYudGFyZ2V0O1xuICAgIGxldCBjb29sZG93biA9IHVuZGVmaW5lZDtcblxuICAgIC8vIEF2b2lkIGRvdWJsZSBldmVudHMgbW91c2VEb3duLT5mb2N1c1xuICAgIGlmKHRoaXMuX3JvdGF0aW9uICYmIHRoaXMuX3JvdGF0aW9uLnR5cGUgIT09IFwiZm9jdXNcIikgcmV0dXJuO1xuXG4gICAgLy8gSWYgdGhlIGJhciB3YXMgdG91Y2hlZCwgZmluZCB0aGUgbmVhcmVzdCBoYW5kbGUgYW5kIGRyYWcgZnJvbSB0aGF0XG4gICAgaWYoaGFuZGxlLmNsYXNzTGlzdC5jb250YWlucyhcInNoYWRvd3BhdGhcIikpIHtcbiAgICAgIGlmKGV2LnR5cGUgPT09IFwidG91Y2hzdGFydFwiKVxuICAgICAgICBjb29sZG93biA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZih0aGlzLl9yb3RhdGlvbikgdGhpcy5fcm90YXRpb24uY29vbGRvd24gPSB1bmRlZmluZWQ7XG4gICAgICAgIH0sIDIwMCk7XG4gICAgICBpZih0aGlzLmxvdyA9PSBudWxsKSB7XG4gICAgICAgIGhhbmRsZSA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiI3ZhbHVlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbW91c2UgPSB0aGlzLl9tb3VzZTJ2YWx1ZShldik7XG4gICAgICAgIGlmKE1hdGguYWJzKG1vdXNlLXRoaXMubG93KSA8IE1hdGguYWJzKG1vdXNlLXRoaXMuaGlnaCkpIHtcbiAgICAgICAgICBoYW5kbGUgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcIiNsb3dcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCIjaGlnaFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIGFuIGludmlzaWJsZSBoYW5kbGUgd2FzIGNsaWNrZWQsIHN3aXRjaCB0byB0aGUgdmlzaWJsZSBjb3VudGVycGFydFxuICAgIGlmKGhhbmRsZS5jbGFzc0xpc3QuY29udGFpbnMoXCJvdmVyZmxvd1wiKSlcbiAgICAgIGhhbmRsZSA9IGhhbmRsZS5uZXh0RWxlbWVudFNpYmxpbmc7XG5cbiAgICBpZighaGFuZGxlLmNsYXNzTGlzdC5jb250YWlucyhcImhhbmRsZVwiKSkgcmV0dXJuO1xuICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIDIqdGhpcy5oYW5kbGVTaXplKnRoaXMuaGFuZGxlWm9vbSp0aGlzLl9zY2FsZSk7XG5cbiAgICBjb25zdCBtaW4gPSBoYW5kbGUuaWQgPT09IFwiaGlnaFwiID8gdGhpcy5sb3cgOiB0aGlzLm1pbjtcbiAgICBjb25zdCBtYXggPSBoYW5kbGUuaWQgPT09IFwibG93XCIgPyB0aGlzLmhpZ2ggOiB0aGlzLm1heDtcbiAgICB0aGlzLl9yb3RhdGlvbiA9IHsgaGFuZGxlLCBtaW4sIG1heCwgc3RhcnQ6IHRoaXNbaGFuZGxlLmlkXSwgdHlwZTogZXYudHlwZSwgY29vbGRvd259O1xuICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICB9XG5cbiAgX2NsZWFudXBSb3RhdGlvbigpIHtcbiAgICBjb25zdCBoYW5kbGUgPSB0aGlzLl9yb3RhdGlvbi5oYW5kbGU7XG4gICAgaGFuZGxlLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgMip0aGlzLmhhbmRsZVNpemUqdGhpcy5fc2NhbGUpO1xuXG4gICAgdGhpcy5fcm90YXRpb24gPSBmYWxzZTtcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG5cbiAgICBoYW5kbGUuYmx1cigpO1xuICB9XG5cbiAgZHJhZ0VuZChldikge1xuICAgIGlmKCF0aGlzLl9zaG93SGFuZGxlIHx8IHRoaXMuZGlzYWJsZWQpIHJldHVybjtcbiAgICBpZighdGhpcy5fcm90YXRpb24pIHJldHVybjtcblxuICAgIGNvbnN0IGhhbmRsZSA9IHRoaXMuX3JvdGF0aW9uLmhhbmRsZTtcbiAgICB0aGlzLl9jbGVhbnVwUm90YXRpb24oKTtcblxuICAgIGxldCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgndmFsdWUtY2hhbmdlZCcsIHtcbiAgICAgIGRldGFpbDoge1xuICAgICAgICBbaGFuZGxlLmlkXSA6IHRoaXNbaGFuZGxlLmlkXSxcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXG4gICAgLy8gVGhpcyBtYWtlcyB0aGUgbG93IGhhbmRsZSByZW5kZXIgb3ZlciB0aGUgaGlnaCBoYW5kbGUgaWYgdGhleSBib3RoIGFyZVxuICAgIC8vIGNsb3NlIHRvIHRoZSB0b3AgZW5kLiAgT3RoZXJ3aXNlIGlmIHdvdWxkIGJlIHVuY2xpY2thYmxlLCBhbmQgdGhlIGhpZ2hcbiAgICAvLyBoYW5kbGUgbG9ja2VkIGJ5IHRoZSBsb3cuICBDYWxjdWFsdGlvbiBpcyBkb25lIGluIHRoZSBkcmFnRW5kIGhhbmRsZXIgdG9cbiAgICAvLyBhdm9pZCBcInogZmlnaHRpbmdcIiB3aGlsZSBkcmFnZ2luZy5cbiAgICBpZih0aGlzLmxvdyAmJiB0aGlzLmxvdyA+PSAwLjk5KnRoaXMubWF4KVxuICAgICAgdGhpcy5fcmV2ZXJzZU9yZGVyID0gdHJ1ZTtcbiAgICBlbHNlXG4gICAgICB0aGlzLl9yZXZlcnNlT3JkZXIgPSBmYWxzZTtcbiAgfVxuXG4gIGRyYWcoZXYpIHtcbiAgICBpZighdGhpcy5fc2hvd0hhbmRsZSB8fCB0aGlzLmRpc2FibGVkKSByZXR1cm47XG4gICAgaWYoIXRoaXMuX3JvdGF0aW9uKSByZXR1cm47XG4gICAgaWYodGhpcy5fcm90YXRpb24uY29vbGRvd24pIHtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fcm90YXRpb24uY29sZG93bik7XG4gICAgICB0aGlzLl9jbGVhbnVwUm90YXRpb24oKVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZih0aGlzLl9yb3RhdGlvbi50eXBlID09PSBcImZvY3VzXCIpIHJldHVybjtcblxuICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBjb25zdCBwb3MgPSB0aGlzLl9tb3VzZTJ2YWx1ZShldik7XG5cbiAgICB0aGlzLl9kcmFncG9zKHBvcyk7XG4gIH1cblxuICBfZHJhZ3Bvcyhwb3MpIHtcbiAgICBpZihwb3MgPCB0aGlzLl9yb3RhdGlvbi5taW4gfHwgcG9zID4gdGhpcy5fcm90YXRpb24ubWF4KSByZXR1cm47XG5cbiAgICBjb25zdCBoYW5kbGUgPSB0aGlzLl9yb3RhdGlvbi5oYW5kbGU7XG4gICAgdGhpc1toYW5kbGUuaWRdID0gcG9zO1xuXG4gICAgbGV0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCd2YWx1ZS1jaGFuZ2luZycsIHtcbiAgICAgIGRldGFpbDoge1xuICAgICAgICBbaGFuZGxlLmlkXSA6IHBvcyxcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9XG5cbiAgX2tleVN0ZXAoZXYpIHtcbiAgICBpZighdGhpcy5fc2hvd0hhbmRsZSB8fCB0aGlzLmRpc2FibGVkKSByZXR1cm47XG4gICAgaWYoIXRoaXMuX3JvdGF0aW9uKSByZXR1cm47XG4gICAgY29uc3QgaGFuZGxlID0gdGhpcy5fcm90YXRpb24uaGFuZGxlO1xuICAgIGlmKGV2LmtleSA9PT0gXCJBcnJvd0xlZnRcIiB8fCBldi5rZXkgPT09IFwiQXJyb3dEb3duXCIpIHtcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZih0aGlzLnJ0bClcbiAgICAgICAgdGhpcy5fZHJhZ3Bvcyh0aGlzW2hhbmRsZS5pZF0gKyB0aGlzLnN0ZXApO1xuICAgICAgZWxzZVxuICAgICAgICB0aGlzLl9kcmFncG9zKHRoaXNbaGFuZGxlLmlkXSAtIHRoaXMuc3RlcCk7XG4gICAgfVxuICAgIGlmKGV2LmtleSA9PT0gXCJBcnJvd1JpZ2h0XCIgfHwgZXYua2V5ID09PSBcIkFycm93VXBcIikge1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmKHRoaXMucnRsKVxuICAgICAgICB0aGlzLl9kcmFncG9zKHRoaXNbaGFuZGxlLmlkXSAtIHRoaXMuc3RlcCk7XG4gICAgICBlbHNlXG4gICAgICAgIHRoaXMuX2RyYWdwb3ModGhpc1toYW5kbGUuaWRdICsgdGhpcy5zdGVwKTtcbiAgICB9XG4gICAgaWYoZXYua2V5ID09PSBcIkhvbWVcIikge1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuX2RyYWdwb3ModGhpcy5taW4pO1xuICAgIH1cbiAgICBpZihldi5rZXkgPT09IFwiRW5kXCIpIHtcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLl9kcmFncG9zKHRoaXMubWF4KTtcbiAgICB9XG4gIH1cblxuICBmaXJzdFVwZGF0ZWQoKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuZHJhZ0VuZC5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuZHJhZ0VuZC5iaW5kKHRoaXMpLCB7cGFzc2l2ZTogZmFsc2V9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLmRyYWcuYmluZCh0aGlzKSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5kcmFnLmJpbmQodGhpcyksIHtwYXNzaXZlOiBmYWxzZX0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9rZXlTdGVwLmJpbmQodGhpcykpO1xuICB9XG5cbiAgdXBkYXRlZChjaGFuZ2VkUHJvcGVydGllcykge1xuXG4gICAgLy8gQWRqdXN0IG1hcmdpbiBpbiB0aGUgYmFyIHNsaWRlciBzdHJva2Ugd2lkdGggaXMgZ3JlYXRlciB0aGFuIHRoZSBoYW5kbGUgc2l6ZVxuICAgIGlmKHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiLnNsaWRlclwiKSkge1xuICAgICAgY29uc3Qgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCIuc2xpZGVyXCIpKTtcbiAgICAgIGlmIChzdHlsZXMgJiYgc3R5bGVzWydzdHJva2VXaWR0aCddKSB7XG4gICAgICAgIGNvbnN0IHN0cm9rZSA9IHBhcnNlRmxvYXQoc3R5bGVzWydzdHJva2VXaWR0aCddKVxuICAgICAgICBpZiAoc3Ryb2tlID4gdGhpcy5oYW5kbGVTaXplKnRoaXMuaGFuZGxlWm9vbSkge1xuICAgICAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLl9ib3VuZGFyaWVzO1xuICAgICAgICAgIGNvbnN0IG1hcmdpbiA9IGBcbiAgICAgICAgICAke3N0cm9rZS8yKk1hdGguYWJzKHZpZXcudXApfXB4XG4gICAgICAgICAgJHtzdHJva2UvMipNYXRoLmFicyh2aWV3LnJpZ2h0KX1weFxuICAgICAgICAgICR7c3Ryb2tlLzIqTWF0aC5hYnModmlldy5kb3duKX1weFxuICAgICAgICAgICR7c3Ryb2tlLzIqTWF0aC5hYnModmlldy5sZWZ0KX1weGA7XG4gICAgICAgICAgdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCJzdmdcIikuc3R5bGUubWFyZ2luID0gbWFyZ2luO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV29ya2Fyb3VuZCBmb3IgdmVjdG9yLWVmZmVjdCBub3Qgd29ya2luZyBpbiBJRSBhbmQgcHJlLUNocm9taXVtIEVkZ2VcbiAgICAvLyBUaGF0J3MgYWxzbyB3aHkgdGhlIF9zY2FsZSBwcm9wZXJ0eSBleGlzdHNcbiAgICBpZih0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcInN2Z1wiKVxuICAgICYmIHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwic3ZnXCIpLnN0eWxlLnZlY3RvckVmZmVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZihjaGFuZ2VkUHJvcGVydGllcy5oYXMoXCJfc2NhbGVcIikgJiYgdGhpcy5fc2NhbGUgIT0gMSkge1xuICAgICAgICB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcInN2Z1wiKS5xdWVyeVNlbGVjdG9yQWxsKFwicGF0aFwiKS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAgICAgaWYoZS5nZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcpKSByZXR1cm47XG4gICAgICAgICAgY29uc3Qgb3JpZyA9IHBhcnNlRmxvYXQoZ2V0Q29tcHV0ZWRTdHlsZShlKS5nZXRQcm9wZXJ0eVZhbHVlKCdzdHJva2Utd2lkdGgnKSk7XG4gICAgICAgICAgZS5zdHlsZS5zdHJva2VXaWR0aCA9IGAke29yaWcqdGhpcy5fc2NhbGV9cHhgO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcInN2Z1wiKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHNjYWxlID0gTWF0aC5tYXgocmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICAgICAgdGhpcy5fc2NhbGUgPSAyL3NjYWxlO1xuICAgIH1cblxuICB9XG5cbiAgX3JlbmRlckFyYyhzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgZGlmZiA9IGVuZC1zdGFydDtcbiAgICBzdGFydCA9IHRoaXMuX2FuZ2xlMnh5KHN0YXJ0KTtcbiAgICBlbmQgPSB0aGlzLl9hbmdsZTJ4eShlbmQrMC4wMDEpOyAvLyBTYWZhcmkgZG9lc24ndCBsaWtlIGFyY3Mgd2l0aCBubyBsZW5ndGhcbiAgICByZXR1cm4gYFxuICAgICAgTSAke3N0YXJ0Lnh9ICR7c3RhcnQueX1cbiAgICAgIEEgMSAxLFxuICAgICAgICAwLFxuICAgICAgICAkeyhkaWZmKSA+IE1hdGguUEkgPyBcIjFcIiA6IFwiMFwifSAke3RoaXMucnRsID8gXCIwXCIgOiBcIjFcIn0sXG4gICAgICAgICR7ZW5kLnh9ICR7ZW5kLnl9XG4gICAgYDtcbiAgfVxuXG4gIF9yZW5kZXJIYW5kbGUoaWQpIHtcbiAgICBjb25zdCB0aGV0YSA9IHRoaXMuX3ZhbHVlMmFuZ2xlKHRoaXNbaWRdKTtcbiAgICBjb25zdCBwb3MgPSB0aGlzLl9hbmdsZTJ4eSh0aGV0YSk7XG4gICAgY29uc3QgbGFiZWwgPSB7XG4gICAgICB2YWx1ZTogdGhpcy52YWx1ZUxhYmVsLFxuICAgICAgbG93OiB0aGlzLmxvd0xhYmVsLFxuICAgICAgaGlnaDogdGhpcy5oaWdoTGFiZWxcbiAgICB9W2lkXSB8fCBcIlwiO1xuXG4gICAgLy8gVHdvIGhhbmRsZXMgYXJlIGRyYXduLiBPbmUgdmlzaWJsZSwgYW5kIG9uZSBpbnZpc2libGUgdGhhdCdzIHR3aWNlIGFzXG4gICAgLy8gYmlnLiBNYWtlcyBpdCBlYXNpZXIgdG8gY2xpY2suXG4gICAgcmV0dXJuIHN2Z2BcbiAgICAgIDxnIGNsYXNzPVwiJHtpZH0gaGFuZGxlXCI+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgaWQ9JHtpZH1cbiAgICAgICAgICBjbGFzcz1cIm92ZXJmbG93XCJcbiAgICAgICAgICBkPVwiXG4gICAgICAgICAgTSAke3Bvcy54fSAke3Bvcy55fVxuICAgICAgICAgIEwgJHtwb3MueCswLjAwMX0gJHtwb3MueSswLjAwMX1cbiAgICAgICAgICBcIlxuICAgICAgICAgIHZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIlxuICAgICAgICAgIHN0cm9rZT1cInJnYmEoMCwwLDAsMClcIlxuICAgICAgICAgIHN0cm9rZS13aWR0aD1cIiR7NCp0aGlzLmhhbmRsZVNpemUqdGhpcy5fc2NhbGV9XCJcbiAgICAgICAgICAvPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGlkPSR7aWR9XG4gICAgICAgICAgY2xhc3M9XCJoYW5kbGVcIlxuICAgICAgICAgIGQ9XCJcbiAgICAgICAgICBNICR7cG9zLnh9ICR7cG9zLnl9XG4gICAgICAgICAgTCAke3Bvcy54KzAuMDAxfSAke3Bvcy55KzAuMDAxfVxuICAgICAgICAgIFwiXG4gICAgICAgICAgdmVjdG9yLWVmZmVjdD1cIm5vbi1zY2FsaW5nLXN0cm9rZVwiXG4gICAgICAgICAgc3Ryb2tlLXdpZHRoPVwiJHsyKnRoaXMuaGFuZGxlU2l6ZSp0aGlzLl9zY2FsZX1cIlxuICAgICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgICAgQGZvY3VzPSR7dGhpcy5kcmFnU3RhcnR9XG4gICAgICAgICAgQGJsdXI9JHt0aGlzLmRyYWdFbmR9XG4gICAgICAgICAgcm9sZT1cInNsaWRlclwiXG4gICAgICAgICAgYXJpYS12YWx1ZW1pbj0ke3RoaXMubWlufVxuICAgICAgICAgIGFyaWEtdmFsdWVtYXg9JHt0aGlzLm1heH1cbiAgICAgICAgICBhcmlhLXZhbHVlbm93PSR7dGhpc1tpZF19XG4gICAgICAgICAgYXJpYS1kaXNhYmxlZD0ke3RoaXMuZGlzYWJsZWR9XG4gICAgICAgICAgYXJpYS1sYWJlbD0ke2xhYmVsIHx8IFwiXCJ9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9nPlxuICAgICAgYFxuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB2aWV3ID0gdGhpcy5fYm91bmRhcmllcztcblxuICAgIHJldHVybiBodG1sYFxuICAgICAgPHN2Z1xuICAgICAgICBAbW91c2Vkb3duPSR7dGhpcy5kcmFnU3RhcnR9XG4gICAgICAgIEB0b3VjaHN0YXJ0PSR7dGhpcy5kcmFnU3RhcnR9XG4gICAgICAgIHhtbG49XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICAgIHZpZXdCb3g9XCIkey12aWV3LmxlZnR9ICR7LXZpZXcudXB9ICR7dmlldy53aWR0aH0gJHt2aWV3LmhlaWdodH1cIlxuICAgICAgICBzdHlsZT1cIm1hcmdpbjogJHt0aGlzLmhhbmRsZVNpemUqdGhpcy5oYW5kbGVab29tfXB4O1wiXG4gICAgICAgID9kaXNhYmxlZD0ke3RoaXMuZGlzYWJsZWR9XG4gICAgICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICAgID5cbiAgICAgICAgPGcgY2xhc3M9XCJzbGlkZXJcIj5cbiAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgY2xhc3M9XCJwYXRoXCJcbiAgICAgICAgICAgIGQ9JHt0aGlzLl9yZW5kZXJBcmModGhpcy5fc3RhcnQsIHRoaXMuX2VuZCl9XG4gICAgICAgICAgICB2ZWN0b3ItZWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCJcbiAgICAgICAgICAvPlxuICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICBjbGFzcz1cImJhclwiXG4gICAgICAgICAgICB2ZWN0b3ItZWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCJcbiAgICAgICAgICAgIGQ9JHt0aGlzLl9yZW5kZXJBcmMoXG4gICAgICAgICAgICAgIHRoaXMuX3ZhbHVlMmFuZ2xlKHRoaXMubG93ICE9IG51bGwgPyB0aGlzLmxvdyA6IHRoaXMubWluKSxcbiAgICAgICAgICAgICAgdGhpcy5fdmFsdWUyYW5nbGUodGhpcy5oaWdoICE9IG51bGwgPyB0aGlzLmhpZ2ggOiB0aGlzLnZhbHVlKVxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAvPlxuICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICBjbGFzcz1cInNoYWRvd3BhdGhcIlxuICAgICAgICAgICAgZD0ke3RoaXMuX3JlbmRlckFyYyh0aGlzLl9zdGFydCwgdGhpcy5fZW5kKX1cbiAgICAgICAgICAgIHZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIlxuICAgICAgICAgICAgc3Ryb2tlPVwicmdiYSgwLDAsMCwwKVwiXG4gICAgICAgICAgICBzdHJva2Utd2lkdGg9XCIkezMqdGhpcy5oYW5kbGVTaXplKnRoaXMuX3NjYWxlfVwiXG4gICAgICAgICAgICBzdHJva2UtbGluZWNhcD1cImJ1dHRcIlxuICAgICAgICAgIC8+XG5cbiAgICAgICAgPC9nPlxuXG4gICAgICAgIDxnIGNsYXNzPVwiaGFuZGxlc1wiPlxuICAgICAgICAkeyB0aGlzLl9zaG93SGFuZGxlXG4gICAgICAgICAgPyB0aGlzLmxvdyAhPSBudWxsXG4gICAgICAgICAgICAgID8gdGhpcy5fcmV2ZXJzZU9yZGVyXG4gICAgICAgICAgICAgICAgPyBodG1sYCR7dGhpcy5fcmVuZGVySGFuZGxlKFwiaGlnaFwiKX0gJHt0aGlzLl9yZW5kZXJIYW5kbGUoXCJsb3dcIil9YFxuICAgICAgICAgICAgICAgIDogaHRtbGAke3RoaXMuX3JlbmRlckhhbmRsZShcImxvd1wiKX0gJHt0aGlzLl9yZW5kZXJIYW5kbGUoXCJoaWdoXCIpfWBcbiAgICAgICAgICAgICAgOiBodG1sYCR7dGhpcy5fcmVuZGVySGFuZGxlKFwidmFsdWVcIil9YFxuICAgICAgICAgIDogYGBcbiAgICAgICAgfVxuICAgICAgICA8L2c+XG4gICAgICA8L3N2Zz5cbiAgICBgO1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHlsZXMoKSB7XG4gICAgcmV0dXJuIGNzc2BcbiAgICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgIH1cbiAgICAgIHN2ZyB7XG4gICAgICAgIG92ZXJmbG93OiB2aXNpYmxlO1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgIH1cbiAgICAgIHBhdGgge1xuICAgICAgICB0cmFuc2l0aW9uOiBzdHJva2UgMXMgZWFzZS1vdXQsIHN0cm9rZS13aWR0aCAyMDBtcyBlYXNlLW91dDtcbiAgICAgIH1cbiAgICAgIC5zbGlkZXIge1xuICAgICAgICBmaWxsOiBub25lO1xuICAgICAgICBzdHJva2Utd2lkdGg6IHZhcigtLXJvdW5kLXNsaWRlci1wYXRoLXdpZHRoLCAzKTtcbiAgICAgICAgc3Ryb2tlLWxpbmVjYXA6IHZhcigtLXJvdW5kLXNsaWRlci1saW5lY2FwLCByb3VuZCk7XG4gICAgICB9XG4gICAgICAucGF0aCB7XG4gICAgICAgIHN0cm9rZTogdmFyKC0tcm91bmQtc2xpZGVyLXBhdGgtY29sb3IsIGxpZ2h0Z3JheSk7XG4gICAgICB9XG4gICAgICAuYmFyIHtcbiAgICAgICAgc3Ryb2tlOiB2YXIoLS1yb3VuZC1zbGlkZXItYmFyLWNvbG9yLCBkZWVwc2t5Ymx1ZSk7XG4gICAgICB9XG4gICAgICBzdmdbZGlzYWJsZWRdIC5iYXIge1xuICAgICAgICBzdHJva2U6IHZhcigtLXJvdW5kLXNsaWRlci1kaXNhYmxlZC1iYXItY29sb3IsIGRhcmtncmF5KTtcbiAgICAgIH1cbiAgICAgIGcuaGFuZGxlcyB7XG4gICAgICAgIHN0cm9rZTogdmFyKC0tcm91bmQtc2xpZGVyLWhhbmRsZS1jb2xvciwgdmFyKC0tcm91bmQtc2xpZGVyLWJhci1jb2xvciwgZGVlcHNreWJsdWUpKTtcbiAgICAgICAgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xuICAgICAgfVxuICAgICAgZy5sb3cuaGFuZGxlIHtcbiAgICAgICAgc3Ryb2tlOiB2YXIoLS1yb3VuZC1zbGlkZXItbG93LWhhbmRsZS1jb2xvcik7XG4gICAgICB9XG4gICAgICBnLmhpZ2guaGFuZGxlIHtcbiAgICAgICAgc3Ryb2tlOiB2YXIoLS1yb3VuZC1zbGlkZXItaGlnaC1oYW5kbGUtY29sb3IpO1xuICAgICAgfVxuICAgICAgc3ZnW2Rpc2FibGVkXSBnLmhhbmRsZXMge1xuICAgICAgICBzdHJva2U6IHZhcigtLXJvdW5kLXNsaWRlci1kaXNhYmxlZC1iYXItY29sb3IsIGRhcmtncmF5KTtcbiAgICAgIH1cbiAgICAgIC5oYW5kbGU6Zm9jdXMge1xuICAgICAgICBvdXRsaW5lOiB1bnNldDtcbiAgICAgIH1cbiAgICBgO1xuICB9XG5cbn1cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgncm91bmQtc2xpZGVyJywgUm91bmRTbGlkZXIpO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQU1BOzs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBbEJBO0FBb0JBOzs7QUFFQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWRBO0FBZUE7QUFDQTs7O0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUErQkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTs7O0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUtBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBREE7QUFLQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFPQTs7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFPQTtBQUNBO0FBQUE7QUFrQ0E7OztBQUVBO0FBQ0E7QUFFQTtBQStDQTs7O0FBclhBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUE0QkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBSEE7QUFLQTs7O0FBaVRBO0FBQ0E7QUEyQ0E7Ozs7QUE3Y0E7QUFDQTtBQStjQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@thomasloven/round-slider/src/main.js\n");

/***/ }),

/***/ "./node_modules/deep-freeze/index.js":
/*!*******************************************!*\
  !*** ./node_modules/deep-freeze/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nmodule.exports = function deepFreeze(o) {\n  Object.freeze(o);\n  Object.getOwnPropertyNames(o).forEach(function (prop) {\n    if (o.hasOwnProperty(prop) && o[prop] !== null && (_typeof(o[prop]) === \"object\" || typeof o[prop] === \"function\") && !Object.isFrozen(o[prop])) {\n      deepFreeze(o[prop]);\n    }\n  });\n  return o;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcC1mcmVlemUvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcC1mcmVlemUvaW5kZXguanM/Yjg4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZXBGcmVlemUgKG8pIHtcbiAgT2JqZWN0LmZyZWV6ZShvKTtcblxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgaWYgKG8uaGFzT3duUHJvcGVydHkocHJvcClcbiAgICAmJiBvW3Byb3BdICE9PSBudWxsXG4gICAgJiYgKHR5cGVvZiBvW3Byb3BdID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvW3Byb3BdID09PSBcImZ1bmN0aW9uXCIpXG4gICAgJiYgIU9iamVjdC5pc0Zyb3plbihvW3Byb3BdKSkge1xuICAgICAgZGVlcEZyZWV6ZShvW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuICBcbiAgcmV0dXJuIG87XG59O1xuIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deep-freeze/index.js\n");

/***/ })

}]);