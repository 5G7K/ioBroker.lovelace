(self["webpackJsonp"] = self["webpackJsonp"] || []).push([["vendors~hui-alarm-panel-card-editor~hui-button-card-editor~hui-conditional-card-editor~hui-entities-~37aad430"],{

/***/ "./node_modules/superstruct/lib/index.es.js":
/*!**************************************************!*\
  !*** ./node_modules/superstruct/lib/index.es.js ***!
  \**************************************************/
/*! exports provided: struct, superstruct, isStruct, StructError */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"struct\", function() { return struct; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"superstruct\", function() { return superstruct; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isStruct\", function() { return isStruct; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StructError\", function() { return StructError; });\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e4) { throw _e4; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e5) { didErr = true; err = _e5; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * Define a struct error.\n *\n * @type {StructError}\n */\nvar StructError = /*#__PURE__*/function (_TypeError) {\n  _inherits(StructError, _TypeError);\n\n  var _super = _createSuper(StructError);\n\n  _createClass(StructError, null, [{\n    key: \"format\",\n    value: function format(attrs) {\n      var type = attrs.type,\n          path = attrs.path,\n          value = attrs.value;\n      var message = \"Expected a value of type `\".concat(type, \"`\").concat(path.length ? \" for `\".concat(path.join('.'), \"`\") : '', \" but received `\").concat(JSON.stringify(value), \"`.\");\n      return message;\n    }\n  }]);\n\n  function StructError(attrs) {\n    var _this;\n\n    _classCallCheck(this, StructError);\n\n    var message = StructError.format(attrs);\n    _this = _super.call(this, message);\n    var data = attrs.data,\n        path = attrs.path,\n        value = attrs.value,\n        reason = attrs.reason,\n        type = attrs.type,\n        _attrs$errors = attrs.errors,\n        errors = _attrs$errors === void 0 ? [] : _attrs$errors;\n    _this.data = data;\n    _this.path = path;\n    _this.value = value;\n    _this.reason = reason;\n    _this.type = type;\n    _this.errors = errors;\n\n    if (!errors.length) {\n      errors.push(_assertThisInitialized(_this));\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(_assertThisInitialized(_this), _this.constructor);\n    } else {\n      _this.stack = new Error().stack;\n    }\n\n    return _this;\n  }\n\n  return StructError;\n}( /*#__PURE__*/_wrapNativeSuper(TypeError));\n\nvar toString = Object.prototype.toString;\n\nvar kindOf = function kindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n\n  var type = _typeof(val);\n\n  if (type === 'boolean') return 'boolean';\n  if (type === 'string') return 'string';\n  if (type === 'number') return 'number';\n  if (type === 'symbol') return 'symbol';\n\n  if (type === 'function') {\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\n  }\n\n  if (isArray(val)) return 'array';\n  if (isBuffer(val)) return 'buffer';\n  if (isArguments(val)) return 'arguments';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  if (isRegexp(val)) return 'regexp';\n\n  switch (ctorName(val)) {\n    case 'Symbol':\n      return 'symbol';\n\n    case 'Promise':\n      return 'promise';\n    // Set, Map, WeakSet, WeakMap\n\n    case 'WeakMap':\n      return 'weakmap';\n\n    case 'WeakSet':\n      return 'weakset';\n\n    case 'Map':\n      return 'map';\n\n    case 'Set':\n      return 'set';\n    // 8-bit typed arrays\n\n    case 'Int8Array':\n      return 'int8array';\n\n    case 'Uint8Array':\n      return 'uint8array';\n\n    case 'Uint8ClampedArray':\n      return 'uint8clampedarray';\n    // 16-bit typed arrays\n\n    case 'Int16Array':\n      return 'int16array';\n\n    case 'Uint16Array':\n      return 'uint16array';\n    // 32-bit typed arrays\n\n    case 'Int32Array':\n      return 'int32array';\n\n    case 'Uint32Array':\n      return 'uint32array';\n\n    case 'Float32Array':\n      return 'float32array';\n\n    case 'Float64Array':\n      return 'float64array';\n  }\n\n  if (isGeneratorObj(val)) {\n    return 'generator';\n  } // Non-plain objects\n\n\n  type = toString.call(val);\n\n  switch (type) {\n    case '[object Object]':\n      return 'object';\n    // iterators\n\n    case '[object Map Iterator]':\n      return 'mapiterator';\n\n    case '[object Set Iterator]':\n      return 'setiterator';\n\n    case '[object String Iterator]':\n      return 'stringiterator';\n\n    case '[object Array Iterator]':\n      return 'arrayiterator';\n  } // other\n\n\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n};\n\nfunction ctorName(val) {\n  return val.constructor ? val.constructor.name : null;\n}\n\nfunction isArray(val) {\n  if (Array.isArray) return Array.isArray(val);\n  return val instanceof Array;\n}\n\nfunction isError(val) {\n  return val instanceof Error || typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number';\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function' && typeof val.getDate === 'function' && typeof val.setDate === 'function';\n}\n\nfunction isRegexp(val) {\n  if (val instanceof RegExp) return true;\n  return typeof val.flags === 'string' && typeof val.ignoreCase === 'boolean' && typeof val.multiline === 'boolean' && typeof val.global === 'boolean';\n}\n\nfunction isGeneratorFn(name, val) {\n  return ctorName(name) === 'GeneratorFunction';\n}\n\nfunction isGeneratorObj(val) {\n  return typeof val[\"throw\"] === 'function' && typeof val[\"return\"] === 'function' && typeof val.next === 'function';\n}\n\nfunction isArguments(val) {\n  try {\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\n      return true;\n    }\n  } catch (err) {\n    if (err.message.indexOf('callee') !== -1) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * If you need to support Safari 5-7 (8-10 yr-old browser),\n * take a look at https://github.com/feross/is-buffer\n */\n\n\nfunction isBuffer(val) {\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\n    return val.constructor.isBuffer(val);\n  }\n\n  return false;\n}\n/**\n * A private string to identify structs by.\n *\n * @type {String}\n */\n\n\nvar IS_STRUCT = '@@__STRUCT__@@';\n/**\n * A private string to refer to a struct's kind.\n *\n * @type {String}\n */\n\nvar KIND = '@@__KIND__@@';\n/**\n * Check if a `value` is a struct.\n *\n * @param {Any} value\n * @return {Boolean}\n */\n\nfunction isStruct(value) {\n  return !!(value && value[IS_STRUCT]);\n}\n/**\n * Resolve `defaults`, for an optional `value`.\n *\n * @param {Function|Any} defaults\n * @param {Any} value\n * @return {Any}\n */\n\n\nfunction resolveDefaults(defaults, value) {\n  return typeof defaults === 'function' ? defaults(value) : defaults;\n}\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n/**\n * Kind.\n *\n * @type {Kind}\n */\n\n\nvar Kind = function Kind(name, type, validate) {\n  _classCallCheck(this, Kind);\n\n  this.name = name;\n  this.type = type;\n  this.validate = validate;\n};\n/**\n * Any.\n *\n * @param {Array|Function|Object|String} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction any(schema, defaults$$1, options) {\n  if (isStruct(schema)) {\n    return schema[KIND];\n  }\n\n  if (schema instanceof Kind) {\n    return schema;\n  }\n\n  switch (kindOf(schema)) {\n    case 'array':\n      {\n        return schema.length > 1 ? tuple(schema, defaults$$1, options) : list(schema, defaults$$1, options);\n      }\n\n    case 'function':\n      {\n        return func(schema, defaults$$1, options);\n      }\n\n    case 'object':\n      {\n        return object(schema, defaults$$1, options);\n      }\n\n    case 'string':\n      {\n        var required = true;\n        var type;\n\n        if (schema.endsWith('?')) {\n          required = false;\n          schema = schema.slice(0, -1);\n        }\n\n        if (schema.includes('|')) {\n          var scalars = schema.split(/\\s*\\|\\s*/g);\n          type = union(scalars, defaults$$1, options);\n        } else if (schema.includes('&')) {\n          var _scalars = schema.split(/\\s*&\\s*/g);\n\n          type = intersection(_scalars, defaults$$1, options);\n        } else {\n          type = scalar(schema, defaults$$1, options);\n        }\n\n        if (!required) {\n          type = optional(type, undefined, options);\n        }\n\n        return type;\n      }\n  }\n\n  if (true) {\n    throw new Error(\"A schema definition must be an object, array, string or function, but you passed: \".concat(schema));\n  } else {}\n}\n/**\n * Dict.\n *\n * @param {Array} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\n\nfunction dict(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array' || schema.length !== 2) {\n    if (true) {\n      throw new Error(\"Dict structs must be defined as an array with two elements, but you passed: \".concat(schema));\n    } else {}\n  }\n\n  var obj = scalar('object', undefined, options);\n  var keys = any(schema[0], undefined, options);\n  var values = any(schema[1], undefined, options);\n  var name = 'dict';\n  var type = \"dict<\".concat(keys.type, \",\").concat(values.type, \">\");\n\n  var validate = function validate(value) {\n    var resolved = resolveDefaults(defaults$$1);\n    value = resolved ? _extends({}, resolved, value) : value;\n\n    var _obj$validate = obj.validate(value),\n        _obj$validate2 = _slicedToArray(_obj$validate, 1),\n        error = _obj$validate2[0];\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    var ret = {};\n    var errors = [];\n\n    var _loop = function _loop(_k) {\n      var v = value[_k];\n\n      var _keys$validate = keys.validate(_k),\n          _keys$validate2 = _slicedToArray(_keys$validate, 2),\n          e = _keys$validate2[0],\n          r = _keys$validate2[1];\n\n      if (e) {\n        var allE = e.errors || [e];\n        allE.forEach(function (singleE) {\n          singleE.path = [_k].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        k = _k;\n        return \"continue\";\n      }\n\n      _k = r;\n\n      var _values$validate = values.validate(v),\n          _values$validate2 = _slicedToArray(_values$validate, 2),\n          e2 = _values$validate2[0],\n          r2 = _values$validate2[1];\n\n      if (e2) {\n        var allE2 = e2.errors || [e2];\n        allE2.forEach(function (singleE) {\n          singleE.path = [_k].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        k = _k;\n        return \"continue\";\n      }\n\n      ret[_k] = r2;\n      k = _k;\n    };\n\n    for (var k in value) {\n      var _ret = _loop(k);\n\n      if (_ret === \"continue\") continue;\n    }\n\n    return errors.length ? [_extends({}, errors[0], {\n      errors: errors\n    })] : [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Enum.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction en(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array') {\n    if (true) {\n      throw new Error(\"Enum structs must be defined as an array, but you passed: \".concat(schema));\n    } else {}\n  }\n\n  var name = 'enum';\n  var type = schema.map(function (s) {\n    try {\n      return JSON.stringify(s);\n    } catch (e) {\n      return String(s);\n    }\n  }).join(' | ');\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n    return schema.includes(value) ? [undefined, value] : [{\n      data: value,\n      path: [],\n      value: value,\n      type: type\n    }];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Enums.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction enums(schema, defaults$$1, options) {\n  var e = en(schema, undefined, options);\n  var l = list([e], defaults$$1, options);\n  return l;\n}\n/**\n * Function.\n *\n * @param {Function} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction func(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'function') {\n    if (true) {\n      throw new Error(\"Function structs must be defined as a function, but you passed: \".concat(schema));\n    } else {}\n  }\n\n  var name = 'function';\n  var type = '<function>';\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n    var data = arguments.length > 1 ? arguments[1] : undefined;\n    var result = schema(value, data);\n    var failure = {\n      path: [],\n      reason: null\n    };\n    var isValid;\n\n    switch (kindOf(result)) {\n      case 'boolean':\n        {\n          isValid = result;\n          break;\n        }\n\n      case 'string':\n        {\n          isValid = false;\n          failure.reason = result;\n          break;\n        }\n\n      case 'object':\n        {\n          isValid = false;\n          failure = _extends({}, failure, result);\n          break;\n        }\n\n      default:\n        {\n          if (true) {\n            throw new Error(\"Validator functions must return a boolean, an error reason string or an error reason object, but you passed: \".concat(schema));\n          } else {}\n        }\n    }\n\n    return isValid ? [undefined, value] : [_extends({\n      type: type,\n      value: value,\n      data: value\n    }, failure)];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Instance.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction instance(schema, defaults$$1, options) {\n  var name = 'instance';\n  var type = \"instance<\".concat(schema.name, \">\");\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n    return value instanceof schema ? [undefined, value] : [{\n      data: value,\n      path: [],\n      value: value,\n      type: type\n    }];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Interface.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\n\nfunction inter(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'object') {\n    if (true) {\n      throw new Error(\"Interface structs must be defined as an object, but you passed: \".concat(schema));\n    } else {}\n  }\n\n  var obj = scalar('object', undefined, options);\n  var ks = [];\n  var properties = {};\n\n  for (var key in schema) {\n    ks.push(key);\n    var s = schema[key];\n    var kind = any(s, undefined, options);\n    properties[key] = kind;\n  }\n\n  var name = 'interface';\n  var type = \"{\".concat(ks.join(), \"}\");\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n\n    var _obj$validate3 = obj.validate(value),\n        _obj$validate4 = _slicedToArray(_obj$validate3, 1),\n        error = _obj$validate4[0];\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    var errors = [];\n    var ret = value;\n\n    var _loop2 = function _loop2(_key) {\n      var v = value[_key];\n      var kind = properties[_key];\n\n      if (v === undefined) {\n        var d = defaults$$1 && defaults$$1[_key];\n        v = resolveDefaults(d, value);\n      }\n\n      var _kind$validate = kind.validate(v, value),\n          _kind$validate2 = _slicedToArray(_kind$validate, 2),\n          e = _kind$validate2[0],\n          r = _kind$validate2[1];\n\n      if (e) {\n        var allE = e.errors || [e];\n        allE.forEach(function (singleE) {\n          singleE.path = [_key].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        return \"continue\";\n      }\n\n      if (_key in value || r !== undefined) {\n        ret[_key] = r;\n      }\n    };\n\n    for (var _key in properties) {\n      var _ret2 = _loop2(_key);\n\n      if (_ret2 === \"continue\") continue;\n    }\n\n    return errors.length ? [_extends({}, errors[0], {\n      errors: errors\n    })] : [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Lazy.\n *\n * @param {Function} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction lazy(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'function') {\n    if (true) {\n      throw new Error(\"Lazy structs must be defined as an function that returns a schema, but you passed: \".concat(schema));\n    } else {}\n  }\n\n  var kind;\n  var struct;\n  var name = 'lazy';\n  var type = \"lazy...\";\n\n  var compile = function compile(value) {\n    struct = schema();\n    kind.name = struct.kind;\n    kind.type = struct.type;\n    kind.validate = struct.validate;\n    return kind.validate(value);\n  };\n\n  kind = new Kind(name, type, compile);\n  return kind;\n}\n/**\n * Dynamic.\n *\n * @param {Function} createSchema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction dynamic(createSchema, defaults$$1, options) {\n  if (kindOf(createSchema) !== 'function') {\n    if (true) {\n      throw new Error(\"Dynamic structs must be defined as a function, but you passed: \".concat(createSchema));\n    } else {}\n  }\n\n  var name = 'dynamic';\n  var type = 'dynamic...';\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n    var data = arguments.length > 1 ? arguments[1] : undefined;\n    var schema = createSchema(value, data);\n\n    if (kindOf(schema) !== 'function') {\n      if (true) {\n        throw new Error(\"Dynamic structs must return a schema, but you passed: \".concat(schema));\n      } else {}\n    }\n\n    var _schema$validate = schema.validate(value),\n        _schema$validate2 = _slicedToArray(_schema$validate, 2),\n        error = _schema$validate2[0],\n        result = _schema$validate2[1];\n\n    if (error) {\n      return [error];\n    }\n\n    return [undefined, result];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * List.\n *\n * @param {Array} schema\n * @param {Array} defaults\n * @param {Object} options\n */\n\n\nfunction list(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array' || schema.length !== 1) {\n    if (true) {\n      throw new Error(\"List structs must be defined as an array with a single element, but you passed: \".concat(schema));\n    } else {}\n  }\n\n  var array = scalar('array', undefined, options);\n  var element = any(schema[0], undefined, options);\n  var name = 'list';\n  var type = \"[\".concat(element.type, \"]\");\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n\n    var _array$validate = array.validate(value),\n        _array$validate2 = _slicedToArray(_array$validate, 2),\n        error = _array$validate2[0],\n        result = _array$validate2[1];\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    value = result;\n    var errors = [];\n    var ret = [];\n\n    var _loop3 = function _loop3(i) {\n      var v = value[i];\n\n      var _element$validate = element.validate(v),\n          _element$validate2 = _slicedToArray(_element$validate, 2),\n          e = _element$validate2[0],\n          r = _element$validate2[1];\n\n      if (e) {\n        var allE = e.errors || [e];\n        allE.forEach(function (singleE) {\n          singleE.path = [i].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        return \"continue\";\n      }\n\n      ret[i] = r;\n    };\n\n    for (var i = 0; i < value.length; i++) {\n      var _ret3 = _loop3(i);\n\n      if (_ret3 === \"continue\") continue;\n    }\n\n    return errors.length ? [_extends({}, errors[0], {\n      errors: errors\n    })] : [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Literal.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction literal(schema, defaults$$1, options) {\n  var name = 'literal';\n  var type = \"literal: \".concat(JSON.stringify(schema));\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n    return value === schema ? [undefined, value] : [{\n      data: value,\n      path: [],\n      value: value,\n      type: type\n    }];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Object.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\n\nfunction object(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'object') {\n    if (true) {\n      throw new Error(\"Object structs must be defined as an object, but you passed: \".concat(schema));\n    } else {}\n  }\n\n  var obj = scalar('object', undefined, options);\n  var ks = [];\n  var properties = {};\n\n  for (var key in schema) {\n    ks.push(key);\n    var s = schema[key];\n    var kind = any(s, undefined, options);\n    properties[key] = kind;\n  }\n\n  var name = 'object';\n  var type = \"{\".concat(ks.join(), \"}\");\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n\n    var _obj$validate5 = obj.validate(value),\n        _obj$validate6 = _slicedToArray(_obj$validate5, 1),\n        error = _obj$validate6[0];\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    var errors = [];\n    var ret = {};\n    var valueKeys = Object.keys(value);\n    var propertiesKeys = Object.keys(properties);\n    var keys = new Set(valueKeys.concat(propertiesKeys));\n    keys.forEach(function (key) {\n      var v = value[key];\n      var kind = properties[key];\n\n      if (v === undefined) {\n        var d = defaults$$1 && defaults$$1[key];\n        v = resolveDefaults(d, value);\n      }\n\n      if (!kind) {\n        var _e2 = {\n          data: value,\n          path: [key],\n          value: v\n        };\n        errors.push(_e2);\n        return;\n      }\n\n      var _kind$validate3 = kind.validate(v, value),\n          _kind$validate4 = _slicedToArray(_kind$validate3, 2),\n          e = _kind$validate4[0],\n          r = _kind$validate4[1];\n\n      if (e) {\n        var allE = e.errors || [e];\n        allE.forEach(function (singleE) {\n          singleE.path = [key].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        return;\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r;\n      }\n    });\n    return errors.length ? [_extends({}, errors[0], {\n      errors: errors\n    })] : [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Optional.\n *\n * @param {Any} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction optional(schema, defaults$$1, options) {\n  return union([schema, 'undefined'], defaults$$1, options);\n}\n/**\n * Partial.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\n\nfunction partial(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'object') {\n    if (true) {\n      throw new Error(\"Partial structs must be defined as an object, but you passed: \".concat(schema));\n    } else {}\n  }\n\n  var obj = scalar('object', undefined, options);\n  var ks = [];\n  var properties = {};\n\n  for (var key in schema) {\n    ks.push(key);\n    var s = schema[key];\n    var kind = any(s, undefined, options);\n    properties[key] = kind;\n  }\n\n  var name = 'partial';\n  var type = \"{\".concat(ks.join(), \",...}\");\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n\n    var _obj$validate7 = obj.validate(value),\n        _obj$validate8 = _slicedToArray(_obj$validate7, 1),\n        error = _obj$validate8[0];\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    var errors = [];\n    var ret = {};\n\n    var _loop4 = function _loop4(_key2) {\n      var v = value[_key2];\n      var kind = properties[_key2];\n\n      if (v === undefined) {\n        var d = defaults$$1 && defaults$$1[_key2];\n        v = resolveDefaults(d, value);\n      }\n\n      var _kind$validate5 = kind.validate(v, value),\n          _kind$validate6 = _slicedToArray(_kind$validate5, 2),\n          e = _kind$validate6[0],\n          r = _kind$validate6[1];\n\n      if (e) {\n        var allE = e.errors || [e];\n        allE.forEach(function (singleE) {\n          singleE.path = [_key2].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        return \"continue\";\n      }\n\n      if (_key2 in value || r !== undefined) {\n        ret[_key2] = r;\n      }\n    };\n\n    for (var _key2 in properties) {\n      var _ret4 = _loop4(_key2);\n\n      if (_ret4 === \"continue\") continue;\n    }\n\n    return errors.length ? [_extends({}, errors[0], {\n      errors: errors\n    })] : [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Scalar.\n *\n * @param {String} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction scalar(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'string') {\n    if (true) {\n      throw new Error(\"Scalar structs must be defined as a string, but you passed: \".concat(schema));\n    } else {}\n  }\n\n  var types = options.types;\n  var fn = types[schema];\n\n  if (kindOf(fn) !== 'function') {\n    if (true) {\n      throw new Error(\"No struct validator function found for type \\\"\".concat(schema, \"\\\".\"));\n    } else {}\n  }\n\n  var kind = func(fn, defaults$$1, options);\n  var name = 'scalar';\n  var type = schema;\n\n  var validate = function validate(value) {\n    var _kind$validate7 = kind.validate(value),\n        _kind$validate8 = _slicedToArray(_kind$validate7, 2),\n        error = _kind$validate8[0],\n        result = _kind$validate8[1];\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    return [undefined, result];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Tuple.\n *\n * @param {Array} schema\n * @param {Array} defaults\n * @param {Object} options\n */\n\n\nfunction tuple(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array') {\n    if (true) {\n      throw new Error(\"Tuple structs must be defined as an array, but you passed: \".concat(schema));\n    } else {}\n  }\n\n  var kinds = schema.map(function (s) {\n    return any(s, undefined, options);\n  });\n  var array = scalar('array', undefined, options);\n  var name = 'tuple';\n  var type = \"[\".concat(kinds.map(function (k) {\n    return k.type;\n  }).join(), \"]\");\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n\n    var _array$validate3 = array.validate(value),\n        _array$validate4 = _slicedToArray(_array$validate3, 1),\n        error = _array$validate4[0];\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    var ret = [];\n    var errors = [];\n    var length = Math.max(value.length, kinds.length);\n\n    var _loop5 = function _loop5(i) {\n      var kind = kinds[i];\n      var v = value[i];\n\n      if (!kind) {\n        var _e3 = {\n          data: value,\n          path: [i],\n          value: v\n        };\n        errors.push(_e3);\n        return \"continue\";\n      }\n\n      var _kind$validate9 = kind.validate(v),\n          _kind$validate10 = _slicedToArray(_kind$validate9, 2),\n          e = _kind$validate10[0],\n          r = _kind$validate10[1];\n\n      if (e) {\n        var allE = e.errors || [e];\n        allE.forEach(function (singleE) {\n          singleE.path = [i].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        return \"continue\";\n      }\n\n      ret[i] = r;\n    };\n\n    for (var i = 0; i < length; i++) {\n      var _ret5 = _loop5(i);\n\n      if (_ret5 === \"continue\") continue;\n    }\n\n    return errors.length ? [_extends({}, errors[0], {\n      errors: errors\n    })] : [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Union.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction union(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array') {\n    if (true) {\n      throw new Error(\"Union structs must be defined as an array, but you passed: \".concat(schema));\n    } else {}\n  }\n\n  var kinds = schema.map(function (s) {\n    return any(s, undefined, options);\n  });\n  var name = 'union';\n  var type = kinds.map(function (k) {\n    return k.type;\n  }).join(' | ');\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n    var errors = [];\n\n    var _iterator = _createForOfIteratorHelper(kinds),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _k2 = _step.value;\n\n        var _k2$validate = _k2.validate(value),\n            _k2$validate2 = _slicedToArray(_k2$validate, 2),\n            e = _k2$validate2[0],\n            r = _k2$validate2[1];\n\n        if (!e) {\n          return [undefined, r];\n        }\n\n        errors.push(e);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    errors[0].type = type;\n    return errors;\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Intersection.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction intersection(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array') {\n    if (true) {\n      throw new Error(\"Intersection structs must be defined as an array, but you passed: \".concat(schema));\n    } else {}\n  }\n\n  var types = schema.map(function (s) {\n    return any(s, undefined, options);\n  });\n  var name = 'intersection';\n  var type = types.map(function (t) {\n    return t.type;\n  }).join(' & ');\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n    var v = value;\n\n    var _iterator2 = _createForOfIteratorHelper(types),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var t = _step2.value;\n\n        var _t$validate = t.validate(v),\n            _t$validate2 = _slicedToArray(_t$validate, 2),\n            e = _t$validate2[0],\n            r = _t$validate2[1];\n\n        if (e) {\n          e.type = type;\n          return [e];\n        }\n\n        v = r;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return [undefined, v];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Kinds.\n *\n * @type {Object}\n */\n\n\nvar Kinds = {\n  any: any,\n  dict: dict,\n  \"enum\": en,\n  enums: enums,\n  \"function\": func,\n  instance: instance,\n  \"interface\": inter,\n  lazy: lazy,\n  list: list,\n  literal: literal,\n  object: object,\n  optional: optional,\n  partial: partial,\n  scalar: scalar,\n  tuple: tuple,\n  union: union,\n  intersection: intersection,\n  dynamic: dynamic\n  /**\n   * Export.\n   *\n   * @type {Object}\n   */\n\n};\n/**\n * The types that `kind-of` supports.\n *\n * @type {Array}\n */\n\nvar TYPES = ['arguments', 'array', 'boolean', 'buffer', 'error', 'float32array', 'float64array', 'function', 'generatorfunction', 'int16array', 'int32array', 'int8array', 'map', 'null', 'number', 'object', 'promise', 'regexp', 'set', 'string', 'symbol', 'uint16array', 'uint32array', 'uint8array', 'uint8clampedarray', 'undefined', 'weakmap', 'weakset'];\n/**\n * The default types that Superstruct ships with.\n *\n * @type {Object}\n */\n\nvar Types = {\n  any: function any(value) {\n    return value !== undefined;\n  }\n};\nTYPES.forEach(function (type) {\n  Types[type] = function (value) {\n    return kindOf(value) === type;\n  };\n});\n/**\n * Handle the 'date' case specially, to throw out invalid `Date` objects.\n *\n * @param {Mixed} value\n * @return {Boolean}\n */\n\nTypes.date = function (value) {\n  return kindOf(value) === 'date' && !isNaN(value);\n};\n/**\n * Create a struct factory with a `config`.\n *\n * @param {Object} config\n * @return {Function}\n */\n\n\nfunction superstruct() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var types = _extends({}, Types, config.types || {});\n  /**\n   * Create a `kind` struct with `schema`, `defaults` and `options`.\n   *\n   * @param {Any} schema\n   * @param {Any} defaults\n   * @param {Object} options\n   * @return {Function}\n   */\n\n\n  function struct(schema, defaults$$1) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (isStruct(schema)) {\n      schema = schema.schema;\n    }\n\n    var kind = Kinds.any(schema, defaults$$1, _extends({}, options, {\n      types: types\n    }));\n\n    function Struct(data) {\n      if (this instanceof Struct) {\n        if (true) {\n          throw new Error('The `Struct` creation function should not be used with the `new` keyword.');\n        } else {}\n      }\n\n      return Struct.assert(data);\n    }\n\n    Object.defineProperty(Struct, IS_STRUCT, {\n      value: true\n    });\n    Object.defineProperty(Struct, KIND, {\n      value: kind\n    });\n    Struct.kind = kind.name;\n    Struct.type = kind.type;\n    Struct.schema = schema;\n    Struct.defaults = defaults$$1;\n    Struct.options = options;\n\n    Struct.assert = function (value) {\n      var _kind$validate11 = kind.validate(value),\n          _kind$validate12 = _slicedToArray(_kind$validate11, 2),\n          error = _kind$validate12[0],\n          result = _kind$validate12[1];\n\n      if (error) {\n        throw new StructError(error);\n      }\n\n      return result;\n    };\n\n    Struct.test = function (value) {\n      var _kind$validate13 = kind.validate(value),\n          _kind$validate14 = _slicedToArray(_kind$validate13, 1),\n          error = _kind$validate14[0];\n\n      return !error;\n    };\n\n    Struct.validate = function (value) {\n      var _kind$validate15 = kind.validate(value),\n          _kind$validate16 = _slicedToArray(_kind$validate15, 2),\n          error = _kind$validate16[0],\n          result = _kind$validate16[1];\n\n      if (error) {\n        return [new StructError(error)];\n      }\n\n      return [undefined, result];\n    };\n\n    return Struct;\n  }\n  /**\n   * Mix in a factory for each specific kind of struct.\n   */\n\n\n  Object.keys(Kinds).forEach(function (name) {\n    var kind = Kinds[name];\n\n    struct[name] = function (schema, defaults$$1, options) {\n      var type = kind(schema, defaults$$1, _extends({}, options, {\n        types: types\n      }));\n      var s = struct(type, defaults$$1, options);\n      return s;\n    };\n  });\n  /**\n   * Return the struct factory.\n   */\n\n  return struct;\n}\n/**\n * Create a convenience `struct` factory for the default types.\n *\n * @type {Function}\n */\n\n\nvar struct = superstruct();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3VwZXJzdHJ1Y3QvbGliL2luZGV4LmVzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL3NyYy9lcnJvci5qcz83OWYxIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMva2luZC1vZi9pbmRleC5qcz82MGVlIiwid2VicGFjazovLy8uLi9zcmMvY29uc3RhbnRzLmpzPzQ3YzgiLCJ3ZWJwYWNrOi8vLy4uL3NyYy91dGlscy5qcz81MGYzIiwid2VicGFjazovLy8uLi9zcmMva2luZHMuanM/MTkwYiIsIndlYnBhY2s6Ly8vLi4vc3JjL3R5cGVzLmpzPzI5NGEiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9zdXBlcnN0cnVjdC5qcz9hZTdmIiwid2VicGFjazovLy8uLi9zcmMvaW5kZXguanM/YTE3OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIERlZmluZSBhIHN0cnVjdCBlcnJvci5cbiAqXG4gKiBAdHlwZSB7U3RydWN0RXJyb3J9XG4gKi9cblxuY2xhc3MgU3RydWN0RXJyb3IgZXh0ZW5kcyBUeXBlRXJyb3Ige1xuICBzdGF0aWMgZm9ybWF0KGF0dHJzKSB7XG4gICAgY29uc3QgeyB0eXBlLCBwYXRoLCB2YWx1ZSB9ID0gYXR0cnNcbiAgICBjb25zdCBtZXNzYWdlID0gYEV4cGVjdGVkIGEgdmFsdWUgb2YgdHlwZSBcXGAke3R5cGV9XFxgJHtcbiAgICAgIHBhdGgubGVuZ3RoID8gYCBmb3IgXFxgJHtwYXRoLmpvaW4oJy4nKX1cXGBgIDogJydcbiAgICB9IGJ1dCByZWNlaXZlZCBcXGAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1cXGAuYFxuICAgIHJldHVybiBtZXNzYWdlXG4gIH1cblxuICBjb25zdHJ1Y3RvcihhdHRycykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBTdHJ1Y3RFcnJvci5mb3JtYXQoYXR0cnMpXG4gICAgc3VwZXIobWVzc2FnZSlcblxuICAgIGNvbnN0IHsgZGF0YSwgcGF0aCwgdmFsdWUsIHJlYXNvbiwgdHlwZSwgZXJyb3JzID0gW10gfSA9IGF0dHJzXG4gICAgdGhpcy5kYXRhID0gZGF0YVxuICAgIHRoaXMucGF0aCA9IHBhdGhcbiAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvblxuICAgIHRoaXMudHlwZSA9IHR5cGVcbiAgICB0aGlzLmVycm9ycyA9IGVycm9yc1xuXG4gICAgaWYgKCFlcnJvcnMubGVuZ3RoKSB7XG4gICAgICBlcnJvcnMucHVzaCh0aGlzKVxuICAgIH1cblxuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3RvcilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRXhwb3J0LlxuICpcbiAqIEB0eXBlIHtTdHJ1Y3RFcnJvcn1cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBTdHJ1Y3RFcnJvclxuIiwidmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBraW5kT2YodmFsKSB7XG4gIGlmICh2YWwgPT09IHZvaWQgMCkgcmV0dXJuICd1bmRlZmluZWQnO1xuICBpZiAodmFsID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdib29sZWFuJykgcmV0dXJuICdib29sZWFuJztcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSByZXR1cm4gJ3N0cmluZyc7XG4gIGlmICh0eXBlID09PSAnbnVtYmVyJykgcmV0dXJuICdudW1iZXInO1xuICBpZiAodHlwZSA9PT0gJ3N5bWJvbCcpIHJldHVybiAnc3ltYm9sJztcbiAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gaXNHZW5lcmF0b3JGbih2YWwpID8gJ2dlbmVyYXRvcmZ1bmN0aW9uJyA6ICdmdW5jdGlvbic7XG4gIH1cblxuICBpZiAoaXNBcnJheSh2YWwpKSByZXR1cm4gJ2FycmF5JztcbiAgaWYgKGlzQnVmZmVyKHZhbCkpIHJldHVybiAnYnVmZmVyJztcbiAgaWYgKGlzQXJndW1lbnRzKHZhbCkpIHJldHVybiAnYXJndW1lbnRzJztcbiAgaWYgKGlzRGF0ZSh2YWwpKSByZXR1cm4gJ2RhdGUnO1xuICBpZiAoaXNFcnJvcih2YWwpKSByZXR1cm4gJ2Vycm9yJztcbiAgaWYgKGlzUmVnZXhwKHZhbCkpIHJldHVybiAncmVnZXhwJztcblxuICBzd2l0Y2ggKGN0b3JOYW1lKHZhbCkpIHtcbiAgICBjYXNlICdTeW1ib2wnOiByZXR1cm4gJ3N5bWJvbCc7XG4gICAgY2FzZSAnUHJvbWlzZSc6IHJldHVybiAncHJvbWlzZSc7XG5cbiAgICAvLyBTZXQsIE1hcCwgV2Vha1NldCwgV2Vha01hcFxuICAgIGNhc2UgJ1dlYWtNYXAnOiByZXR1cm4gJ3dlYWttYXAnO1xuICAgIGNhc2UgJ1dlYWtTZXQnOiByZXR1cm4gJ3dlYWtzZXQnO1xuICAgIGNhc2UgJ01hcCc6IHJldHVybiAnbWFwJztcbiAgICBjYXNlICdTZXQnOiByZXR1cm4gJ3NldCc7XG5cbiAgICAvLyA4LWJpdCB0eXBlZCBhcnJheXNcbiAgICBjYXNlICdJbnQ4QXJyYXknOiByZXR1cm4gJ2ludDhhcnJheSc7XG4gICAgY2FzZSAnVWludDhBcnJheSc6IHJldHVybiAndWludDhhcnJheSc7XG4gICAgY2FzZSAnVWludDhDbGFtcGVkQXJyYXknOiByZXR1cm4gJ3VpbnQ4Y2xhbXBlZGFycmF5JztcblxuICAgIC8vIDE2LWJpdCB0eXBlZCBhcnJheXNcbiAgICBjYXNlICdJbnQxNkFycmF5JzogcmV0dXJuICdpbnQxNmFycmF5JztcbiAgICBjYXNlICdVaW50MTZBcnJheSc6IHJldHVybiAndWludDE2YXJyYXknO1xuXG4gICAgLy8gMzItYml0IHR5cGVkIGFycmF5c1xuICAgIGNhc2UgJ0ludDMyQXJyYXknOiByZXR1cm4gJ2ludDMyYXJyYXknO1xuICAgIGNhc2UgJ1VpbnQzMkFycmF5JzogcmV0dXJuICd1aW50MzJhcnJheSc7XG4gICAgY2FzZSAnRmxvYXQzMkFycmF5JzogcmV0dXJuICdmbG9hdDMyYXJyYXknO1xuICAgIGNhc2UgJ0Zsb2F0NjRBcnJheSc6IHJldHVybiAnZmxvYXQ2NGFycmF5JztcbiAgfVxuXG4gIGlmIChpc0dlbmVyYXRvck9iaih2YWwpKSB7XG4gICAgcmV0dXJuICdnZW5lcmF0b3InO1xuICB9XG5cbiAgLy8gTm9uLXBsYWluIG9iamVjdHNcbiAgdHlwZSA9IHRvU3RyaW5nLmNhbGwodmFsKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnW29iamVjdCBPYmplY3RdJzogcmV0dXJuICdvYmplY3QnO1xuICAgIC8vIGl0ZXJhdG9yc1xuICAgIGNhc2UgJ1tvYmplY3QgTWFwIEl0ZXJhdG9yXSc6IHJldHVybiAnbWFwaXRlcmF0b3InO1xuICAgIGNhc2UgJ1tvYmplY3QgU2V0IEl0ZXJhdG9yXSc6IHJldHVybiAnc2V0aXRlcmF0b3InO1xuICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nIEl0ZXJhdG9yXSc6IHJldHVybiAnc3RyaW5naXRlcmF0b3InO1xuICAgIGNhc2UgJ1tvYmplY3QgQXJyYXkgSXRlcmF0b3JdJzogcmV0dXJuICdhcnJheWl0ZXJhdG9yJztcbiAgfVxuXG4gIC8vIG90aGVyXG4gIHJldHVybiB0eXBlLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccy9nLCAnJyk7XG59O1xuXG5mdW5jdGlvbiBjdG9yTmFtZSh2YWwpIHtcbiAgcmV0dXJuIHZhbC5jb25zdHJ1Y3RvciA/IHZhbC5jb25zdHJ1Y3Rvci5uYW1lIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHJldHVybiBBcnJheS5pc0FycmF5KHZhbCk7XG4gIHJldHVybiB2YWwgaW5zdGFuY2VvZiBBcnJheTtcbn1cblxuZnVuY3Rpb24gaXNFcnJvcih2YWwpIHtcbiAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIEVycm9yIHx8ICh0eXBlb2YgdmFsLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmIHZhbC5jb25zdHJ1Y3RvciAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLnN0YWNrVHJhY2VMaW1pdCA9PT0gJ251bWJlcicpO1xufVxuXG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIHR5cGVvZiB2YWwudG9EYXRlU3RyaW5nID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIHZhbC5nZXREYXRlID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIHZhbC5zZXREYXRlID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc1JlZ2V4cCh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIFJlZ0V4cCkgcmV0dXJuIHRydWU7XG4gIHJldHVybiB0eXBlb2YgdmFsLmZsYWdzID09PSAnc3RyaW5nJ1xuICAgICYmIHR5cGVvZiB2YWwuaWdub3JlQ2FzZSA9PT0gJ2Jvb2xlYW4nXG4gICAgJiYgdHlwZW9mIHZhbC5tdWx0aWxpbmUgPT09ICdib29sZWFuJ1xuICAgICYmIHR5cGVvZiB2YWwuZ2xvYmFsID09PSAnYm9vbGVhbic7XG59XG5cbmZ1bmN0aW9uIGlzR2VuZXJhdG9yRm4obmFtZSwgdmFsKSB7XG4gIHJldHVybiBjdG9yTmFtZShuYW1lKSA9PT0gJ0dlbmVyYXRvckZ1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNHZW5lcmF0b3JPYmoodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsLnRocm93ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIHZhbC5yZXR1cm4gPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgdmFsLm5leHQgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbCkge1xuICB0cnkge1xuICAgIGlmICh0eXBlb2YgdmFsLmxlbmd0aCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbC5jYWxsZWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyci5tZXNzYWdlLmluZGV4T2YoJ2NhbGxlZScpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBJZiB5b3UgbmVlZCB0byBzdXBwb3J0IFNhZmFyaSA1LTcgKDgtMTAgeXItb2xkIGJyb3dzZXIpLFxuICogdGFrZSBhIGxvb2sgYXQgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9pcy1idWZmZXJcbiAqL1xuXG5mdW5jdGlvbiBpc0J1ZmZlcih2YWwpIHtcbiAgaWYgKHZhbC5jb25zdHJ1Y3RvciAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih2YWwpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsIi8qKlxuICogQSBwcml2YXRlIHN0cmluZyB0byBpZGVudGlmeSBzdHJ1Y3RzIGJ5LlxuICpcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cblxuY29uc3QgSVNfU1RSVUNUID0gJ0BAX19TVFJVQ1RfX0BAJ1xuXG4vKipcbiAqIEEgcHJpdmF0ZSBzdHJpbmcgdG8gcmVmZXIgdG8gYSBzdHJ1Y3QncyBraW5kLlxuICpcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cblxuY29uc3QgS0lORCA9ICdAQF9fS0lORF9fQEAnXG5cbi8qKlxuICogRXhwb3J0LlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxuZXhwb3J0IHsgSVNfU1RSVUNULCBLSU5EIH1cbiIsImltcG9ydCB7IElTX1NUUlVDVCB9IGZyb20gJy4vY29uc3RhbnRzJ1xuXG4vKipcbiAqIENoZWNrIGlmIGEgYHZhbHVlYCBpcyBhIHN0cnVjdC5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RydWN0KHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtJU19TVFJVQ1RdKVxufVxuXG4vKipcbiAqIFJlc29sdmUgYGRlZmF1bHRzYCwgZm9yIGFuIG9wdGlvbmFsIGB2YWx1ZWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbnxBbnl9IGRlZmF1bHRzXG4gKiBAcGFyYW0ge0FueX0gdmFsdWVcbiAqIEByZXR1cm4ge0FueX1cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZURlZmF1bHRzKGRlZmF1bHRzLCB2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIGRlZmF1bHRzID09PSAnZnVuY3Rpb24nID8gZGVmYXVsdHModmFsdWUpIDogZGVmYXVsdHNcbn1cbiIsImltcG9ydCBraW5kT2YgZnJvbSAna2luZC1vZidcblxuaW1wb3J0IHsgS0lORCB9IGZyb20gJy4vY29uc3RhbnRzJ1xuaW1wb3J0IHsgaXNTdHJ1Y3QsIHJlc29sdmVEZWZhdWx0cyB9IGZyb20gJy4vdXRpbHMnXG5cbi8qKlxuICogS2luZC5cbiAqXG4gKiBAdHlwZSB7S2luZH1cbiAqL1xuXG5jbGFzcyBLaW5kIHtcbiAgY29uc3RydWN0b3IobmFtZSwgdHlwZSwgdmFsaWRhdGUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgdGhpcy50eXBlID0gdHlwZVxuICAgIHRoaXMudmFsaWRhdGUgPSB2YWxpZGF0ZVxuICB9XG59XG5cbi8qKlxuICogQW55LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb258T2JqZWN0fFN0cmluZ30gc2NoZW1hXG4gKiBAcGFyYW0ge0FueX0gZGVmYXVsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gYW55KHNjaGVtYSwgZGVmYXVsdHMsIG9wdGlvbnMpIHtcbiAgaWYgKGlzU3RydWN0KHNjaGVtYSkpIHtcbiAgICByZXR1cm4gc2NoZW1hW0tJTkRdXG4gIH1cblxuICBpZiAoc2NoZW1hIGluc3RhbmNlb2YgS2luZCkge1xuICAgIHJldHVybiBzY2hlbWFcbiAgfVxuXG4gIHN3aXRjaCAoa2luZE9mKHNjaGVtYSkpIHtcbiAgICBjYXNlICdhcnJheSc6IHtcbiAgICAgIHJldHVybiBzY2hlbWEubGVuZ3RoID4gMVxuICAgICAgICA/IHR1cGxlKHNjaGVtYSwgZGVmYXVsdHMsIG9wdGlvbnMpXG4gICAgICAgIDogbGlzdChzY2hlbWEsIGRlZmF1bHRzLCBvcHRpb25zKVxuICAgIH1cblxuICAgIGNhc2UgJ2Z1bmN0aW9uJzoge1xuICAgICAgcmV0dXJuIGZ1bmMoc2NoZW1hLCBkZWZhdWx0cywgb3B0aW9ucylcbiAgICB9XG5cbiAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICByZXR1cm4gb2JqZWN0KHNjaGVtYSwgZGVmYXVsdHMsIG9wdGlvbnMpXG4gICAgfVxuXG4gICAgY2FzZSAnc3RyaW5nJzoge1xuICAgICAgbGV0IHJlcXVpcmVkID0gdHJ1ZVxuICAgICAgbGV0IHR5cGVcblxuICAgICAgaWYgKHNjaGVtYS5lbmRzV2l0aCgnPycpKSB7XG4gICAgICAgIHJlcXVpcmVkID0gZmFsc2VcbiAgICAgICAgc2NoZW1hID0gc2NoZW1hLnNsaWNlKDAsIC0xKVxuICAgICAgfVxuXG4gICAgICBpZiAoc2NoZW1hLmluY2x1ZGVzKCd8JykpIHtcbiAgICAgICAgY29uc3Qgc2NhbGFycyA9IHNjaGVtYS5zcGxpdCgvXFxzKlxcfFxccyovZylcbiAgICAgICAgdHlwZSA9IHVuaW9uKHNjYWxhcnMsIGRlZmF1bHRzLCBvcHRpb25zKVxuICAgICAgfSBlbHNlIGlmIChzY2hlbWEuaW5jbHVkZXMoJyYnKSkge1xuICAgICAgICBjb25zdCBzY2FsYXJzID0gc2NoZW1hLnNwbGl0KC9cXHMqJlxccyovZylcbiAgICAgICAgdHlwZSA9IGludGVyc2VjdGlvbihzY2FsYXJzLCBkZWZhdWx0cywgb3B0aW9ucylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGUgPSBzY2FsYXIoc2NoZW1hLCBkZWZhdWx0cywgb3B0aW9ucylcbiAgICAgIH1cblxuICAgICAgaWYgKCFyZXF1aXJlZCkge1xuICAgICAgICB0eXBlID0gb3B0aW9uYWwodHlwZSwgdW5kZWZpbmVkLCBvcHRpb25zKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHlwZVxuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEEgc2NoZW1hIGRlZmluaXRpb24gbXVzdCBiZSBhbiBvYmplY3QsIGFycmF5LCBzdHJpbmcgb3IgZnVuY3Rpb24sIGJ1dCB5b3UgcGFzc2VkOiAke3NjaGVtYX1gXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzY2hlbWE6ICR7c2NoZW1hfWApXG4gIH1cbn1cblxuLyoqXG4gKiBEaWN0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNjaGVtYVxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGRpY3Qoc2NoZW1hLCBkZWZhdWx0cywgb3B0aW9ucykge1xuICBpZiAoa2luZE9mKHNjaGVtYSkgIT09ICdhcnJheScgfHwgc2NoZW1hLmxlbmd0aCAhPT0gMikge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBEaWN0IHN0cnVjdHMgbXVzdCBiZSBkZWZpbmVkIGFzIGFuIGFycmF5IHdpdGggdHdvIGVsZW1lbnRzLCBidXQgeW91IHBhc3NlZDogJHtzY2hlbWF9YFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2NoZW1hOiAke3NjaGVtYX1gKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG9iaiA9IHNjYWxhcignb2JqZWN0JywgdW5kZWZpbmVkLCBvcHRpb25zKVxuICBjb25zdCBrZXlzID0gYW55KHNjaGVtYVswXSwgdW5kZWZpbmVkLCBvcHRpb25zKVxuICBjb25zdCB2YWx1ZXMgPSBhbnkoc2NoZW1hWzFdLCB1bmRlZmluZWQsIG9wdGlvbnMpXG4gIGNvbnN0IG5hbWUgPSAnZGljdCdcbiAgY29uc3QgdHlwZSA9IGBkaWN0PCR7a2V5cy50eXBlfSwke3ZhbHVlcy50eXBlfT5gXG4gIGNvbnN0IHZhbGlkYXRlID0gdmFsdWUgPT4ge1xuICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZURlZmF1bHRzKGRlZmF1bHRzKVxuICAgIHZhbHVlID0gcmVzb2x2ZWQgPyB7IC4uLnJlc29sdmVkLCAuLi52YWx1ZSB9IDogdmFsdWVcbiAgICBjb25zdCBbZXJyb3JdID0gb2JqLnZhbGlkYXRlKHZhbHVlKVxuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBlcnJvci50eXBlID0gdHlwZVxuICAgICAgcmV0dXJuIFtlcnJvcl1cbiAgICB9XG5cbiAgICBjb25zdCByZXQgPSB7fVxuICAgIGNvbnN0IGVycm9ycyA9IFtdXG5cbiAgICBmb3IgKGxldCBrIGluIHZhbHVlKSB7XG4gICAgICBjb25zdCB2ID0gdmFsdWVba11cbiAgICAgIGNvbnN0IFtlLCByXSA9IGtleXMudmFsaWRhdGUoaylcblxuICAgICAgaWYgKGUpIHtcbiAgICAgICAgY29uc3QgYWxsRSA9IGUuZXJyb3JzIHx8IFtlXVxuICAgICAgICBhbGxFLmZvckVhY2goc2luZ2xlRSA9PiB7XG4gICAgICAgICAgc2luZ2xlRS5wYXRoID0gW2tdLmNvbmNhdChzaW5nbGVFLnBhdGgpXG4gICAgICAgICAgc2luZ2xlRS5kYXRhID0gdmFsdWVcbiAgICAgICAgICBlcnJvcnMucHVzaChzaW5nbGVFKVxuICAgICAgICB9KVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBrID0gclxuICAgICAgY29uc3QgW2UyLCByMl0gPSB2YWx1ZXMudmFsaWRhdGUodilcblxuICAgICAgaWYgKGUyKSB7XG4gICAgICAgIGNvbnN0IGFsbEUyID0gZTIuZXJyb3JzIHx8IFtlMl1cbiAgICAgICAgYWxsRTIuZm9yRWFjaChzaW5nbGVFID0+IHtcbiAgICAgICAgICBzaW5nbGVFLnBhdGggPSBba10uY29uY2F0KHNpbmdsZUUucGF0aClcbiAgICAgICAgICBzaW5nbGVFLmRhdGEgPSB2YWx1ZVxuICAgICAgICAgIGVycm9ycy5wdXNoKHNpbmdsZUUpXG4gICAgICAgIH0pXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHJldFtrXSA9IHIyXG4gICAgfVxuXG4gICAgcmV0dXJuIGVycm9ycy5sZW5ndGggPyBbeyAuLi5lcnJvcnNbMF0sIGVycm9ycyB9XSA6IFt1bmRlZmluZWQsIHJldF1cbiAgfVxuXG4gIHJldHVybiBuZXcgS2luZChuYW1lLCB0eXBlLCB2YWxpZGF0ZSlcbn1cblxuLyoqXG4gKiBFbnVtLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNjaGVtYVxuICogQHBhcmFtIHtBbnl9IGRlZmF1bHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGVuKHNjaGVtYSwgZGVmYXVsdHMsIG9wdGlvbnMpIHtcbiAgaWYgKGtpbmRPZihzY2hlbWEpICE9PSAnYXJyYXknKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEVudW0gc3RydWN0cyBtdXN0IGJlIGRlZmluZWQgYXMgYW4gYXJyYXksIGJ1dCB5b3UgcGFzc2VkOiAke3NjaGVtYX1gXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzY2hlbWE6ICR7c2NoZW1hfWApXG4gICAgfVxuICB9XG5cbiAgY29uc3QgbmFtZSA9ICdlbnVtJ1xuICBjb25zdCB0eXBlID0gc2NoZW1hXG4gICAgLm1hcChzID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHMpXG4gICAgICB9XG4gICAgfSlcbiAgICAuam9pbignIHwgJylcblxuICBjb25zdCB2YWxpZGF0ZSA9ICh2YWx1ZSA9IHJlc29sdmVEZWZhdWx0cyhkZWZhdWx0cykpID0+IHtcbiAgICByZXR1cm4gc2NoZW1hLmluY2x1ZGVzKHZhbHVlKVxuICAgICAgPyBbdW5kZWZpbmVkLCB2YWx1ZV1cbiAgICAgIDogW3sgZGF0YTogdmFsdWUsIHBhdGg6IFtdLCB2YWx1ZSwgdHlwZSB9XVxuICB9XG5cbiAgcmV0dXJuIG5ldyBLaW5kKG5hbWUsIHR5cGUsIHZhbGlkYXRlKVxufVxuXG4vKipcbiAqIEVudW1zLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNjaGVtYVxuICogQHBhcmFtIHtBbnl9IGRlZmF1bHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGVudW1zKHNjaGVtYSwgZGVmYXVsdHMsIG9wdGlvbnMpIHtcbiAgY29uc3QgZSA9IGVuKHNjaGVtYSwgdW5kZWZpbmVkLCBvcHRpb25zKVxuICBjb25zdCBsID0gbGlzdChbZV0sIGRlZmF1bHRzLCBvcHRpb25zKVxuICByZXR1cm4gbFxufVxuXG4vKipcbiAqIEZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNjaGVtYVxuICogQHBhcmFtIHtBbnl9IGRlZmF1bHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGZ1bmMoc2NoZW1hLCBkZWZhdWx0cywgb3B0aW9ucykge1xuICBpZiAoa2luZE9mKHNjaGVtYSkgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRnVuY3Rpb24gc3RydWN0cyBtdXN0IGJlIGRlZmluZWQgYXMgYSBmdW5jdGlvbiwgYnV0IHlvdSBwYXNzZWQ6ICR7c2NoZW1hfWBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNjaGVtYTogJHtzY2hlbWF9YClcbiAgICB9XG4gIH1cblxuICBjb25zdCBuYW1lID0gJ2Z1bmN0aW9uJ1xuICBjb25zdCB0eXBlID0gJzxmdW5jdGlvbj4nXG4gIGNvbnN0IHZhbGlkYXRlID0gKHZhbHVlID0gcmVzb2x2ZURlZmF1bHRzKGRlZmF1bHRzKSwgZGF0YSkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHNjaGVtYSh2YWx1ZSwgZGF0YSlcbiAgICBsZXQgZmFpbHVyZSA9IHsgcGF0aDogW10sIHJlYXNvbjogbnVsbCB9XG4gICAgbGV0IGlzVmFsaWRcblxuICAgIHN3aXRjaCAoa2luZE9mKHJlc3VsdCkpIHtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOiB7XG4gICAgICAgIGlzVmFsaWQgPSByZXN1bHRcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3N0cmluZyc6IHtcbiAgICAgICAgaXNWYWxpZCA9IGZhbHNlXG4gICAgICAgIGZhaWx1cmUucmVhc29uID0gcmVzdWx0XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgIGlzVmFsaWQgPSBmYWxzZVxuICAgICAgICBmYWlsdXJlID0geyAuLi5mYWlsdXJlLCAuLi5yZXN1bHQgfVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBWYWxpZGF0b3IgZnVuY3Rpb25zIG11c3QgcmV0dXJuIGEgYm9vbGVhbiwgYW4gZXJyb3IgcmVhc29uIHN0cmluZyBvciBhbiBlcnJvciByZWFzb24gb2JqZWN0LCBidXQgeW91IHBhc3NlZDogJHtzY2hlbWF9YFxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcmVzdWx0OiAke3Jlc3VsdH1gKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzVmFsaWRcbiAgICAgID8gW3VuZGVmaW5lZCwgdmFsdWVdXG4gICAgICA6IFt7IHR5cGUsIHZhbHVlLCBkYXRhOiB2YWx1ZSwgLi4uZmFpbHVyZSB9XVxuICB9XG5cbiAgcmV0dXJuIG5ldyBLaW5kKG5hbWUsIHR5cGUsIHZhbGlkYXRlKVxufVxuXG4vKipcbiAqIEluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNjaGVtYVxuICogQHBhcmFtIHtBbnl9IGRlZmF1bHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGluc3RhbmNlKHNjaGVtYSwgZGVmYXVsdHMsIG9wdGlvbnMpIHtcbiAgY29uc3QgbmFtZSA9ICdpbnN0YW5jZSdcbiAgY29uc3QgdHlwZSA9IGBpbnN0YW5jZTwke3NjaGVtYS5uYW1lfT5gXG4gIGNvbnN0IHZhbGlkYXRlID0gKHZhbHVlID0gcmVzb2x2ZURlZmF1bHRzKGRlZmF1bHRzKSkgPT4ge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIHNjaGVtYVxuICAgICAgPyBbdW5kZWZpbmVkLCB2YWx1ZV1cbiAgICAgIDogW3sgZGF0YTogdmFsdWUsIHBhdGg6IFtdLCB2YWx1ZSwgdHlwZSB9XVxuICB9XG5cbiAgcmV0dXJuIG5ldyBLaW5kKG5hbWUsIHR5cGUsIHZhbGlkYXRlKVxufVxuXG4vKipcbiAqIEludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2NoZW1hXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gaW50ZXIoc2NoZW1hLCBkZWZhdWx0cywgb3B0aW9ucykge1xuICBpZiAoa2luZE9mKHNjaGVtYSkgIT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEludGVyZmFjZSBzdHJ1Y3RzIG11c3QgYmUgZGVmaW5lZCBhcyBhbiBvYmplY3QsIGJ1dCB5b3UgcGFzc2VkOiAke3NjaGVtYX1gXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzY2hlbWE6ICR7c2NoZW1hfWApXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgb2JqID0gc2NhbGFyKCdvYmplY3QnLCB1bmRlZmluZWQsIG9wdGlvbnMpXG4gIGNvbnN0IGtzID0gW11cbiAgY29uc3QgcHJvcGVydGllcyA9IHt9XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAga3MucHVzaChrZXkpXG4gICAgY29uc3QgcyA9IHNjaGVtYVtrZXldXG4gICAgY29uc3Qga2luZCA9IGFueShzLCB1bmRlZmluZWQsIG9wdGlvbnMpXG4gICAgcHJvcGVydGllc1trZXldID0ga2luZFxuICB9XG5cbiAgY29uc3QgbmFtZSA9ICdpbnRlcmZhY2UnXG4gIGNvbnN0IHR5cGUgPSBgeyR7a3Muam9pbigpfX1gXG4gIGNvbnN0IHZhbGlkYXRlID0gKHZhbHVlID0gcmVzb2x2ZURlZmF1bHRzKGRlZmF1bHRzKSkgPT4ge1xuICAgIGNvbnN0IFtlcnJvcl0gPSBvYmoudmFsaWRhdGUodmFsdWUpXG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGVycm9yLnR5cGUgPSB0eXBlXG4gICAgICByZXR1cm4gW2Vycm9yXVxuICAgIH1cblxuICAgIGNvbnN0IGVycm9ycyA9IFtdXG4gICAgY29uc3QgcmV0ID0gdmFsdWVcblxuICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgIGxldCB2ID0gdmFsdWVba2V5XVxuICAgICAgY29uc3Qga2luZCA9IHByb3BlcnRpZXNba2V5XVxuXG4gICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGQgPSBkZWZhdWx0cyAmJiBkZWZhdWx0c1trZXldXG4gICAgICAgIHYgPSByZXNvbHZlRGVmYXVsdHMoZCwgdmFsdWUpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IFtlLCByXSA9IGtpbmQudmFsaWRhdGUodiwgdmFsdWUpXG5cbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGNvbnN0IGFsbEUgPSBlLmVycm9ycyB8fCBbZV1cbiAgICAgICAgYWxsRS5mb3JFYWNoKHNpbmdsZUUgPT4ge1xuICAgICAgICAgIHNpbmdsZUUucGF0aCA9IFtrZXldLmNvbmNhdChzaW5nbGVFLnBhdGgpXG4gICAgICAgICAgc2luZ2xlRS5kYXRhID0gdmFsdWVcbiAgICAgICAgICBlcnJvcnMucHVzaChzaW5nbGVFKVxuICAgICAgICB9KVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAoa2V5IGluIHZhbHVlIHx8IHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXRba2V5XSA9IHJcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXJyb3JzLmxlbmd0aCA/IFt7IC4uLmVycm9yc1swXSwgZXJyb3JzIH1dIDogW3VuZGVmaW5lZCwgcmV0XVxuICB9XG5cbiAgcmV0dXJuIG5ldyBLaW5kKG5hbWUsIHR5cGUsIHZhbGlkYXRlKVxufVxuXG4vKipcbiAqIExhenkuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2NoZW1hXG4gKiBAcGFyYW0ge0FueX0gZGVmYXVsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gbGF6eShzY2hlbWEsIGRlZmF1bHRzLCBvcHRpb25zKSB7XG4gIGlmIChraW5kT2Yoc2NoZW1hKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBMYXp5IHN0cnVjdHMgbXVzdCBiZSBkZWZpbmVkIGFzIGFuIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNjaGVtYSwgYnV0IHlvdSBwYXNzZWQ6ICR7c2NoZW1hfWBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNjaGVtYTogJHtzY2hlbWF9YClcbiAgICB9XG4gIH1cblxuICBsZXQga2luZFxuICBsZXQgc3RydWN0XG4gIGNvbnN0IG5hbWUgPSAnbGF6eSdcbiAgY29uc3QgdHlwZSA9IGBsYXp5Li4uYFxuICBjb25zdCBjb21waWxlID0gdmFsdWUgPT4ge1xuICAgIHN0cnVjdCA9IHNjaGVtYSgpXG4gICAga2luZC5uYW1lID0gc3RydWN0LmtpbmRcbiAgICBraW5kLnR5cGUgPSBzdHJ1Y3QudHlwZVxuICAgIGtpbmQudmFsaWRhdGUgPSBzdHJ1Y3QudmFsaWRhdGVcbiAgICByZXR1cm4ga2luZC52YWxpZGF0ZSh2YWx1ZSlcbiAgfVxuXG4gIGtpbmQgPSBuZXcgS2luZChuYW1lLCB0eXBlLCBjb21waWxlKVxuICByZXR1cm4ga2luZFxufVxuXG4vKipcbiAqIER5bmFtaWMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3JlYXRlU2NoZW1hXG4gKiBAcGFyYW0ge0FueX0gZGVmYXVsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gZHluYW1pYyhjcmVhdGVTY2hlbWEsIGRlZmF1bHRzLCBvcHRpb25zKSB7XG4gIGlmIChraW5kT2YoY3JlYXRlU2NoZW1hKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBEeW5hbWljIHN0cnVjdHMgbXVzdCBiZSBkZWZpbmVkIGFzIGEgZnVuY3Rpb24sIGJ1dCB5b3UgcGFzc2VkOiAke2NyZWF0ZVNjaGVtYX1gXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzY2hlbWE6ICR7Y3JlYXRlU2NoZW1hfWApXG4gICAgfVxuICB9XG5cbiAgY29uc3QgbmFtZSA9ICdkeW5hbWljJ1xuICBjb25zdCB0eXBlID0gJ2R5bmFtaWMuLi4nXG4gIGNvbnN0IHZhbGlkYXRlID0gKHZhbHVlID0gcmVzb2x2ZURlZmF1bHRzKGRlZmF1bHRzKSwgZGF0YSkgPT4ge1xuICAgIGNvbnN0IHNjaGVtYSA9IGNyZWF0ZVNjaGVtYSh2YWx1ZSwgZGF0YSlcblxuICAgIGlmIChraW5kT2Yoc2NoZW1hKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBEeW5hbWljIHN0cnVjdHMgbXVzdCByZXR1cm4gYSBzY2hlbWEsIGJ1dCB5b3UgcGFzc2VkOiAke3NjaGVtYX1gXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzY2hlbWE6ICR7c2NoZW1hfWApXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgW2Vycm9yLCByZXN1bHRdID0gc2NoZW1hLnZhbGlkYXRlKHZhbHVlKVxuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICByZXR1cm4gW2Vycm9yXVxuICAgIH1cblxuICAgIHJldHVybiBbdW5kZWZpbmVkLCByZXN1bHRdXG4gIH1cblxuICByZXR1cm4gbmV3IEtpbmQobmFtZSwgdHlwZSwgdmFsaWRhdGUpXG59XG5cbi8qKlxuICogTGlzdC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBzY2hlbWFcbiAqIEBwYXJhbSB7QXJyYXl9IGRlZmF1bHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGxpc3Qoc2NoZW1hLCBkZWZhdWx0cywgb3B0aW9ucykge1xuICBpZiAoa2luZE9mKHNjaGVtYSkgIT09ICdhcnJheScgfHwgc2NoZW1hLmxlbmd0aCAhPT0gMSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBMaXN0IHN0cnVjdHMgbXVzdCBiZSBkZWZpbmVkIGFzIGFuIGFycmF5IHdpdGggYSBzaW5nbGUgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQ6ICR7c2NoZW1hfWBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNjaGVtYTogJHtzY2hlbWF9YClcbiAgICB9XG4gIH1cblxuICBjb25zdCBhcnJheSA9IHNjYWxhcignYXJyYXknLCB1bmRlZmluZWQsIG9wdGlvbnMpXG4gIGNvbnN0IGVsZW1lbnQgPSBhbnkoc2NoZW1hWzBdLCB1bmRlZmluZWQsIG9wdGlvbnMpXG4gIGNvbnN0IG5hbWUgPSAnbGlzdCdcbiAgY29uc3QgdHlwZSA9IGBbJHtlbGVtZW50LnR5cGV9XWBcbiAgY29uc3QgdmFsaWRhdGUgPSAodmFsdWUgPSByZXNvbHZlRGVmYXVsdHMoZGVmYXVsdHMpKSA9PiB7XG4gICAgY29uc3QgW2Vycm9yLCByZXN1bHRdID0gYXJyYXkudmFsaWRhdGUodmFsdWUpXG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGVycm9yLnR5cGUgPSB0eXBlXG4gICAgICByZXR1cm4gW2Vycm9yXVxuICAgIH1cblxuICAgIHZhbHVlID0gcmVzdWx0XG4gICAgY29uc3QgZXJyb3JzID0gW11cbiAgICBjb25zdCByZXQgPSBbXVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdiA9IHZhbHVlW2ldXG4gICAgICBjb25zdCBbZSwgcl0gPSBlbGVtZW50LnZhbGlkYXRlKHYpXG5cbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGNvbnN0IGFsbEUgPSBlLmVycm9ycyB8fCBbZV1cbiAgICAgICAgYWxsRS5mb3JFYWNoKHNpbmdsZUUgPT4ge1xuICAgICAgICAgIHNpbmdsZUUucGF0aCA9IFtpXS5jb25jYXQoc2luZ2xlRS5wYXRoKVxuICAgICAgICAgIHNpbmdsZUUuZGF0YSA9IHZhbHVlXG4gICAgICAgICAgZXJyb3JzLnB1c2goc2luZ2xlRSlcbiAgICAgICAgfSlcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgcmV0W2ldID0gclxuICAgIH1cblxuICAgIHJldHVybiBlcnJvcnMubGVuZ3RoID8gW3sgLi4uZXJyb3JzWzBdLCBlcnJvcnMgfV0gOiBbdW5kZWZpbmVkLCByZXRdXG4gIH1cblxuICByZXR1cm4gbmV3IEtpbmQobmFtZSwgdHlwZSwgdmFsaWRhdGUpXG59XG5cbi8qKlxuICogTGl0ZXJhbC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBzY2hlbWFcbiAqIEBwYXJhbSB7QW55fSBkZWZhdWx0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBsaXRlcmFsKHNjaGVtYSwgZGVmYXVsdHMsIG9wdGlvbnMpIHtcbiAgY29uc3QgbmFtZSA9ICdsaXRlcmFsJ1xuICBjb25zdCB0eXBlID0gYGxpdGVyYWw6ICR7SlNPTi5zdHJpbmdpZnkoc2NoZW1hKX1gXG4gIGNvbnN0IHZhbGlkYXRlID0gKHZhbHVlID0gcmVzb2x2ZURlZmF1bHRzKGRlZmF1bHRzKSkgPT4ge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gc2NoZW1hXG4gICAgICA/IFt1bmRlZmluZWQsIHZhbHVlXVxuICAgICAgOiBbeyBkYXRhOiB2YWx1ZSwgcGF0aDogW10sIHZhbHVlLCB0eXBlIH1dXG4gIH1cblxuICByZXR1cm4gbmV3IEtpbmQobmFtZSwgdHlwZSwgdmFsaWRhdGUpXG59XG5cbi8qKlxuICogT2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBvYmplY3Qoc2NoZW1hLCBkZWZhdWx0cywgb3B0aW9ucykge1xuICBpZiAoa2luZE9mKHNjaGVtYSkgIT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYE9iamVjdCBzdHJ1Y3RzIG11c3QgYmUgZGVmaW5lZCBhcyBhbiBvYmplY3QsIGJ1dCB5b3UgcGFzc2VkOiAke3NjaGVtYX1gXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzY2hlbWE6ICR7c2NoZW1hfWApXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgb2JqID0gc2NhbGFyKCdvYmplY3QnLCB1bmRlZmluZWQsIG9wdGlvbnMpXG4gIGNvbnN0IGtzID0gW11cbiAgY29uc3QgcHJvcGVydGllcyA9IHt9XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAga3MucHVzaChrZXkpXG4gICAgY29uc3QgcyA9IHNjaGVtYVtrZXldXG4gICAgY29uc3Qga2luZCA9IGFueShzLCB1bmRlZmluZWQsIG9wdGlvbnMpXG4gICAgcHJvcGVydGllc1trZXldID0ga2luZFxuICB9XG5cbiAgY29uc3QgbmFtZSA9ICdvYmplY3QnXG4gIGNvbnN0IHR5cGUgPSBgeyR7a3Muam9pbigpfX1gXG4gIGNvbnN0IHZhbGlkYXRlID0gKHZhbHVlID0gcmVzb2x2ZURlZmF1bHRzKGRlZmF1bHRzKSkgPT4ge1xuICAgIGNvbnN0IFtlcnJvcl0gPSBvYmoudmFsaWRhdGUodmFsdWUpXG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGVycm9yLnR5cGUgPSB0eXBlXG4gICAgICByZXR1cm4gW2Vycm9yXVxuICAgIH1cblxuICAgIGNvbnN0IGVycm9ycyA9IFtdXG4gICAgY29uc3QgcmV0ID0ge31cbiAgICBjb25zdCB2YWx1ZUtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSlcbiAgICBjb25zdCBwcm9wZXJ0aWVzS2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpXG4gICAgY29uc3Qga2V5cyA9IG5ldyBTZXQodmFsdWVLZXlzLmNvbmNhdChwcm9wZXJ0aWVzS2V5cykpXG5cbiAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGxldCB2ID0gdmFsdWVba2V5XVxuICAgICAgY29uc3Qga2luZCA9IHByb3BlcnRpZXNba2V5XVxuXG4gICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGQgPSBkZWZhdWx0cyAmJiBkZWZhdWx0c1trZXldXG4gICAgICAgIHYgPSByZXNvbHZlRGVmYXVsdHMoZCwgdmFsdWUpXG4gICAgICB9XG5cbiAgICAgIGlmICgha2luZCkge1xuICAgICAgICBjb25zdCBlID0geyBkYXRhOiB2YWx1ZSwgcGF0aDogW2tleV0sIHZhbHVlOiB2IH1cbiAgICAgICAgZXJyb3JzLnB1c2goZSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IFtlLCByXSA9IGtpbmQudmFsaWRhdGUodiwgdmFsdWUpXG5cbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGNvbnN0IGFsbEUgPSBlLmVycm9ycyB8fCBbZV1cbiAgICAgICAgYWxsRS5mb3JFYWNoKHNpbmdsZUUgPT4ge1xuICAgICAgICAgIHNpbmdsZUUucGF0aCA9IFtrZXldLmNvbmNhdChzaW5nbGVFLnBhdGgpXG4gICAgICAgICAgc2luZ2xlRS5kYXRhID0gdmFsdWVcbiAgICAgICAgICBlcnJvcnMucHVzaChzaW5nbGVFKVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKGtleSBpbiB2YWx1ZSB8fCByICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0W2tleV0gPSByXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiBlcnJvcnMubGVuZ3RoID8gW3sgLi4uZXJyb3JzWzBdLCBlcnJvcnMgfV0gOiBbdW5kZWZpbmVkLCByZXRdXG4gIH1cblxuICByZXR1cm4gbmV3IEtpbmQobmFtZSwgdHlwZSwgdmFsaWRhdGUpXG59XG5cbi8qKlxuICogT3B0aW9uYWwuXG4gKlxuICogQHBhcmFtIHtBbnl9IHNjaGVtYVxuICogQHBhcmFtIHtBbnl9IGRlZmF1bHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIG9wdGlvbmFsKHNjaGVtYSwgZGVmYXVsdHMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHVuaW9uKFtzY2hlbWEsICd1bmRlZmluZWQnXSwgZGVmYXVsdHMsIG9wdGlvbnMpXG59XG5cbi8qKlxuICogUGFydGlhbC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2NoZW1hXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gcGFydGlhbChzY2hlbWEsIGRlZmF1bHRzLCBvcHRpb25zKSB7XG4gIGlmIChraW5kT2Yoc2NoZW1hKSAhPT0gJ29iamVjdCcpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgUGFydGlhbCBzdHJ1Y3RzIG11c3QgYmUgZGVmaW5lZCBhcyBhbiBvYmplY3QsIGJ1dCB5b3UgcGFzc2VkOiAke3NjaGVtYX1gXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzY2hlbWE6ICR7c2NoZW1hfWApXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgb2JqID0gc2NhbGFyKCdvYmplY3QnLCB1bmRlZmluZWQsIG9wdGlvbnMpXG4gIGNvbnN0IGtzID0gW11cbiAgY29uc3QgcHJvcGVydGllcyA9IHt9XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAga3MucHVzaChrZXkpXG4gICAgY29uc3QgcyA9IHNjaGVtYVtrZXldXG4gICAgY29uc3Qga2luZCA9IGFueShzLCB1bmRlZmluZWQsIG9wdGlvbnMpXG4gICAgcHJvcGVydGllc1trZXldID0ga2luZFxuICB9XG5cbiAgY29uc3QgbmFtZSA9ICdwYXJ0aWFsJ1xuICBjb25zdCB0eXBlID0gYHske2tzLmpvaW4oKX0sLi4ufWBcbiAgY29uc3QgdmFsaWRhdGUgPSAodmFsdWUgPSByZXNvbHZlRGVmYXVsdHMoZGVmYXVsdHMpKSA9PiB7XG4gICAgY29uc3QgW2Vycm9yXSA9IG9iai52YWxpZGF0ZSh2YWx1ZSlcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgZXJyb3IudHlwZSA9IHR5cGVcbiAgICAgIHJldHVybiBbZXJyb3JdXG4gICAgfVxuXG4gICAgY29uc3QgZXJyb3JzID0gW11cbiAgICBjb25zdCByZXQgPSB7fVxuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcGVydGllcykge1xuICAgICAgbGV0IHYgPSB2YWx1ZVtrZXldXG4gICAgICBjb25zdCBraW5kID0gcHJvcGVydGllc1trZXldXG5cbiAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZCA9IGRlZmF1bHRzICYmIGRlZmF1bHRzW2tleV1cbiAgICAgICAgdiA9IHJlc29sdmVEZWZhdWx0cyhkLCB2YWx1ZSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgW2UsIHJdID0ga2luZC52YWxpZGF0ZSh2LCB2YWx1ZSlcblxuICAgICAgaWYgKGUpIHtcbiAgICAgICAgY29uc3QgYWxsRSA9IGUuZXJyb3JzIHx8IFtlXVxuICAgICAgICBhbGxFLmZvckVhY2goc2luZ2xlRSA9PiB7XG4gICAgICAgICAgc2luZ2xlRS5wYXRoID0gW2tleV0uY29uY2F0KHNpbmdsZUUucGF0aClcbiAgICAgICAgICBzaW5nbGVFLmRhdGEgPSB2YWx1ZVxuICAgICAgICAgIGVycm9ycy5wdXNoKHNpbmdsZUUpXG4gICAgICAgIH0pXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChrZXkgaW4gdmFsdWUgfHwgciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldFtrZXldID0gclxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlcnJvcnMubGVuZ3RoID8gW3sgLi4uZXJyb3JzWzBdLCBlcnJvcnMgfV0gOiBbdW5kZWZpbmVkLCByZXRdXG4gIH1cblxuICByZXR1cm4gbmV3IEtpbmQobmFtZSwgdHlwZSwgdmFsaWRhdGUpXG59XG5cbi8qKlxuICogU2NhbGFyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzY2hlbWFcbiAqIEBwYXJhbSB7QW55fSBkZWZhdWx0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBzY2FsYXIoc2NoZW1hLCBkZWZhdWx0cywgb3B0aW9ucykge1xuICBpZiAoa2luZE9mKHNjaGVtYSkgIT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFNjYWxhciBzdHJ1Y3RzIG11c3QgYmUgZGVmaW5lZCBhcyBhIHN0cmluZywgYnV0IHlvdSBwYXNzZWQ6ICR7c2NoZW1hfWBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNjaGVtYTogJHtzY2hlbWF9YClcbiAgICB9XG4gIH1cblxuICBjb25zdCB7IHR5cGVzIH0gPSBvcHRpb25zXG4gIGNvbnN0IGZuID0gdHlwZXNbc2NoZW1hXVxuXG4gIGlmIChraW5kT2YoZm4pICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYE5vIHN0cnVjdCB2YWxpZGF0b3IgZnVuY3Rpb24gZm91bmQgZm9yIHR5cGUgXCIke3NjaGVtYX1cIi5gXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0eXBlOiAke3NjaGVtYX1gKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGtpbmQgPSBmdW5jKGZuLCBkZWZhdWx0cywgb3B0aW9ucylcbiAgY29uc3QgbmFtZSA9ICdzY2FsYXInXG4gIGNvbnN0IHR5cGUgPSBzY2hlbWFcbiAgY29uc3QgdmFsaWRhdGUgPSB2YWx1ZSA9PiB7XG4gICAgY29uc3QgW2Vycm9yLCByZXN1bHRdID0ga2luZC52YWxpZGF0ZSh2YWx1ZSlcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgZXJyb3IudHlwZSA9IHR5cGVcbiAgICAgIHJldHVybiBbZXJyb3JdXG4gICAgfVxuXG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIHJlc3VsdF1cbiAgfVxuXG4gIHJldHVybiBuZXcgS2luZChuYW1lLCB0eXBlLCB2YWxpZGF0ZSlcbn1cblxuLyoqXG4gKiBUdXBsZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBzY2hlbWFcbiAqIEBwYXJhbSB7QXJyYXl9IGRlZmF1bHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIHR1cGxlKHNjaGVtYSwgZGVmYXVsdHMsIG9wdGlvbnMpIHtcbiAgaWYgKGtpbmRPZihzY2hlbWEpICE9PSAnYXJyYXknKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFR1cGxlIHN0cnVjdHMgbXVzdCBiZSBkZWZpbmVkIGFzIGFuIGFycmF5LCBidXQgeW91IHBhc3NlZDogJHtzY2hlbWF9YFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2NoZW1hOiAke3NjaGVtYX1gKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGtpbmRzID0gc2NoZW1hLm1hcChzID0+IGFueShzLCB1bmRlZmluZWQsIG9wdGlvbnMpKVxuICBjb25zdCBhcnJheSA9IHNjYWxhcignYXJyYXknLCB1bmRlZmluZWQsIG9wdGlvbnMpXG4gIGNvbnN0IG5hbWUgPSAndHVwbGUnXG4gIGNvbnN0IHR5cGUgPSBgWyR7a2luZHMubWFwKGsgPT4gay50eXBlKS5qb2luKCl9XWBcbiAgY29uc3QgdmFsaWRhdGUgPSAodmFsdWUgPSByZXNvbHZlRGVmYXVsdHMoZGVmYXVsdHMpKSA9PiB7XG4gICAgY29uc3QgW2Vycm9yXSA9IGFycmF5LnZhbGlkYXRlKHZhbHVlKVxuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBlcnJvci50eXBlID0gdHlwZVxuICAgICAgcmV0dXJuIFtlcnJvcl1cbiAgICB9XG5cbiAgICBjb25zdCByZXQgPSBbXVxuICAgIGNvbnN0IGVycm9ycyA9IFtdXG4gICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgodmFsdWUubGVuZ3RoLCBraW5kcy5sZW5ndGgpXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBraW5kID0ga2luZHNbaV1cbiAgICAgIGNvbnN0IHYgPSB2YWx1ZVtpXVxuXG4gICAgICBpZiAoIWtpbmQpIHtcbiAgICAgICAgY29uc3QgZSA9IHsgZGF0YTogdmFsdWUsIHBhdGg6IFtpXSwgdmFsdWU6IHYgfVxuICAgICAgICBlcnJvcnMucHVzaChlKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBbZSwgcl0gPSBraW5kLnZhbGlkYXRlKHYpXG5cbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGNvbnN0IGFsbEUgPSBlLmVycm9ycyB8fCBbZV1cbiAgICAgICAgYWxsRS5mb3JFYWNoKHNpbmdsZUUgPT4ge1xuICAgICAgICAgIHNpbmdsZUUucGF0aCA9IFtpXS5jb25jYXQoc2luZ2xlRS5wYXRoKVxuICAgICAgICAgIHNpbmdsZUUuZGF0YSA9IHZhbHVlXG4gICAgICAgICAgZXJyb3JzLnB1c2goc2luZ2xlRSlcbiAgICAgICAgfSlcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgcmV0W2ldID0gclxuICAgIH1cblxuICAgIHJldHVybiBlcnJvcnMubGVuZ3RoID8gW3sgLi4uZXJyb3JzWzBdLCBlcnJvcnMgfV0gOiBbdW5kZWZpbmVkLCByZXRdXG4gIH1cblxuICByZXR1cm4gbmV3IEtpbmQobmFtZSwgdHlwZSwgdmFsaWRhdGUpXG59XG5cbi8qKlxuICogVW5pb24uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc2NoZW1hXG4gKiBAcGFyYW0ge0FueX0gZGVmYXVsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gdW5pb24oc2NoZW1hLCBkZWZhdWx0cywgb3B0aW9ucykge1xuICBpZiAoa2luZE9mKHNjaGVtYSkgIT09ICdhcnJheScpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVW5pb24gc3RydWN0cyBtdXN0IGJlIGRlZmluZWQgYXMgYW4gYXJyYXksIGJ1dCB5b3UgcGFzc2VkOiAke3NjaGVtYX1gXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzY2hlbWE6ICR7c2NoZW1hfWApXG4gICAgfVxuICB9XG5cbiAgY29uc3Qga2luZHMgPSBzY2hlbWEubWFwKHMgPT4gYW55KHMsIHVuZGVmaW5lZCwgb3B0aW9ucykpXG4gIGNvbnN0IG5hbWUgPSAndW5pb24nXG4gIGNvbnN0IHR5cGUgPSBraW5kcy5tYXAoayA9PiBrLnR5cGUpLmpvaW4oJyB8ICcpXG4gIGNvbnN0IHZhbGlkYXRlID0gKHZhbHVlID0gcmVzb2x2ZURlZmF1bHRzKGRlZmF1bHRzKSkgPT4ge1xuICAgIGNvbnN0IGVycm9ycyA9IFtdXG5cbiAgICBmb3IgKGNvbnN0IGsgb2Yga2luZHMpIHtcbiAgICAgIGNvbnN0IFtlLCByXSA9IGsudmFsaWRhdGUodmFsdWUpXG5cbiAgICAgIGlmICghZSkge1xuICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgcl1cbiAgICAgIH1cblxuICAgICAgZXJyb3JzLnB1c2goZSlcbiAgICB9XG4gICAgZXJyb3JzWzBdLnR5cGUgPSB0eXBlXG4gICAgcmV0dXJuIGVycm9yc1xuICB9XG5cbiAgcmV0dXJuIG5ldyBLaW5kKG5hbWUsIHR5cGUsIHZhbGlkYXRlKVxufVxuXG4vKipcbiAqIEludGVyc2VjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBzY2hlbWFcbiAqIEBwYXJhbSB7QW55fSBkZWZhdWx0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24oc2NoZW1hLCBkZWZhdWx0cywgb3B0aW9ucykge1xuICBpZiAoa2luZE9mKHNjaGVtYSkgIT09ICdhcnJheScpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW50ZXJzZWN0aW9uIHN0cnVjdHMgbXVzdCBiZSBkZWZpbmVkIGFzIGFuIGFycmF5LCBidXQgeW91IHBhc3NlZDogJHtzY2hlbWF9YFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2NoZW1hOiAke3NjaGVtYX1gKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHR5cGVzID0gc2NoZW1hLm1hcChzID0+IGFueShzLCB1bmRlZmluZWQsIG9wdGlvbnMpKVxuICBjb25zdCBuYW1lID0gJ2ludGVyc2VjdGlvbidcbiAgY29uc3QgdHlwZSA9IHR5cGVzLm1hcCh0ID0+IHQudHlwZSkuam9pbignICYgJylcbiAgY29uc3QgdmFsaWRhdGUgPSAodmFsdWUgPSByZXNvbHZlRGVmYXVsdHMoZGVmYXVsdHMpKSA9PiB7XG4gICAgbGV0IHYgPSB2YWx1ZVxuXG4gICAgZm9yIChjb25zdCB0IG9mIHR5cGVzKSB7XG4gICAgICBjb25zdCBbZSwgcl0gPSB0LnZhbGlkYXRlKHYpXG5cbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGUudHlwZSA9IHR5cGVcbiAgICAgICAgcmV0dXJuIFtlXVxuICAgICAgfVxuXG4gICAgICB2ID0gclxuICAgIH1cblxuICAgIHJldHVybiBbdW5kZWZpbmVkLCB2XVxuICB9XG5cbiAgcmV0dXJuIG5ldyBLaW5kKG5hbWUsIHR5cGUsIHZhbGlkYXRlKVxufVxuXG4vKipcbiAqIEtpbmRzLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxuY29uc3QgS2luZHMgPSB7XG4gIGFueSxcbiAgZGljdCxcbiAgZW51bTogZW4sXG4gIGVudW1zLFxuICBmdW5jdGlvbjogZnVuYyxcbiAgaW5zdGFuY2UsXG4gIGludGVyZmFjZTogaW50ZXIsXG4gIGxhenksXG4gIGxpc3QsXG4gIGxpdGVyYWwsXG4gIG9iamVjdCxcbiAgb3B0aW9uYWwsXG4gIHBhcnRpYWwsXG4gIHNjYWxhcixcbiAgdHVwbGUsXG4gIHVuaW9uLFxuICBpbnRlcnNlY3Rpb24sXG4gIGR5bmFtaWMsXG59XG5cbi8qKlxuICogRXhwb3J0LlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgS2luZHNcbiIsImltcG9ydCBraW5kT2YgZnJvbSAna2luZC1vZidcblxuLyoqXG4gKiBUaGUgdHlwZXMgdGhhdCBga2luZC1vZmAgc3VwcG9ydHMuXG4gKlxuICogQHR5cGUge0FycmF5fVxuICovXG5cbmNvbnN0IFRZUEVTID0gW1xuICAnYXJndW1lbnRzJyxcbiAgJ2FycmF5JyxcbiAgJ2Jvb2xlYW4nLFxuICAnYnVmZmVyJyxcbiAgJ2Vycm9yJyxcbiAgJ2Zsb2F0MzJhcnJheScsXG4gICdmbG9hdDY0YXJyYXknLFxuICAnZnVuY3Rpb24nLFxuICAnZ2VuZXJhdG9yZnVuY3Rpb24nLFxuICAnaW50MTZhcnJheScsXG4gICdpbnQzMmFycmF5JyxcbiAgJ2ludDhhcnJheScsXG4gICdtYXAnLFxuICAnbnVsbCcsXG4gICdudW1iZXInLFxuICAnb2JqZWN0JyxcbiAgJ3Byb21pc2UnLFxuICAncmVnZXhwJyxcbiAgJ3NldCcsXG4gICdzdHJpbmcnLFxuICAnc3ltYm9sJyxcbiAgJ3VpbnQxNmFycmF5JyxcbiAgJ3VpbnQzMmFycmF5JyxcbiAgJ3VpbnQ4YXJyYXknLFxuICAndWludDhjbGFtcGVkYXJyYXknLFxuICAndW5kZWZpbmVkJyxcbiAgJ3dlYWttYXAnLFxuICAnd2Vha3NldCcsXG5dXG5cbi8qKlxuICogVGhlIGRlZmF1bHQgdHlwZXMgdGhhdCBTdXBlcnN0cnVjdCBzaGlwcyB3aXRoLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxuY29uc3QgVHlwZXMgPSB7XG4gIGFueTogdmFsdWUgPT4gdmFsdWUgIT09IHVuZGVmaW5lZCxcbn1cblxuVFlQRVMuZm9yRWFjaCh0eXBlID0+IHtcbiAgVHlwZXNbdHlwZV0gPSB2YWx1ZSA9PiBraW5kT2YodmFsdWUpID09PSB0eXBlXG59KVxuXG4vKipcbiAqIEhhbmRsZSB0aGUgJ2RhdGUnIGNhc2Ugc3BlY2lhbGx5LCB0byB0aHJvdyBvdXQgaW52YWxpZCBgRGF0ZWAgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5UeXBlcy5kYXRlID0gdmFsdWUgPT4ga2luZE9mKHZhbHVlKSA9PT0gJ2RhdGUnICYmICFpc05hTih2YWx1ZSlcblxuLyoqXG4gKiBFeHBvcnQuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBUeXBlc1xuIiwiaW1wb3J0IEtpbmRzIGZyb20gJy4va2luZHMnXG5pbXBvcnQgU3RydWN0RXJyb3IgZnJvbSAnLi9lcnJvcidcbmltcG9ydCBUeXBlcyBmcm9tICcuL3R5cGVzJ1xuaW1wb3J0IHsgaXNTdHJ1Y3QgfSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0IHsgSVNfU1RSVUNULCBLSU5EIH0gZnJvbSAnLi9jb25zdGFudHMnXG5cbi8qKlxuICogQ3JlYXRlIGEgc3RydWN0IGZhY3Rvcnkgd2l0aCBhIGBjb25maWdgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIHN1cGVyc3RydWN0KGNvbmZpZyA9IHt9KSB7XG4gIGNvbnN0IHR5cGVzID0ge1xuICAgIC4uLlR5cGVzLFxuICAgIC4uLihjb25maWcudHlwZXMgfHwge30pLFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGBraW5kYCBzdHJ1Y3Qgd2l0aCBgc2NoZW1hYCwgYGRlZmF1bHRzYCBhbmQgYG9wdGlvbnNgLlxuICAgKlxuICAgKiBAcGFyYW0ge0FueX0gc2NoZW1hXG4gICAqIEBwYXJhbSB7QW55fSBkZWZhdWx0c1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG5cbiAgZnVuY3Rpb24gc3RydWN0KHNjaGVtYSwgZGVmYXVsdHMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChpc1N0cnVjdChzY2hlbWEpKSB7XG4gICAgICBzY2hlbWEgPSBzY2hlbWEuc2NoZW1hXG4gICAgfVxuXG4gICAgY29uc3Qga2luZCA9IEtpbmRzLmFueShzY2hlbWEsIGRlZmF1bHRzLCB7IC4uLm9wdGlvbnMsIHR5cGVzIH0pXG5cbiAgICBmdW5jdGlvbiBTdHJ1Y3QoZGF0YSkge1xuICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBTdHJ1Y3QpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnVGhlIGBTdHJ1Y3RgIGNyZWF0aW9uIGZ1bmN0aW9uIHNob3VsZCBub3QgYmUgdXNlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLidcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGBuZXdgIGtleXdvcmQhJylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gU3RydWN0LmFzc2VydChkYXRhKVxuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJ1Y3QsIElTX1NUUlVDVCwgeyB2YWx1ZTogdHJ1ZSB9KVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJ1Y3QsIEtJTkQsIHsgdmFsdWU6IGtpbmQgfSlcblxuICAgIFN0cnVjdC5raW5kID0ga2luZC5uYW1lXG4gICAgU3RydWN0LnR5cGUgPSBraW5kLnR5cGVcbiAgICBTdHJ1Y3Quc2NoZW1hID0gc2NoZW1hXG4gICAgU3RydWN0LmRlZmF1bHRzID0gZGVmYXVsdHNcbiAgICBTdHJ1Y3Qub3B0aW9ucyA9IG9wdGlvbnNcblxuICAgIFN0cnVjdC5hc3NlcnQgPSB2YWx1ZSA9PiB7XG4gICAgICBjb25zdCBbZXJyb3IsIHJlc3VsdF0gPSBraW5kLnZhbGlkYXRlKHZhbHVlKVxuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN0cnVjdEVycm9yKGVycm9yKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgU3RydWN0LnRlc3QgPSB2YWx1ZSA9PiB7XG4gICAgICBjb25zdCBbZXJyb3JdID0ga2luZC52YWxpZGF0ZSh2YWx1ZSlcbiAgICAgIHJldHVybiAhZXJyb3JcbiAgICB9XG5cbiAgICBTdHJ1Y3QudmFsaWRhdGUgPSB2YWx1ZSA9PiB7XG4gICAgICBjb25zdCBbZXJyb3IsIHJlc3VsdF0gPSBraW5kLnZhbGlkYXRlKHZhbHVlKVxuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgU3RydWN0RXJyb3IoZXJyb3IpXVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3VuZGVmaW5lZCwgcmVzdWx0XVxuICAgIH1cblxuICAgIHJldHVybiBTdHJ1Y3RcbiAgfVxuXG4gIC8qKlxuICAgKiBNaXggaW4gYSBmYWN0b3J5IGZvciBlYWNoIHNwZWNpZmljIGtpbmQgb2Ygc3RydWN0LlxuICAgKi9cblxuICBPYmplY3Qua2V5cyhLaW5kcykuZm9yRWFjaChuYW1lID0+IHtcbiAgICBjb25zdCBraW5kID0gS2luZHNbbmFtZV1cblxuICAgIHN0cnVjdFtuYW1lXSA9IChzY2hlbWEsIGRlZmF1bHRzLCBvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCB0eXBlID0ga2luZChzY2hlbWEsIGRlZmF1bHRzLCB7IC4uLm9wdGlvbnMsIHR5cGVzIH0pXG4gICAgICBjb25zdCBzID0gc3RydWN0KHR5cGUsIGRlZmF1bHRzLCBvcHRpb25zKVxuICAgICAgcmV0dXJuIHNcbiAgICB9XG4gIH0pXG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgc3RydWN0IGZhY3RvcnkuXG4gICAqL1xuXG4gIHJldHVybiBzdHJ1Y3Rcbn1cblxuLyoqXG4gKiBFeHBvcnQuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IHN1cGVyc3RydWN0XG4iLCJpbXBvcnQgU3RydWN0RXJyb3IgZnJvbSAnLi9lcnJvcidcbmltcG9ydCBzdXBlcnN0cnVjdCBmcm9tICcuL3N1cGVyc3RydWN0J1xuaW1wb3J0IHsgaXNTdHJ1Y3QgfSBmcm9tICcuL3V0aWxzJ1xuXG4vKipcbiAqIENyZWF0ZSBhIGNvbnZlbmllbmNlIGBzdHJ1Y3RgIGZhY3RvcnkgZm9yIHRoZSBkZWZhdWx0IHR5cGVzLlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xuXG5jb25zdCBzdHJ1Y3QgPSBzdXBlcnN0cnVjdCgpXG5cbi8qKlxuICogRXhwb3J0LlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xuXG5leHBvcnQgeyBzdHJ1Y3QsIHN1cGVyc3RydWN0LCBpc1N0cnVjdCwgU3RydWN0RXJyb3IgfVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7OztBQU1BOzs7Ozs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUdBOzs7O0FBR0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFGQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQURBO0FBR0E7OztBQW5CQTs7OztBQVRBO0FBQ0E7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7OztBQUdBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7OztBQUdBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7OztBQUdBO0FBQUE7QUFDQTtBQUFBO0FBQUE7OztBQUdBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUF2QkE7QUFDQTtBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTs7O0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQU5BO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQ2hJQTs7Ozs7OztBQU1BOzs7Ozs7O0FBUUE7QUNaQTs7Ozs7OztBQU9BO0FBQ0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ2pCQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBQ0E7OztBQUtBOztBQUNBOzs7QUFHQTs7QUFDQTs7O0FBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFBQTtBQUZBO0FBSUE7OztBQUdBO0FBQ0E7OztBQUdBOzs7O0FBSUE7QUFDQTtBQURBOzs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQURBOzs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFaQTtBQWNBO0FBQ0E7QUFmQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBRkE7Ozs7QUFVQTtBQUNBO0FBNUJBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUE2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFGQTs7OztBQVVBO0FBeENBO0FBQUE7QUFDQTtBQVlBO0FBQUE7QUFDQTtBQURBOzs7QUE4QkE7QUFBQTtBQUFBO0FBM0NBO0FBQ0E7QUE2Q0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTs7O0FBU0E7QUFDQTtBQUVBO0FBQ0E7QUFEQTtBQUdBOztBQUxBO0FBQ0E7QUFTQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSEE7QUFDQTtBQUtBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7OztBQVNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7OztBQUdBOztBQUNBO0FBQ0E7Ozs7QUFHQTs7QUFDQTtBQUNBOzs7Ozs7QUFJQTtBQUNBO0FBREE7Ozs7QUFVQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBakNBO0FBQ0E7QUFtQ0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSEE7QUFDQTtBQUtBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQVZBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFqQkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7OztBQVFBO0FBQ0E7O0FBakNBO0FBQ0E7QUFVQTtBQUFBO0FBQ0E7QUFEQTs7O0FBMEJBO0FBQUE7QUFBQTtBQXJDQTtBQUNBO0FBdUNBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQURBOzs7QUFTQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7OztBQUpBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFjQTtBQUNBOzs7QUFHQTtBQW5CQTtBQUNBO0FBcUJBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBYUE7QUFDQTtBQWRBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7OztBQVFBO0FBMUJBO0FBQ0E7QUFXQTtBQUFBO0FBQ0E7QUFEQTs7O0FBaUJBO0FBQUE7QUFBQTtBQTdCQTtBQUNBO0FBK0JBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUhBO0FBQ0E7QUFLQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQURBOzs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7O0FBWEE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7OztBQVFBO0FBQ0E7O0FBNUJBO0FBZ0NBO0FBQUE7QUFBQTtBQTlDQTtBQUNBO0FBZ0RBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBVkE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQWpCQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOzs7O0FBUUE7QUFDQTs7QUFqQ0E7QUFDQTtBQVVBO0FBQUE7QUFDQTtBQURBOzs7QUEwQkE7QUFBQTtBQUFBO0FBckNBO0FBQ0E7QUF1Q0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTs7O0FBRkE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQVJBO0FBQ0E7QUFVQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQURBOzs7QUFTQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7O0FBbEJBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7Ozs7QUFRQTtBQWxDQTtBQUNBO0FBV0E7QUFBQTtBQUNBO0FBREE7OztBQXlCQTtBQUFBO0FBQUE7QUFyQ0E7QUFDQTtBQXVDQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQURBOzs7QUFTQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUFBO0FBQ0E7QUFEQTtBQUdBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBOzs7QUFHQTs7QUFWQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFXQTtBQUNBO0FBYkE7QUFDQTtBQWVBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7OztBQVNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUZBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBWEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBYUE7QUFkQTtBQUNBO0FBZ0JBOzs7Ozs7Ozs7QUFTQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7O0FBQUE7QUNwNEJBOzs7Ozs7QUFNQTs7Ozs7OztBQXFDQTtBQUNBO0FBQUE7QUFBQTtBQURBO0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFEQTs7Ozs7Ozs7QUFXQTtBQUFBO0FBQUE7QUN0REE7Ozs7Ozs7O0FBT0E7QUFBQTtBQUNBO0FBQUE7Ozs7Ozs7Ozs7O0FBY0E7QUFBQTtBQUNBO0FBQUE7QUFDQTs7O0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBOzs7QUFTQTs7O0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTs7O0FBR0E7QUFQQTtBQUNBO0FBU0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7OztBQUdBO0FBUEE7QUFDQTtBQVNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBSEE7QUFIQTs7Ozs7QUFjQTs7QUNwR0E7Ozs7Ozs7QUFNQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/superstruct/lib/index.es.js\n");

/***/ })

}]);