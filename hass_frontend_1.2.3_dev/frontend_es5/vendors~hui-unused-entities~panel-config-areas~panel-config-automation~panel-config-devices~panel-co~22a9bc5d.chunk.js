(self["webpackJsonp"] = self["webpackJsonp"] || []).push([["vendors~hui-unused-entities~panel-config-areas~panel-config-automation~panel-config-devices~panel-co~22a9bc5d"],{

/***/ "./node_modules/lit-virtualizer/lib/lit-virtualizer.js":
/*!*************************************************************!*\
  !*** ./node_modules/lit-virtualizer/lib/lit-virtualizer.js ***!
  \*************************************************************/
/*! exports provided: LitVirtualizer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LitVirtualizer\", function() { return LitVirtualizer; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"./node_modules/lit-virtualizer/node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var lit_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit-element */ \"./node_modules/lit-element/lit-element.js\");\n/* harmony import */ var _scroll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scroll.js */ \"./node_modules/lit-virtualizer/lib/scroll.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\", \"\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n/**\n * A LitElement wrapper of the scroll directive.\n *\n * Import this module to declare the lit-virtualizer custom element.\n * Pass an items array, renderItem method, and scroll target as properties\n * to the <lit-virtualizer> element.\n */\n\nvar LitVirtualizer = /*#__PURE__*/function (_LitElement) {\n  _inherits(LitVirtualizer, _LitElement);\n\n  var _super = _createSuper(LitVirtualizer);\n\n  function LitVirtualizer() {\n    var _this;\n\n    _classCallCheck(this, LitVirtualizer);\n\n    _this = _super.call(this);\n    _this.renderRoot = _assertThisInitialized(_this);\n    return _this;\n  }\n  /**\n   * The method used for rendering each item.\n   */\n\n\n  _createClass(LitVirtualizer, [{\n    key: \"scrollToIndex\",\n\n    /**\n     * Scroll to the specified index, placing that item at the given position\n     * in the scroll view.\n     */\n    value: function () {\n      var _scrollToIndex = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(index) {\n        var position,\n            _args = arguments;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                position = _args.length > 1 && _args[1] !== undefined ? _args[1] : 'start';\n                this._scrollToIndex = {\n                  index: index,\n                  position: position\n                };\n                this.requestUpdate();\n                _context.next = 5;\n                return this.updateComplete;\n\n              case 5:\n                this._scrollToIndex = null;\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function scrollToIndex(_x) {\n        return _scrollToIndex.apply(this, arguments);\n      }\n\n      return scrollToIndex;\n    }()\n  }, {\n    key: \"render\",\n    value: function render() {\n      return Object(lit_element__WEBPACK_IMPORTED_MODULE_1__[\"html\"])(_templateObject(), Object(_scroll_js__WEBPACK_IMPORTED_MODULE_2__[\"scroll\"])({\n        items: this.items,\n        renderItem: this._renderItem,\n        scrollTarget: this.scrollTarget,\n        scrollToIndex: this._scrollToIndex,\n        useShadowDOM: true // TODO: allow configuration of a layout.\n\n      }));\n    }\n  }, {\n    key: \"renderItem\",\n    get: function get() {\n      return this._renderItem;\n    },\n    set: function set(renderItem) {\n      if (renderItem !== this.renderItem) {\n        this._renderItem = renderItem;\n        this.requestUpdate();\n      }\n    }\n  }]);\n\n  return LitVirtualizer;\n}(lit_element__WEBPACK_IMPORTED_MODULE_1__[\"LitElement\"]);\n\ntslib__WEBPACK_IMPORTED_MODULE_0__[\"__decorate\"]([Object(lit_element__WEBPACK_IMPORTED_MODULE_1__[\"property\"])()], LitVirtualizer.prototype, \"_renderItem\", void 0);\n\ntslib__WEBPACK_IMPORTED_MODULE_0__[\"__decorate\"]([Object(lit_element__WEBPACK_IMPORTED_MODULE_1__[\"property\"])()], LitVirtualizer.prototype, \"items\", void 0);\n\ntslib__WEBPACK_IMPORTED_MODULE_0__[\"__decorate\"]([Object(lit_element__WEBPACK_IMPORTED_MODULE_1__[\"property\"])()], LitVirtualizer.prototype, \"scrollTarget\", void 0);\n\nLitVirtualizer = tslib__WEBPACK_IMPORTED_MODULE_0__[\"__decorate\"]([Object(lit_element__WEBPACK_IMPORTED_MODULE_1__[\"customElement\"])('lit-virtualizer')], LitVirtualizer);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LXZpcnR1YWxpemVyL2xpYi9saXQtdmlydHVhbGl6ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGl0LXZpcnR1YWxpemVyL2xpYi9saXQtdmlydHVhbGl6ZXIuanM/ZGNmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgaHRtbCwgTGl0RWxlbWVudCwgY3VzdG9tRWxlbWVudCwgcHJvcGVydHkgfSBmcm9tICdsaXQtZWxlbWVudCc7XG5pbXBvcnQgeyBzY3JvbGwgfSBmcm9tICcuL3Njcm9sbC5qcyc7XG4vKipcbiAqIEEgTGl0RWxlbWVudCB3cmFwcGVyIG9mIHRoZSBzY3JvbGwgZGlyZWN0aXZlLlxuICpcbiAqIEltcG9ydCB0aGlzIG1vZHVsZSB0byBkZWNsYXJlIHRoZSBsaXQtdmlydHVhbGl6ZXIgY3VzdG9tIGVsZW1lbnQuXG4gKiBQYXNzIGFuIGl0ZW1zIGFycmF5LCByZW5kZXJJdGVtIG1ldGhvZCwgYW5kIHNjcm9sbCB0YXJnZXQgYXMgcHJvcGVydGllc1xuICogdG8gdGhlIDxsaXQtdmlydHVhbGl6ZXI+IGVsZW1lbnQuXG4gKi9cbmxldCBMaXRWaXJ0dWFsaXplciA9IGNsYXNzIExpdFZpcnR1YWxpemVyIGV4dGVuZHMgTGl0RWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucmVuZGVyUm9vdCA9IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRob2QgdXNlZCBmb3IgcmVuZGVyaW5nIGVhY2ggaXRlbS5cbiAgICAgKi9cbiAgICBnZXQgcmVuZGVySXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlckl0ZW07XG4gICAgfVxuICAgIHNldCByZW5kZXJJdGVtKHJlbmRlckl0ZW0pIHtcbiAgICAgICAgaWYgKHJlbmRlckl0ZW0gIT09IHRoaXMucmVuZGVySXRlbSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVySXRlbSA9IHJlbmRlckl0ZW07XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY3JvbGwgdG8gdGhlIHNwZWNpZmllZCBpbmRleCwgcGxhY2luZyB0aGF0IGl0ZW0gYXQgdGhlIGdpdmVuIHBvc2l0aW9uXG4gICAgICogaW4gdGhlIHNjcm9sbCB2aWV3LlxuICAgICAqL1xuICAgIGFzeW5jIHNjcm9sbFRvSW5kZXgoaW5kZXgsIHBvc2l0aW9uID0gJ3N0YXJ0Jykge1xuICAgICAgICB0aGlzLl9zY3JvbGxUb0luZGV4ID0geyBpbmRleCwgcG9zaXRpb24gfTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0VXBkYXRlKCk7XG4gICAgICAgIGF3YWl0IHRoaXMudXBkYXRlQ29tcGxldGU7XG4gICAgICAgIHRoaXMuX3Njcm9sbFRvSW5kZXggPSBudWxsO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBodG1sIGAke3Njcm9sbCh7XG4gICAgICAgICAgICBpdGVtczogdGhpcy5pdGVtcyxcbiAgICAgICAgICAgIHJlbmRlckl0ZW06IHRoaXMuX3JlbmRlckl0ZW0sXG4gICAgICAgICAgICBzY3JvbGxUYXJnZXQ6IHRoaXMuc2Nyb2xsVGFyZ2V0LFxuICAgICAgICAgICAgc2Nyb2xsVG9JbmRleDogdGhpcy5fc2Nyb2xsVG9JbmRleCxcbiAgICAgICAgICAgIHVzZVNoYWRvd0RPTTogdHJ1ZVxuICAgICAgICAgICAgLy8gVE9ETzogYWxsb3cgY29uZmlndXJhdGlvbiBvZiBhIGxheW91dC5cbiAgICAgICAgfSl9YDtcbiAgICB9XG59O1xudHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICBwcm9wZXJ0eSgpXG5dLCBMaXRWaXJ0dWFsaXplci5wcm90b3R5cGUsIFwiX3JlbmRlckl0ZW1cIiwgdm9pZCAwKTtcbnRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgcHJvcGVydHkoKVxuXSwgTGl0VmlydHVhbGl6ZXIucHJvdG90eXBlLCBcIml0ZW1zXCIsIHZvaWQgMCk7XG50c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgIHByb3BlcnR5KClcbl0sIExpdFZpcnR1YWxpemVyLnByb3RvdHlwZSwgXCJzY3JvbGxUYXJnZXRcIiwgdm9pZCAwKTtcbkxpdFZpcnR1YWxpemVyID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICBjdXN0b21FbGVtZW50KCdsaXQtdmlydHVhbGl6ZXInKVxuXSwgTGl0VmlydHVhbGl6ZXIpO1xuZXhwb3J0IHsgTGl0VmlydHVhbGl6ZXIgfTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUZBO0FBR0E7QUFDQTs7Ozs7QUFMQTtBQUFBO0FBQ0E7QUFnQkE7Ozs7QUFqQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQXFCQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUF2QkE7QUFBQTtBQUNBO0FBREE7QUF5QkE7QUFDQTtBQTFCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBNEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQXBDQTtBQUFBO0FBQUE7QUFTQTtBQUNBO0FBVkE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaEJBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFxQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lit-virtualizer/lib/lit-virtualizer.js\n");

/***/ }),

/***/ "./node_modules/lit-virtualizer/lib/repeat.js":
/*!****************************************************!*\
  !*** ./node_modules/lit-virtualizer/lib/repeat.js ***!
  \****************************************************/
/*! exports provided: LitMixin, LitRepeater, repeat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LitMixin\", function() { return LitMixin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LitRepeater\", function() { return LitRepeater; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"repeat\", function() { return repeat; });\n/* harmony import */ var lit_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit-html */ \"./node_modules/lit-html/lit-html.js\");\n/* harmony import */ var _uni_virtualizer_lib_VirtualRepeater_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./uni-virtualizer/lib/VirtualRepeater.js */ \"./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/VirtualRepeater.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n/**\n * Mixin for VirtualRepeater and VirtualScroller. This mixin overrides the generic\n * methods in those classes to provide lit-specific implementations of element\n * creation and manipulation.\n *\n * This mixin implements child recycling, so children can be reused after removal\n * from the DOM.\n */\n\nvar LitMixin = function LitMixin(Superclass) {\n  return /*#__PURE__*/function (_Superclass) {\n    _inherits(_class, _Superclass);\n\n    var _super = _createSuper(_class);\n\n    function _class(config) {\n      var _this;\n\n      _classCallCheck(this, _class);\n\n      var part = config.part,\n          renderItem = config.renderItem,\n          useShadowDOM = config.useShadowDOM,\n          layout = config.layout;\n      var container = part.startNode.parentNode;\n      var scrollTarget = config.scrollTarget || container;\n      _this = _super.call(this, {\n        container: container,\n        scrollTarget: scrollTarget,\n        useShadowDOM: useShadowDOM,\n        layout: layout\n      });\n      _this._pool = [];\n      _this._renderItem = renderItem;\n      _this._hostPart = part;\n      return _this;\n    }\n\n    _createClass(_class, [{\n      key: \"createElement\",\n      value: function createElement() {\n        return this._pool.pop() || new lit_html__WEBPACK_IMPORTED_MODULE_0__[\"NodePart\"](this._hostPart.options);\n      }\n    }, {\n      key: \"updateElement\",\n      value: function updateElement(part, item, idx) {\n        part.setValue(this._renderItem(item, idx));\n        part.commit();\n      }\n    }, {\n      key: \"recycleElement\",\n      value: function recycleElement(part) {\n        this._pool.push(part);\n      }\n      /*\n       * Lit-specific overrides for node manipulation\n       */\n\n    }, {\n      key: \"_node\",\n      value: function _node(part) {\n        return part.startNode;\n      }\n    }, {\n      key: \"_nextSibling\",\n      value: function _nextSibling(part) {\n        return part.endNode.nextSibling;\n      }\n    }, {\n      key: \"_insertBefore\",\n      value: function _insertBefore(part, referenceNode) {\n        if (referenceNode === null) {\n          referenceNode = this._hostPart.endNode;\n        }\n\n        if (!this._childIsAttached(part)) {\n          // Inserting new part\n          part.startNode = Object(lit_html__WEBPACK_IMPORTED_MODULE_0__[\"createMarker\"])();\n          part.endNode = Object(lit_html__WEBPACK_IMPORTED_MODULE_0__[\"createMarker\"])();\n\n          _get(_getPrototypeOf(_class.prototype), \"_insertBefore\", this).call(this, part.startNode, referenceNode);\n\n          _get(_getPrototypeOf(_class.prototype), \"_insertBefore\", this).call(this, part.endNode, referenceNode);\n        } else {\n          // Inserting existing part\n          var boundary = part.endNode.nextSibling;\n\n          if (referenceNode !== part.startNode && referenceNode !== boundary) {\n            // Part is not already in the right place\n            for (var node = part.startNode; node !== boundary;) {\n              var n = node.nextSibling;\n\n              _get(_getPrototypeOf(_class.prototype), \"_insertBefore\", this).call(this, node, referenceNode);\n\n              node = n;\n            }\n          }\n        }\n      }\n    }, {\n      key: \"_hideChild\",\n      value: function _hideChild(part) {\n        var node = part.startNode;\n\n        while (node && node !== part.endNode) {\n          _get(_getPrototypeOf(_class.prototype), \"_hideChild\", this).call(this, node);\n\n          node = node.nextSibling;\n        }\n      }\n    }, {\n      key: \"_showChild\",\n      value: function _showChild(part) {\n        var node = part.startNode;\n\n        while (node && node !== part.endNode) {\n          _get(_getPrototypeOf(_class.prototype), \"_showChild\", this).call(this, node);\n\n          node = node.nextSibling;\n        }\n      }\n    }, {\n      key: \"_measureChild\",\n      value: function _measureChild(part) {\n        // Currently, we assume there's only one node in the part (between start and\n        // end nodes)\n        return _get(_getPrototypeOf(_class.prototype), \"_measureChild\", this).call(this, part.startNode.nextElementSibling);\n      }\n    }, {\n      key: \"_kids\",\n      get: function get() {\n        return this._ordered.map(function (p) {\n          return p.startNode.nextElementSibling;\n        });\n      }\n    }]);\n\n    return _class;\n  }(Superclass);\n};\nvar LitRepeater = /*#__PURE__*/function (_LitMixin) {\n  _inherits(LitRepeater, _LitMixin);\n\n  var _super2 = _createSuper(LitRepeater);\n\n  function LitRepeater() {\n    _classCallCheck(this, LitRepeater);\n\n    return _super2.apply(this, arguments);\n  }\n\n  return LitRepeater;\n}(LitMixin(_uni_virtualizer_lib_VirtualRepeater_js__WEBPACK_IMPORTED_MODULE_1__[\"VirtualRepeater\"]));\n;\nvar partToRepeater = new WeakMap();\nvar repeat = Object(lit_html__WEBPACK_IMPORTED_MODULE_0__[\"directive\"])(function (config) {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(part) {\n      var repeater, first, num, totalItems;\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              // Retain the repeater so that re-rendering the directive's parent won't\n              // create another one.\n              repeater = partToRepeater.get(part);\n\n              if (repeater) {\n                _context.next = 7;\n                break;\n              }\n\n              if (part.startNode.isConnected) {\n                _context.next = 5;\n                break;\n              }\n\n              _context.next = 5;\n              return Promise.resolve();\n\n            case 5:\n              repeater = new LitRepeater({\n                part: part,\n                renderItem: config.renderItem\n              });\n              partToRepeater.set(part, repeater);\n\n            case 7:\n              first = config.first, num = config.num, totalItems = config.totalItems;\n              Object.assign(repeater, {\n                first: first,\n                num: num,\n                totalItems: totalItems\n              });\n\n            case 9:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LXZpcnR1YWxpemVyL2xpYi9yZXBlYXQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGl0LXZpcnR1YWxpemVyL2xpYi9yZXBlYXQuanM/ZGU1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkaXJlY3RpdmUsIE5vZGVQYXJ0LCBjcmVhdGVNYXJrZXIgfSBmcm9tICdsaXQtaHRtbCc7XG5pbXBvcnQgeyBWaXJ0dWFsUmVwZWF0ZXIgfSBmcm9tICcuL3VuaS12aXJ0dWFsaXplci9saWIvVmlydHVhbFJlcGVhdGVyLmpzJztcbi8qKlxuICogTWl4aW4gZm9yIFZpcnR1YWxSZXBlYXRlciBhbmQgVmlydHVhbFNjcm9sbGVyLiBUaGlzIG1peGluIG92ZXJyaWRlcyB0aGUgZ2VuZXJpY1xuICogbWV0aG9kcyBpbiB0aG9zZSBjbGFzc2VzIHRvIHByb3ZpZGUgbGl0LXNwZWNpZmljIGltcGxlbWVudGF0aW9ucyBvZiBlbGVtZW50XG4gKiBjcmVhdGlvbiBhbmQgbWFuaXB1bGF0aW9uLlxuICpcbiAqIFRoaXMgbWl4aW4gaW1wbGVtZW50cyBjaGlsZCByZWN5Y2xpbmcsIHNvIGNoaWxkcmVuIGNhbiBiZSByZXVzZWQgYWZ0ZXIgcmVtb3ZhbFxuICogZnJvbSB0aGUgRE9NLlxuICovXG5leHBvcnQgY29uc3QgTGl0TWl4aW4gPSAoU3VwZXJjbGFzcykgPT4gY2xhc3MgZXh0ZW5kcyBTdXBlcmNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgY29uc3QgeyBwYXJ0LCByZW5kZXJJdGVtLCB1c2VTaGFkb3dET00sIGxheW91dCB9ID0gY29uZmlnO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBwYXJ0LnN0YXJ0Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICBjb25zdCBzY3JvbGxUYXJnZXQgPSBjb25maWcuc2Nyb2xsVGFyZ2V0IHx8IGNvbnRhaW5lcjtcbiAgICAgICAgc3VwZXIoeyBjb250YWluZXIsIHNjcm9sbFRhcmdldCwgdXNlU2hhZG93RE9NLCBsYXlvdXQgfSk7XG4gICAgICAgIHRoaXMuX3Bvb2wgPSBbXTtcbiAgICAgICAgdGhpcy5fcmVuZGVySXRlbSA9IHJlbmRlckl0ZW07XG4gICAgICAgIHRoaXMuX2hvc3RQYXJ0ID0gcGFydDtcbiAgICB9XG4gICAgY3JlYXRlRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bvb2wucG9wKCkgfHwgbmV3IE5vZGVQYXJ0KHRoaXMuX2hvc3RQYXJ0Lm9wdGlvbnMpO1xuICAgIH1cbiAgICB1cGRhdGVFbGVtZW50KHBhcnQsIGl0ZW0sIGlkeCkge1xuICAgICAgICBwYXJ0LnNldFZhbHVlKHRoaXMuX3JlbmRlckl0ZW0oaXRlbSwgaWR4KSk7XG4gICAgICAgIHBhcnQuY29tbWl0KCk7XG4gICAgfVxuICAgIHJlY3ljbGVFbGVtZW50KHBhcnQpIHtcbiAgICAgICAgdGhpcy5fcG9vbC5wdXNoKHBhcnQpO1xuICAgIH1cbiAgICAvKlxuICAgICAqIExpdC1zcGVjaWZpYyBvdmVycmlkZXMgZm9yIG5vZGUgbWFuaXB1bGF0aW9uXG4gICAgICovXG4gICAgZ2V0IF9raWRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3JkZXJlZC5tYXAoKHApID0+IHAuc3RhcnROb2RlLm5leHRFbGVtZW50U2libGluZyk7XG4gICAgfVxuICAgIF9ub2RlKHBhcnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnQuc3RhcnROb2RlO1xuICAgIH1cbiAgICBfbmV4dFNpYmxpbmcocGFydCkge1xuICAgICAgICByZXR1cm4gcGFydC5lbmROb2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICBfaW5zZXJ0QmVmb3JlKHBhcnQsIHJlZmVyZW5jZU5vZGUpIHtcbiAgICAgICAgaWYgKHJlZmVyZW5jZU5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZU5vZGUgPSB0aGlzLl9ob3N0UGFydC5lbmROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fY2hpbGRJc0F0dGFjaGVkKHBhcnQpKSB7XG4gICAgICAgICAgICAvLyBJbnNlcnRpbmcgbmV3IHBhcnRcbiAgICAgICAgICAgIHBhcnQuc3RhcnROb2RlID0gY3JlYXRlTWFya2VyKCk7XG4gICAgICAgICAgICBwYXJ0LmVuZE5vZGUgPSBjcmVhdGVNYXJrZXIoKTtcbiAgICAgICAgICAgIHN1cGVyLl9pbnNlcnRCZWZvcmUocGFydC5zdGFydE5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICAgICAgICAgICAgc3VwZXIuX2luc2VydEJlZm9yZShwYXJ0LmVuZE5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSW5zZXJ0aW5nIGV4aXN0aW5nIHBhcnRcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kYXJ5ID0gcGFydC5lbmROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKHJlZmVyZW5jZU5vZGUgIT09IHBhcnQuc3RhcnROb2RlICYmIHJlZmVyZW5jZU5vZGUgIT09IGJvdW5kYXJ5KSB7XG4gICAgICAgICAgICAgICAgLy8gUGFydCBpcyBub3QgYWxyZWFkeSBpbiB0aGUgcmlnaHQgcGxhY2VcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBub2RlID0gcGFydC5zdGFydE5vZGU7IG5vZGUgIT09IGJvdW5kYXJ5Oykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIuX2luc2VydEJlZm9yZShub2RlLCByZWZlcmVuY2VOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9oaWRlQ2hpbGQocGFydCkge1xuICAgICAgICBsZXQgbm9kZSA9IHBhcnQuc3RhcnROb2RlO1xuICAgICAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9PSBwYXJ0LmVuZE5vZGUpIHtcbiAgICAgICAgICAgIHN1cGVyLl9oaWRlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc2hvd0NoaWxkKHBhcnQpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBwYXJ0LnN0YXJ0Tm9kZTtcbiAgICAgICAgd2hpbGUgKG5vZGUgJiYgbm9kZSAhPT0gcGFydC5lbmROb2RlKSB7XG4gICAgICAgICAgICBzdXBlci5fc2hvd0NoaWxkKG5vZGUpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX21lYXN1cmVDaGlsZChwYXJ0KSB7XG4gICAgICAgIC8vIEN1cnJlbnRseSwgd2UgYXNzdW1lIHRoZXJlJ3Mgb25seSBvbmUgbm9kZSBpbiB0aGUgcGFydCAoYmV0d2VlbiBzdGFydCBhbmRcbiAgICAgICAgLy8gZW5kIG5vZGVzKVxuICAgICAgICByZXR1cm4gc3VwZXIuX21lYXN1cmVDaGlsZChwYXJ0LnN0YXJ0Tm9kZS5uZXh0RWxlbWVudFNpYmxpbmcpO1xuICAgIH1cbn07XG5leHBvcnQgY2xhc3MgTGl0UmVwZWF0ZXIgZXh0ZW5kcyBMaXRNaXhpbihWaXJ0dWFsUmVwZWF0ZXIpIHtcbn1cbjtcbmNvbnN0IHBhcnRUb1JlcGVhdGVyID0gbmV3IFdlYWtNYXAoKTtcbmV4cG9ydCBjb25zdCByZXBlYXQgPSBkaXJlY3RpdmUoKGNvbmZpZykgPT4gYXN5bmMgKHBhcnQpID0+IHtcbiAgICAvLyBSZXRhaW4gdGhlIHJlcGVhdGVyIHNvIHRoYXQgcmUtcmVuZGVyaW5nIHRoZSBkaXJlY3RpdmUncyBwYXJlbnQgd29uJ3RcbiAgICAvLyBjcmVhdGUgYW5vdGhlciBvbmUuXG4gICAgbGV0IHJlcGVhdGVyID0gcGFydFRvUmVwZWF0ZXIuZ2V0KHBhcnQpO1xuICAgIGlmICghcmVwZWF0ZXIpIHtcbiAgICAgICAgaWYgKCFwYXJ0LnN0YXJ0Tm9kZS5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVwZWF0ZXIgPSBuZXcgTGl0UmVwZWF0ZXIoeyBwYXJ0LCByZW5kZXJJdGVtOiBjb25maWcucmVuZGVySXRlbSB9KTtcbiAgICAgICAgcGFydFRvUmVwZWF0ZXIuc2V0KHBhcnQsIHJlcGVhdGVyKTtcbiAgICB9XG4gICAgY29uc3QgeyBmaXJzdCwgbnVtLCB0b3RhbEl0ZW1zIH0gPSBjb25maWc7XG4gICAgT2JqZWN0LmFzc2lnbihyZXBlYXRlciwgeyBmaXJzdCwgbnVtLCB0b3RhbEl0ZW1zIH0pO1xufSk7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBUUE7QUFDQTtBQVZBO0FBQUE7QUFBQTtBQVdBO0FBQ0E7QUFaQTtBQUFBO0FBQUE7QUFjQTtBQUNBO0FBQ0E7QUFoQkE7QUFBQTtBQUFBO0FBa0JBO0FBQ0E7QUFDQTs7OztBQXBCQTtBQUFBO0FBQUE7QUEyQkE7QUFDQTtBQTVCQTtBQUFBO0FBQUE7QUE4QkE7QUFDQTtBQS9CQTtBQUFBO0FBQUE7QUFpQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF2REE7QUFBQTtBQUFBO0FBeURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUE5REE7QUFBQTtBQUFBO0FBZ0VBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFyRUE7QUFBQTtBQUFBO0FBdUVBO0FBQ0E7QUFDQTtBQUNBO0FBMUVBO0FBQUE7QUFBQTtBQXdCQTtBQUFBO0FBQUE7QUFDQTtBQXpCQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBNEVBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFRQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFWQTtBQVdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBYkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lit-virtualizer/lib/repeat.js\n");

/***/ }),

/***/ "./node_modules/lit-virtualizer/lib/scroll.js":
/*!****************************************************!*\
  !*** ./node_modules/lit-virtualizer/lib/scroll.js ***!
  \****************************************************/
/*! exports provided: LitScroller, scroll */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LitScroller\", function() { return LitScroller; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scroll\", function() { return scroll; });\n/* harmony import */ var lit_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit-html */ \"./node_modules/lit-html/lit-html.js\");\n/* harmony import */ var _uni_virtualizer_lib_VirtualScroller_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./uni-virtualizer/lib/VirtualScroller.js */ \"./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/VirtualScroller.js\");\n/* harmony import */ var _repeat_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./repeat.js */ \"./node_modules/lit-virtualizer/lib/repeat.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\nvar LitScroller = /*#__PURE__*/function (_LitMixin) {\n  _inherits(LitScroller, _LitMixin);\n\n  var _super = _createSuper(LitScroller);\n\n  function LitScroller() {\n    _classCallCheck(this, LitScroller);\n\n    return _super.apply(this, arguments);\n  }\n\n  return LitScroller;\n}(Object(_repeat_js__WEBPACK_IMPORTED_MODULE_2__[\"LitMixin\"])(_uni_virtualizer_lib_VirtualScroller_js__WEBPACK_IMPORTED_MODULE_1__[\"VirtualScroller\"]));\nvar partToScroller = new WeakMap();\n/**\n * A lit-html directive that turns its parent node into a virtual scroller.\n *\n * See ScrollConfig interface for configuration options.\n */\n\nvar scroll = Object(lit_html__WEBPACK_IMPORTED_MODULE_0__[\"directive\"])(function (config) {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(part) {\n      var scroller, renderItem, layout, scrollTarget, useShadowDOM;\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              // Retain the scroller so that re-rendering the directive's parent won't\n              // create another one.\n              scroller = partToScroller.get(part);\n\n              if (scroller) {\n                _context.next = 8;\n                break;\n              }\n\n              if (part.startNode.isConnected) {\n                _context.next = 5;\n                break;\n              }\n\n              _context.next = 5;\n              return Promise.resolve();\n\n            case 5:\n              renderItem = config.renderItem, layout = config.layout, scrollTarget = config.scrollTarget, useShadowDOM = config.useShadowDOM;\n              scroller = new LitScroller({\n                part: part,\n                renderItem: renderItem,\n                layout: layout,\n                scrollTarget: scrollTarget,\n                useShadowDOM: useShadowDOM\n              });\n              partToScroller.set(part, scroller);\n\n            case 8:\n              Object.assign(scroller, {\n                items: config.items,\n                totalItems: config.totalItems === undefined ? null : config.totalItems,\n                scrollToIndex: config.scrollToIndex === undefined ? null : config.scrollToIndex\n              });\n\n            case 9:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LXZpcnR1YWxpemVyL2xpYi9zY3JvbGwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGl0LXZpcnR1YWxpemVyL2xpYi9zY3JvbGwuanM/ZDhjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkaXJlY3RpdmUgfSBmcm9tICdsaXQtaHRtbCc7XG5pbXBvcnQgeyBWaXJ0dWFsU2Nyb2xsZXIgfSBmcm9tICcuL3VuaS12aXJ0dWFsaXplci9saWIvVmlydHVhbFNjcm9sbGVyLmpzJztcbmltcG9ydCB7IExpdE1peGluIH0gZnJvbSAnLi9yZXBlYXQuanMnO1xuZXhwb3J0IGNsYXNzIExpdFNjcm9sbGVyIGV4dGVuZHMgTGl0TWl4aW4oVmlydHVhbFNjcm9sbGVyKSB7XG59XG5jb25zdCBwYXJ0VG9TY3JvbGxlciA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIEEgbGl0LWh0bWwgZGlyZWN0aXZlIHRoYXQgdHVybnMgaXRzIHBhcmVudCBub2RlIGludG8gYSB2aXJ0dWFsIHNjcm9sbGVyLlxuICpcbiAqIFNlZSBTY3JvbGxDb25maWcgaW50ZXJmYWNlIGZvciBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gKi9cbmV4cG9ydCBjb25zdCBzY3JvbGwgPSBkaXJlY3RpdmUoKGNvbmZpZykgPT4gYXN5bmMgKHBhcnQpID0+IHtcbiAgICAvLyBSZXRhaW4gdGhlIHNjcm9sbGVyIHNvIHRoYXQgcmUtcmVuZGVyaW5nIHRoZSBkaXJlY3RpdmUncyBwYXJlbnQgd29uJ3RcbiAgICAvLyBjcmVhdGUgYW5vdGhlciBvbmUuXG4gICAgbGV0IHNjcm9sbGVyID0gcGFydFRvU2Nyb2xsZXIuZ2V0KHBhcnQpO1xuICAgIGlmICghc2Nyb2xsZXIpIHtcbiAgICAgICAgaWYgKCFwYXJ0LnN0YXJ0Tm9kZS5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyByZW5kZXJJdGVtLCBsYXlvdXQsIHNjcm9sbFRhcmdldCwgdXNlU2hhZG93RE9NIH0gPSBjb25maWc7XG4gICAgICAgIHNjcm9sbGVyID0gbmV3IExpdFNjcm9sbGVyKHsgcGFydCwgcmVuZGVySXRlbSwgbGF5b3V0LCBzY3JvbGxUYXJnZXQsIHVzZVNoYWRvd0RPTSB9KTtcbiAgICAgICAgcGFydFRvU2Nyb2xsZXIuc2V0KHBhcnQsIHNjcm9sbGVyKTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihzY3JvbGxlciwge1xuICAgICAgICBpdGVtczogY29uZmlnLml0ZW1zLFxuICAgICAgICB0b3RhbEl0ZW1zOiBjb25maWcudG90YWxJdGVtcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy50b3RhbEl0ZW1zLFxuICAgICAgICBzY3JvbGxUb0luZGV4OiBjb25maWcuc2Nyb2xsVG9JbmRleCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5zY3JvbGxUb0luZGV4LFxuICAgIH0pO1xufSk7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUVBO0FBQ0E7Ozs7OztBQUtBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFRQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQVhBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBYkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lit-virtualizer/lib/scroll.js\n");

/***/ }),

/***/ "./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/VirtualRepeater.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/VirtualRepeater.js ***!
  \*********************************************************************************/
/*! exports provided: VirtualRepeater */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VirtualRepeater\", function() { return VirtualRepeater; });\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar VirtualRepeater = /*#__PURE__*/function () {\n  function VirtualRepeater(config) {\n    _classCallCheck(this, VirtualRepeater);\n\n    /**\n     * Invoked when a new (not recycled) child needs to be displayed.\n     * Set by createElement.\n     */\n    this._createElementFn = null;\n    /**\n     * Invoked on new (including recycled) children after the range changes.\n     * Set by updateElement.\n     */\n\n    this._updateElementFn = null;\n    /**\n     * Invoked on outgoing children after the range changes. Set by recycleElement.\n     */\n\n    this._recycleElementFn = null;\n    /**\n     * Used for generating a key for storing references to children. Set by elementKey.\n     */\n\n    this._elementKeyFn = null;\n    /**\n     * Items to render. Set by items.\n     */\n\n    this._items = [];\n    /**\n     * Total number of items to render. Set by totalItems.\n     */\n\n    this._totalItems = null;\n    /**\n     * Flag for asynchnronous reset requests. Resetting clears and reinserts\n     * children in the range.\n     */\n\n    this._needsReset = false;\n    /**\n     * Flag for asynchnronous remeasure requests. Signals that all children\n     * should be remeasured.\n     */\n\n    this._needsRemeasure = false;\n    /**\n     * Used to keep track of children that can be cleaned up after a range update.\n     */\n\n    this._active = new Map();\n    this._prevActive = new Map();\n    /**\n     * Used for recycling purposes.\n     */\n\n    this._keyToChild = new Map();\n    this._childToKey = new WeakMap();\n    /**\n     * Used to keep track of measures by index.\n     */\n\n    this._indexToMeasure = {};\n    this.__incremental = false;\n    /**\n     * Invoked at the end of each render cycle: children in the range are\n     * measured, and their dimensions passed to this callback. Use it to layout\n     * children as needed.\n     */\n\n    this._measureCallback = null;\n    /**\n     * Number of children in the range. Set by num.\n     * TODO @straversi: Consider renaming this. count? visibleElements?\n     */\n\n    this._num = Infinity;\n    /**\n     * Index of the first child in the range, not necessarily the first visible child.\n     * TODO @straversi: Consider renaming these.\n     */\n\n    this._first = 0;\n    /**\n     * Index of the last child in the range.\n     */\n\n    this._last = 0;\n    /**\n     * Previous first rendered index. Used to avoid unnecessary updates.\n     */\n\n    this._prevFirst = 0;\n    /**\n     * Previous last rendered index. Used to avoid unnecessary updates.\n     */\n\n    this._prevLast = 0;\n    /**\n     * Flag for asynchnronous render requests. Renders can be requested several\n     * times before a render actually happens.\n     */\n\n    this._pendingRender = null;\n    /**\n     * Containing element. Set by container.\n     */\n\n    this._container = null;\n    /**\n     * Children in the rendered order.\n     */\n\n    this._ordered = [];\n\n    if (config) {\n      Object.assign(this, config);\n    }\n  } // API\n\n  /**\n   * The parent of all child nodes to be rendered.\n   */\n\n\n  _createClass(VirtualRepeater, [{\n    key: \"requestRemeasure\",\n\n    /**\n     * Invoke to request that all elements in the range be measured.\n     */\n    value: function requestRemeasure() {\n      this._needsRemeasure = true;\n\n      this._scheduleRender();\n    } // Core functionality\n\n  }, {\n    key: \"_shouldRender\",\n    value: function _shouldRender() {\n      return Boolean(this.container && this.createElement);\n    }\n    /**\n     * Render at the next opportunity.\n     */\n\n  }, {\n    key: \"_scheduleRender\",\n    value: function () {\n      var _scheduleRender2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this._pendingRender) {\n                  _context.next = 6;\n                  break;\n                }\n\n                this._pendingRender = true;\n                _context.next = 4;\n                return Promise.resolve();\n\n              case 4:\n                this._pendingRender = false;\n\n                if (this._shouldRender()) {\n                  this._render();\n                } // this._pendingRender = requestAnimationFrame(() => {\n                //   this._pendingRender = null;\n                //   if (this._shouldRender()) {\n                //     this._render();\n                //   }\n                // });\n\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _scheduleRender() {\n        return _scheduleRender2.apply(this, arguments);\n      }\n\n      return _scheduleRender;\n    }()\n    /**\n     * Invoke to request that all elements in the range be updated.\n     */\n\n  }, {\n    key: \"requestReset\",\n    value: function requestReset() {\n      this._needsReset = true;\n\n      this._scheduleRender();\n    }\n    /**\n     * Returns those children that are about to be displayed and that require to\n     * be positioned. If reset or remeasure has been triggered, all children are\n     * returned.\n     */\n\n  }, {\n    key: \"_measureChildren\",\n\n    /**\n     * Measures each child bounds and builds a map of index/bounds to be passed\n     * to the `_measureCallback`\n     */\n    value: function () {\n      var _measureChildren2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref) {\n        var _this = this;\n\n        var indices, children, pm, mm;\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                indices = _ref.indices, children = _ref.children;\n                _context2.next = 3;\n                return new Promise(function (resolve) {\n                  requestAnimationFrame(resolve);\n                });\n\n              case 3:\n                pm = children.map(function (c) {\n                  return _this._measureChild(c);\n                });\n                mm =\n                /** @type {{number: {width: number, height: number}}} */\n                pm.reduce(function (out, cur, i) {\n                  out[indices[i]] = _this._indexToMeasure[indices[i]] = cur;\n                  return out;\n                }, {});\n\n                this._measureCallback(mm);\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _measureChildren(_x) {\n        return _measureChildren2.apply(this, arguments);\n      }\n\n      return _measureChildren;\n    }()\n    /**\n     * Render items within the current range to the DOM.\n     */\n\n  }, {\n    key: \"_render\",\n    value: function () {\n      var _render2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {\n        var _this2 = this;\n\n        var rangeChanged, shouldMeasure, toMeasure;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                rangeChanged = this._first !== this._prevFirst || this._num !== this._prevNum; // Create/update/recycle DOM.\n\n                if (rangeChanged || this._needsReset) {\n                  this._last = this._first + Math.min(this._num, this.totalItems - this._first) - 1;\n\n                  if (this._num || this._prevNum) {\n                    if (this._needsReset) {\n                      this._reset(this._first, this._last);\n                    } else {\n                      // Remove old children and insert new children without touching\n                      // shared children.\n                      this._discardHead();\n\n                      this._discardTail();\n\n                      this._addHead();\n\n                      this._addTail();\n                    }\n                  }\n                }\n\n                if (this._needsRemeasure || this._needsReset) {\n                  this._indexToMeasure = {};\n                } // Retrieve DOM to be measured.\n                // Do it right before cleanup and reset of properties.\n\n\n                shouldMeasure = this._num > 0 && this._measureCallback && (rangeChanged || this._needsRemeasure || this._needsReset);\n                toMeasure = shouldMeasure ? this._toMeasure : null; // Cleanup.\n\n                if (!this._incremental) {\n                  this._prevActive.forEach(function (idx, child) {\n                    return _this2._unassignChild(child, idx);\n                  });\n\n                  this._prevActive.clear();\n                } // Reset internal properties.\n\n\n                this._prevFirst = this._first;\n                this._prevLast = this._last;\n                this._prevNum = this._num;\n                this._needsReset = false;\n                this._needsRemeasure = false; // Notify render completed.\n\n                this._didRender(); // Measure DOM.\n\n\n                if (!toMeasure) {\n                  _context3.next = 15;\n                  break;\n                }\n\n                _context3.next = 15;\n                return this._measureChildren(toMeasure);\n\n              case 15:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _render() {\n        return _render2.apply(this, arguments);\n      }\n\n      return _render;\n    }()\n    /**\n     * Invoked after DOM is updated, and before it gets measured.\n     */\n\n  }, {\n    key: \"_didRender\",\n    value: function _didRender() {}\n    /**\n     * Unassigns any children at indices lower than the start of the current\n     * range.\n     */\n\n  }, {\n    key: \"_discardHead\",\n    value: function _discardHead() {\n      var o = this._ordered;\n\n      for (var idx = this._prevFirst; o.length && idx < this._first; idx++) {\n        this._unassignChild(o.shift(), idx);\n      }\n    }\n    /**\n     * Unassigns any children at indices higher than the end of the current\n     * range.\n     */\n\n  }, {\n    key: \"_discardTail\",\n    value: function _discardTail() {\n      var o = this._ordered;\n\n      for (var idx = this._prevLast; o.length && idx > this._last; idx--) {\n        this._unassignChild(o.pop(), idx);\n      }\n    }\n    /**\n     * Assigns and inserts non-existent children from the current range with\n     * indices lower than the start of the previous range.\n     */\n\n  }, {\n    key: \"_addHead\",\n    value: function _addHead() {\n      var start = this._first;\n      var end = Math.min(this._last, this._prevFirst - 1);\n\n      for (var idx = end; idx >= start; idx--) {\n        var child = this._assignChild(idx); // Maintain dom order.\n\n\n        this._insertBefore(child, this._firstChild);\n\n        if (this.updateElement) {\n          this.updateElement(child, this._items[idx], idx);\n        }\n\n        this._ordered.unshift(child);\n      }\n    }\n    /**\n     * Assigns and appends non-existent children from the current range with\n     * indices higher than the end of the previous range.\n     */\n\n  }, {\n    key: \"_addTail\",\n    value: function _addTail() {\n      var start = Math.max(this._first, this._prevLast + 1);\n      var end = this._last;\n\n      for (var idx = start; idx <= end; idx++) {\n        var child = this._assignChild(idx); // Maintain dom order.\n\n\n        this._insertBefore(child, null);\n\n        if (this.updateElement) {\n          this.updateElement(child, this._items[idx], idx);\n        }\n\n        this._ordered.push(child);\n      }\n    }\n    /**\n     * Re-insert and update children in the given range.\n     */\n\n  }, {\n    key: \"_reset\",\n    value: function _reset(first, last) {\n      // Swapping prevActive with active affects _assignChild.\n      // Upon resetting, the current active children become potentially inactive.\n      // _assignChild will remove a child from _prevActive if it is still active.\n      var prevActive = this._active;\n      this._active = this._prevActive;\n      this._prevActive = prevActive;\n      this._ordered.length = 0;\n      var currentMarker = this._firstChild;\n\n      for (var i = first; i <= last; i++) {\n        var child = this._assignChild(i);\n\n        this._ordered.push(child);\n\n        if (currentMarker) {\n          if (currentMarker === this._node(child)) {\n            currentMarker = this._nextSibling(child);\n          } else {\n            this._insertBefore(child, currentMarker);\n          }\n        } else if (!this._childIsAttached(child)) {\n          this._insertBefore(child, null);\n        }\n\n        if (this.updateElement) {\n          this.updateElement(child, this._items[i], i);\n        }\n      }\n    }\n    /**\n     * Instantiates, tracks, and returns the child at idx.\n     * Prevents cleanup of children that already exist.\n     * Returns the new child at idx.\n     */\n\n  }, {\n    key: \"_assignChild\",\n    value: function _assignChild(idx) {\n      var key = this.elementKey ? this.elementKey(idx) : idx;\n      var child;\n\n      if (child = this._keyToChild.get(key)) {\n        this._prevActive[\"delete\"](child);\n      } else {\n        child = this.createElement(this._items[idx], idx);\n\n        this._keyToChild.set(key, child);\n\n        this._childToKey.set(child, key);\n      }\n\n      this._showChild(child);\n\n      this._active.set(child, idx);\n\n      return child;\n    }\n    /**\n     * Removes the child at idx, recycling it if possible.\n     */\n\n  }, {\n    key: \"_unassignChild\",\n    value: function _unassignChild(child, idx) {\n      this._hideChild(child);\n\n      if (this._incremental) {\n        this._active[\"delete\"](child);\n\n        this._prevActive.set(child, idx);\n      } else {\n        var key = this._childToKey.get(child);\n\n        this._childToKey[\"delete\"](child);\n\n        this._keyToChild[\"delete\"](key);\n\n        this._active[\"delete\"](child);\n\n        if (this.recycleElement) {\n          this.recycleElement(child, idx);\n        } else if (this._node(child).parentNode) {\n          this._removeChild(child);\n        }\n      }\n    }\n    /**\n     * Returns the node for the first child in the current range, if the node is\n     * in the DOM.\n     * TODO: Is this the right name?\n     */\n\n  }, {\n    key: \"_node\",\n\n    /**\n     * Overridable abstractions for child manipulation\n     */\n\n    /**\n     * Return the node for child.\n     * Override if child !== child's node.\n     */\n    value: function _node(child) {\n      return child;\n    }\n    /**\n     * Returns the next node sibling of a child node.\n     */\n\n  }, {\n    key: \"_nextSibling\",\n    value: function _nextSibling(child) {\n      return child.nextSibling;\n    }\n    /**\n     * Inserts child before referenceNode in the container.\n     * Override to control child insertion.\n     */\n\n  }, {\n    key: \"_insertBefore\",\n    value: function _insertBefore(child, referenceNode) {\n      this._container.insertBefore(child, referenceNode);\n    }\n    /**\n     * Removes child from the DOM.\n     * TODO @straversi: this will not work (_node should be called on child), but\n     * is not currently being used or tested.\n     */\n\n  }, {\n    key: \"_removeChild\",\n    value: function _removeChild(child) {\n      child.parentNode.removeChild(child);\n    }\n    /**\n     * Returns whether the child's node is a child of the container\n     * element.\n     */\n\n  }, {\n    key: \"_childIsAttached\",\n    value: function _childIsAttached(child) {\n      var node = this._node(child);\n\n      return node && node.parentNode === this._container;\n    }\n    /**\n     * Sets the display style of the given node to 'none'.\n     */\n\n  }, {\n    key: \"_hideChild\",\n    value: function _hideChild(child) {\n      if (child instanceof HTMLElement) {\n        child.style.display = 'none';\n      }\n    }\n    /**\n     * Sets the display style of the given node to null.\n     */\n\n  }, {\n    key: \"_showChild\",\n    value: function _showChild(child) {\n      if (child instanceof HTMLElement) {\n        child.style.display = null;\n      }\n    }\n    /**\n     * Returns the width, height, and margins of the given child.\n     * Override if child !== child's node.\n     */\n\n  }, {\n    key: \"_measureChild\",\n    value: function _measureChild(child) {\n      // offsetWidth doesn't take transforms in consideration, so we use\n      // getBoundingClientRect which does.\n      var _child$getBoundingCli = child.getBoundingClientRect(),\n          width = _child$getBoundingCli.width,\n          height = _child$getBoundingCli.height;\n\n      return Object.assign({\n        width: width,\n        height: height\n      }, getMargins(child));\n    }\n  }, {\n    key: \"container\",\n    get: function get() {\n      return this._container;\n    },\n    set: function set(container) {\n      var _this3 = this;\n\n      if (container === this._container) {\n        return;\n      }\n\n      if (this._container) {\n        // Remove children from old container.\n        this._ordered.forEach(function (child) {\n          return _this3._removeChild(child);\n        });\n      }\n\n      this._container = container;\n\n      if (container) {\n        // Insert children in new container.\n        this._ordered.forEach(function (child) {\n          return _this3._insertBefore(child, null);\n        });\n      } else {\n        this._ordered.length = 0;\n\n        this._active.clear();\n\n        this._prevActive.clear();\n      }\n\n      this.requestReset();\n    }\n    /**\n     * Invoked to create a child.\n     * Override or set directly to control element creation.\n     */\n\n  }, {\n    key: \"createElement\",\n    get: function get() {\n      return this._createElementFn;\n    },\n    set: function set(fn) {\n      if (fn !== this._createElementFn) {\n        this._createElementFn = fn;\n\n        this._keyToChild.clear();\n\n        this.requestReset();\n      }\n    }\n    /**\n     * Invoked to update a child.\n     * Override or set directly to control element updates.\n     */\n\n  }, {\n    key: \"updateElement\",\n    get: function get() {\n      return this._updateElementFn;\n    },\n    set: function set(fn) {\n      if (fn !== this._updateElementFn) {\n        this._updateElementFn = fn;\n        this.requestReset();\n      }\n    }\n    /**\n     * Invoked in place of removing a child from the DOM, so that it can be reused.\n     * Override or set directly to prepare children for reuse.\n     */\n\n  }, {\n    key: \"recycleElement\",\n    get: function get() {\n      return this._recycleElementFn;\n    },\n    set: function set(fn) {\n      if (fn !== this._recycleElementFn) {\n        this._recycleElementFn = fn;\n        this.requestReset();\n      }\n    }\n    /**\n     * Invoked to generate a key for an element.\n     * Override or set directly to control how keys are generated for children.\n     */\n\n  }, {\n    key: \"elementKey\",\n    get: function get() {\n      return this._elementKeyFn;\n    },\n    set: function set(fn) {\n      if (fn !== this._elementKeyFn) {\n        this._elementKeyFn = fn;\n\n        this._keyToChild.clear();\n\n        this.requestReset();\n      }\n    }\n    /**\n     * The index of the first child in the range.\n     */\n\n  }, {\n    key: \"first\",\n    get: function get() {\n      return this._first;\n    },\n    set: function set(idx) {\n      if (typeof idx !== 'number') {\n        throw new Error('New value must be a number.');\n      }\n\n      var newFirst = Math.max(0, Math.min(idx, this.totalItems - this._num));\n\n      if (newFirst !== this._first) {\n        this._first = newFirst;\n\n        this._scheduleRender();\n      }\n    }\n    /**\n     * The number of children in the range.\n     */\n\n  }, {\n    key: \"num\",\n    get: function get() {\n      return this._num;\n    },\n    set: function set(n) {\n      if (typeof n !== 'number') {\n        throw new Error('New value must be a number.');\n      }\n\n      if (n !== this._num) {\n        this._num = n;\n        this.first = this._first;\n\n        this._scheduleRender();\n      }\n    }\n    /**\n     * An array of data to be used to render child nodes.\n     */\n\n  }, {\n    key: \"items\",\n    get: function get() {\n      return this._items;\n    },\n    set: function set(items) {\n      if (items !== this._items && Array.isArray(items)) {\n        this._items = items;\n        this.requestReset();\n      }\n    }\n    /**\n     * The total number of items, regardless of the range, that can be rendered\n     * as child nodes.\n     */\n\n  }, {\n    key: \"totalItems\",\n    get: function get() {\n      return this._totalItems === null ? this._items.length : this._totalItems;\n    },\n    set: function set(num) {\n      if (typeof num !== 'number' && num !== null) {\n        throw new Error('New value must be a number.');\n      } // TODO(valdrin) should we check if it is a finite number?\n      // Technically, Infinity would break Layout, not VirtualRepeater.\n\n\n      if (num !== this._totalItems) {\n        this._totalItems = num;\n        this.first = this._first;\n        this.requestReset();\n      }\n    }\n    /**\n     * TODO @straversi: Document this.\n     */\n\n  }, {\n    key: \"_incremental\",\n    get: function get() {\n      return this.__incremental;\n    },\n    set: function set(inc) {\n      if (inc !== this.__incremental) {\n        this.__incremental = inc;\n\n        this._scheduleRender();\n      }\n    }\n  }, {\n    key: \"_toMeasure\",\n    get: function get() {\n      var _this4 = this;\n\n      return this._ordered.reduce(function (toMeasure, c, i) {\n        var idx = _this4._first + i;\n\n        if (_this4._needsReset || _this4._needsRemeasure || idx < _this4._prevFirst || idx > _this4._prevLast) {\n          toMeasure.indices.push(idx);\n          toMeasure.children.push(c);\n        }\n\n        return toMeasure;\n      }, {\n        indices: [],\n        children: []\n      });\n    }\n  }, {\n    key: \"_firstChild\",\n    get: function get() {\n      return this._ordered.length && this._childIsAttached(this._ordered[0]) ? this._node(this._ordered[0]) : null;\n    }\n  }]);\n\n  return VirtualRepeater;\n}();\n\nfunction getMargins(el) {\n  var style = window.getComputedStyle(el);\n  return {\n    marginTop: getMarginValue(style.marginTop),\n    marginRight: getMarginValue(style.marginRight),\n    marginBottom: getMarginValue(style.marginBottom),\n    marginLeft: getMarginValue(style.marginLeft)\n  };\n}\n\nfunction getMarginValue(value) {\n  var _float = value ? parseFloat(value) : NaN;\n\n  return Number.isNaN(_float) ? 0 : _float;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LXZpcnR1YWxpemVyL2xpYi91bmktdmlydHVhbGl6ZXIvbGliL1ZpcnR1YWxSZXBlYXRlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saXQtdmlydHVhbGl6ZXIvbGliL3VuaS12aXJ0dWFsaXplci9saWIvVmlydHVhbFJlcGVhdGVyLmpzPzhhYzEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIFZpcnR1YWxSZXBlYXRlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnZva2VkIHdoZW4gYSBuZXcgKG5vdCByZWN5Y2xlZCkgY2hpbGQgbmVlZHMgdG8gYmUgZGlzcGxheWVkLlxuICAgICAgICAgKiBTZXQgYnkgY3JlYXRlRWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2NyZWF0ZUVsZW1lbnRGbiA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnZva2VkIG9uIG5ldyAoaW5jbHVkaW5nIHJlY3ljbGVkKSBjaGlsZHJlbiBhZnRlciB0aGUgcmFuZ2UgY2hhbmdlcy5cbiAgICAgICAgICogU2V0IGJ5IHVwZGF0ZUVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl91cGRhdGVFbGVtZW50Rm4gPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW52b2tlZCBvbiBvdXRnb2luZyBjaGlsZHJlbiBhZnRlciB0aGUgcmFuZ2UgY2hhbmdlcy4gU2V0IGJ5IHJlY3ljbGVFbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcmVjeWNsZUVsZW1lbnRGbiA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIGZvciBnZW5lcmF0aW5nIGEga2V5IGZvciBzdG9yaW5nIHJlZmVyZW5jZXMgdG8gY2hpbGRyZW4uIFNldCBieSBlbGVtZW50S2V5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZWxlbWVudEtleUZuID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZW1zIHRvIHJlbmRlci4gU2V0IGJ5IGl0ZW1zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRvdGFsIG51bWJlciBvZiBpdGVtcyB0byByZW5kZXIuIFNldCBieSB0b3RhbEl0ZW1zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdG90YWxJdGVtcyA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGbGFnIGZvciBhc3luY2hucm9ub3VzIHJlc2V0IHJlcXVlc3RzLiBSZXNldHRpbmcgY2xlYXJzIGFuZCByZWluc2VydHNcbiAgICAgICAgICogY2hpbGRyZW4gaW4gdGhlIHJhbmdlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbmVlZHNSZXNldCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmxhZyBmb3IgYXN5bmNobnJvbm91cyByZW1lYXN1cmUgcmVxdWVzdHMuIFNpZ25hbHMgdGhhdCBhbGwgY2hpbGRyZW5cbiAgICAgICAgICogc2hvdWxkIGJlIHJlbWVhc3VyZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9uZWVkc1JlbWVhc3VyZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIHRoYXQgY2FuIGJlIGNsZWFuZWQgdXAgYWZ0ZXIgYSByYW5nZSB1cGRhdGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9hY3RpdmUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3ByZXZBY3RpdmUgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIGZvciByZWN5Y2xpbmcgcHVycG9zZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9rZXlUb0NoaWxkID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jaGlsZFRvS2V5ID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZWQgdG8ga2VlcCB0cmFjayBvZiBtZWFzdXJlcyBieSBpbmRleC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2luZGV4VG9NZWFzdXJlID0ge307XG4gICAgICAgIHRoaXMuX19pbmNyZW1lbnRhbCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW52b2tlZCBhdCB0aGUgZW5kIG9mIGVhY2ggcmVuZGVyIGN5Y2xlOiBjaGlsZHJlbiBpbiB0aGUgcmFuZ2UgYXJlXG4gICAgICAgICAqIG1lYXN1cmVkLCBhbmQgdGhlaXIgZGltZW5zaW9ucyBwYXNzZWQgdG8gdGhpcyBjYWxsYmFjay4gVXNlIGl0IHRvIGxheW91dFxuICAgICAgICAgKiBjaGlsZHJlbiBhcyBuZWVkZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tZWFzdXJlQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogTnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoZSByYW5nZS4gU2V0IGJ5IG51bS5cbiAgICAgICAgICogVE9ETyBAc3RyYXZlcnNpOiBDb25zaWRlciByZW5hbWluZyB0aGlzLiBjb3VudD8gdmlzaWJsZUVsZW1lbnRzP1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbnVtID0gSW5maW5pdHk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRleCBvZiB0aGUgZmlyc3QgY2hpbGQgaW4gdGhlIHJhbmdlLCBub3QgbmVjZXNzYXJpbHkgdGhlIGZpcnN0IHZpc2libGUgY2hpbGQuXG4gICAgICAgICAqIFRPRE8gQHN0cmF2ZXJzaTogQ29uc2lkZXIgcmVuYW1pbmcgdGhlc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9maXJzdCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRleCBvZiB0aGUgbGFzdCBjaGlsZCBpbiB0aGUgcmFuZ2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sYXN0ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByZXZpb3VzIGZpcnN0IHJlbmRlcmVkIGluZGV4LiBVc2VkIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHVwZGF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9wcmV2Rmlyc3QgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJldmlvdXMgbGFzdCByZW5kZXJlZCBpbmRleC4gVXNlZCB0byBhdm9pZCB1bm5lY2Vzc2FyeSB1cGRhdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcHJldkxhc3QgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmxhZyBmb3IgYXN5bmNobnJvbm91cyByZW5kZXIgcmVxdWVzdHMuIFJlbmRlcnMgY2FuIGJlIHJlcXVlc3RlZCBzZXZlcmFsXG4gICAgICAgICAqIHRpbWVzIGJlZm9yZSBhIHJlbmRlciBhY3R1YWxseSBoYXBwZW5zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcGVuZGluZ1JlbmRlciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250YWluaW5nIGVsZW1lbnQuIFNldCBieSBjb250YWluZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hpbGRyZW4gaW4gdGhlIHJlbmRlcmVkIG9yZGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb3JkZXJlZCA9IFtdO1xuICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQVBJXG4gICAgLyoqXG4gICAgICogVGhlIHBhcmVudCBvZiBhbGwgY2hpbGQgbm9kZXMgdG8gYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgZ2V0IGNvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcbiAgICB9XG4gICAgc2V0IGNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICAgICAgaWYgKGNvbnRhaW5lciA9PT0gdGhpcy5fY29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NvbnRhaW5lcikge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGNoaWxkcmVuIGZyb20gb2xkIGNvbnRhaW5lci5cbiAgICAgICAgICAgIHRoaXMuX29yZGVyZWQuZm9yRWFjaCgoY2hpbGQpID0+IHRoaXMuX3JlbW92ZUNoaWxkKGNoaWxkKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICAvLyBJbnNlcnQgY2hpbGRyZW4gaW4gbmV3IGNvbnRhaW5lci5cbiAgICAgICAgICAgIHRoaXMuX29yZGVyZWQuZm9yRWFjaCgoY2hpbGQpID0+IHRoaXMuX2luc2VydEJlZm9yZShjaGlsZCwgbnVsbCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fb3JkZXJlZC5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLl9wcmV2QWN0aXZlLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXF1ZXN0UmVzZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlZCB0byBjcmVhdGUgYSBjaGlsZC5cbiAgICAgKiBPdmVycmlkZSBvciBzZXQgZGlyZWN0bHkgdG8gY29udHJvbCBlbGVtZW50IGNyZWF0aW9uLlxuICAgICAqL1xuICAgIGdldCBjcmVhdGVFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlRWxlbWVudEZuO1xuICAgIH1cbiAgICBzZXQgY3JlYXRlRWxlbWVudChmbikge1xuICAgICAgICBpZiAoZm4gIT09IHRoaXMuX2NyZWF0ZUVsZW1lbnRGbikge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlRWxlbWVudEZuID0gZm47XG4gICAgICAgICAgICB0aGlzLl9rZXlUb0NoaWxkLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RSZXNldCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZWQgdG8gdXBkYXRlIGEgY2hpbGQuXG4gICAgICogT3ZlcnJpZGUgb3Igc2V0IGRpcmVjdGx5IHRvIGNvbnRyb2wgZWxlbWVudCB1cGRhdGVzLlxuICAgICAqL1xuICAgIGdldCB1cGRhdGVFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlRWxlbWVudEZuO1xuICAgIH1cbiAgICBzZXQgdXBkYXRlRWxlbWVudChmbikge1xuICAgICAgICBpZiAoZm4gIT09IHRoaXMuX3VwZGF0ZUVsZW1lbnRGbikge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRWxlbWVudEZuID0gZm47XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RSZXNldCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZWQgaW4gcGxhY2Ugb2YgcmVtb3ZpbmcgYSBjaGlsZCBmcm9tIHRoZSBET00sIHNvIHRoYXQgaXQgY2FuIGJlIHJldXNlZC5cbiAgICAgKiBPdmVycmlkZSBvciBzZXQgZGlyZWN0bHkgdG8gcHJlcGFyZSBjaGlsZHJlbiBmb3IgcmV1c2UuXG4gICAgICovXG4gICAgZ2V0IHJlY3ljbGVFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVjeWNsZUVsZW1lbnRGbjtcbiAgICB9XG4gICAgc2V0IHJlY3ljbGVFbGVtZW50KGZuKSB7XG4gICAgICAgIGlmIChmbiAhPT0gdGhpcy5fcmVjeWNsZUVsZW1lbnRGbikge1xuICAgICAgICAgICAgdGhpcy5fcmVjeWNsZUVsZW1lbnRGbiA9IGZuO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0UmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHRvIGdlbmVyYXRlIGEga2V5IGZvciBhbiBlbGVtZW50LlxuICAgICAqIE92ZXJyaWRlIG9yIHNldCBkaXJlY3RseSB0byBjb250cm9sIGhvdyBrZXlzIGFyZSBnZW5lcmF0ZWQgZm9yIGNoaWxkcmVuLlxuICAgICAqL1xuICAgIGdldCBlbGVtZW50S2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudEtleUZuO1xuICAgIH1cbiAgICBzZXQgZWxlbWVudEtleShmbikge1xuICAgICAgICBpZiAoZm4gIT09IHRoaXMuX2VsZW1lbnRLZXlGbikge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudEtleUZuID0gZm47XG4gICAgICAgICAgICB0aGlzLl9rZXlUb0NoaWxkLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RSZXNldCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2hpbGQgaW4gdGhlIHJhbmdlLlxuICAgICAqL1xuICAgIGdldCBmaXJzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0O1xuICAgIH1cbiAgICBzZXQgZmlyc3QoaWR4KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaWR4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXcgdmFsdWUgbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdGaXJzdCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGlkeCwgdGhpcy50b3RhbEl0ZW1zIC0gdGhpcy5fbnVtKSk7XG4gICAgICAgIGlmIChuZXdGaXJzdCAhPT0gdGhpcy5fZmlyc3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0ID0gbmV3Rmlyc3Q7XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhlIHJhbmdlLlxuICAgICAqL1xuICAgIGdldCBudW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9udW07XG4gICAgfVxuICAgIHNldCBudW0obikge1xuICAgICAgICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05ldyB2YWx1ZSBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuICE9PSB0aGlzLl9udW0pIHtcbiAgICAgICAgICAgIHRoaXMuX251bSA9IG47XG4gICAgICAgICAgICB0aGlzLmZpcnN0ID0gdGhpcy5fZmlyc3Q7XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIGRhdGEgdG8gYmUgdXNlZCB0byByZW5kZXIgY2hpbGQgbm9kZXMuXG4gICAgICovXG4gICAgZ2V0IGl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXM7XG4gICAgfVxuICAgIHNldCBpdGVtcyhpdGVtcykge1xuICAgICAgICBpZiAoaXRlbXMgIT09IHRoaXMuX2l0ZW1zICYmIEFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICB0aGlzLl9pdGVtcyA9IGl0ZW1zO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0UmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdG90YWwgbnVtYmVyIG9mIGl0ZW1zLCByZWdhcmRsZXNzIG9mIHRoZSByYW5nZSwgdGhhdCBjYW4gYmUgcmVuZGVyZWRcbiAgICAgKiBhcyBjaGlsZCBub2Rlcy5cbiAgICAgKi9cbiAgICBnZXQgdG90YWxJdGVtcygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl90b3RhbEl0ZW1zID09PSBudWxsID8gdGhpcy5faXRlbXMubGVuZ3RoIDogdGhpcy5fdG90YWxJdGVtcyk7XG4gICAgfVxuICAgIHNldCB0b3RhbEl0ZW1zKG51bSkge1xuICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ251bWJlcicgJiYgbnVtICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05ldyB2YWx1ZSBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8odmFsZHJpbikgc2hvdWxkIHdlIGNoZWNrIGlmIGl0IGlzIGEgZmluaXRlIG51bWJlcj9cbiAgICAgICAgLy8gVGVjaG5pY2FsbHksIEluZmluaXR5IHdvdWxkIGJyZWFrIExheW91dCwgbm90IFZpcnR1YWxSZXBlYXRlci5cbiAgICAgICAgaWYgKG51bSAhPT0gdGhpcy5fdG90YWxJdGVtcykge1xuICAgICAgICAgICAgdGhpcy5fdG90YWxJdGVtcyA9IG51bTtcbiAgICAgICAgICAgIHRoaXMuZmlyc3QgPSB0aGlzLl9maXJzdDtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVE9ETyBAc3RyYXZlcnNpOiBEb2N1bWVudCB0aGlzLlxuICAgICAqL1xuICAgIGdldCBfaW5jcmVtZW50YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9faW5jcmVtZW50YWw7XG4gICAgfVxuICAgIHNldCBfaW5jcmVtZW50YWwoaW5jKSB7XG4gICAgICAgIGlmIChpbmMgIT09IHRoaXMuX19pbmNyZW1lbnRhbCkge1xuICAgICAgICAgICAgdGhpcy5fX2luY3JlbWVudGFsID0gaW5jO1xuICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZva2UgdG8gcmVxdWVzdCB0aGF0IGFsbCBlbGVtZW50cyBpbiB0aGUgcmFuZ2UgYmUgbWVhc3VyZWQuXG4gICAgICovXG4gICAgcmVxdWVzdFJlbWVhc3VyZSgpIHtcbiAgICAgICAgdGhpcy5fbmVlZHNSZW1lYXN1cmUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zY2hlZHVsZVJlbmRlcigpO1xuICAgIH1cbiAgICAvLyBDb3JlIGZ1bmN0aW9uYWxpdHlcbiAgICBfc2hvdWxkUmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmNvbnRhaW5lciAmJiB0aGlzLmNyZWF0ZUVsZW1lbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYXQgdGhlIG5leHQgb3Bwb3J0dW5pdHkuXG4gICAgICovXG4gICAgYXN5bmMgX3NjaGVkdWxlUmVuZGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3BlbmRpbmdSZW5kZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdSZW5kZXIgPSB0cnVlO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nUmVuZGVyID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2hvdWxkUmVuZGVyKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoaXMuX3BlbmRpbmdSZW5kZXIgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgLy8gICB0aGlzLl9wZW5kaW5nUmVuZGVyID0gbnVsbDtcbiAgICAgICAgICAgIC8vICAgaWYgKHRoaXMuX3Nob3VsZFJlbmRlcigpKSB7XG4gICAgICAgICAgICAvLyAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAgIC8vIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZSB0byByZXF1ZXN0IHRoYXQgYWxsIGVsZW1lbnRzIGluIHRoZSByYW5nZSBiZSB1cGRhdGVkLlxuICAgICAqL1xuICAgIHJlcXVlc3RSZXNldCgpIHtcbiAgICAgICAgdGhpcy5fbmVlZHNSZXNldCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlUmVuZGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhvc2UgY2hpbGRyZW4gdGhhdCBhcmUgYWJvdXQgdG8gYmUgZGlzcGxheWVkIGFuZCB0aGF0IHJlcXVpcmUgdG9cbiAgICAgKiBiZSBwb3NpdGlvbmVkLiBJZiByZXNldCBvciByZW1lYXN1cmUgaGFzIGJlZW4gdHJpZ2dlcmVkLCBhbGwgY2hpbGRyZW4gYXJlXG4gICAgICogcmV0dXJuZWQuXG4gICAgICovXG4gICAgZ2V0IF90b01lYXN1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmRlcmVkLnJlZHVjZSgodG9NZWFzdXJlLCBjLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9maXJzdCArIGk7XG4gICAgICAgICAgICBpZiAodGhpcy5fbmVlZHNSZXNldCB8fCB0aGlzLl9uZWVkc1JlbWVhc3VyZSB8fCBpZHggPCB0aGlzLl9wcmV2Rmlyc3QgfHxcbiAgICAgICAgICAgICAgICBpZHggPiB0aGlzLl9wcmV2TGFzdCkge1xuICAgICAgICAgICAgICAgIHRvTWVhc3VyZS5pbmRpY2VzLnB1c2goaWR4KTtcbiAgICAgICAgICAgICAgICB0b01lYXN1cmUuY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b01lYXN1cmU7XG4gICAgICAgIH0sIHsgaW5kaWNlczogW10sIGNoaWxkcmVuOiBbXSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVhc3VyZXMgZWFjaCBjaGlsZCBib3VuZHMgYW5kIGJ1aWxkcyBhIG1hcCBvZiBpbmRleC9ib3VuZHMgdG8gYmUgcGFzc2VkXG4gICAgICogdG8gdGhlIGBfbWVhc3VyZUNhbGxiYWNrYFxuICAgICAqL1xuICAgIGFzeW5jIF9tZWFzdXJlQ2hpbGRyZW4oeyBpbmRpY2VzLCBjaGlsZHJlbiB9KSB7XG4gICAgICAgIGF3YWl0IChuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlc29sdmUpO1xuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IHBtID0gY2hpbGRyZW4ubWFwKChjKSA9PiB0aGlzLl9tZWFzdXJlQ2hpbGQoYykpO1xuICAgICAgICBjb25zdCBtbSA9IC8qKiBAdHlwZSB7e251bWJlcjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX19ICovIChwbS5yZWR1Y2UoKG91dCwgY3VyLCBpKSA9PiB7XG4gICAgICAgICAgICBvdXRbaW5kaWNlc1tpXV0gPSB0aGlzLl9pbmRleFRvTWVhc3VyZVtpbmRpY2VzW2ldXSA9IGN1cjtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sIHt9KSk7XG4gICAgICAgIHRoaXMuX21lYXN1cmVDYWxsYmFjayhtbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlciBpdGVtcyB3aXRoaW4gdGhlIGN1cnJlbnQgcmFuZ2UgdG8gdGhlIERPTS5cbiAgICAgKi9cbiAgICBhc3luYyBfcmVuZGVyKCkge1xuICAgICAgICBjb25zdCByYW5nZUNoYW5nZWQgPSB0aGlzLl9maXJzdCAhPT0gdGhpcy5fcHJldkZpcnN0IHx8IHRoaXMuX251bSAhPT0gdGhpcy5fcHJldk51bTtcbiAgICAgICAgLy8gQ3JlYXRlL3VwZGF0ZS9yZWN5Y2xlIERPTS5cbiAgICAgICAgaWYgKHJhbmdlQ2hhbmdlZCB8fCB0aGlzLl9uZWVkc1Jlc2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0ID1cbiAgICAgICAgICAgICAgICB0aGlzLl9maXJzdCArIE1hdGgubWluKHRoaXMuX251bSwgdGhpcy50b3RhbEl0ZW1zIC0gdGhpcy5fZmlyc3QpIC0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9udW0gfHwgdGhpcy5fcHJldk51bSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9uZWVkc1Jlc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2V0KHRoaXMuX2ZpcnN0LCB0aGlzLl9sYXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBvbGQgY2hpbGRyZW4gYW5kIGluc2VydCBuZXcgY2hpbGRyZW4gd2l0aG91dCB0b3VjaGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBzaGFyZWQgY2hpbGRyZW4uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc2NhcmRIZWFkKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc2NhcmRUYWlsKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEhlYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkVGFpbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbmVlZHNSZW1lYXN1cmUgfHwgdGhpcy5fbmVlZHNSZXNldCkge1xuICAgICAgICAgICAgdGhpcy5faW5kZXhUb01lYXN1cmUgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXRyaWV2ZSBET00gdG8gYmUgbWVhc3VyZWQuXG4gICAgICAgIC8vIERvIGl0IHJpZ2h0IGJlZm9yZSBjbGVhbnVwIGFuZCByZXNldCBvZiBwcm9wZXJ0aWVzLlxuICAgICAgICBjb25zdCBzaG91bGRNZWFzdXJlID0gdGhpcy5fbnVtID4gMCAmJiB0aGlzLl9tZWFzdXJlQ2FsbGJhY2sgJiZcbiAgICAgICAgICAgIChyYW5nZUNoYW5nZWQgfHwgdGhpcy5fbmVlZHNSZW1lYXN1cmUgfHwgdGhpcy5fbmVlZHNSZXNldCk7XG4gICAgICAgIGNvbnN0IHRvTWVhc3VyZSA9IHNob3VsZE1lYXN1cmUgPyB0aGlzLl90b01lYXN1cmUgOiBudWxsO1xuICAgICAgICAvLyBDbGVhbnVwLlxuICAgICAgICBpZiAoIXRoaXMuX2luY3JlbWVudGFsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcmV2QWN0aXZlLmZvckVhY2goKGlkeCwgY2hpbGQpID0+IHRoaXMuX3VuYXNzaWduQ2hpbGQoY2hpbGQsIGlkeCkpO1xuICAgICAgICAgICAgdGhpcy5fcHJldkFjdGl2ZS5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2V0IGludGVybmFsIHByb3BlcnRpZXMuXG4gICAgICAgIHRoaXMuX3ByZXZGaXJzdCA9IHRoaXMuX2ZpcnN0O1xuICAgICAgICB0aGlzLl9wcmV2TGFzdCA9IHRoaXMuX2xhc3Q7XG4gICAgICAgIHRoaXMuX3ByZXZOdW0gPSB0aGlzLl9udW07XG4gICAgICAgIHRoaXMuX25lZWRzUmVzZXQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbmVlZHNSZW1lYXN1cmUgPSBmYWxzZTtcbiAgICAgICAgLy8gTm90aWZ5IHJlbmRlciBjb21wbGV0ZWQuXG4gICAgICAgIHRoaXMuX2RpZFJlbmRlcigpO1xuICAgICAgICAvLyBNZWFzdXJlIERPTS5cbiAgICAgICAgaWYgKHRvTWVhc3VyZSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fbWVhc3VyZUNoaWxkcmVuKHRvTWVhc3VyZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlZCBhZnRlciBET00gaXMgdXBkYXRlZCwgYW5kIGJlZm9yZSBpdCBnZXRzIG1lYXN1cmVkLlxuICAgICAqL1xuICAgIF9kaWRSZW5kZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuYXNzaWducyBhbnkgY2hpbGRyZW4gYXQgaW5kaWNlcyBsb3dlciB0aGFuIHRoZSBzdGFydCBvZiB0aGUgY3VycmVudFxuICAgICAqIHJhbmdlLlxuICAgICAqL1xuICAgIF9kaXNjYXJkSGVhZCgpIHtcbiAgICAgICAgY29uc3QgbyA9IHRoaXMuX29yZGVyZWQ7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IHRoaXMuX3ByZXZGaXJzdDsgby5sZW5ndGggJiYgaWR4IDwgdGhpcy5fZmlyc3Q7IGlkeCsrKSB7XG4gICAgICAgICAgICB0aGlzLl91bmFzc2lnbkNoaWxkKG8uc2hpZnQoKSwgaWR4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbmFzc2lnbnMgYW55IGNoaWxkcmVuIGF0IGluZGljZXMgaGlnaGVyIHRoYW4gdGhlIGVuZCBvZiB0aGUgY3VycmVudFxuICAgICAqIHJhbmdlLlxuICAgICAqL1xuICAgIF9kaXNjYXJkVGFpbCgpIHtcbiAgICAgICAgY29uc3QgbyA9IHRoaXMuX29yZGVyZWQ7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IHRoaXMuX3ByZXZMYXN0OyBvLmxlbmd0aCAmJiBpZHggPiB0aGlzLl9sYXN0OyBpZHgtLSkge1xuICAgICAgICAgICAgdGhpcy5fdW5hc3NpZ25DaGlsZChvLnBvcCgpLCBpZHgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgYW5kIGluc2VydHMgbm9uLWV4aXN0ZW50IGNoaWxkcmVuIGZyb20gdGhlIGN1cnJlbnQgcmFuZ2Ugd2l0aFxuICAgICAqIGluZGljZXMgbG93ZXIgdGhhbiB0aGUgc3RhcnQgb2YgdGhlIHByZXZpb3VzIHJhbmdlLlxuICAgICAqL1xuICAgIF9hZGRIZWFkKCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX2ZpcnN0O1xuICAgICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbih0aGlzLl9sYXN0LCB0aGlzLl9wcmV2Rmlyc3QgLSAxKTtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gZW5kOyBpZHggPj0gc3RhcnQ7IGlkeC0tKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuX2Fzc2lnbkNoaWxkKGlkeCk7XG4gICAgICAgICAgICAvLyBNYWludGFpbiBkb20gb3JkZXIuXG4gICAgICAgICAgICB0aGlzLl9pbnNlcnRCZWZvcmUoY2hpbGQsIHRoaXMuX2ZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgaWYgKHRoaXMudXBkYXRlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRWxlbWVudChjaGlsZCwgdGhpcy5faXRlbXNbaWR4XSwgaWR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29yZGVyZWQudW5zaGlmdChjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzaWducyBhbmQgYXBwZW5kcyBub24tZXhpc3RlbnQgY2hpbGRyZW4gZnJvbSB0aGUgY3VycmVudCByYW5nZSB3aXRoXG4gICAgICogaW5kaWNlcyBoaWdoZXIgdGhhbiB0aGUgZW5kIG9mIHRoZSBwcmV2aW91cyByYW5nZS5cbiAgICAgKi9cbiAgICBfYWRkVGFpbCgpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heCh0aGlzLl9maXJzdCwgdGhpcy5fcHJldkxhc3QgKyAxKTtcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fbGFzdDtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gc3RhcnQ7IGlkeCA8PSBlbmQ7IGlkeCsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuX2Fzc2lnbkNoaWxkKGlkeCk7XG4gICAgICAgICAgICAvLyBNYWludGFpbiBkb20gb3JkZXIuXG4gICAgICAgICAgICB0aGlzLl9pbnNlcnRCZWZvcmUoY2hpbGQsIG51bGwpO1xuICAgICAgICAgICAgaWYgKHRoaXMudXBkYXRlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRWxlbWVudChjaGlsZCwgdGhpcy5faXRlbXNbaWR4XSwgaWR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29yZGVyZWQucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmUtaW5zZXJ0IGFuZCB1cGRhdGUgY2hpbGRyZW4gaW4gdGhlIGdpdmVuIHJhbmdlLlxuICAgICAqL1xuICAgIF9yZXNldChmaXJzdCwgbGFzdCkge1xuICAgICAgICAvLyBTd2FwcGluZyBwcmV2QWN0aXZlIHdpdGggYWN0aXZlIGFmZmVjdHMgX2Fzc2lnbkNoaWxkLlxuICAgICAgICAvLyBVcG9uIHJlc2V0dGluZywgdGhlIGN1cnJlbnQgYWN0aXZlIGNoaWxkcmVuIGJlY29tZSBwb3RlbnRpYWxseSBpbmFjdGl2ZS5cbiAgICAgICAgLy8gX2Fzc2lnbkNoaWxkIHdpbGwgcmVtb3ZlIGEgY2hpbGQgZnJvbSBfcHJldkFjdGl2ZSBpZiBpdCBpcyBzdGlsbCBhY3RpdmUuXG4gICAgICAgIGNvbnN0IHByZXZBY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IHRoaXMuX3ByZXZBY3RpdmU7XG4gICAgICAgIHRoaXMuX3ByZXZBY3RpdmUgPSBwcmV2QWN0aXZlO1xuICAgICAgICB0aGlzLl9vcmRlcmVkLmxlbmd0aCA9IDA7XG4gICAgICAgIGxldCBjdXJyZW50TWFya2VyID0gdGhpcy5fZmlyc3RDaGlsZDtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZpcnN0OyBpIDw9IGxhc3Q7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLl9hc3NpZ25DaGlsZChpKTtcbiAgICAgICAgICAgIHRoaXMuX29yZGVyZWQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudE1hcmtlcikge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TWFya2VyID09PSB0aGlzLl9ub2RlKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TWFya2VyID0gdGhpcy5fbmV4dFNpYmxpbmcoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5zZXJ0QmVmb3JlKGNoaWxkLCBjdXJyZW50TWFya2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5fY2hpbGRJc0F0dGFjaGVkKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luc2VydEJlZm9yZShjaGlsZCwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy51cGRhdGVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGNoaWxkLCB0aGlzLl9pdGVtc1tpXSwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGVzLCB0cmFja3MsIGFuZCByZXR1cm5zIHRoZSBjaGlsZCBhdCBpZHguXG4gICAgICogUHJldmVudHMgY2xlYW51cCBvZiBjaGlsZHJlbiB0aGF0IGFscmVhZHkgZXhpc3QuXG4gICAgICogUmV0dXJucyB0aGUgbmV3IGNoaWxkIGF0IGlkeC5cbiAgICAgKi9cbiAgICBfYXNzaWduQ2hpbGQoaWR4KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZWxlbWVudEtleSA/IHRoaXMuZWxlbWVudEtleShpZHgpIDogaWR4O1xuICAgICAgICBsZXQgY2hpbGQ7XG4gICAgICAgIGlmIChjaGlsZCA9IHRoaXMuX2tleVRvQ2hpbGQuZ2V0KGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZBY3RpdmUuZGVsZXRlKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkID0gdGhpcy5jcmVhdGVFbGVtZW50KHRoaXMuX2l0ZW1zW2lkeF0sIGlkeCk7XG4gICAgICAgICAgICB0aGlzLl9rZXlUb0NoaWxkLnNldChrZXksIGNoaWxkKTtcbiAgICAgICAgICAgIHRoaXMuX2NoaWxkVG9LZXkuc2V0KGNoaWxkLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Nob3dDaGlsZChjaGlsZCk7XG4gICAgICAgIHRoaXMuX2FjdGl2ZS5zZXQoY2hpbGQsIGlkeCk7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgY2hpbGQgYXQgaWR4LCByZWN5Y2xpbmcgaXQgaWYgcG9zc2libGUuXG4gICAgICovXG4gICAgX3VuYXNzaWduQ2hpbGQoY2hpbGQsIGlkeCkge1xuICAgICAgICB0aGlzLl9oaWRlQ2hpbGQoY2hpbGQpO1xuICAgICAgICBpZiAodGhpcy5faW5jcmVtZW50YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZS5kZWxldGUoY2hpbGQpO1xuICAgICAgICAgICAgdGhpcy5fcHJldkFjdGl2ZS5zZXQoY2hpbGQsIGlkeCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLl9jaGlsZFRvS2V5LmdldChjaGlsZCk7XG4gICAgICAgICAgICB0aGlzLl9jaGlsZFRvS2V5LmRlbGV0ZShjaGlsZCk7XG4gICAgICAgICAgICB0aGlzLl9rZXlUb0NoaWxkLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlLmRlbGV0ZShjaGlsZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWN5Y2xlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVjeWNsZUVsZW1lbnQoY2hpbGQsIGlkeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9ub2RlKGNoaWxkKS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5vZGUgZm9yIHRoZSBmaXJzdCBjaGlsZCBpbiB0aGUgY3VycmVudCByYW5nZSwgaWYgdGhlIG5vZGUgaXNcbiAgICAgKiBpbiB0aGUgRE9NLlxuICAgICAqIFRPRE86IElzIHRoaXMgdGhlIHJpZ2h0IG5hbWU/XG4gICAgICovXG4gICAgZ2V0IF9maXJzdENoaWxkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3JkZXJlZC5sZW5ndGggJiYgdGhpcy5fY2hpbGRJc0F0dGFjaGVkKHRoaXMuX29yZGVyZWRbMF0pID9cbiAgICAgICAgICAgIHRoaXMuX25vZGUodGhpcy5fb3JkZXJlZFswXSkgOlxuICAgICAgICAgICAgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGFibGUgYWJzdHJhY3Rpb25zIGZvciBjaGlsZCBtYW5pcHVsYXRpb25cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG5vZGUgZm9yIGNoaWxkLlxuICAgICAqIE92ZXJyaWRlIGlmIGNoaWxkICE9PSBjaGlsZCdzIG5vZGUuXG4gICAgICovXG4gICAgX25vZGUoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuZXh0IG5vZGUgc2libGluZyBvZiBhIGNoaWxkIG5vZGUuXG4gICAgICovXG4gICAgX25leHRTaWJsaW5nKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBjaGlsZC5uZXh0U2libGluZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBjaGlsZCBiZWZvcmUgcmVmZXJlbmNlTm9kZSBpbiB0aGUgY29udGFpbmVyLlxuICAgICAqIE92ZXJyaWRlIHRvIGNvbnRyb2wgY2hpbGQgaW5zZXJ0aW9uLlxuICAgICAqL1xuICAgIF9pbnNlcnRCZWZvcmUoY2hpbGQsIHJlZmVyZW5jZU5vZGUpIHtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmluc2VydEJlZm9yZShjaGlsZCwgcmVmZXJlbmNlTm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgY2hpbGQgZnJvbSB0aGUgRE9NLlxuICAgICAqIFRPRE8gQHN0cmF2ZXJzaTogdGhpcyB3aWxsIG5vdCB3b3JrIChfbm9kZSBzaG91bGQgYmUgY2FsbGVkIG9uIGNoaWxkKSwgYnV0XG4gICAgICogaXMgbm90IGN1cnJlbnRseSBiZWluZyB1c2VkIG9yIHRlc3RlZC5cbiAgICAgKi9cbiAgICBfcmVtb3ZlQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgY2hpbGQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgY2hpbGQncyBub2RlIGlzIGEgY2hpbGQgb2YgdGhlIGNvbnRhaW5lclxuICAgICAqIGVsZW1lbnQuXG4gICAgICovXG4gICAgX2NoaWxkSXNBdHRhY2hlZChjaGlsZCkge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fbm9kZShjaGlsZCk7XG4gICAgICAgIHJldHVybiBub2RlICYmIG5vZGUucGFyZW50Tm9kZSA9PT0gdGhpcy5fY29udGFpbmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkaXNwbGF5IHN0eWxlIG9mIHRoZSBnaXZlbiBub2RlIHRvICdub25lJy5cbiAgICAgKi9cbiAgICBfaGlkZUNoaWxkKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICBjaGlsZC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRpc3BsYXkgc3R5bGUgb2YgdGhlIGdpdmVuIG5vZGUgdG8gbnVsbC5cbiAgICAgKi9cbiAgICBfc2hvd0NoaWxkKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICBjaGlsZC5zdHlsZS5kaXNwbGF5ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3aWR0aCwgaGVpZ2h0LCBhbmQgbWFyZ2lucyBvZiB0aGUgZ2l2ZW4gY2hpbGQuXG4gICAgICogT3ZlcnJpZGUgaWYgY2hpbGQgIT09IGNoaWxkJ3Mgbm9kZS5cbiAgICAgKi9cbiAgICBfbWVhc3VyZUNoaWxkKGNoaWxkKSB7XG4gICAgICAgIC8vIG9mZnNldFdpZHRoIGRvZXNuJ3QgdGFrZSB0cmFuc2Zvcm1zIGluIGNvbnNpZGVyYXRpb24sIHNvIHdlIHVzZVxuICAgICAgICAvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgd2hpY2ggZG9lcy5cbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBjaGlsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyB3aWR0aCwgaGVpZ2h0IH0sIGdldE1hcmdpbnMoY2hpbGQpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRNYXJnaW5zKGVsKSB7XG4gICAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWFyZ2luVG9wOiBnZXRNYXJnaW5WYWx1ZShzdHlsZS5tYXJnaW5Ub3ApLFxuICAgICAgICBtYXJnaW5SaWdodDogZ2V0TWFyZ2luVmFsdWUoc3R5bGUubWFyZ2luUmlnaHQpLFxuICAgICAgICBtYXJnaW5Cb3R0b206IGdldE1hcmdpblZhbHVlKHN0eWxlLm1hcmdpbkJvdHRvbSksXG4gICAgICAgIG1hcmdpbkxlZnQ6IGdldE1hcmdpblZhbHVlKHN0eWxlLm1hcmdpbkxlZnQpLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRNYXJnaW5WYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IGZsb2F0ID0gdmFsdWUgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IE5hTjtcbiAgICByZXR1cm4gTnVtYmVyLmlzTmFOKGZsb2F0KSA/IDAgOiBmbG9hdDtcbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTs7OztBQUlBO0FBQ0E7Ozs7O0FBSUE7QUFDQTs7OztBQUdBO0FBQ0E7Ozs7QUFHQTtBQUNBOzs7O0FBR0E7QUFDQTs7OztBQUdBO0FBQ0E7Ozs7O0FBSUE7QUFDQTs7Ozs7QUFJQTtBQUNBOzs7O0FBR0E7QUFDQTtBQUNBOzs7O0FBR0E7QUFDQTtBQUNBOzs7O0FBR0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBOzs7OztBQUlBO0FBQ0E7Ozs7O0FBSUE7QUFDQTs7OztBQUdBO0FBQ0E7Ozs7QUFHQTtBQUNBOzs7O0FBR0E7QUFDQTs7Ozs7QUFJQTtBQUNBOzs7O0FBR0E7QUFDQTs7OztBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBbkdBO0FBQUE7QUFDQTtBQTZQQTs7O0FBOVBBO0FBa1FBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFyUUE7QUFBQTtBQUFBO0FBdVFBO0FBQ0E7QUFDQTs7OztBQXpRQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQTZRQTtBQTlRQTtBQUFBO0FBQ0E7QUFEQTtBQWdSQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEzUkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQTRSQTs7OztBQTVSQTtBQUFBO0FBQUE7QUFnU0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7O0FBblNBO0FBQUE7QUFDQTtBQWtUQTs7OztBQW5UQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUF1VEE7QUF2VEE7QUFBQTtBQXlUQTtBQUNBO0FBQ0E7QUEzVEE7QUEyVEE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBalVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFrVUE7Ozs7QUFsVUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQXNVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQS9XQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQW1YQTs7OztBQW5YQTtBQUFBO0FBQUE7QUF3WEE7Ozs7O0FBeFhBO0FBQUE7QUFBQTtBQTZYQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFsWUE7QUFBQTtBQUFBO0FBdVlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQTVZQTtBQUFBO0FBQUE7QUFpWkE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUE3WkE7QUFBQTtBQUFBO0FBa2FBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUE5YUE7QUFBQTtBQUFBO0FBa2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBN2NBO0FBQUE7QUFBQTtBQW1kQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7O0FBamVBO0FBQUE7QUFBQTtBQXFlQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUF2ZkE7QUFBQTtBQUNBO0FBZ2dCQTs7OztBQUdBOzs7O0FBcGdCQTtBQXlnQkE7QUFDQTtBQUNBOzs7O0FBM2dCQTtBQUFBO0FBQUE7QUErZ0JBO0FBQ0E7QUFDQTs7Ozs7QUFqaEJBO0FBQUE7QUFBQTtBQXNoQkE7QUFDQTtBQUNBOzs7Ozs7QUF4aEJBO0FBQUE7QUFBQTtBQThoQkE7QUFDQTtBQUNBOzs7OztBQWhpQkE7QUFBQTtBQUFBO0FBcWlCQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7O0FBeGlCQTtBQUFBO0FBQUE7QUE0aUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFoakJBO0FBQUE7QUFBQTtBQW9qQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUF4akJBO0FBQUE7QUFBQTtBQTZqQkE7QUFDQTtBQUZBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQWprQkE7QUFBQTtBQUFBO0FBdUdBO0FBQ0E7QUF4R0E7QUF5R0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7Ozs7O0FBN0hBO0FBQUE7QUFBQTtBQWtJQTtBQUNBO0FBbklBO0FBcUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUEzSUE7QUFBQTtBQUFBO0FBZ0pBO0FBQ0E7QUFqSkE7QUFtSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQXhKQTtBQUFBO0FBQUE7QUE2SkE7QUFDQTtBQTlKQTtBQWdLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBcktBO0FBQUE7QUFBQTtBQTBLQTtBQUNBO0FBM0tBO0FBNktBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7OztBQW5MQTtBQUFBO0FBQUE7QUF1TEE7QUFDQTtBQXhMQTtBQTBMQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7OztBQW5NQTtBQUFBO0FBQUE7QUF1TUE7QUFDQTtBQXhNQTtBQTBNQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFuTkE7QUFBQTtBQUFBO0FBdU5BO0FBQ0E7QUF4TkE7QUEwTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQS9OQTtBQUFBO0FBQUE7QUFvT0E7QUFDQTtBQXJPQTtBQXVPQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQWxQQTtBQUFBO0FBQUE7QUFzUEE7QUFDQTtBQXZQQTtBQXlQQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUE3UEE7QUFBQTtBQUFBO0FBd1NBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBbFRBO0FBQUE7QUFBQTtBQTZmQTtBQUdBO0FBaGdCQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBa2tCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/VirtualRepeater.js\n");

/***/ }),

/***/ "./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/VirtualScroller.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/VirtualScroller.js ***!
  \*********************************************************************************/
/*! exports provided: RangeChangeEvent, VirtualScroller */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RangeChangeEvent\", function() { return RangeChangeEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VirtualScroller\", function() { return VirtualScroller; });\n/* harmony import */ var _VirtualRepeater_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VirtualRepeater.js */ \"./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/VirtualRepeater.js\");\n/* harmony import */ var _polyfillLoaders_ResizeObserver_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./polyfillLoaders/ResizeObserver.js */ \"./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/polyfillLoaders/ResizeObserver.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction set(target, property, value, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.set) { set = Reflect.set; } else { set = function set(target, property, value, receiver) { var base = _superPropBase(target, property); var desc; if (base) { desc = Object.getOwnPropertyDescriptor(base, property); if (desc.set) { desc.set.call(receiver, value); return true; } else if (!desc.writable) { return false; } } desc = Object.getOwnPropertyDescriptor(receiver, property); if (desc) { if (!desc.writable) { return false; } desc.value = value; Object.defineProperty(receiver, property, desc); } else { _defineProperty(receiver, property, value); } return true; }; } return set(target, property, value, receiver); }\n\nfunction _set(target, property, value, receiver, isStrict) { var s = set(target, property, value, receiver || target); if (!s && isStrict) { throw new Error('failed to set property'); } return value; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar HOST_CLASSNAME = 'uni-virtualizer-host';\nvar globalContainerStylesheet = null;\n\nfunction containerStyles(hostSel, childSel) {\n  return \"\\n    \".concat(hostSel, \" {\\n      display: block;\\n      position: relative;\\n      contain: strict;\\n      height: 150px;\\n      overflow: auto;\\n    }\\n    \").concat(childSel, \" {\\n      box-sizing: border-box;\\n    }\");\n}\n\nfunction attachGlobalContainerStylesheet() {\n  if (!globalContainerStylesheet) {\n    globalContainerStylesheet = document.createElement('style');\n    globalContainerStylesheet.textContent = containerStyles(\".\".concat(HOST_CLASSNAME), \".\".concat(HOST_CLASSNAME, \" > *\"));\n    document.head.appendChild(globalContainerStylesheet);\n  }\n}\n\nvar RangeChangeEvent = /*#__PURE__*/function (_Event) {\n  _inherits(RangeChangeEvent, _Event);\n\n  var _super = _createSuper(RangeChangeEvent);\n\n  function RangeChangeEvent(type, init) {\n    var _this;\n\n    _classCallCheck(this, RangeChangeEvent);\n\n    _this = _super.call(this, type, init);\n    _this._first = Math.floor(init.first || 0);\n    _this._last = Math.floor(init.last || 0);\n    _this._firstVisible = Math.floor(init.firstVisible || 0);\n    _this._lastVisible = Math.floor(init.lastVisible || 0);\n    return _this;\n  }\n\n  _createClass(RangeChangeEvent, [{\n    key: \"first\",\n    get: function get() {\n      return this._first;\n    }\n  }, {\n    key: \"last\",\n    get: function get() {\n      return this._last;\n    }\n  }, {\n    key: \"firstVisible\",\n    get: function get() {\n      return this._firstVisible;\n    }\n  }, {\n    key: \"lastVisible\",\n    get: function get() {\n      return this._lastVisible;\n    }\n  }]);\n\n  return RangeChangeEvent;\n}( /*#__PURE__*/_wrapNativeSuper(Event));\n/**\n * Provides virtual scrolling boilerplate.\n *\n * Extensions of this class must set container, layout, scrollTarget, and\n * useShadowDOM.\n *\n * Extensions of this class must also override VirtualRepeater's DOM\n * manipulation methods.\n */\n\nvar VirtualScroller = /*#__PURE__*/function (_VirtualRepeater) {\n  _inherits(VirtualScroller, _VirtualRepeater);\n\n  var _super2 = _createSuper(VirtualScroller);\n\n  function VirtualScroller(config) {\n    var _this2;\n\n    _classCallCheck(this, VirtualScroller);\n\n    _this2 = _super2.call(this, {});\n    /**\n     * Whether the layout should receive an updated viewport size on the next\n     * render.\n     */\n\n    _this2._needsUpdateView = false;\n    _this2._layout = null;\n    /**\n     * Whether to import the default (1d) layout on first render.\n     */\n\n    _this2._lazyLoadDefaultLayout = true;\n    /**\n     * The element that generates scroll events and defines the container\n     * viewport. Set by scrollTarget.\n     */\n\n    _this2._scrollTarget = null;\n    /**\n     * A sentinel element that sizes the container when it is a scrolling\n     * element. This ensures the scroll bar accurately reflects the total\n     * size of the list.\n     */\n\n    _this2._sizer = null;\n    /**\n     * Layout provides these values, we set them on _render().\n     * TODO @straversi: Can we find an XOR type, usable for the key here?\n     */\n\n    _this2._scrollSize = null;\n    /**\n     * Difference between scroll target's current and required scroll offsets.\n     * Provided by layout.\n     */\n\n    _this2._scrollErr = null;\n    /**\n     * A list of the positions (top, left) of the children in the current range.\n     */\n\n    _this2._childrenPos = null;\n    /**\n     * The parent of all child nodes to be rendered. Set by container.\n     */\n\n    _this2._containerElement = null;\n    /**\n     * Keep track of original inline style of the container, so it can be\n     * restored when container is changed.\n     */\n\n    _this2._containerInlineStyle = null;\n    /**\n     * Keep track of original container stylesheet, so it can be restored\n     * when container is changed.\n     */\n\n    _this2._containerStylesheet = null;\n    /**\n     * Whether to build the virtual scroller within a shadow DOM.\n     */\n\n    _this2._useShadowDOM = true;\n    /**\n     * Size of the container.\n     */\n\n    _this2._containerSize = null;\n    /**\n     * Resize observer attached to container.\n     */\n\n    _this2._containerRO = null;\n    /**\n     * Resize observer attached to children.\n     */\n\n    _this2._childrenRO = null;\n    /**\n     * Flag for skipping a children measurement if that computation was just\n     * completed.\n     */\n\n    _this2._skipNextChildrenSizeChanged = false;\n    /**\n     * Index and position of item to scroll to.\n     */\n\n    _this2._scrollToIndex = null;\n    _this2._num = 0;\n    _this2._first = -1;\n    _this2._last = -1;\n    _this2._prevFirst = -1;\n    _this2._prevLast = -1;\n\n    if (config) {\n      Object.assign(_assertThisInitialized(_this2), config);\n    }\n\n    return _this2;\n  }\n\n  _createClass(VirtualScroller, [{\n    key: \"_render\",\n\n    /**\n     * Display the items in the current range.\n     * Continue relayout of child positions until they have stabilized.\n     */\n    value: function () {\n      var _render2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        var _this3 = this;\n\n        var _yield$import, Layout1d;\n\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this._lazyLoadDefaultLayout && !this._layout)) {\n                  _context.next = 8;\n                  break;\n                }\n\n                this._lazyLoadDefaultLayout = false;\n                _context.next = 4;\n                return Promise.resolve(/*! import() */).then(__webpack_require__.bind(null, /*! ./layouts/Layout1d */ \"./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/layouts/Layout1d.js\"));\n\n              case 4:\n                _yield$import = _context.sent;\n                Layout1d = _yield$import.Layout1d;\n                this.layout = new Layout1d({});\n                return _context.abrupt(\"return\");\n\n              case 8:\n                this._childrenRO.disconnect(); // Update layout properties before rendering to have correct first, num,\n                // scroll size, children positions.\n\n\n                this._layout.totalItems = this.totalItems;\n\n                if (this._needsUpdateView) {\n                  this._needsUpdateView = false;\n\n                  this._updateView();\n                }\n\n                if (this._scrollToIndex !== null) {\n                  this._layout.scrollToIndex(this._scrollToIndex.index, this._scrollToIndex.position);\n\n                  this._scrollToIndex = null;\n                }\n\n                this._layout.reflowIfNeeded(); // Keep rendering until there is no more scheduled renders.\n\n\n              case 13:\n                if (false) {}\n\n                if (this._pendingRender) {\n                  // cancelAnimationFrame(this._pendingRender);\n                  this._pendingRender = false;\n                } // Update scroll size and correct scroll error before rendering.\n\n\n                this._sizeContainer(this._scrollSize);\n\n                if (this._scrollErr) {\n                  // This triggers a 'scroll' event (async) which triggers another\n                  // _updateView().\n                  this._correctScrollError(this._scrollErr);\n\n                  this._scrollErr = null;\n                } // Position children (_didRender()), and provide their measures to layout.\n\n\n                _context.next = 19;\n                return _get(_getPrototypeOf(VirtualScroller.prototype), \"_render\", this).call(this);\n\n              case 19:\n                this._layout.reflowIfNeeded(); // If layout reflow did not provoke another render, we're done.\n\n\n                if (this._pendingRender) {\n                  _context.next = 22;\n                  break;\n                }\n\n                return _context.abrupt(\"break\", 24);\n\n              case 22:\n                _context.next = 13;\n                break;\n\n              case 24:\n                // We want to skip the first ResizeObserver callback call as we already\n                // measured the children.\n                this._skipNextChildrenSizeChanged = true;\n\n                this._kids.forEach(function (child) {\n                  return _this3._childrenRO.observe(child);\n                });\n\n              case 26:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _render() {\n        return _render2.apply(this, arguments);\n      }\n\n      return _render;\n    }()\n    /**\n     * Position children before they get measured. Measuring will force relayout,\n     * so by positioning them first, we reduce computations.\n     */\n\n  }, {\n    key: \"_didRender\",\n    value: function _didRender() {\n      if (this._childrenPos) {\n        this._positionChildren(this._childrenPos);\n\n        this._childrenPos = null;\n      }\n    }\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(event) {\n      switch (event.type) {\n        case 'scroll':\n          if (!this._scrollTarget || event.target === this._scrollTarget) {\n            this._scheduleUpdateView();\n          }\n\n          break;\n\n        case 'scrollsizechange':\n          this._scrollSize = event.detail;\n\n          this._scheduleRender();\n\n          break;\n\n        case 'scrollerrorchange':\n          this._scrollErr = event.detail;\n\n          this._scheduleRender();\n\n          break;\n\n        case 'itempositionchange':\n          this._childrenPos = event.detail;\n\n          this._scheduleRender();\n\n          break;\n\n        case 'rangechange':\n          this._adjustRange(event.detail);\n\n          break;\n\n        default:\n          console.warn('event not handled', event);\n      }\n    }\n  }, {\n    key: \"_initResizeObservers\",\n    value: function () {\n      var _initResizeObservers2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n        var _this4 = this;\n\n        var ResizeObserver;\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this._containerRO === null)) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                _context2.next = 3;\n                return Object(_polyfillLoaders_ResizeObserver_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n\n              case 3:\n                ResizeObserver = _context2.sent;\n                this._containerRO = new ResizeObserver(function (entries) {\n                  return _this4._containerSizeChanged(entries[0].contentRect);\n                });\n                this._childrenRO = new ResizeObserver(function () {\n                  return _this4._childrenSizeChanged();\n                });\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _initResizeObservers() {\n        return _initResizeObservers2.apply(this, arguments);\n      }\n\n      return _initResizeObservers;\n    }()\n  }, {\n    key: \"_applyContainerStyles\",\n    value: function _applyContainerStyles() {\n      if (this._useShadowDOM) {\n        if (this._containerStylesheet === null) {\n          var sheet = this._containerStylesheet = document.createElement('style');\n          sheet.textContent = containerStyles(':host', '::slotted(*)');\n        }\n\n        var root = this._containerElement.shadowRoot || this._containerElement.attachShadow({\n          mode: 'open'\n        });\n\n        var slot = root.querySelector('slot:not([name])');\n        root.appendChild(this._containerStylesheet);\n\n        if (!slot) {\n          root.appendChild(document.createElement('slot'));\n        }\n      } else {\n        attachGlobalContainerStylesheet();\n\n        if (this._containerElement) {\n          this._containerElement.classList.add(HOST_CLASSNAME);\n        }\n      }\n    }\n  }, {\n    key: \"_createContainerSizer\",\n    value: function _createContainerSizer() {\n      var sizer = document.createElement('div'); // When the scrollHeight is large, the height of this element might be\n      // ignored. Setting content and font-size ensures the element has a size.\n\n      Object.assign(sizer.style, {\n        position: 'absolute',\n        margin: '-2px 0 0 0',\n        padding: 0,\n        visibility: 'hidden',\n        fontSize: '2px'\n      });\n      sizer.innerHTML = '&nbsp;';\n      return sizer;\n    }\n    /**\n     * TODO: Rename _ordered to _kids?\n     */\n\n  }, {\n    key: \"_scheduleUpdateView\",\n\n    /**\n     * Render and update the view at the next opportunity.\n     */\n    value: function _scheduleUpdateView() {\n      this._needsUpdateView = true;\n\n      this._scheduleRender();\n    }\n  }, {\n    key: \"_updateView\",\n    value: function _updateView() {\n      var width, height, top, left;\n\n      if (this._scrollTarget === this._containerElement) {\n        width = this._containerSize.width;\n        height = this._containerSize.height;\n        left = this._containerElement.scrollLeft;\n        top = this._containerElement.scrollTop;\n      } else {\n        var containerBounds = this._containerElement.getBoundingClientRect();\n\n        var scrollBounds = this._scrollTarget ? this._scrollTarget.getBoundingClientRect() : {\n          top: containerBounds.top + scrollY,\n          left: containerBounds.left + scrollX,\n          width: innerWidth,\n          height: innerHeight\n        };\n        var scrollerWidth = scrollBounds.width;\n        var scrollerHeight = scrollBounds.height;\n        var xMin = Math.max(0, Math.min(scrollerWidth, containerBounds.left - scrollBounds.left));\n        var yMin = Math.max(0, Math.min(scrollerHeight, containerBounds.top - scrollBounds.top)); // TODO: Direction is intended to be a layout-level concept, not a scroller-level concept,\n        // so this feels like a factoring problem\n\n        var xMax = this._layout.direction === 'vertical' ? Math.max(0, Math.min(scrollerWidth, containerBounds.right - scrollBounds.left)) : scrollerWidth;\n        var yMax = this._layout.direction === 'vertical' ? scrollerHeight : Math.max(0, Math.min(scrollerHeight, containerBounds.bottom - scrollBounds.top));\n        width = xMax - xMin;\n        height = yMax - yMin;\n        left = Math.max(0, -(containerBounds.left - scrollBounds.left));\n        top = Math.max(0, -(containerBounds.top - scrollBounds.top));\n      }\n\n      this._layout.viewportSize = {\n        width: width,\n        height: height\n      };\n      this._layout.viewportScroll = {\n        top: top,\n        left: left\n      };\n    }\n    /**\n     * Styles the _sizer element or the container so that its size reflects the\n     * total size of all items.\n     */\n\n  }, {\n    key: \"_sizeContainer\",\n    value: function _sizeContainer(size) {\n      if (this._scrollTarget === this._containerElement) {\n        var left = size && size.width ? size.width - 1 : 0;\n        var top = size && size.height ? size.height - 1 : 0;\n        this._sizer.style.transform = \"translate(\".concat(left, \"px, \").concat(top, \"px)\");\n      } else {\n        var style = this._containerElement.style;\n        style.minWidth = size && size.width ? size.width + 'px' : null;\n        style.minHeight = size && size.height ? size.height + 'px' : null;\n      }\n    }\n    /**\n     * Sets the top and left transform style of the children from the values in\n     * pos.\n     */\n\n  }, {\n    key: \"_positionChildren\",\n    value: function _positionChildren(pos) {\n      var _this5 = this;\n\n      var kids = this._kids;\n      Object.keys(pos).forEach(function (key) {\n        var idx = key - _this5._first;\n        var child = kids[idx];\n\n        if (child) {\n          var _pos$key = pos[key],\n              top = _pos$key.top,\n              left = _pos$key.left;\n          child.style.position = 'absolute';\n          child.style.transform = \"translate(\".concat(left, \"px, \").concat(top, \"px)\");\n        }\n      });\n    }\n  }, {\n    key: \"_adjustRange\",\n    value: function _adjustRange(range) {\n      this.num = range.num;\n      this.first = range.first;\n      var visiblityChanged = this._firstVisible !== range.firstVisible || this._lastVisible !== range.lastVisible;\n      this._firstVisible = range.firstVisible;\n      this._lastVisible = range.lastVisible;\n      this._incremental = !range.stable;\n\n      if (range.remeasure) {\n        this.requestRemeasure();\n      } else if (range.stable || visiblityChanged) {\n        this._notifyRange();\n      }\n    }\n  }, {\n    key: \"_shouldRender\",\n    value: function _shouldRender() {\n      if (!_get(_getPrototypeOf(VirtualScroller.prototype), \"_shouldRender\", this).call(this) || !this._containerElement || !this._layout && !this._lazyLoadDefaultLayout) {\n        return false;\n      } // NOTE: we're about to render, but the ResizeObserver didn't execute yet.\n      // Since we want to keep rAF timing, we compute _containerSize now. Would\n      // be nice to have a way to flush ResizeObservers.\n\n\n      if (this._containerSize === null) {\n        var _this$_containerEleme = this._containerElement.getBoundingClientRect(),\n            width = _this$_containerEleme.width,\n            height = _this$_containerEleme.height;\n\n        this._containerSize = {\n          width: width,\n          height: height\n        };\n      }\n\n      return this._containerSize.width > 0 || this._containerSize.height > 0;\n    }\n  }, {\n    key: \"_correctScrollError\",\n    value: function _correctScrollError(err) {\n      if (this._scrollTarget) {\n        this._scrollTarget.scrollTop -= err.top;\n        this._scrollTarget.scrollLeft -= err.left;\n      } else {\n        window.scroll(window.scrollX - err.left, window.scrollY - err.top);\n      }\n    }\n    /**\n     * Emits a rangechange event with the current first, last, firstVisible, and\n     * lastVisible.\n     */\n\n  }, {\n    key: \"_notifyRange\",\n    value: function _notifyRange() {\n      var first = this.first,\n          num = this.num;\n      var last = first + num - 1;\n\n      this._container.dispatchEvent(new RangeChangeEvent('rangechange', {\n        first: first,\n        last: last,\n        firstVisible: this._firstVisible,\n        lastVisible: this._lastVisible\n      }));\n    }\n    /**\n     * Render and update the view at the next opportunity with the given\n     * container size.\n     */\n\n  }, {\n    key: \"_containerSizeChanged\",\n    value: function _containerSizeChanged(size) {\n      var width = size.width,\n          height = size.height;\n      this._containerSize = {\n        width: width,\n        height: height\n      };\n\n      this._scheduleUpdateView();\n    }\n  }, {\n    key: \"_childrenSizeChanged\",\n    value: function _childrenSizeChanged() {\n      if (this._skipNextChildrenSizeChanged) {\n        this._skipNextChildrenSizeChanged = false;\n      } else {\n        this.requestRemeasure();\n      }\n    }\n  }, {\n    key: \"container\",\n    get: function get() {\n      return _get(_getPrototypeOf(VirtualScroller.prototype), \"container\", this);\n    },\n    set: function set(container) {\n      var _this6 = this;\n\n      _set(_getPrototypeOf(VirtualScroller.prototype), \"container\", container, this, true);\n\n      this._initResizeObservers().then(function () {\n        var oldEl = _this6._containerElement; // Consider document fragments as shadowRoots.\n\n        var newEl = container && container.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? container.host : container;\n\n        if (oldEl === newEl) {\n          return;\n        }\n\n        _this6._containerRO.disconnect();\n\n        _this6._containerSize = null;\n\n        if (oldEl) {\n          if (_this6._containerInlineStyle) {\n            oldEl.setAttribute('style', _this6._containerInlineStyle);\n          } else {\n            oldEl.removeAttribute('style');\n          }\n\n          _this6._containerInlineStyle = null;\n\n          if (oldEl === _this6._scrollTarget) {\n            oldEl.removeEventListener('scroll', _this6, {\n              passive: true\n            });\n            _this6._sizer && _this6._sizer.remove();\n          }\n        } else {\n          // First time container was setup, add listeners only now.\n          addEventListener('scroll', _this6, {\n            passive: true\n          });\n        }\n\n        _this6._containerElement = newEl;\n\n        if (newEl) {\n          _this6._containerInlineStyle = newEl.getAttribute('style') || null;\n\n          _this6._applyContainerStyles();\n\n          if (newEl === _this6._scrollTarget) {\n            _this6._sizer = _this6._sizer || _this6._createContainerSizer();\n\n            _this6._container.prepend(_this6._sizer);\n          }\n\n          _this6._scheduleUpdateView();\n\n          _this6._containerRO.observe(newEl);\n        }\n      });\n    }\n  }, {\n    key: \"layout\",\n    get: function get() {\n      return this._layout;\n    },\n    set: function set(layout) {\n      if (layout === this._layout) {\n        return;\n      }\n\n      if (this._layout) {\n        this._measureCallback = null;\n\n        this._layout.removeEventListener('scrollsizechange', this);\n\n        this._layout.removeEventListener('scrollerrorchange', this);\n\n        this._layout.removeEventListener('itempositionchange', this);\n\n        this._layout.removeEventListener('rangechange', this); // Reset container size so layout can get correct viewport size.\n\n\n        if (this._containerElement) {\n          this._sizeContainer(undefined);\n        }\n      }\n\n      this._layout = layout;\n\n      if (this._layout) {\n        if (typeof this._layout.updateItemSizes === 'function') {\n          this._measureCallback = this._layout.updateItemSizes.bind(this._layout);\n          this.requestRemeasure();\n        }\n\n        this._layout.addEventListener('scrollsizechange', this);\n\n        this._layout.addEventListener('scrollerrorchange', this);\n\n        this._layout.addEventListener('itempositionchange', this);\n\n        this._layout.addEventListener('rangechange', this);\n\n        this._scheduleUpdateView();\n      }\n    }\n    /**\n     * The element that generates scroll events and defines the container\n     * viewport. The value `null` (default) corresponds to `window` as scroll\n     * target.\n     */\n\n  }, {\n    key: \"scrollTarget\",\n    get: function get() {\n      return this._scrollTarget;\n    },\n    set: function set(target) {\n      // Consider window as null.\n      if (target === window) {\n        target = null;\n      }\n\n      if (this._scrollTarget === target) {\n        return;\n      }\n\n      if (this._scrollTarget) {\n        this._scrollTarget.removeEventListener('scroll', this, {\n          passive: true\n        });\n\n        if (this._sizer && this._scrollTarget === this._containerElement) {\n          this._sizer.remove();\n        }\n      }\n\n      this._scrollTarget = target;\n\n      if (target) {\n        target.addEventListener('scroll', this, {\n          passive: true\n        });\n\n        if (target === this._containerElement) {\n          this._sizer = this._sizer || this._createContainerSizer();\n\n          this._container.prepend(this._sizer);\n        }\n      }\n    }\n  }, {\n    key: \"useShadowDOM\",\n    get: function get() {\n      return this._useShadowDOM;\n    },\n    set: function set(newVal) {\n      if (this._useShadowDOM !== newVal) {\n        this._useShadowDOM = Boolean(newVal);\n\n        if (this._containerStylesheet) {\n          this._containerStylesheet.parentElement.removeChild(this._containerStylesheet);\n\n          this._containerStylesheet = null;\n        }\n\n        this._applyContainerStyles();\n      }\n    }\n    /**\n     * Index and position of item to scroll to. The scroller will fix to that point\n     * until the user scrolls.\n     */\n\n  }, {\n    key: \"scrollToIndex\",\n    set: function set(newValue) {\n      this._scrollToIndex = newValue;\n\n      this._scheduleUpdateView();\n    }\n  }, {\n    key: \"_kids\",\n    get: function get() {\n      return this._ordered;\n    }\n  }]);\n\n  return VirtualScroller;\n}(_VirtualRepeater_js__WEBPACK_IMPORTED_MODULE_0__[\"VirtualRepeater\"]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LXZpcnR1YWxpemVyL2xpYi91bmktdmlydHVhbGl6ZXIvbGliL1ZpcnR1YWxTY3JvbGxlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saXQtdmlydHVhbGl6ZXIvbGliL3VuaS12aXJ0dWFsaXplci9saWIvVmlydHVhbFNjcm9sbGVyLmpzPzRkMzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmlydHVhbFJlcGVhdGVyIH0gZnJvbSAnLi9WaXJ0dWFsUmVwZWF0ZXIuanMnO1xuaW1wb3J0IGdldFJlc2l6ZU9ic2VydmVyIGZyb20gJy4vcG9seWZpbGxMb2FkZXJzL1Jlc2l6ZU9ic2VydmVyLmpzJztcbmNvbnN0IEhPU1RfQ0xBU1NOQU1FID0gJ3VuaS12aXJ0dWFsaXplci1ob3N0JztcbmxldCBnbG9iYWxDb250YWluZXJTdHlsZXNoZWV0ID0gbnVsbDtcbmZ1bmN0aW9uIGNvbnRhaW5lclN0eWxlcyhob3N0U2VsLCBjaGlsZFNlbCkge1xuICAgIHJldHVybiBgXG4gICAgJHtob3N0U2VsfSB7XG4gICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIGNvbnRhaW46IHN0cmljdDtcbiAgICAgIGhlaWdodDogMTUwcHg7XG4gICAgICBvdmVyZmxvdzogYXV0bztcbiAgICB9XG4gICAgJHtjaGlsZFNlbH0ge1xuICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICB9YDtcbn1cbmZ1bmN0aW9uIGF0dGFjaEdsb2JhbENvbnRhaW5lclN0eWxlc2hlZXQoKSB7XG4gICAgaWYgKCFnbG9iYWxDb250YWluZXJTdHlsZXNoZWV0KSB7XG4gICAgICAgIGdsb2JhbENvbnRhaW5lclN0eWxlc2hlZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBnbG9iYWxDb250YWluZXJTdHlsZXNoZWV0LnRleHRDb250ZW50ID0gY29udGFpbmVyU3R5bGVzKGAuJHtIT1NUX0NMQVNTTkFNRX1gLCBgLiR7SE9TVF9DTEFTU05BTUV9ID4gKmApO1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGdsb2JhbENvbnRhaW5lclN0eWxlc2hlZXQpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBSYW5nZUNoYW5nZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGluaXQpIHtcbiAgICAgICAgc3VwZXIodHlwZSwgaW5pdCk7XG4gICAgICAgIHRoaXMuX2ZpcnN0ID0gTWF0aC5mbG9vcihpbml0LmZpcnN0IHx8IDApO1xuICAgICAgICB0aGlzLl9sYXN0ID0gTWF0aC5mbG9vcihpbml0Lmxhc3QgfHwgMCk7XG4gICAgICAgIHRoaXMuX2ZpcnN0VmlzaWJsZSA9IE1hdGguZmxvb3IoaW5pdC5maXJzdFZpc2libGUgfHwgMCk7XG4gICAgICAgIHRoaXMuX2xhc3RWaXNpYmxlID0gTWF0aC5mbG9vcihpbml0Lmxhc3RWaXNpYmxlIHx8IDApO1xuICAgIH1cbiAgICBnZXQgZmlyc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maXJzdDtcbiAgICB9XG4gICAgZ2V0IGxhc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXN0O1xuICAgIH1cbiAgICBnZXQgZmlyc3RWaXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlyc3RWaXNpYmxlO1xuICAgIH1cbiAgICBnZXQgbGFzdFZpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXN0VmlzaWJsZTtcbiAgICB9XG59XG4vKipcbiAqIFByb3ZpZGVzIHZpcnR1YWwgc2Nyb2xsaW5nIGJvaWxlcnBsYXRlLlxuICpcbiAqIEV4dGVuc2lvbnMgb2YgdGhpcyBjbGFzcyBtdXN0IHNldCBjb250YWluZXIsIGxheW91dCwgc2Nyb2xsVGFyZ2V0LCBhbmRcbiAqIHVzZVNoYWRvd0RPTS5cbiAqXG4gKiBFeHRlbnNpb25zIG9mIHRoaXMgY2xhc3MgbXVzdCBhbHNvIG92ZXJyaWRlIFZpcnR1YWxSZXBlYXRlcidzIERPTVxuICogbWFuaXB1bGF0aW9uIG1ldGhvZHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBWaXJ0dWFsU2Nyb2xsZXIgZXh0ZW5kcyBWaXJ0dWFsUmVwZWF0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcih7fSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBsYXlvdXQgc2hvdWxkIHJlY2VpdmUgYW4gdXBkYXRlZCB2aWV3cG9ydCBzaXplIG9uIHRoZSBuZXh0XG4gICAgICAgICAqIHJlbmRlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX25lZWRzVXBkYXRlVmlldyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9sYXlvdXQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0byBpbXBvcnQgdGhlIGRlZmF1bHQgKDFkKSBsYXlvdXQgb24gZmlyc3QgcmVuZGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbGF6eUxvYWREZWZhdWx0TGF5b3V0ID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBlbGVtZW50IHRoYXQgZ2VuZXJhdGVzIHNjcm9sbCBldmVudHMgYW5kIGRlZmluZXMgdGhlIGNvbnRhaW5lclxuICAgICAgICAgKiB2aWV3cG9ydC4gU2V0IGJ5IHNjcm9sbFRhcmdldC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Njcm9sbFRhcmdldCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHNlbnRpbmVsIGVsZW1lbnQgdGhhdCBzaXplcyB0aGUgY29udGFpbmVyIHdoZW4gaXQgaXMgYSBzY3JvbGxpbmdcbiAgICAgICAgICogZWxlbWVudC4gVGhpcyBlbnN1cmVzIHRoZSBzY3JvbGwgYmFyIGFjY3VyYXRlbHkgcmVmbGVjdHMgdGhlIHRvdGFsXG4gICAgICAgICAqIHNpemUgb2YgdGhlIGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zaXplciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMYXlvdXQgcHJvdmlkZXMgdGhlc2UgdmFsdWVzLCB3ZSBzZXQgdGhlbSBvbiBfcmVuZGVyKCkuXG4gICAgICAgICAqIFRPRE8gQHN0cmF2ZXJzaTogQ2FuIHdlIGZpbmQgYW4gWE9SIHR5cGUsIHVzYWJsZSBmb3IgdGhlIGtleSBoZXJlP1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2Nyb2xsU2l6ZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaWZmZXJlbmNlIGJldHdlZW4gc2Nyb2xsIHRhcmdldCdzIGN1cnJlbnQgYW5kIHJlcXVpcmVkIHNjcm9sbCBvZmZzZXRzLlxuICAgICAgICAgKiBQcm92aWRlZCBieSBsYXlvdXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zY3JvbGxFcnIgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIHRoZSBwb3NpdGlvbnMgKHRvcCwgbGVmdCkgb2YgdGhlIGNoaWxkcmVuIGluIHRoZSBjdXJyZW50IHJhbmdlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY2hpbGRyZW5Qb3MgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhcmVudCBvZiBhbGwgY2hpbGQgbm9kZXMgdG8gYmUgcmVuZGVyZWQuIFNldCBieSBjb250YWluZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jb250YWluZXJFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEtlZXAgdHJhY2sgb2Ygb3JpZ2luYWwgaW5saW5lIHN0eWxlIG9mIHRoZSBjb250YWluZXIsIHNvIGl0IGNhbiBiZVxuICAgICAgICAgKiByZXN0b3JlZCB3aGVuIGNvbnRhaW5lciBpcyBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY29udGFpbmVySW5saW5lU3R5bGUgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogS2VlcCB0cmFjayBvZiBvcmlnaW5hbCBjb250YWluZXIgc3R5bGVzaGVldCwgc28gaXQgY2FuIGJlIHJlc3RvcmVkXG4gICAgICAgICAqIHdoZW4gY29udGFpbmVyIGlzIGNoYW5nZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jb250YWluZXJTdHlsZXNoZWV0ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdG8gYnVpbGQgdGhlIHZpcnR1YWwgc2Nyb2xsZXIgd2l0aGluIGEgc2hhZG93IERPTS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3VzZVNoYWRvd0RPTSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaXplIG9mIHRoZSBjb250YWluZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jb250YWluZXJTaXplID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2l6ZSBvYnNlcnZlciBhdHRhY2hlZCB0byBjb250YWluZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jb250YWluZXJSTyA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNpemUgb2JzZXJ2ZXIgYXR0YWNoZWQgdG8gY2hpbGRyZW4uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jaGlsZHJlblJPID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsYWcgZm9yIHNraXBwaW5nIGEgY2hpbGRyZW4gbWVhc3VyZW1lbnQgaWYgdGhhdCBjb21wdXRhdGlvbiB3YXMganVzdFxuICAgICAgICAgKiBjb21wbGV0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9za2lwTmV4dENoaWxkcmVuU2l6ZUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGV4IGFuZCBwb3NpdGlvbiBvZiBpdGVtIHRvIHNjcm9sbCB0by5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Njcm9sbFRvSW5kZXggPSBudWxsO1xuICAgICAgICB0aGlzLl9udW0gPSAwO1xuICAgICAgICB0aGlzLl9maXJzdCA9IC0xO1xuICAgICAgICB0aGlzLl9sYXN0ID0gLTE7XG4gICAgICAgIHRoaXMuX3ByZXZGaXJzdCA9IC0xO1xuICAgICAgICB0aGlzLl9wcmV2TGFzdCA9IC0xO1xuICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmNvbnRhaW5lcjtcbiAgICB9XG4gICAgc2V0IGNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICAgICAgc3VwZXIuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLl9pbml0UmVzaXplT2JzZXJ2ZXJzKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvbGRFbCA9IHRoaXMuX2NvbnRhaW5lckVsZW1lbnQ7XG4gICAgICAgICAgICAvLyBDb25zaWRlciBkb2N1bWVudCBmcmFnbWVudHMgYXMgc2hhZG93Um9vdHMuXG4gICAgICAgICAgICBjb25zdCBuZXdFbCA9IChjb250YWluZXIgJiYgY29udGFpbmVyLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpID9cbiAgICAgICAgICAgICAgICBjb250YWluZXIuaG9zdCA6XG4gICAgICAgICAgICAgICAgY29udGFpbmVyO1xuICAgICAgICAgICAgaWYgKG9sZEVsID09PSBuZXdFbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lclJPLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lclNpemUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKG9sZEVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnRhaW5lcklubGluZVN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZEVsLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCB0aGlzLl9jb250YWluZXJJbmxpbmVTdHlsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvbGRFbC5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lcklubGluZVN0eWxlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAob2xkRWwgPT09IHRoaXMuX3Njcm9sbFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBvbGRFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NpemVyICYmIHRoaXMuX3NpemVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZpcnN0IHRpbWUgY29udGFpbmVyIHdhcyBzZXR1cCwgYWRkIGxpc3RlbmVycyBvbmx5IG5vdy5cbiAgICAgICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXJFbGVtZW50ID0gbmV3RWw7XG4gICAgICAgICAgICBpZiAobmV3RWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250YWluZXJJbmxpbmVTdHlsZSA9IG5ld0VsLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSB8fCBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5Q29udGFpbmVyU3R5bGVzKCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0VsID09PSB0aGlzLl9zY3JvbGxUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2l6ZXIgPSB0aGlzLl9zaXplciB8fCB0aGlzLl9jcmVhdGVDb250YWluZXJTaXplcigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250YWluZXIucHJlcGVuZCh0aGlzLl9zaXplcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlVXBkYXRlVmlldygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lclJPLm9ic2VydmUobmV3RWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGxheW91dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheW91dDtcbiAgICB9XG4gICAgc2V0IGxheW91dChsYXlvdXQpIHtcbiAgICAgICAgaWYgKGxheW91dCA9PT0gdGhpcy5fbGF5b3V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2xheW91dCkge1xuICAgICAgICAgICAgdGhpcy5fbWVhc3VyZUNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2xheW91dC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGxzaXplY2hhbmdlJywgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9sYXlvdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsZXJyb3JjaGFuZ2UnLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2xheW91dC5yZW1vdmVFdmVudExpc3RlbmVyKCdpdGVtcG9zaXRpb25jaGFuZ2UnLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2xheW91dC5yZW1vdmVFdmVudExpc3RlbmVyKCdyYW5nZWNoYW5nZScsIHRoaXMpO1xuICAgICAgICAgICAgLy8gUmVzZXQgY29udGFpbmVyIHNpemUgc28gbGF5b3V0IGNhbiBnZXQgY29ycmVjdCB2aWV3cG9ydCBzaXplLlxuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnRhaW5lckVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaXplQ29udGFpbmVyKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGF5b3V0ID0gbGF5b3V0O1xuICAgICAgICBpZiAodGhpcy5fbGF5b3V0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2xheW91dC51cGRhdGVJdGVtU2l6ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tZWFzdXJlQ2FsbGJhY2sgPSB0aGlzLl9sYXlvdXQudXBkYXRlSXRlbVNpemVzLmJpbmQodGhpcy5fbGF5b3V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RSZW1lYXN1cmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xheW91dC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGxzaXplY2hhbmdlJywgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9sYXlvdXQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsZXJyb3JjaGFuZ2UnLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2xheW91dC5hZGRFdmVudExpc3RlbmVyKCdpdGVtcG9zaXRpb25jaGFuZ2UnLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2xheW91dC5hZGRFdmVudExpc3RlbmVyKCdyYW5nZWNoYW5nZScsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGVVcGRhdGVWaWV3KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGVsZW1lbnQgdGhhdCBnZW5lcmF0ZXMgc2Nyb2xsIGV2ZW50cyBhbmQgZGVmaW5lcyB0aGUgY29udGFpbmVyXG4gICAgICogdmlld3BvcnQuIFRoZSB2YWx1ZSBgbnVsbGAgKGRlZmF1bHQpIGNvcnJlc3BvbmRzIHRvIGB3aW5kb3dgIGFzIHNjcm9sbFxuICAgICAqIHRhcmdldC5cbiAgICAgKi9cbiAgICBnZXQgc2Nyb2xsVGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsVGFyZ2V0O1xuICAgIH1cbiAgICBzZXQgc2Nyb2xsVGFyZ2V0KHRhcmdldCkge1xuICAgICAgICAvLyBDb25zaWRlciB3aW5kb3cgYXMgbnVsbC5cbiAgICAgICAgaWYgKHRhcmdldCA9PT0gd2luZG93KSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zY3JvbGxUYXJnZXQgPT09IHRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zY3JvbGxUYXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2l6ZXIgJiYgdGhpcy5fc2Nyb2xsVGFyZ2V0ID09PSB0aGlzLl9jb250YWluZXJFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2l6ZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2Nyb2xsVGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcywgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gdGhpcy5fY29udGFpbmVyRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NpemVyID0gdGhpcy5fc2l6ZXIgfHwgdGhpcy5fY3JlYXRlQ29udGFpbmVyU2l6ZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250YWluZXIucHJlcGVuZCh0aGlzLl9zaXplcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHVzZVNoYWRvd0RPTSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VzZVNoYWRvd0RPTTtcbiAgICB9XG4gICAgc2V0IHVzZVNoYWRvd0RPTShuZXdWYWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX3VzZVNoYWRvd0RPTSAhPT0gbmV3VmFsKSB7XG4gICAgICAgICAgICB0aGlzLl91c2VTaGFkb3dET00gPSBCb29sZWFuKG5ld1ZhbCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29udGFpbmVyU3R5bGVzaGVldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lclN0eWxlc2hlZXQucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLl9jb250YWluZXJTdHlsZXNoZWV0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250YWluZXJTdHlsZXNoZWV0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FwcGx5Q29udGFpbmVyU3R5bGVzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5kZXggYW5kIHBvc2l0aW9uIG9mIGl0ZW0gdG8gc2Nyb2xsIHRvLiBUaGUgc2Nyb2xsZXIgd2lsbCBmaXggdG8gdGhhdCBwb2ludFxuICAgICAqIHVudGlsIHRoZSB1c2VyIHNjcm9sbHMuXG4gICAgICovXG4gICAgc2V0IHNjcm9sbFRvSW5kZXgobmV3VmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsVG9JbmRleCA9IG5ld1ZhbHVlO1xuICAgICAgICB0aGlzLl9zY2hlZHVsZVVwZGF0ZVZpZXcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcGxheSB0aGUgaXRlbXMgaW4gdGhlIGN1cnJlbnQgcmFuZ2UuXG4gICAgICogQ29udGludWUgcmVsYXlvdXQgb2YgY2hpbGQgcG9zaXRpb25zIHVudGlsIHRoZXkgaGF2ZSBzdGFiaWxpemVkLlxuICAgICAqL1xuICAgIGFzeW5jIF9yZW5kZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYXp5TG9hZERlZmF1bHRMYXlvdXQgJiYgIXRoaXMuX2xheW91dCkge1xuICAgICAgICAgICAgdGhpcy5fbGF6eUxvYWREZWZhdWx0TGF5b3V0ID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCB7IExheW91dDFkIH0gPSBhd2FpdCBpbXBvcnQoJy4vbGF5b3V0cy9MYXlvdXQxZCcpO1xuICAgICAgICAgICAgdGhpcy5sYXlvdXQgPSBuZXcgTGF5b3V0MWQoe30pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuUk8uZGlzY29ubmVjdCgpO1xuICAgICAgICAvLyBVcGRhdGUgbGF5b3V0IHByb3BlcnRpZXMgYmVmb3JlIHJlbmRlcmluZyB0byBoYXZlIGNvcnJlY3QgZmlyc3QsIG51bSxcbiAgICAgICAgLy8gc2Nyb2xsIHNpemUsIGNoaWxkcmVuIHBvc2l0aW9ucy5cbiAgICAgICAgdGhpcy5fbGF5b3V0LnRvdGFsSXRlbXMgPSB0aGlzLnRvdGFsSXRlbXM7XG4gICAgICAgIGlmICh0aGlzLl9uZWVkc1VwZGF0ZVZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzVXBkYXRlVmlldyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVmlldygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zY3JvbGxUb0luZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXlvdXQuc2Nyb2xsVG9JbmRleCh0aGlzLl9zY3JvbGxUb0luZGV4LmluZGV4LCB0aGlzLl9zY3JvbGxUb0luZGV4LnBvc2l0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFRvSW5kZXggPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xheW91dC5yZWZsb3dJZk5lZWRlZCgpO1xuICAgICAgICAvLyBLZWVwIHJlbmRlcmluZyB1bnRpbCB0aGVyZSBpcyBubyBtb3JlIHNjaGVkdWxlZCByZW5kZXJzLlxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdSZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9wZW5kaW5nUmVuZGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nUmVuZGVyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgc2Nyb2xsIHNpemUgYW5kIGNvcnJlY3Qgc2Nyb2xsIGVycm9yIGJlZm9yZSByZW5kZXJpbmcuXG4gICAgICAgICAgICB0aGlzLl9zaXplQ29udGFpbmVyKHRoaXMuX3Njcm9sbFNpemUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Njcm9sbEVycikge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgdHJpZ2dlcnMgYSAnc2Nyb2xsJyBldmVudCAoYXN5bmMpIHdoaWNoIHRyaWdnZXJzIGFub3RoZXJcbiAgICAgICAgICAgICAgICAvLyBfdXBkYXRlVmlldygpLlxuICAgICAgICAgICAgICAgIHRoaXMuX2NvcnJlY3RTY3JvbGxFcnJvcih0aGlzLl9zY3JvbGxFcnIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbEVyciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQb3NpdGlvbiBjaGlsZHJlbiAoX2RpZFJlbmRlcigpKSwgYW5kIHByb3ZpZGUgdGhlaXIgbWVhc3VyZXMgdG8gbGF5b3V0LlxuICAgICAgICAgICAgYXdhaXQgc3VwZXIuX3JlbmRlcigpO1xuICAgICAgICAgICAgdGhpcy5fbGF5b3V0LnJlZmxvd0lmTmVlZGVkKCk7XG4gICAgICAgICAgICAvLyBJZiBsYXlvdXQgcmVmbG93IGRpZCBub3QgcHJvdm9rZSBhbm90aGVyIHJlbmRlciwgd2UncmUgZG9uZS5cbiAgICAgICAgICAgIGlmICghdGhpcy5fcGVuZGluZ1JlbmRlcikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gc2tpcCB0aGUgZmlyc3QgUmVzaXplT2JzZXJ2ZXIgY2FsbGJhY2sgY2FsbCBhcyB3ZSBhbHJlYWR5XG4gICAgICAgIC8vIG1lYXN1cmVkIHRoZSBjaGlsZHJlbi5cbiAgICAgICAgdGhpcy5fc2tpcE5leHRDaGlsZHJlblNpemVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fa2lkcy5mb3JFYWNoKChjaGlsZCkgPT4gdGhpcy5fY2hpbGRyZW5STy5vYnNlcnZlKGNoaWxkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIGNoaWxkcmVuIGJlZm9yZSB0aGV5IGdldCBtZWFzdXJlZC4gTWVhc3VyaW5nIHdpbGwgZm9yY2UgcmVsYXlvdXQsXG4gICAgICogc28gYnkgcG9zaXRpb25pbmcgdGhlbSBmaXJzdCwgd2UgcmVkdWNlIGNvbXB1dGF0aW9ucy5cbiAgICAgKi9cbiAgICBfZGlkUmVuZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5fY2hpbGRyZW5Qb3MpIHtcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uQ2hpbGRyZW4odGhpcy5fY2hpbGRyZW5Qb3MpO1xuICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW5Qb3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc2Nyb2xsJzpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3Njcm9sbFRhcmdldCB8fCBldmVudC50YXJnZXQgPT09IHRoaXMuX3Njcm9sbFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY2hlZHVsZVVwZGF0ZVZpZXcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzY3JvbGxzaXplY2hhbmdlJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxTaXplID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzY3JvbGxlcnJvcmNoYW5nZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsRXJyID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpdGVtcG9zaXRpb25jaGFuZ2UnOlxuICAgICAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuUG9zID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyYW5nZWNoYW5nZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRqdXN0UmFuZ2UoZXZlbnQuZGV0YWlsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdldmVudCBub3QgaGFuZGxlZCcsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfaW5pdFJlc2l6ZU9ic2VydmVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRhaW5lclJPID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBSZXNpemVPYnNlcnZlciA9IGF3YWl0IGdldFJlc2l6ZU9ic2VydmVyKCk7XG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXJSTyA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4gdGhpcy5fY29udGFpbmVyU2l6ZUNoYW5nZWQoZW50cmllc1swXS5jb250ZW50UmVjdCkpO1xuICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW5STyA9XG4gICAgICAgICAgICAgICAgbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHRoaXMuX2NoaWxkcmVuU2l6ZUNoYW5nZWQoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2FwcGx5Q29udGFpbmVyU3R5bGVzKCkge1xuICAgICAgICBpZiAodGhpcy5fdXNlU2hhZG93RE9NKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29udGFpbmVyU3R5bGVzaGVldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNoZWV0ID0gKHRoaXMuX2NvbnRhaW5lclN0eWxlc2hlZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpKTtcbiAgICAgICAgICAgICAgICBzaGVldC50ZXh0Q29udGVudCA9IGNvbnRhaW5lclN0eWxlcygnOmhvc3QnLCAnOjpzbG90dGVkKCopJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByb290ID0gdGhpcy5fY29udGFpbmVyRWxlbWVudC5zaGFkb3dSb290IHx8IHRoaXMuX2NvbnRhaW5lckVsZW1lbnQuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xuICAgICAgICAgICAgY29uc3Qgc2xvdCA9IHJvb3QucXVlcnlTZWxlY3Rvcignc2xvdDpub3QoW25hbWVdKScpO1xuICAgICAgICAgICAgcm9vdC5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXJTdHlsZXNoZWV0KTtcbiAgICAgICAgICAgIGlmICghc2xvdCkge1xuICAgICAgICAgICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2xvdCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF0dGFjaEdsb2JhbENvbnRhaW5lclN0eWxlc2hlZXQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb250YWluZXJFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyRWxlbWVudC5jbGFzc0xpc3QuYWRkKEhPU1RfQ0xBU1NOQU1FKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfY3JlYXRlQ29udGFpbmVyU2l6ZXIoKSB7XG4gICAgICAgIGNvbnN0IHNpemVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIC8vIFdoZW4gdGhlIHNjcm9sbEhlaWdodCBpcyBsYXJnZSwgdGhlIGhlaWdodCBvZiB0aGlzIGVsZW1lbnQgbWlnaHQgYmVcbiAgICAgICAgLy8gaWdub3JlZC4gU2V0dGluZyBjb250ZW50IGFuZCBmb250LXNpemUgZW5zdXJlcyB0aGUgZWxlbWVudCBoYXMgYSBzaXplLlxuICAgICAgICBPYmplY3QuYXNzaWduKHNpemVyLnN0eWxlLCB7XG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIG1hcmdpbjogJy0ycHggMCAwIDAnLFxuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nLFxuICAgICAgICAgICAgZm9udFNpemU6ICcycHgnLFxuICAgICAgICB9KTtcbiAgICAgICAgc2l6ZXIuaW5uZXJIVE1MID0gJyZuYnNwOyc7XG4gICAgICAgIHJldHVybiBzaXplcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVE9ETzogUmVuYW1lIF9vcmRlcmVkIHRvIF9raWRzP1xuICAgICAqL1xuICAgIGdldCBfa2lkcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yZGVyZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlciBhbmQgdXBkYXRlIHRoZSB2aWV3IGF0IHRoZSBuZXh0IG9wcG9ydHVuaXR5LlxuICAgICAqL1xuICAgIF9zY2hlZHVsZVVwZGF0ZVZpZXcoKSB7XG4gICAgICAgIHRoaXMuX25lZWRzVXBkYXRlVmlldyA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlUmVuZGVyKCk7XG4gICAgfVxuICAgIF91cGRhdGVWaWV3KCkge1xuICAgICAgICBsZXQgd2lkdGgsIGhlaWdodCwgdG9wLCBsZWZ0O1xuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsVGFyZ2V0ID09PSB0aGlzLl9jb250YWluZXJFbGVtZW50KSB7XG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMuX2NvbnRhaW5lclNpemUud2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQgPSB0aGlzLl9jb250YWluZXJTaXplLmhlaWdodDtcbiAgICAgICAgICAgIGxlZnQgPSB0aGlzLl9jb250YWluZXJFbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgICAgICAgICB0b3AgPSB0aGlzLl9jb250YWluZXJFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lckJvdW5kcyA9IHRoaXMuX2NvbnRhaW5lckVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBjb25zdCBzY3JvbGxCb3VuZHMgPSB0aGlzLl9zY3JvbGxUYXJnZXQgP1xuICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbFRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0b3A6IGNvbnRhaW5lckJvdW5kcy50b3AgKyBzY3JvbGxZLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBjb250YWluZXJCb3VuZHMubGVmdCArIHNjcm9sbFgsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBpbm5lcldpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGlubmVySGVpZ2h0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbGVyV2lkdGggPSBzY3JvbGxCb3VuZHMud2lkdGg7XG4gICAgICAgICAgICBjb25zdCBzY3JvbGxlckhlaWdodCA9IHNjcm9sbEJvdW5kcy5oZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCB4TWluID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc2Nyb2xsZXJXaWR0aCwgY29udGFpbmVyQm91bmRzLmxlZnQgLSBzY3JvbGxCb3VuZHMubGVmdCkpO1xuICAgICAgICAgICAgY29uc3QgeU1pbiA9IE1hdGgubWF4KDAsIE1hdGgubWluKHNjcm9sbGVySGVpZ2h0LCBjb250YWluZXJCb3VuZHMudG9wIC0gc2Nyb2xsQm91bmRzLnRvcCkpO1xuICAgICAgICAgICAgLy8gVE9ETzogRGlyZWN0aW9uIGlzIGludGVuZGVkIHRvIGJlIGEgbGF5b3V0LWxldmVsIGNvbmNlcHQsIG5vdCBhIHNjcm9sbGVyLWxldmVsIGNvbmNlcHQsXG4gICAgICAgICAgICAvLyBzbyB0aGlzIGZlZWxzIGxpa2UgYSBmYWN0b3JpbmcgcHJvYmxlbVxuICAgICAgICAgICAgY29uc3QgeE1heCA9IHRoaXMuX2xheW91dC5kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcgP1xuICAgICAgICAgICAgICAgIE1hdGgubWF4KDAsIE1hdGgubWluKHNjcm9sbGVyV2lkdGgsIGNvbnRhaW5lckJvdW5kcy5yaWdodCAtIHNjcm9sbEJvdW5kcy5sZWZ0KSkgOlxuICAgICAgICAgICAgICAgIHNjcm9sbGVyV2lkdGg7XG4gICAgICAgICAgICBjb25zdCB5TWF4ID0gdGhpcy5fbGF5b3V0LmRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJyA/XG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJIZWlnaHQgOlxuICAgICAgICAgICAgICAgIE1hdGgubWF4KDAsIE1hdGgubWluKHNjcm9sbGVySGVpZ2h0LCBjb250YWluZXJCb3VuZHMuYm90dG9tIC0gc2Nyb2xsQm91bmRzLnRvcCkpO1xuICAgICAgICAgICAgd2lkdGggPSB4TWF4IC0geE1pbjtcbiAgICAgICAgICAgIGhlaWdodCA9IHlNYXggLSB5TWluO1xuICAgICAgICAgICAgbGVmdCA9IE1hdGgubWF4KDAsIC0oY29udGFpbmVyQm91bmRzLmxlZnQgLSBzY3JvbGxCb3VuZHMubGVmdCkpO1xuICAgICAgICAgICAgdG9wID0gTWF0aC5tYXgoMCwgLShjb250YWluZXJCb3VuZHMudG9wIC0gc2Nyb2xsQm91bmRzLnRvcCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xheW91dC52aWV3cG9ydFNpemUgPSB7IHdpZHRoLCBoZWlnaHQgfTtcbiAgICAgICAgdGhpcy5fbGF5b3V0LnZpZXdwb3J0U2Nyb2xsID0geyB0b3AsIGxlZnQgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3R5bGVzIHRoZSBfc2l6ZXIgZWxlbWVudCBvciB0aGUgY29udGFpbmVyIHNvIHRoYXQgaXRzIHNpemUgcmVmbGVjdHMgdGhlXG4gICAgICogdG90YWwgc2l6ZSBvZiBhbGwgaXRlbXMuXG4gICAgICovXG4gICAgX3NpemVDb250YWluZXIoc2l6ZSkge1xuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsVGFyZ2V0ID09PSB0aGlzLl9jb250YWluZXJFbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gc2l6ZSAmJiBzaXplLndpZHRoID8gc2l6ZS53aWR0aCAtIDEgOiAwO1xuICAgICAgICAgICAgY29uc3QgdG9wID0gc2l6ZSAmJiBzaXplLmhlaWdodCA/IHNpemUuaGVpZ2h0IC0gMSA6IDA7XG4gICAgICAgICAgICB0aGlzLl9zaXplci5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7bGVmdH1weCwgJHt0b3B9cHgpYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gdGhpcy5fY29udGFpbmVyRWxlbWVudC5zdHlsZTtcbiAgICAgICAgICAgIHN0eWxlLm1pbldpZHRoID0gc2l6ZSAmJiBzaXplLndpZHRoID8gc2l6ZS53aWR0aCArICdweCcgOiBudWxsO1xuICAgICAgICAgICAgc3R5bGUubWluSGVpZ2h0ID0gc2l6ZSAmJiBzaXplLmhlaWdodCA/IHNpemUuaGVpZ2h0ICsgJ3B4JyA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdG9wIGFuZCBsZWZ0IHRyYW5zZm9ybSBzdHlsZSBvZiB0aGUgY2hpbGRyZW4gZnJvbSB0aGUgdmFsdWVzIGluXG4gICAgICogcG9zLlxuICAgICAqL1xuICAgIF9wb3NpdGlvbkNoaWxkcmVuKHBvcykge1xuICAgICAgICBjb25zdCBraWRzID0gdGhpcy5fa2lkcztcbiAgICAgICAgT2JqZWN0LmtleXMocG9zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IGtleSAtIHRoaXMuX2ZpcnN0O1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBraWRzW2lkeF07XG4gICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRvcCwgbGVmdCB9ID0gcG9zW2tleV07XG4gICAgICAgICAgICAgICAgY2hpbGQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgICAgIGNoaWxkLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtsZWZ0fXB4LCAke3RvcH1weClgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FkanVzdFJhbmdlKHJhbmdlKSB7XG4gICAgICAgIHRoaXMubnVtID0gcmFuZ2UubnVtO1xuICAgICAgICB0aGlzLmZpcnN0ID0gcmFuZ2UuZmlyc3Q7XG4gICAgICAgIGNvbnN0IHZpc2libGl0eUNoYW5nZWQgPSB0aGlzLl9maXJzdFZpc2libGUgIT09IHJhbmdlLmZpcnN0VmlzaWJsZSB8fCB0aGlzLl9sYXN0VmlzaWJsZSAhPT0gcmFuZ2UubGFzdFZpc2libGU7XG4gICAgICAgIHRoaXMuX2ZpcnN0VmlzaWJsZSA9IHJhbmdlLmZpcnN0VmlzaWJsZTtcbiAgICAgICAgdGhpcy5fbGFzdFZpc2libGUgPSByYW5nZS5sYXN0VmlzaWJsZTtcbiAgICAgICAgdGhpcy5faW5jcmVtZW50YWwgPSAhKHJhbmdlLnN0YWJsZSk7XG4gICAgICAgIGlmIChyYW5nZS5yZW1lYXN1cmUpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFJlbWVhc3VyZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJhbmdlLnN0YWJsZSB8fCB2aXNpYmxpdHlDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9ub3RpZnlSYW5nZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9zaG91bGRSZW5kZXIoKSB7XG4gICAgICAgIGlmICghc3VwZXIuX3Nob3VsZFJlbmRlcigpIHx8ICF0aGlzLl9jb250YWluZXJFbGVtZW50IHx8ICghdGhpcy5fbGF5b3V0ICYmICF0aGlzLl9sYXp5TG9hZERlZmF1bHRMYXlvdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9URTogd2UncmUgYWJvdXQgdG8gcmVuZGVyLCBidXQgdGhlIFJlc2l6ZU9ic2VydmVyIGRpZG4ndCBleGVjdXRlIHlldC5cbiAgICAgICAgLy8gU2luY2Ugd2Ugd2FudCB0byBrZWVwIHJBRiB0aW1pbmcsIHdlIGNvbXB1dGUgX2NvbnRhaW5lclNpemUgbm93LiBXb3VsZFxuICAgICAgICAvLyBiZSBuaWNlIHRvIGhhdmUgYSB3YXkgdG8gZmx1c2ggUmVzaXplT2JzZXJ2ZXJzLlxuICAgICAgICBpZiAodGhpcy5fY29udGFpbmVyU2l6ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLl9jb250YWluZXJFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyU2l6ZSA9IHsgd2lkdGgsIGhlaWdodCB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXJTaXplLndpZHRoID4gMCB8fCB0aGlzLl9jb250YWluZXJTaXplLmhlaWdodCA+IDA7XG4gICAgfVxuICAgIF9jb3JyZWN0U2Nyb2xsRXJyb3IoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLl9zY3JvbGxUYXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFRhcmdldC5zY3JvbGxUb3AgLT0gZXJyLnRvcDtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFRhcmdldC5zY3JvbGxMZWZ0IC09IGVyci5sZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2luZG93LnNjcm9sbCh3aW5kb3cuc2Nyb2xsWCAtIGVyci5sZWZ0LCB3aW5kb3cuc2Nyb2xsWSAtIGVyci50b3ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIGEgcmFuZ2VjaGFuZ2UgZXZlbnQgd2l0aCB0aGUgY3VycmVudCBmaXJzdCwgbGFzdCwgZmlyc3RWaXNpYmxlLCBhbmRcbiAgICAgKiBsYXN0VmlzaWJsZS5cbiAgICAgKi9cbiAgICBfbm90aWZ5UmFuZ2UoKSB7XG4gICAgICAgIGNvbnN0IHsgZmlyc3QsIG51bSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbGFzdCA9IGZpcnN0ICsgbnVtIC0gMTtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmRpc3BhdGNoRXZlbnQobmV3IFJhbmdlQ2hhbmdlRXZlbnQoJ3JhbmdlY2hhbmdlJywge1xuICAgICAgICAgICAgZmlyc3QsXG4gICAgICAgICAgICBsYXN0LFxuICAgICAgICAgICAgZmlyc3RWaXNpYmxlOiB0aGlzLl9maXJzdFZpc2libGUsXG4gICAgICAgICAgICBsYXN0VmlzaWJsZTogdGhpcy5fbGFzdFZpc2libGUsXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVuZGVyIGFuZCB1cGRhdGUgdGhlIHZpZXcgYXQgdGhlIG5leHQgb3Bwb3J0dW5pdHkgd2l0aCB0aGUgZ2l2ZW5cbiAgICAgKiBjb250YWluZXIgc2l6ZS5cbiAgICAgKi9cbiAgICBfY29udGFpbmVyU2l6ZUNoYW5nZWQoc2l6ZSkge1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHNpemU7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lclNpemUgPSB7IHdpZHRoLCBoZWlnaHQgfTtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGVVcGRhdGVWaWV3KCk7XG4gICAgfVxuICAgIF9jaGlsZHJlblNpemVDaGFuZ2VkKCkge1xuICAgICAgICBpZiAodGhpcy5fc2tpcE5leHRDaGlsZHJlblNpemVDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9za2lwTmV4dENoaWxkcmVuU2l6ZUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFJlbWVhc3VyZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBV0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU1BO0FBQ0E7QUFSQTtBQUFBO0FBQUE7QUFTQTtBQUNBO0FBVkE7QUFBQTtBQUFBO0FBWUE7QUFDQTtBQWJBO0FBQUE7QUFBQTtBQWVBO0FBQ0E7QUFoQkE7QUFBQTtBQUFBO0FBa0JBO0FBQ0E7QUFuQkE7QUFDQTtBQURBO0FBQUE7QUFxQkE7Ozs7Ozs7Ozs7QUFTQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7Ozs7O0FBSUE7QUFDQTtBQUNBOzs7O0FBR0E7QUFDQTs7Ozs7QUFJQTtBQUNBOzs7Ozs7QUFLQTtBQUNBOzs7OztBQUlBO0FBQ0E7Ozs7O0FBSUE7QUFDQTs7OztBQUdBO0FBQ0E7Ozs7QUFHQTtBQUNBOzs7OztBQUlBO0FBQ0E7Ozs7O0FBSUE7QUFDQTs7OztBQUdBO0FBQ0E7Ozs7QUFHQTtBQUNBOzs7O0FBR0E7QUFDQTs7OztBQUdBO0FBQ0E7Ozs7O0FBSUE7QUFDQTs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFwRkE7QUFvRkE7QUFDQTtBQXRGQTtBQUFBO0FBQ0E7QUFzTkE7Ozs7QUF2TkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBNE5BO0FBN05BO0FBQUE7QUFDQTtBQURBO0FBQUE7QUE4TkE7QUFDQTtBQS9OQTtBQUNBO0FBREE7QUFrT0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBaFBBO0FBQUE7QUFDQTtBQWdQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBOVBBO0FBQUE7QUFDQTtBQURBO0FBK1BBO0FBQ0E7QUFDQTtBQWpRQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFxUUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQXpRQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBMFFBOzs7OztBQTFRQTtBQUFBO0FBQUE7QUErUUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBblJBO0FBQUE7QUFBQTtBQXFSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUF0QkE7QUF3QkE7QUE3U0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQWdUQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBcFRBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUF1VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBelVBO0FBQUE7QUFBQTtBQTJVQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBOzs7O0FBeFZBO0FBQUE7QUFDQTtBQTZWQTs7O0FBOVZBO0FBa1dBO0FBQ0E7QUFBQTtBQUNBO0FBcFdBO0FBQUE7QUFBQTtBQXNXQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7QUEzWUE7QUFBQTtBQUFBO0FBZ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBM1pBO0FBQUE7QUFBQTtBQStaQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTFhQTtBQUFBO0FBQUE7QUE0YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUF4YkE7QUFBQTtBQUFBO0FBMGJBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFyY0E7QUFBQTtBQUFBO0FBdWNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBL2NBO0FBQUE7QUFBQTtBQW1kQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7Ozs7O0FBN2RBO0FBQUE7QUFBQTtBQWllQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFyZUE7QUFBQTtBQUFBO0FBdWVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQTdlQTtBQUFBO0FBQUE7QUF1RkE7QUFDQTtBQXhGQTtBQXlGQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQW5JQTtBQUFBO0FBQUE7QUFxSUE7QUFDQTtBQXRJQTtBQXdJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFuS0E7QUFBQTtBQUFBO0FBeUtBO0FBQ0E7QUExS0E7QUE0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBak1BO0FBQUE7QUFBQTtBQW1NQTtBQUNBO0FBcE1BO0FBc01BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQS9NQTtBQUFBO0FBQUE7QUFvTkE7QUFDQTtBQUFBO0FBQ0E7QUF0TkE7QUFBQTtBQUFBO0FBNFZBO0FBQ0E7QUE3VkE7QUFDQTtBQURBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/VirtualScroller.js\n");

/***/ }),

/***/ "./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/layouts/Layout1d.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/layouts/Layout1d.js ***!
  \**********************************************************************************/
/*! exports provided: Layout1d */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Layout1d\", function() { return Layout1d; });\n/* harmony import */ var _Layout1dBase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Layout1dBase.js */ \"./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/layouts/Layout1dBase.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\nvar Layout1d = /*#__PURE__*/function (_Layout1dBase) {\n  _inherits(Layout1d, _Layout1dBase);\n\n  var _super = _createSuper(Layout1d);\n\n  function Layout1d(config) {\n    var _this;\n\n    _classCallCheck(this, Layout1d);\n\n    _this = _super.call(this, config);\n    /**\n     * Indices of children mapped to their (position and length) in the scrolling\n     * direction. Used to keep track of children that are in range.\n     */\n\n    _this._physicalItems = new Map();\n    /**\n     * Used in tandem with _physicalItems to track children in range across\n     * reflows.\n     */\n\n    _this._newPhysicalItems = new Map();\n    /**\n     * Width and height of children by their index.\n     */\n\n    _this._metrics = new Map();\n    /**\n     * anchorIdx is the anchor around which we reflow. It is designed to allow\n     * jumping to any point of the scroll size. We choose it once and stick with\n     * it until stable. _first and _last are deduced around it.\n     */\n\n    _this._anchorIdx = null;\n    /**\n     * Position in the scrolling direction of the anchor child.\n     */\n\n    _this._anchorPos = null;\n    /**\n     * Whether all children in range were in range during the previous reflow.\n     */\n\n    _this._stable = true;\n    /**\n     * Whether to remeasure children during the next reflow.\n     */\n\n    _this._needsRemeasure = false;\n    /**\n     * Number of children to lay out.\n     */\n\n    _this._nMeasured = 0;\n    /**\n     * Total length in the scrolling direction of the laid out children.\n     */\n\n    _this._tMeasured = 0;\n    _this._estimate = true;\n    return _this;\n  }\n  /**\n   * Determine the average size of all children represented in the sizes\n   * argument.\n   */\n\n\n  _createClass(Layout1d, [{\n    key: \"updateItemSizes\",\n    value: function updateItemSizes(sizes) {\n      var _this2 = this;\n\n      Object.keys(sizes).forEach(function (key) {\n        var metrics = sizes[key],\n            mi = _this2._getMetrics(Number(key)),\n            prevSize = mi[_this2._sizeDim]; // TODO(valdrin) Handle margin collapsing.\n        // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing\n\n\n        mi.width = metrics.width + (metrics.marginLeft || 0) + (metrics.marginRight || 0);\n        mi.height = metrics.height + (metrics.marginTop || 0) + (metrics.marginBottom || 0);\n        var size = mi[_this2._sizeDim];\n\n        var item = _this2._getPhysicalItem(Number(key));\n\n        if (item) {\n          var delta;\n\n          if (size !== undefined) {\n            item.size = size;\n\n            if (prevSize === undefined) {\n              delta = size;\n              _this2._nMeasured++;\n            } else {\n              delta = size - prevSize;\n            }\n          }\n\n          _this2._tMeasured = _this2._tMeasured + delta;\n        }\n      });\n\n      if (!this._nMeasured) {\n        console.warn(\"No items measured yet.\");\n      } else {\n        this._updateItemSize();\n\n        this._scheduleReflow();\n      }\n    }\n    /**\n     * Set the average item size based on the total length and number of children\n     * in range.\n     */\n\n  }, {\n    key: \"_updateItemSize\",\n    value: function _updateItemSize() {\n      // Keep integer values.\n      this._itemSize[this._sizeDim] = Math.round(this._tMeasured / this._nMeasured);\n    }\n  }, {\n    key: \"_getMetrics\",\n    value: function _getMetrics(idx) {\n      return this._metrics[idx] = this._metrics[idx] || {};\n    }\n  }, {\n    key: \"_getPhysicalItem\",\n    value: function _getPhysicalItem(idx) {\n      return this._newPhysicalItems.get(idx) || this._physicalItems.get(idx);\n    }\n  }, {\n    key: \"_getSize\",\n    value: function _getSize(idx) {\n      var item = this._getPhysicalItem(idx);\n\n      return item && item.size;\n    }\n    /**\n     * Returns the position in the scrolling direction of the item at idx.\n     * Estimates it if the item at idx is not in the DOM.\n     */\n\n  }, {\n    key: \"_getPosition\",\n    value: function _getPosition(idx) {\n      var item = this._physicalItems.get(idx);\n\n      return item ? item.pos : idx * this._delta + this._spacing;\n    }\n  }, {\n    key: \"_calculateAnchor\",\n    value: function _calculateAnchor(lower, upper) {\n      if (lower === 0) {\n        return 0;\n      }\n\n      if (upper > this._scrollSize - this._viewDim1) {\n        return this._totalItems - 1;\n      }\n\n      return Math.max(0, Math.min(this._totalItems - 1, Math.floor((lower + upper) / 2 / this._delta)));\n    }\n  }, {\n    key: \"_getAnchor\",\n    value: function _getAnchor(lower, upper) {\n      if (this._physicalItems.size === 0) {\n        return this._calculateAnchor(lower, upper);\n      }\n\n      if (this._first < 0) {\n        console.error('_getAnchor: negative _first');\n        return this._calculateAnchor(lower, upper);\n      }\n\n      if (this._last < 0) {\n        console.error('_getAnchor: negative _last');\n        return this._calculateAnchor(lower, upper);\n      }\n\n      var firstItem = this._getPhysicalItem(this._first),\n          lastItem = this._getPhysicalItem(this._last),\n          firstMin = firstItem.pos,\n          firstMax = firstMin + firstItem.size,\n          lastMin = lastItem.pos,\n          lastMax = lastMin + lastItem.size;\n\n      if (lastMax < lower) {\n        // Window is entirely past physical items, calculate new anchor\n        return this._calculateAnchor(lower, upper);\n      }\n\n      if (firstMin > upper) {\n        // Window is entirely before physical items, calculate new anchor\n        return this._calculateAnchor(lower, upper);\n      }\n\n      if (firstMin >= lower || firstMax >= lower) {\n        // First physical item overlaps window, choose it\n        return this._first;\n      }\n\n      if (lastMax <= upper || lastMin <= upper) {\n        // Last physical overlaps window, choose it\n        return this._last;\n      } // Window contains a physical item, but not the first or last\n\n\n      var maxIdx = this._last,\n          minIdx = this._first;\n\n      while (true) {\n        var candidateIdx = Math.round((maxIdx + minIdx) / 2),\n            candidate = this._physicalItems.get(candidateIdx),\n            cMin = candidate.pos,\n            cMax = cMin + candidate.size;\n\n        if (cMin >= lower && cMin <= upper || cMax >= lower && cMax <= upper) {\n          return candidateIdx;\n        } else if (cMax < lower) {\n          minIdx = candidateIdx + 1;\n        } else if (cMin > upper) {\n          maxIdx = candidateIdx - 1;\n        }\n      }\n    }\n    /**\n     * Updates _first and _last based on items that should be in the current\n     * viewed range.\n     */\n\n  }, {\n    key: \"_getActiveItems\",\n    value: function _getActiveItems() {\n      if (this._viewDim1 === 0 || this._totalItems === 0) {\n        this._clearItems();\n      } else {\n        var upper = Math.min(this._scrollSize, this._scrollPosition + this._viewDim1 + this._overhang),\n            lower = Math.max(0, upper - this._viewDim1 - 2 * this._overhang);\n\n        this._getItems(lower, upper);\n      }\n    }\n    /**\n     * Sets the range to empty.\n     */\n\n  }, {\n    key: \"_clearItems\",\n    value: function _clearItems() {\n      this._first = -1;\n      this._last = -1;\n      this._physicalMin = 0;\n      this._physicalMax = 0;\n      var items = this._newPhysicalItems;\n      this._newPhysicalItems = this._physicalItems;\n\n      this._newPhysicalItems.clear();\n\n      this._physicalItems = items;\n      this._stable = true;\n    }\n    /*\n     * Updates _first and _last based on items that should be in the given range.\n     */\n\n  }, {\n    key: \"_getItems\",\n    value: function _getItems(lower, upper) {\n      var items = this._newPhysicalItems; // The anchorIdx is the anchor around which we reflow. It is designed to\n      // allow jumping to any point of the scroll size. We choose it once and\n      // stick with it until stable. first and last are deduced around it.\n\n      if (this._anchorIdx === null || this._anchorPos === null) {\n        this._anchorIdx = this._getAnchor(lower, upper);\n        this._anchorPos = this._getPosition(this._anchorIdx);\n      }\n\n      var anchorSize = this._getSize(this._anchorIdx);\n\n      if (anchorSize === undefined) {\n        anchorSize = this._itemDim1;\n      } // Anchor might be outside bounds, so prefer correcting the error and keep\n      // that anchorIdx.\n\n\n      var anchorErr = 0;\n\n      if (this._anchorPos + anchorSize + this._spacing < lower) {\n        anchorErr = lower - (this._anchorPos + anchorSize + this._spacing);\n      }\n\n      if (this._anchorPos > upper) {\n        anchorErr = upper - this._anchorPos;\n      }\n\n      if (anchorErr) {\n        this._scrollPosition -= anchorErr;\n        lower -= anchorErr;\n        upper -= anchorErr;\n        this._scrollError += anchorErr;\n      } // TODO @straversi: If size is always itemDim1, then why keep track of it?\n\n\n      items.set(this._anchorIdx, {\n        pos: this._anchorPos,\n        size: anchorSize\n      });\n      this._first = this._last = this._anchorIdx;\n      this._physicalMin = this._physicalMax = this._anchorPos;\n      this._stable = true;\n\n      while (this._physicalMin > lower && this._first > 0) {\n        var size = this._getSize(--this._first);\n\n        if (size === undefined) {\n          this._stable = false;\n          size = this._itemDim1;\n        }\n\n        var pos = this._physicalMin -= size + this._spacing;\n        items.set(this._first, {\n          pos: pos,\n          size: size\n        });\n\n        if (this._stable === false && this._estimate === false) {\n          break;\n        }\n      }\n\n      while (this._physicalMax < upper && this._last < this._totalItems) {\n        var _size = this._getSize(this._last);\n\n        if (_size === undefined) {\n          this._stable = false;\n          _size = this._itemDim1;\n        }\n\n        items.set(this._last++, {\n          pos: this._physicalMax,\n          size: _size\n        });\n\n        if (this._stable === false && this._estimate === false) {\n          break;\n        } else {\n          this._physicalMax += _size + this._spacing;\n        }\n      }\n\n      this._last--; // This handles the cases where we were relying on estimated sizes.\n\n      var extentErr = this._calculateError();\n\n      if (extentErr) {\n        this._physicalMin -= extentErr;\n        this._physicalMax -= extentErr;\n        this._anchorPos -= extentErr;\n        this._scrollPosition -= extentErr;\n        items.forEach(function (item) {\n          return item.pos -= extentErr;\n        });\n        this._scrollError += extentErr;\n      }\n\n      if (this._stable) {\n        this._newPhysicalItems = this._physicalItems;\n\n        this._newPhysicalItems.clear();\n\n        this._physicalItems = items;\n      }\n    }\n  }, {\n    key: \"_calculateError\",\n    value: function _calculateError() {\n      if (this._first === 0) {\n        return this._physicalMin;\n      } else if (this._physicalMin <= 0) {\n        return this._physicalMin - this._first * this._delta;\n      } else if (this._last === this._totalItems - 1) {\n        return this._physicalMax - this._scrollSize;\n      } else if (this._physicalMax >= this._scrollSize) {\n        return this._physicalMax - this._scrollSize + (this._totalItems - 1 - this._last) * this._delta;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"_updateScrollSize\",\n    value: function _updateScrollSize() {\n      // Reuse previously calculated physical max, as it might be higher than the\n      // estimated size.\n      _get(_getPrototypeOf(Layout1d.prototype), \"_updateScrollSize\", this).call(this);\n\n      this._scrollSize = Math.max(this._physicalMax, this._scrollSize);\n    } // TODO: Can this be made to inherit from base, with proper hooks?\n\n  }, {\n    key: \"_reflow\",\n    value: function _reflow() {\n      var _first = this._first,\n          _last = this._last,\n          _scrollSize = this._scrollSize;\n\n      this._updateScrollSize();\n\n      this._getActiveItems();\n\n      this._scrollIfNeeded();\n\n      if (this._scrollSize !== _scrollSize) {\n        this._emitScrollSize();\n      }\n\n      this._updateVisibleIndices();\n\n      this._emitRange();\n\n      if (this._first === -1 && this._last === -1) {\n        this._resetReflowState();\n      } else if (this._first !== _first || this._last !== _last || this._needsRemeasure) {\n        this._emitChildPositions();\n\n        this._emitScrollError();\n      } else {\n        this._emitChildPositions();\n\n        this._emitScrollError();\n\n        this._resetReflowState();\n      }\n    }\n  }, {\n    key: \"_resetReflowState\",\n    value: function _resetReflowState() {\n      this._anchorIdx = null;\n      this._anchorPos = null;\n      this._stable = true;\n    }\n    /**\n     * Returns the top and left positioning of the item at idx.\n     */\n\n  }, {\n    key: \"_getItemPosition\",\n    value: function _getItemPosition(idx) {\n      var _ref;\n\n      return _ref = {}, _defineProperty(_ref, this._positionDim, this._getPosition(idx)), _defineProperty(_ref, this._secondaryPositionDim, 0), _ref;\n    }\n    /**\n     * Returns the height and width of the item at idx.\n     */\n\n  }, {\n    key: \"_getItemSize\",\n    value: function _getItemSize(idx) {\n      var _ref2;\n\n      return _ref2 = {}, _defineProperty(_ref2, this._sizeDim, this._getSize(idx) || this._itemDim1), _defineProperty(_ref2, this._secondarySizeDim, this._itemDim2), _ref2;\n    }\n  }, {\n    key: \"_viewDim2Changed\",\n    value: function _viewDim2Changed() {\n      this._needsRemeasure = true;\n\n      this._scheduleReflow();\n    }\n  }, {\n    key: \"_emitRange\",\n    value: function _emitRange() {\n      var remeasure = this._needsRemeasure;\n      var stable = this._stable;\n      this._needsRemeasure = false;\n\n      _get(_getPrototypeOf(Layout1d.prototype), \"_emitRange\", this).call(this, {\n        remeasure: remeasure,\n        stable: stable\n      });\n    }\n  }]);\n\n  return Layout1d;\n}(_Layout1dBase_js__WEBPACK_IMPORTED_MODULE_0__[\"Layout1dBase\"]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LXZpcnR1YWxpemVyL2xpYi91bmktdmlydHVhbGl6ZXIvbGliL2xheW91dHMvTGF5b3V0MWQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGl0LXZpcnR1YWxpemVyL2xpYi91bmktdmlydHVhbGl6ZXIvbGliL2xheW91dHMvTGF5b3V0MWQuanM/OWUwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMYXlvdXQxZEJhc2UgfSBmcm9tICcuL0xheW91dDFkQmFzZS5qcyc7XG5leHBvcnQgY2xhc3MgTGF5b3V0MWQgZXh0ZW5kcyBMYXlvdXQxZEJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNlcyBvZiBjaGlsZHJlbiBtYXBwZWQgdG8gdGhlaXIgKHBvc2l0aW9uIGFuZCBsZW5ndGgpIGluIHRoZSBzY3JvbGxpbmdcbiAgICAgICAgICogZGlyZWN0aW9uLiBVc2VkIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gdGhhdCBhcmUgaW4gcmFuZ2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9waHlzaWNhbEl0ZW1zID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCBpbiB0YW5kZW0gd2l0aCBfcGh5c2ljYWxJdGVtcyB0byB0cmFjayBjaGlsZHJlbiBpbiByYW5nZSBhY3Jvc3NcbiAgICAgICAgICogcmVmbG93cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX25ld1BoeXNpY2FsSXRlbXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaWR0aCBhbmQgaGVpZ2h0IG9mIGNoaWxkcmVuIGJ5IHRoZWlyIGluZGV4LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbWV0cmljcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFuY2hvcklkeCBpcyB0aGUgYW5jaG9yIGFyb3VuZCB3aGljaCB3ZSByZWZsb3cuIEl0IGlzIGRlc2lnbmVkIHRvIGFsbG93XG4gICAgICAgICAqIGp1bXBpbmcgdG8gYW55IHBvaW50IG9mIHRoZSBzY3JvbGwgc2l6ZS4gV2UgY2hvb3NlIGl0IG9uY2UgYW5kIHN0aWNrIHdpdGhcbiAgICAgICAgICogaXQgdW50aWwgc3RhYmxlLiBfZmlyc3QgYW5kIF9sYXN0IGFyZSBkZWR1Y2VkIGFyb3VuZCBpdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2FuY2hvcklkeCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQb3NpdGlvbiBpbiB0aGUgc2Nyb2xsaW5nIGRpcmVjdGlvbiBvZiB0aGUgYW5jaG9yIGNoaWxkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYW5jaG9yUG9zID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgYWxsIGNoaWxkcmVuIGluIHJhbmdlIHdlcmUgaW4gcmFuZ2UgZHVyaW5nIHRoZSBwcmV2aW91cyByZWZsb3cuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zdGFibGUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0byByZW1lYXN1cmUgY2hpbGRyZW4gZHVyaW5nIHRoZSBuZXh0IHJlZmxvdy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX25lZWRzUmVtZWFzdXJlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOdW1iZXIgb2YgY2hpbGRyZW4gdG8gbGF5IG91dC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX25NZWFzdXJlZCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3RhbCBsZW5ndGggaW4gdGhlIHNjcm9sbGluZyBkaXJlY3Rpb24gb2YgdGhlIGxhaWQgb3V0IGNoaWxkcmVuLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdE1lYXN1cmVkID0gMDtcbiAgICAgICAgdGhpcy5fZXN0aW1hdGUgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIGF2ZXJhZ2Ugc2l6ZSBvZiBhbGwgY2hpbGRyZW4gcmVwcmVzZW50ZWQgaW4gdGhlIHNpemVzXG4gICAgICogYXJndW1lbnQuXG4gICAgICovXG4gICAgdXBkYXRlSXRlbVNpemVzKHNpemVzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHNpemVzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1ldHJpY3MgPSBzaXplc1trZXldLCBtaSA9IHRoaXMuX2dldE1ldHJpY3MoTnVtYmVyKGtleSkpLCBwcmV2U2l6ZSA9IG1pW3RoaXMuX3NpemVEaW1dO1xuICAgICAgICAgICAgLy8gVE9ETyh2YWxkcmluKSBIYW5kbGUgbWFyZ2luIGNvbGxhcHNpbmcuXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ1NTX0JveF9Nb2RlbC9NYXN0ZXJpbmdfbWFyZ2luX2NvbGxhcHNpbmdcbiAgICAgICAgICAgIG1pLndpZHRoID0gbWV0cmljcy53aWR0aCArIChtZXRyaWNzLm1hcmdpbkxlZnQgfHwgMCkgK1xuICAgICAgICAgICAgICAgIChtZXRyaWNzLm1hcmdpblJpZ2h0IHx8IDApO1xuICAgICAgICAgICAgbWkuaGVpZ2h0ID0gbWV0cmljcy5oZWlnaHQgKyAobWV0cmljcy5tYXJnaW5Ub3AgfHwgMCkgK1xuICAgICAgICAgICAgICAgIChtZXRyaWNzLm1hcmdpbkJvdHRvbSB8fCAwKTtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBtaVt0aGlzLl9zaXplRGltXTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9nZXRQaHlzaWNhbEl0ZW0oTnVtYmVyKGtleSkpO1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBsZXQgZGVsdGE7XG4gICAgICAgICAgICAgICAgaWYgKHNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnNpemUgPSBzaXplO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldlNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSBzaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbk1lYXN1cmVkKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IHNpemUgLSBwcmV2U2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl90TWVhc3VyZWQgPSB0aGlzLl90TWVhc3VyZWQgKyBkZWx0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdGhpcy5fbk1lYXN1cmVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYE5vIGl0ZW1zIG1lYXN1cmVkIHlldC5gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUl0ZW1TaXplKCk7XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZVJlZmxvdygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgYXZlcmFnZSBpdGVtIHNpemUgYmFzZWQgb24gdGhlIHRvdGFsIGxlbmd0aCBhbmQgbnVtYmVyIG9mIGNoaWxkcmVuXG4gICAgICogaW4gcmFuZ2UuXG4gICAgICovXG4gICAgX3VwZGF0ZUl0ZW1TaXplKCkge1xuICAgICAgICAvLyBLZWVwIGludGVnZXIgdmFsdWVzLlxuICAgICAgICB0aGlzLl9pdGVtU2l6ZVt0aGlzLl9zaXplRGltXSA9XG4gICAgICAgICAgICBNYXRoLnJvdW5kKHRoaXMuX3RNZWFzdXJlZCAvIHRoaXMuX25NZWFzdXJlZCk7XG4gICAgfVxuICAgIF9nZXRNZXRyaWNzKGlkeCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX21ldHJpY3NbaWR4XSA9IHRoaXMuX21ldHJpY3NbaWR4XSB8fCB7fSk7XG4gICAgfVxuICAgIF9nZXRQaHlzaWNhbEl0ZW0oaWR4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdQaHlzaWNhbEl0ZW1zLmdldChpZHgpIHx8IHRoaXMuX3BoeXNpY2FsSXRlbXMuZ2V0KGlkeCk7XG4gICAgfVxuICAgIF9nZXRTaXplKGlkeCkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5fZ2V0UGh5c2ljYWxJdGVtKGlkeCk7XG4gICAgICAgIHJldHVybiBpdGVtICYmIGl0ZW0uc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9zaXRpb24gaW4gdGhlIHNjcm9sbGluZyBkaXJlY3Rpb24gb2YgdGhlIGl0ZW0gYXQgaWR4LlxuICAgICAqIEVzdGltYXRlcyBpdCBpZiB0aGUgaXRlbSBhdCBpZHggaXMgbm90IGluIHRoZSBET00uXG4gICAgICovXG4gICAgX2dldFBvc2l0aW9uKGlkeCkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5fcGh5c2ljYWxJdGVtcy5nZXQoaWR4KTtcbiAgICAgICAgcmV0dXJuIGl0ZW0gPyBpdGVtLnBvcyA6IChpZHggKiAodGhpcy5fZGVsdGEpKSArIHRoaXMuX3NwYWNpbmc7XG4gICAgfVxuICAgIF9jYWxjdWxhdGVBbmNob3IobG93ZXIsIHVwcGVyKSB7XG4gICAgICAgIGlmIChsb3dlciA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwcGVyID4gdGhpcy5fc2Nyb2xsU2l6ZSAtIHRoaXMuX3ZpZXdEaW0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdG90YWxJdGVtcyAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuX3RvdGFsSXRlbXMgLSAxLCBNYXRoLmZsb29yKCgobG93ZXIgKyB1cHBlcikgLyAyKSAvIHRoaXMuX2RlbHRhKSkpO1xuICAgIH1cbiAgICBfZ2V0QW5jaG9yKGxvd2VyLCB1cHBlcikge1xuICAgICAgICBpZiAodGhpcy5fcGh5c2ljYWxJdGVtcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlQW5jaG9yKGxvd2VyLCB1cHBlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2ZpcnN0IDwgMCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignX2dldEFuY2hvcjogbmVnYXRpdmUgX2ZpcnN0Jyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlQW5jaG9yKGxvd2VyLCB1cHBlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2xhc3QgPCAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdfZ2V0QW5jaG9yOiBuZWdhdGl2ZSBfbGFzdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZUFuY2hvcihsb3dlciwgdXBwZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpcnN0SXRlbSA9IHRoaXMuX2dldFBoeXNpY2FsSXRlbSh0aGlzLl9maXJzdCksIGxhc3RJdGVtID0gdGhpcy5fZ2V0UGh5c2ljYWxJdGVtKHRoaXMuX2xhc3QpLCBmaXJzdE1pbiA9IGZpcnN0SXRlbS5wb3MsIGZpcnN0TWF4ID0gZmlyc3RNaW4gKyBmaXJzdEl0ZW0uc2l6ZSwgbGFzdE1pbiA9IGxhc3RJdGVtLnBvcywgbGFzdE1heCA9IGxhc3RNaW4gKyBsYXN0SXRlbS5zaXplO1xuICAgICAgICBpZiAobGFzdE1heCA8IGxvd2VyKSB7XG4gICAgICAgICAgICAvLyBXaW5kb3cgaXMgZW50aXJlbHkgcGFzdCBwaHlzaWNhbCBpdGVtcywgY2FsY3VsYXRlIG5ldyBhbmNob3JcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVBbmNob3IobG93ZXIsIHVwcGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlyc3RNaW4gPiB1cHBlcikge1xuICAgICAgICAgICAgLy8gV2luZG93IGlzIGVudGlyZWx5IGJlZm9yZSBwaHlzaWNhbCBpdGVtcywgY2FsY3VsYXRlIG5ldyBhbmNob3JcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVBbmNob3IobG93ZXIsIHVwcGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlyc3RNaW4gPj0gbG93ZXIgfHwgZmlyc3RNYXggPj0gbG93ZXIpIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IHBoeXNpY2FsIGl0ZW0gb3ZlcmxhcHMgd2luZG93LCBjaG9vc2UgaXRcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9maXJzdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdE1heCA8PSB1cHBlciB8fCBsYXN0TWluIDw9IHVwcGVyKSB7XG4gICAgICAgICAgICAvLyBMYXN0IHBoeXNpY2FsIG92ZXJsYXBzIHdpbmRvdywgY2hvb3NlIGl0XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGFzdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaW5kb3cgY29udGFpbnMgYSBwaHlzaWNhbCBpdGVtLCBidXQgbm90IHRoZSBmaXJzdCBvciBsYXN0XG4gICAgICAgIGxldCBtYXhJZHggPSB0aGlzLl9sYXN0LCBtaW5JZHggPSB0aGlzLl9maXJzdDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZUlkeCA9IE1hdGgucm91bmQoKG1heElkeCArIG1pbklkeCkgLyAyKSwgY2FuZGlkYXRlID0gdGhpcy5fcGh5c2ljYWxJdGVtcy5nZXQoY2FuZGlkYXRlSWR4KSwgY01pbiA9IGNhbmRpZGF0ZS5wb3MsIGNNYXggPSBjTWluICsgY2FuZGlkYXRlLnNpemU7XG4gICAgICAgICAgICBpZiAoKGNNaW4gPj0gbG93ZXIgJiYgY01pbiA8PSB1cHBlcikgfHxcbiAgICAgICAgICAgICAgICAoY01heCA+PSBsb3dlciAmJiBjTWF4IDw9IHVwcGVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGVJZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjTWF4IDwgbG93ZXIpIHtcbiAgICAgICAgICAgICAgICBtaW5JZHggPSBjYW5kaWRhdGVJZHggKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY01pbiA+IHVwcGVyKSB7XG4gICAgICAgICAgICAgICAgbWF4SWR4ID0gY2FuZGlkYXRlSWR4IC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIF9maXJzdCBhbmQgX2xhc3QgYmFzZWQgb24gaXRlbXMgdGhhdCBzaG91bGQgYmUgaW4gdGhlIGN1cnJlbnRcbiAgICAgKiB2aWV3ZWQgcmFuZ2UuXG4gICAgICovXG4gICAgX2dldEFjdGl2ZUl0ZW1zKCkge1xuICAgICAgICBpZiAodGhpcy5fdmlld0RpbTEgPT09IDAgfHwgdGhpcy5fdG90YWxJdGVtcyA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJJdGVtcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdXBwZXIgPSBNYXRoLm1pbih0aGlzLl9zY3JvbGxTaXplLCB0aGlzLl9zY3JvbGxQb3NpdGlvbiArIHRoaXMuX3ZpZXdEaW0xICsgdGhpcy5fb3ZlcmhhbmcpLCBsb3dlciA9IE1hdGgubWF4KDAsIHVwcGVyIC0gdGhpcy5fdmlld0RpbTEgLSAoMiAqIHRoaXMuX292ZXJoYW5nKSk7XG4gICAgICAgICAgICB0aGlzLl9nZXRJdGVtcyhsb3dlciwgdXBwZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHJhbmdlIHRvIGVtcHR5LlxuICAgICAqL1xuICAgIF9jbGVhckl0ZW1zKCkge1xuICAgICAgICB0aGlzLl9maXJzdCA9IC0xO1xuICAgICAgICB0aGlzLl9sYXN0ID0gLTE7XG4gICAgICAgIHRoaXMuX3BoeXNpY2FsTWluID0gMDtcbiAgICAgICAgdGhpcy5fcGh5c2ljYWxNYXggPSAwO1xuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuX25ld1BoeXNpY2FsSXRlbXM7XG4gICAgICAgIHRoaXMuX25ld1BoeXNpY2FsSXRlbXMgPSB0aGlzLl9waHlzaWNhbEl0ZW1zO1xuICAgICAgICB0aGlzLl9uZXdQaHlzaWNhbEl0ZW1zLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX3BoeXNpY2FsSXRlbXMgPSBpdGVtcztcbiAgICAgICAgdGhpcy5fc3RhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgLypcbiAgICAgKiBVcGRhdGVzIF9maXJzdCBhbmQgX2xhc3QgYmFzZWQgb24gaXRlbXMgdGhhdCBzaG91bGQgYmUgaW4gdGhlIGdpdmVuIHJhbmdlLlxuICAgICAqL1xuICAgIF9nZXRJdGVtcyhsb3dlciwgdXBwZXIpIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLl9uZXdQaHlzaWNhbEl0ZW1zO1xuICAgICAgICAvLyBUaGUgYW5jaG9ySWR4IGlzIHRoZSBhbmNob3IgYXJvdW5kIHdoaWNoIHdlIHJlZmxvdy4gSXQgaXMgZGVzaWduZWQgdG9cbiAgICAgICAgLy8gYWxsb3cganVtcGluZyB0byBhbnkgcG9pbnQgb2YgdGhlIHNjcm9sbCBzaXplLiBXZSBjaG9vc2UgaXQgb25jZSBhbmRcbiAgICAgICAgLy8gc3RpY2sgd2l0aCBpdCB1bnRpbCBzdGFibGUuIGZpcnN0IGFuZCBsYXN0IGFyZSBkZWR1Y2VkIGFyb3VuZCBpdC5cbiAgICAgICAgaWYgKHRoaXMuX2FuY2hvcklkeCA9PT0gbnVsbCB8fCB0aGlzLl9hbmNob3JQb3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2FuY2hvcklkeCA9IHRoaXMuX2dldEFuY2hvcihsb3dlciwgdXBwZXIpO1xuICAgICAgICAgICAgdGhpcy5fYW5jaG9yUG9zID0gdGhpcy5fZ2V0UG9zaXRpb24odGhpcy5fYW5jaG9ySWR4KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYW5jaG9yU2l6ZSA9IHRoaXMuX2dldFNpemUodGhpcy5fYW5jaG9ySWR4KTtcbiAgICAgICAgaWYgKGFuY2hvclNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYW5jaG9yU2l6ZSA9IHRoaXMuX2l0ZW1EaW0xO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFuY2hvciBtaWdodCBiZSBvdXRzaWRlIGJvdW5kcywgc28gcHJlZmVyIGNvcnJlY3RpbmcgdGhlIGVycm9yIGFuZCBrZWVwXG4gICAgICAgIC8vIHRoYXQgYW5jaG9ySWR4LlxuICAgICAgICBsZXQgYW5jaG9yRXJyID0gMDtcbiAgICAgICAgaWYgKHRoaXMuX2FuY2hvclBvcyArIGFuY2hvclNpemUgKyB0aGlzLl9zcGFjaW5nIDwgbG93ZXIpIHtcbiAgICAgICAgICAgIGFuY2hvckVyciA9IGxvd2VyIC0gKHRoaXMuX2FuY2hvclBvcyArIGFuY2hvclNpemUgKyB0aGlzLl9zcGFjaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYW5jaG9yUG9zID4gdXBwZXIpIHtcbiAgICAgICAgICAgIGFuY2hvckVyciA9IHVwcGVyIC0gdGhpcy5fYW5jaG9yUG9zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbmNob3JFcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFBvc2l0aW9uIC09IGFuY2hvckVycjtcbiAgICAgICAgICAgIGxvd2VyIC09IGFuY2hvckVycjtcbiAgICAgICAgICAgIHVwcGVyIC09IGFuY2hvckVycjtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEVycm9yICs9IGFuY2hvckVycjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIEBzdHJhdmVyc2k6IElmIHNpemUgaXMgYWx3YXlzIGl0ZW1EaW0xLCB0aGVuIHdoeSBrZWVwIHRyYWNrIG9mIGl0P1xuICAgICAgICBpdGVtcy5zZXQodGhpcy5fYW5jaG9ySWR4LCB7IHBvczogdGhpcy5fYW5jaG9yUG9zLCBzaXplOiBhbmNob3JTaXplIH0pO1xuICAgICAgICB0aGlzLl9maXJzdCA9ICh0aGlzLl9sYXN0ID0gdGhpcy5fYW5jaG9ySWR4KTtcbiAgICAgICAgdGhpcy5fcGh5c2ljYWxNaW4gPSAodGhpcy5fcGh5c2ljYWxNYXggPSB0aGlzLl9hbmNob3JQb3MpO1xuICAgICAgICB0aGlzLl9zdGFibGUgPSB0cnVlO1xuICAgICAgICB3aGlsZSAodGhpcy5fcGh5c2ljYWxNaW4gPiBsb3dlciAmJiB0aGlzLl9maXJzdCA+IDApIHtcbiAgICAgICAgICAgIGxldCBzaXplID0gdGhpcy5fZ2V0U2l6ZSgtLXRoaXMuX2ZpcnN0KTtcbiAgICAgICAgICAgIGlmIChzaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzaXplID0gdGhpcy5faXRlbURpbTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwb3MgPSAodGhpcy5fcGh5c2ljYWxNaW4gLT0gc2l6ZSArIHRoaXMuX3NwYWNpbmcpO1xuICAgICAgICAgICAgaXRlbXMuc2V0KHRoaXMuX2ZpcnN0LCB7IHBvcywgc2l6ZSB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGFibGUgPT09IGZhbHNlICYmIHRoaXMuX2VzdGltYXRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLl9waHlzaWNhbE1heCA8IHVwcGVyICYmIHRoaXMuX2xhc3QgPCB0aGlzLl90b3RhbEl0ZW1zKSB7XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHRoaXMuX2dldFNpemUodGhpcy5fbGFzdCk7XG4gICAgICAgICAgICBpZiAoc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IHRoaXMuX2l0ZW1EaW0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbXMuc2V0KHRoaXMuX2xhc3QrKywgeyBwb3M6IHRoaXMuX3BoeXNpY2FsTWF4LCBzaXplIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YWJsZSA9PT0gZmFsc2UgJiYgdGhpcy5fZXN0aW1hdGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9waHlzaWNhbE1heCArPSBzaXplICsgdGhpcy5fc3BhY2luZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0LS07XG4gICAgICAgIC8vIFRoaXMgaGFuZGxlcyB0aGUgY2FzZXMgd2hlcmUgd2Ugd2VyZSByZWx5aW5nIG9uIGVzdGltYXRlZCBzaXplcy5cbiAgICAgICAgY29uc3QgZXh0ZW50RXJyID0gdGhpcy5fY2FsY3VsYXRlRXJyb3IoKTtcbiAgICAgICAgaWYgKGV4dGVudEVycikge1xuICAgICAgICAgICAgdGhpcy5fcGh5c2ljYWxNaW4gLT0gZXh0ZW50RXJyO1xuICAgICAgICAgICAgdGhpcy5fcGh5c2ljYWxNYXggLT0gZXh0ZW50RXJyO1xuICAgICAgICAgICAgdGhpcy5fYW5jaG9yUG9zIC09IGV4dGVudEVycjtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFBvc2l0aW9uIC09IGV4dGVudEVycjtcbiAgICAgICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IGl0ZW0ucG9zIC09IGV4dGVudEVycik7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxFcnJvciArPSBleHRlbnRFcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3N0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fbmV3UGh5c2ljYWxJdGVtcyA9IHRoaXMuX3BoeXNpY2FsSXRlbXM7XG4gICAgICAgICAgICB0aGlzLl9uZXdQaHlzaWNhbEl0ZW1zLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLl9waHlzaWNhbEl0ZW1zID0gaXRlbXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NhbGN1bGF0ZUVycm9yKCkge1xuICAgICAgICBpZiAodGhpcy5fZmlyc3QgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9waHlzaWNhbE1pbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9waHlzaWNhbE1pbiA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGh5c2ljYWxNaW4gLSAodGhpcy5fZmlyc3QgKiB0aGlzLl9kZWx0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fbGFzdCA9PT0gdGhpcy5fdG90YWxJdGVtcyAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9waHlzaWNhbE1heCAtIHRoaXMuX3Njcm9sbFNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fcGh5c2ljYWxNYXggPj0gdGhpcy5fc2Nyb2xsU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuICgodGhpcy5fcGh5c2ljYWxNYXggLSB0aGlzLl9zY3JvbGxTaXplKSArXG4gICAgICAgICAgICAgICAgKCh0aGlzLl90b3RhbEl0ZW1zIC0gMSAtIHRoaXMuX2xhc3QpICogdGhpcy5fZGVsdGEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgX3VwZGF0ZVNjcm9sbFNpemUoKSB7XG4gICAgICAgIC8vIFJldXNlIHByZXZpb3VzbHkgY2FsY3VsYXRlZCBwaHlzaWNhbCBtYXgsIGFzIGl0IG1pZ2h0IGJlIGhpZ2hlciB0aGFuIHRoZVxuICAgICAgICAvLyBlc3RpbWF0ZWQgc2l6ZS5cbiAgICAgICAgc3VwZXIuX3VwZGF0ZVNjcm9sbFNpemUoKTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsU2l6ZSA9IE1hdGgubWF4KHRoaXMuX3BoeXNpY2FsTWF4LCB0aGlzLl9zY3JvbGxTaXplKTtcbiAgICB9XG4gICAgLy8gVE9ETzogQ2FuIHRoaXMgYmUgbWFkZSB0byBpbmhlcml0IGZyb20gYmFzZSwgd2l0aCBwcm9wZXIgaG9va3M/XG4gICAgX3JlZmxvdygpIHtcbiAgICAgICAgY29uc3QgeyBfZmlyc3QsIF9sYXN0LCBfc2Nyb2xsU2l6ZSB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5fdXBkYXRlU2Nyb2xsU2l6ZSgpO1xuICAgICAgICB0aGlzLl9nZXRBY3RpdmVJdGVtcygpO1xuICAgICAgICB0aGlzLl9zY3JvbGxJZk5lZWRlZCgpO1xuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsU2l6ZSAhPT0gX3Njcm9sbFNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXRTY3JvbGxTaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlVmlzaWJsZUluZGljZXMoKTtcbiAgICAgICAgdGhpcy5fZW1pdFJhbmdlKCk7XG4gICAgICAgIGlmICh0aGlzLl9maXJzdCA9PT0gLTEgJiYgdGhpcy5fbGFzdCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0UmVmbG93U3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9maXJzdCAhPT0gX2ZpcnN0IHx8IHRoaXMuX2xhc3QgIT09IF9sYXN0IHx8XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlbWVhc3VyZSkge1xuICAgICAgICAgICAgdGhpcy5fZW1pdENoaWxkUG9zaXRpb25zKCk7XG4gICAgICAgICAgICB0aGlzLl9lbWl0U2Nyb2xsRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXRDaGlsZFBvc2l0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5fZW1pdFNjcm9sbEVycm9yKCk7XG4gICAgICAgICAgICB0aGlzLl9yZXNldFJlZmxvd1N0YXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3Jlc2V0UmVmbG93U3RhdGUoKSB7XG4gICAgICAgIHRoaXMuX2FuY2hvcklkeCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2FuY2hvclBvcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3N0YWJsZSA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRvcCBhbmQgbGVmdCBwb3NpdGlvbmluZyBvZiB0aGUgaXRlbSBhdCBpZHguXG4gICAgICovXG4gICAgX2dldEl0ZW1Qb3NpdGlvbihpZHgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFt0aGlzLl9wb3NpdGlvbkRpbV06IHRoaXMuX2dldFBvc2l0aW9uKGlkeCksXG4gICAgICAgICAgICBbdGhpcy5fc2Vjb25kYXJ5UG9zaXRpb25EaW1dOiAwLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgYW5kIHdpZHRoIG9mIHRoZSBpdGVtIGF0IGlkeC5cbiAgICAgKi9cbiAgICBfZ2V0SXRlbVNpemUoaWR4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbdGhpcy5fc2l6ZURpbV06IHRoaXMuX2dldFNpemUoaWR4KSB8fCB0aGlzLl9pdGVtRGltMSxcbiAgICAgICAgICAgIFt0aGlzLl9zZWNvbmRhcnlTaXplRGltXTogdGhpcy5faXRlbURpbTIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIF92aWV3RGltMkNoYW5nZWQoKSB7XG4gICAgICAgIHRoaXMuX25lZWRzUmVtZWFzdXJlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGVSZWZsb3coKTtcbiAgICB9XG4gICAgX2VtaXRSYW5nZSgpIHtcbiAgICAgICAgY29uc3QgcmVtZWFzdXJlID0gdGhpcy5fbmVlZHNSZW1lYXN1cmU7XG4gICAgICAgIGNvbnN0IHN0YWJsZSA9IHRoaXMuX3N0YWJsZTtcbiAgICAgICAgdGhpcy5fbmVlZHNSZW1lYXN1cmUgPSBmYWxzZTtcbiAgICAgICAgc3VwZXIuX2VtaXRSYW5nZSh7IHJlbWVhc3VyZSwgc3RhYmxlIH0pO1xuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBOzs7OztBQUlBO0FBQ0E7Ozs7O0FBSUE7QUFDQTs7OztBQUdBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7Ozs7QUFHQTtBQUNBOzs7O0FBR0E7QUFDQTs7OztBQUdBO0FBQ0E7Ozs7QUFHQTtBQUNBOzs7O0FBR0E7QUFDQTtBQTFDQTtBQTJDQTtBQUNBOzs7Ozs7QUE3Q0E7QUFBQTtBQUFBO0FBaURBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFuRkE7QUFBQTtBQUFBO0FBd0ZBO0FBQ0E7QUFFQTtBQTNGQTtBQUFBO0FBQUE7QUE2RkE7QUFDQTtBQTlGQTtBQUFBO0FBQUE7QUFnR0E7QUFDQTtBQWpHQTtBQUFBO0FBQUE7QUFtR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7QUF0R0E7QUFBQTtBQUFBO0FBMkdBO0FBQ0E7QUFBQTtBQUNBO0FBN0dBO0FBQUE7QUFBQTtBQStHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQXRIQTtBQUFBO0FBQUE7QUF3SEE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBcEtBO0FBQUE7QUFBQTtBQXlLQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7OztBQWpMQTtBQUFBO0FBQUE7QUFxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUEvTEE7QUFBQTtBQUFBO0FBbU1BO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQTdRQTtBQUFBO0FBQUE7QUErUUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBN1JBO0FBQUE7QUFBQTtBQStSQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQXBTQTtBQUFBO0FBQUE7QUFxU0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQTVUQTtBQUFBO0FBQUE7QUE4VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQWxVQTtBQUFBO0FBQUE7QUFxVUE7QUFDQTtBQUFBO0FBSUE7QUFDQTs7OztBQTNVQTtBQUFBO0FBQUE7QUE4VUE7QUFDQTtBQUFBO0FBSUE7QUFuVkE7QUFBQTtBQUFBO0FBcVZBO0FBQ0E7QUFBQTtBQUNBO0FBdlZBO0FBQUE7QUFBQTtBQXlWQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUE3VkE7QUFDQTtBQURBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/layouts/Layout1d.js\n");

/***/ }),

/***/ "./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/layouts/Layout1dBase.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/layouts/Layout1dBase.js ***!
  \**************************************************************************************/
/*! exports provided: Layout1dBase */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Layout1dBase\", function() { return Layout1dBase; });\n/* harmony import */ var _polyfillLoaders_EventTarget_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../polyfillLoaders/EventTarget.js */ \"./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/polyfillLoaders/EventTarget.js\");\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\nvar Layout1dBase = /*#__PURE__*/function () {\n  function Layout1dBase(config) {\n    var _this = this;\n\n    _classCallCheck(this, Layout1dBase);\n\n    /**\n     * The last set viewport scroll position.\n     */\n    this._latestCoords = {\n      left: 0,\n      top: 0\n    };\n    /**\n     * Scrolling direction.\n     */\n\n    this._direction = 'vertical';\n    /**\n     * Dimensions of the viewport.\n     */\n\n    this._viewportSize = {\n      width: 0,\n      height: 0\n    };\n    /**\n     * Flag for debouncing asynchnronous reflow requests.\n     */\n\n    this._pendingReflow = false;\n    /**\n     * Index of the item that has been scrolled to via the public API. When the\n     * container is otherwise scrolled, this value is set back to -1.\n     */\n\n    this._scrollToIndex = -1;\n    /**\n     * When a child is scrolled to, the offset from the top of the child and the\n     * top of the viewport. Value is a proportion of the item size.\n     */\n\n    this._scrollToAnchor = 0;\n    this._eventTargetPromise = Object(_polyfillLoaders_EventTarget_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])().then(function (Ctor) {\n      return _this._eventTarget = new Ctor();\n    });\n    /**\n     * Pixel offset in the scroll direction of the first child.\n     */\n\n    this._physicalMin = 0;\n    /**\n     * Pixel offset in the scroll direction of the last child.\n     */\n\n    this._physicalMax = 0;\n    /**\n     * Index of the first child.\n     */\n\n    this._first = -1;\n    /**\n     * Index of the last child.\n     */\n\n    this._last = -1;\n    /**\n     * The _estimated_ size of a child.\n     */\n\n    this._itemSize = {\n      width: 100,\n      height: 100\n    };\n    /**\n     * Space in pixels between children.\n     */\n\n    this._spacing = 0;\n    /**\n     * Length in the scrolling direction.\n     */\n\n    this._sizeDim = 'height';\n    /**\n     * Length in the non-scrolling direction.\n     */\n\n    this._secondarySizeDim = 'width';\n    /**\n     * Position in the scrolling direction.\n     */\n\n    this._positionDim = 'top';\n    /**\n     * Position in the non-scrolling direction.\n     */\n\n    this._secondaryPositionDim = 'left';\n    /**\n     * Current scroll offset in pixels.\n     */\n\n    this._scrollPosition = 0;\n    /**\n     * Difference between current scroll offset and scroll offset calculated due\n     * to a reflow.\n     */\n\n    this._scrollError = 0;\n    /**\n     * Total number of items that could possibly be displayed. Used to help\n     * calculate the scroll size.\n     */\n\n    this._totalItems = 0;\n    /**\n     * The total (estimated) length of all items in the scrolling direction.\n     */\n\n    this._scrollSize = 1;\n    /**\n     * Number of pixels beyond the visible size of the container to still include\n     * in the active range of items.\n     */\n\n    this._overhang = 150;\n    Object.assign(this, config);\n  }\n  /**\n   * Maximum index of children + 1, to help estimate total height of the scroll\n   * space.\n   */\n\n\n  _createClass(Layout1dBase, [{\n    key: \"reflowIfNeeded\",\n\n    /**\n     * Perform a reflow if one has been scheduled.\n     */\n    value: function reflowIfNeeded() {\n      if (this._pendingReflow) {\n        this._pendingReflow = false;\n\n        this._reflow();\n      }\n    }\n    /**\n     * Scroll to the child at the given index, and the given position within that\n     * child.\n     */\n\n  }, {\n    key: \"scrollToIndex\",\n    value: function scrollToIndex(index) {\n      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'start';\n      if (!Number.isFinite(index)) return;\n      index = Math.min(this.totalItems, Math.max(0, index));\n      this._scrollToIndex = index;\n\n      if (position === 'nearest') {\n        position = index > this._first + this._num / 2 ? 'end' : 'start';\n      }\n\n      switch (position) {\n        case 'start':\n          this._scrollToAnchor = 0;\n          break;\n\n        case 'center':\n          this._scrollToAnchor = 0.5;\n          break;\n\n        case 'end':\n          this._scrollToAnchor = 1;\n          break;\n\n        default:\n          throw new TypeError('position must be one of: start, center, end, nearest');\n      }\n\n      this._scheduleReflow();\n\n      this.reflowIfNeeded();\n    }\n  }, {\n    key: \"dispatchEvent\",\n    value: function () {\n      var _dispatchEvent = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        var _this$_eventTarget;\n\n        var _args = arguments;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._eventTargetPromise;\n\n              case 2:\n                (_this$_eventTarget = this._eventTarget).dispatchEvent.apply(_this$_eventTarget, _args);\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function dispatchEvent() {\n        return _dispatchEvent.apply(this, arguments);\n      }\n\n      return dispatchEvent;\n    }()\n  }, {\n    key: \"addEventListener\",\n    value: function () {\n      var _addEventListener = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n        var _this$_eventTarget2;\n\n        var _args2 = arguments;\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this._eventTargetPromise;\n\n              case 2:\n                (_this$_eventTarget2 = this._eventTarget).addEventListener.apply(_this$_eventTarget2, _args2);\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function addEventListener() {\n        return _addEventListener.apply(this, arguments);\n      }\n\n      return addEventListener;\n    }()\n  }, {\n    key: \"removeEventListener\",\n    value: function () {\n      var _removeEventListener = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {\n        var _this$_eventTarget3;\n\n        var _args3 = arguments;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this._eventTargetPromise;\n\n              case 2:\n                (_this$_eventTarget3 = this._eventTarget).removeEventListener.apply(_this$_eventTarget3, _args3);\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function removeEventListener() {\n        return _removeEventListener.apply(this, arguments);\n      }\n\n      return removeEventListener;\n    }()\n  }, {\n    key: \"updateItemSizes\",\n    value: function updateItemSizes(_sizes) {// Override\n    }\n  }, {\n    key: \"_itemDim2Changed\",\n    value: function _itemDim2Changed() {// Override\n    }\n  }, {\n    key: \"_viewDim2Changed\",\n    value: function _viewDim2Changed() {// Override\n    }\n  }, {\n    key: \"_getItemSize\",\n    value: function _getItemSize(_idx) {\n      var _ref;\n\n      return _ref = {}, _defineProperty(_ref, this._sizeDim, this._itemDim1), _defineProperty(_ref, this._secondarySizeDim, this._itemDim2), _ref;\n    }\n    /**\n     * The size of an item in the scrolling direction + space between items.\n     */\n\n  }, {\n    key: \"_scheduleReflow\",\n    value: function _scheduleReflow() {\n      this._pendingReflow = true;\n    }\n  }, {\n    key: \"_reflow\",\n    value: function _reflow() {\n      var _first = this._first,\n          _last = this._last,\n          _scrollSize = this._scrollSize;\n\n      this._updateScrollSize();\n\n      this._getActiveItems();\n\n      this._scrollIfNeeded();\n\n      if (this._scrollSize !== _scrollSize) {\n        this._emitScrollSize();\n      }\n\n      if (this._first === -1 && this._last === -1) {\n        // TODO: have default empty object for emitRange instead\n        this._emitRange();\n      } else if (this._first !== _first || this._last !== _last || this._spacingChanged) {\n        // TODO: have default empty object for emitRange instead\n        this._emitRange();\n\n        this._emitChildPositions();\n      }\n\n      this._emitScrollError();\n    }\n    /**\n     * Estimates the total length of all items in the scrolling direction, including spacing.\n     */\n\n  }, {\n    key: \"_updateScrollSize\",\n    value: function _updateScrollSize() {\n      // Ensure we have at least 1px - this allows getting at least 1 item to be\n      // rendered.\n      this._scrollSize = Math.max(1, this._totalItems * this._delta);\n    }\n  }, {\n    key: \"_scrollIfNeeded\",\n    value: function _scrollIfNeeded() {\n      if (this._scrollToIndex === -1) {\n        return;\n      }\n\n      var index = this._scrollToIndex;\n      var anchor = this._scrollToAnchor;\n\n      var pos = this._getItemPosition(index)[this._positionDim];\n\n      var size = this._getItemSize(index)[this._sizeDim];\n\n      var curAnchorPos = this._scrollPosition + this._viewDim1 * anchor;\n      var newAnchorPos = pos + size * anchor; // Ensure scroll position is an integer within scroll bounds.\n\n      var scrollPosition = Math.floor(Math.min(this._scrollSize - this._viewDim1, Math.max(0, this._scrollPosition - curAnchorPos + newAnchorPos)));\n      this._scrollError += this._scrollPosition - scrollPosition;\n      this._scrollPosition = scrollPosition;\n    }\n  }, {\n    key: \"_emitRange\",\n    value: function _emitRange() {\n      var inProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      var detail = Object.assign({\n        first: this._first,\n        last: this._last,\n        num: this._num,\n        stable: true,\n        firstVisible: this._firstVisible,\n        lastVisible: this._lastVisible\n      }, inProps);\n      this.dispatchEvent(new CustomEvent('rangechange', {\n        detail: detail\n      }));\n    }\n  }, {\n    key: \"_emitScrollSize\",\n    value: function _emitScrollSize() {\n      var detail = _defineProperty({}, this._sizeDim, this._scrollSize);\n\n      this.dispatchEvent(new CustomEvent('scrollsizechange', {\n        detail: detail\n      }));\n    }\n  }, {\n    key: \"_emitScrollError\",\n    value: function _emitScrollError() {\n      if (this._scrollError) {\n        var _detail2;\n\n        var detail = (_detail2 = {}, _defineProperty(_detail2, this._positionDim, this._scrollError), _defineProperty(_detail2, this._secondaryPositionDim, 0), _detail2);\n        this.dispatchEvent(new CustomEvent('scrollerrorchange', {\n          detail: detail\n        }));\n        this._scrollError = 0;\n      }\n    }\n    /**\n     * Get or estimate the top and left positions of items in the current range.\n     * Emit an itempositionchange event with these positions.\n     */\n\n  }, {\n    key: \"_emitChildPositions\",\n    value: function _emitChildPositions() {\n      var detail = {};\n\n      for (var idx = this._first; idx <= this._last; idx++) {\n        detail[idx] = this._getItemPosition(idx);\n      }\n\n      this.dispatchEvent(new CustomEvent('itempositionchange', {\n        detail: detail\n      }));\n    }\n    /**\n     * Number of items to display.\n     */\n\n  }, {\n    key: \"_checkThresholds\",\n    value: function _checkThresholds() {\n      if (this._viewDim1 === 0 && this._num > 0) {\n        this._scheduleReflow();\n      } else {\n        var min = Math.max(0, this._scrollPosition - this._overhang);\n        var max = Math.min(this._scrollSize, this._scrollPosition + this._viewDim1 + this._overhang);\n\n        if (this._physicalMin > min || this._physicalMax < max) {\n          this._scheduleReflow();\n        }\n      }\n    }\n    /**\n     * Find the indices of the first and last items to intersect the viewport.\n     * Emit a visibleindiceschange event when either index changes.\n     */\n\n  }, {\n    key: \"_updateVisibleIndices\",\n    value: function _updateVisibleIndices() {\n      var firstVisible = this._firstVisible;\n      var lastVisible = this._lastVisible;\n\n      for (var i = this._first; i <= this._last; i++) {\n        var itemY = this._getItemPosition(i)[this._positionDim];\n\n        if (itemY <= this._scrollPosition) {\n          firstVisible = i;\n        }\n\n        if (itemY < this._scrollPosition + this._viewDim1) {\n          lastVisible = i;\n        }\n      } // If scrolling is occurring very quickly, item positions may change\n      // during this calculation. Ignore the results when that happens.\n\n\n      if (firstVisible > lastVisible) {\n        return;\n      }\n\n      if (firstVisible !== this._firstVisible || lastVisible !== this._lastVisible) {\n        this._firstVisible = firstVisible;\n        this._lastVisible = lastVisible;\n\n        this._emitRange();\n      }\n    }\n  }, {\n    key: \"_scrollPositionChanged\",\n    value: function _scrollPositionChanged(oldPos, newPos) {\n      // When both values are bigger than the max scroll position, keep the\n      // current _scrollToIndex, otherwise invalidate it.\n      var maxPos = this._scrollSize - this._viewDim1;\n\n      if (oldPos < maxPos || newPos < maxPos) {\n        this._scrollToIndex = -1;\n      }\n    }\n  }, {\n    key: \"totalItems\",\n    get: function get() {\n      return this._totalItems;\n    },\n    set: function set(num) {\n      if (num !== this._totalItems) {\n        this._totalItems = num;\n\n        this._scheduleReflow();\n      }\n    }\n    /**\n     * Primary scrolling direction.\n     */\n\n  }, {\n    key: \"direction\",\n    get: function get() {\n      return this._direction;\n    },\n    set: function set(dir) {\n      // Force it to be either horizontal or vertical.\n      dir = dir === 'horizontal' ? dir : 'vertical';\n\n      if (dir !== this._direction) {\n        this._direction = dir;\n        this._sizeDim = dir === 'horizontal' ? 'width' : 'height';\n        this._secondarySizeDim = dir === 'horizontal' ? 'height' : 'width';\n        this._positionDim = dir === 'horizontal' ? 'left' : 'top';\n        this._secondaryPositionDim = dir === 'horizontal' ? 'top' : 'left';\n\n        this._scheduleReflow();\n      }\n    }\n    /**\n     * Estimate of the dimensions of a single child.\n     */\n\n  }, {\n    key: \"itemSize\",\n    get: function get() {\n      return this._itemSize;\n    },\n    set: function set(dims) {\n      var _itemDim1 = this._itemDim1,\n          _itemDim2 = this._itemDim2;\n      Object.assign(this._itemSize, dims);\n\n      if (_itemDim1 !== this._itemDim1 || _itemDim2 !== this._itemDim2) {\n        if (_itemDim2 !== this._itemDim2) {\n          this._itemDim2Changed();\n        } else {\n          this._scheduleReflow();\n        }\n      }\n    }\n    /**\n     * Amount of space in between items.\n     */\n\n  }, {\n    key: \"spacing\",\n    get: function get() {\n      return this._spacing;\n    },\n    set: function set(px) {\n      if (px !== this._spacing) {\n        this._spacing = px;\n\n        this._scheduleReflow();\n      }\n    }\n    /**\n     * Height and width of the viewport.\n     */\n\n  }, {\n    key: \"viewportSize\",\n    get: function get() {\n      return this._viewportSize;\n    },\n    set: function set(dims) {\n      var _viewDim1 = this._viewDim1,\n          _viewDim2 = this._viewDim2;\n      Object.assign(this._viewportSize, dims);\n\n      if (_viewDim2 !== this._viewDim2) {\n        this._viewDim2Changed();\n      } else if (_viewDim1 !== this._viewDim1) {\n        this._checkThresholds();\n      }\n    }\n    /**\n     * Scroll offset of the viewport.\n     */\n\n  }, {\n    key: \"viewportScroll\",\n    get: function get() {\n      return this._latestCoords;\n    },\n    set: function set(coords) {\n      Object.assign(this._latestCoords, coords);\n      var oldPos = this._scrollPosition;\n      this._scrollPosition = this._latestCoords[this._positionDim];\n\n      if (oldPos !== this._scrollPosition) {\n        this._scrollPositionChanged(oldPos, this._scrollPosition);\n\n        this._updateVisibleIndices();\n      }\n\n      this._checkThresholds();\n    }\n  }, {\n    key: \"_delta\",\n    get: function get() {\n      return this._itemDim1 + this._spacing;\n    }\n    /**\n     * The height or width of an item, whichever corresponds to the scrolling direction.\n     */\n\n  }, {\n    key: \"_itemDim1\",\n    get: function get() {\n      return this._itemSize[this._sizeDim];\n    }\n    /**\n     * The height or width of an item, whichever does NOT correspond to the scrolling direction.\n     */\n\n  }, {\n    key: \"_itemDim2\",\n    get: function get() {\n      return this._itemSize[this._secondarySizeDim];\n    }\n    /**\n     * The height or width of the viewport, whichever corresponds to the scrolling direction.\n     */\n\n  }, {\n    key: \"_viewDim1\",\n    get: function get() {\n      return this._viewportSize[this._sizeDim];\n    }\n    /**\n     * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n     */\n\n  }, {\n    key: \"_viewDim2\",\n    get: function get() {\n      return this._viewportSize[this._secondarySizeDim];\n    }\n  }, {\n    key: \"_num\",\n    get: function get() {\n      if (this._first === -1 || this._last === -1) {\n        return 0;\n      }\n\n      return this._last - this._first + 1;\n    }\n  }]);\n\n  return Layout1dBase;\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LXZpcnR1YWxpemVyL2xpYi91bmktdmlydHVhbGl6ZXIvbGliL2xheW91dHMvTGF5b3V0MWRCYXNlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC12aXJ0dWFsaXplci9saWIvdW5pLXZpcnR1YWxpemVyL2xpYi9sYXlvdXRzL0xheW91dDFkQmFzZS5qcz9kZjdkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBFdmVudFRhcmdldCBmcm9tICcuLi9wb2x5ZmlsbExvYWRlcnMvRXZlbnRUYXJnZXQuanMnO1xuZXhwb3J0IGNsYXNzIExheW91dDFkQmFzZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGFzdCBzZXQgdmlld3BvcnQgc2Nyb2xsIHBvc2l0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbGF0ZXN0Q29vcmRzID0geyBsZWZ0OiAwLCB0b3A6IDAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjcm9sbGluZyBkaXJlY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAndmVydGljYWwnO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGltZW5zaW9ucyBvZiB0aGUgdmlld3BvcnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl92aWV3cG9ydFNpemUgPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsYWcgZm9yIGRlYm91bmNpbmcgYXN5bmNobnJvbm91cyByZWZsb3cgcmVxdWVzdHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9wZW5kaW5nUmVmbG93ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRleCBvZiB0aGUgaXRlbSB0aGF0IGhhcyBiZWVuIHNjcm9sbGVkIHRvIHZpYSB0aGUgcHVibGljIEFQSS4gV2hlbiB0aGVcbiAgICAgICAgICogY29udGFpbmVyIGlzIG90aGVyd2lzZSBzY3JvbGxlZCwgdGhpcyB2YWx1ZSBpcyBzZXQgYmFjayB0byAtMS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Njcm9sbFRvSW5kZXggPSAtMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gYSBjaGlsZCBpcyBzY3JvbGxlZCB0bywgdGhlIG9mZnNldCBmcm9tIHRoZSB0b3Agb2YgdGhlIGNoaWxkIGFuZCB0aGVcbiAgICAgICAgICogdG9wIG9mIHRoZSB2aWV3cG9ydC4gVmFsdWUgaXMgYSBwcm9wb3J0aW9uIG9mIHRoZSBpdGVtIHNpemUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zY3JvbGxUb0FuY2hvciA9IDA7XG4gICAgICAgIHRoaXMuX2V2ZW50VGFyZ2V0UHJvbWlzZSA9IChFdmVudFRhcmdldCgpLnRoZW4oKEN0b3IpID0+IHRoaXMuX2V2ZW50VGFyZ2V0ID0gbmV3IEN0b3IoKSkpO1xuICAgICAgICAvKipcbiAgICAgICAgICogUGl4ZWwgb2Zmc2V0IGluIHRoZSBzY3JvbGwgZGlyZWN0aW9uIG9mIHRoZSBmaXJzdCBjaGlsZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3BoeXNpY2FsTWluID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBpeGVsIG9mZnNldCBpbiB0aGUgc2Nyb2xsIGRpcmVjdGlvbiBvZiB0aGUgbGFzdCBjaGlsZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3BoeXNpY2FsTWF4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGV4IG9mIHRoZSBmaXJzdCBjaGlsZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2ZpcnN0ID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRleCBvZiB0aGUgbGFzdCBjaGlsZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xhc3QgPSAtMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBfZXN0aW1hdGVkXyBzaXplIG9mIGEgY2hpbGQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pdGVtU2l6ZSA9IHsgd2lkdGg6IDEwMCwgaGVpZ2h0OiAxMDAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwYWNlIGluIHBpeGVscyBiZXR3ZWVuIGNoaWxkcmVuLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc3BhY2luZyA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMZW5ndGggaW4gdGhlIHNjcm9sbGluZyBkaXJlY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zaXplRGltID0gJ2hlaWdodCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMZW5ndGggaW4gdGhlIG5vbi1zY3JvbGxpbmcgZGlyZWN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2Vjb25kYXJ5U2l6ZURpbSA9ICd3aWR0aCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQb3NpdGlvbiBpbiB0aGUgc2Nyb2xsaW5nIGRpcmVjdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uRGltID0gJ3RvcCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQb3NpdGlvbiBpbiB0aGUgbm9uLXNjcm9sbGluZyBkaXJlY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zZWNvbmRhcnlQb3NpdGlvbkRpbSA9ICdsZWZ0JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1cnJlbnQgc2Nyb2xsIG9mZnNldCBpbiBwaXhlbHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zY3JvbGxQb3NpdGlvbiA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaWZmZXJlbmNlIGJldHdlZW4gY3VycmVudCBzY3JvbGwgb2Zmc2V0IGFuZCBzY3JvbGwgb2Zmc2V0IGNhbGN1bGF0ZWQgZHVlXG4gICAgICAgICAqIHRvIGEgcmVmbG93LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2Nyb2xsRXJyb3IgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVG90YWwgbnVtYmVyIG9mIGl0ZW1zIHRoYXQgY291bGQgcG9zc2libHkgYmUgZGlzcGxheWVkLiBVc2VkIHRvIGhlbHBcbiAgICAgICAgICogY2FsY3VsYXRlIHRoZSBzY3JvbGwgc2l6ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RvdGFsSXRlbXMgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvdGFsIChlc3RpbWF0ZWQpIGxlbmd0aCBvZiBhbGwgaXRlbXMgaW4gdGhlIHNjcm9sbGluZyBkaXJlY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zY3JvbGxTaXplID0gMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE51bWJlciBvZiBwaXhlbHMgYmV5b25kIHRoZSB2aXNpYmxlIHNpemUgb2YgdGhlIGNvbnRhaW5lciB0byBzdGlsbCBpbmNsdWRlXG4gICAgICAgICAqIGluIHRoZSBhY3RpdmUgcmFuZ2Ugb2YgaXRlbXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vdmVyaGFuZyA9IDE1MDtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjb25maWcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXhpbXVtIGluZGV4IG9mIGNoaWxkcmVuICsgMSwgdG8gaGVscCBlc3RpbWF0ZSB0b3RhbCBoZWlnaHQgb2YgdGhlIHNjcm9sbFxuICAgICAqIHNwYWNlLlxuICAgICAqL1xuICAgIGdldCB0b3RhbEl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG90YWxJdGVtcztcbiAgICB9XG4gICAgc2V0IHRvdGFsSXRlbXMobnVtKSB7XG4gICAgICAgIGlmIChudW0gIT09IHRoaXMuX3RvdGFsSXRlbXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsSXRlbXMgPSBudW07XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZVJlZmxvdygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaW1hcnkgc2Nyb2xsaW5nIGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgZGlyZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlyZWN0aW9uO1xuICAgIH1cbiAgICBzZXQgZGlyZWN0aW9uKGRpcikge1xuICAgICAgICAvLyBGb3JjZSBpdCB0byBiZSBlaXRoZXIgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbC5cbiAgICAgICAgZGlyID0gKGRpciA9PT0gJ2hvcml6b250YWwnKSA/IGRpciA6ICd2ZXJ0aWNhbCc7XG4gICAgICAgIGlmIChkaXIgIT09IHRoaXMuX2RpcmVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gZGlyO1xuICAgICAgICAgICAgdGhpcy5fc2l6ZURpbSA9IChkaXIgPT09ICdob3Jpem9udGFsJykgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICAgICAgICB0aGlzLl9zZWNvbmRhcnlTaXplRGltID0gKGRpciA9PT0gJ2hvcml6b250YWwnKSA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uRGltID0gKGRpciA9PT0gJ2hvcml6b250YWwnKSA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgICAgICAgICAgdGhpcy5fc2Vjb25kYXJ5UG9zaXRpb25EaW0gPSAoZGlyID09PSAnaG9yaXpvbnRhbCcpID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZVJlZmxvdygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVzdGltYXRlIG9mIHRoZSBkaW1lbnNpb25zIG9mIGEgc2luZ2xlIGNoaWxkLlxuICAgICAqL1xuICAgIGdldCBpdGVtU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1TaXplO1xuICAgIH1cbiAgICBzZXQgaXRlbVNpemUoZGltcykge1xuICAgICAgICBjb25zdCB7IF9pdGVtRGltMSwgX2l0ZW1EaW0yIH0gPSB0aGlzO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX2l0ZW1TaXplLCBkaW1zKTtcbiAgICAgICAgaWYgKF9pdGVtRGltMSAhPT0gdGhpcy5faXRlbURpbTEgfHwgX2l0ZW1EaW0yICE9PSB0aGlzLl9pdGVtRGltMikge1xuICAgICAgICAgICAgaWYgKF9pdGVtRGltMiAhPT0gdGhpcy5faXRlbURpbTIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pdGVtRGltMkNoYW5nZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlUmVmbG93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQW1vdW50IG9mIHNwYWNlIGluIGJldHdlZW4gaXRlbXMuXG4gICAgICovXG4gICAgZ2V0IHNwYWNpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zcGFjaW5nO1xuICAgIH1cbiAgICBzZXQgc3BhY2luZyhweCkge1xuICAgICAgICBpZiAocHggIT09IHRoaXMuX3NwYWNpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX3NwYWNpbmcgPSBweDtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlUmVmbG93KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVpZ2h0IGFuZCB3aWR0aCBvZiB0aGUgdmlld3BvcnQuXG4gICAgICovXG4gICAgZ2V0IHZpZXdwb3J0U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0U2l6ZTtcbiAgICB9XG4gICAgc2V0IHZpZXdwb3J0U2l6ZShkaW1zKSB7XG4gICAgICAgIGNvbnN0IHsgX3ZpZXdEaW0xLCBfdmlld0RpbTIgfSA9IHRoaXM7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fdmlld3BvcnRTaXplLCBkaW1zKTtcbiAgICAgICAgaWYgKF92aWV3RGltMiAhPT0gdGhpcy5fdmlld0RpbTIpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdEaW0yQ2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF92aWV3RGltMSAhPT0gdGhpcy5fdmlld0RpbTEpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrVGhyZXNob2xkcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjcm9sbCBvZmZzZXQgb2YgdGhlIHZpZXdwb3J0LlxuICAgICAqL1xuICAgIGdldCB2aWV3cG9ydFNjcm9sbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhdGVzdENvb3JkcztcbiAgICB9XG4gICAgc2V0IHZpZXdwb3J0U2Nyb2xsKGNvb3Jkcykge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX2xhdGVzdENvb3JkcywgY29vcmRzKTtcbiAgICAgICAgY29uc3Qgb2xkUG9zID0gdGhpcy5fc2Nyb2xsUG9zaXRpb247XG4gICAgICAgIHRoaXMuX3Njcm9sbFBvc2l0aW9uID0gdGhpcy5fbGF0ZXN0Q29vcmRzW3RoaXMuX3Bvc2l0aW9uRGltXTtcbiAgICAgICAgaWYgKG9sZFBvcyAhPT0gdGhpcy5fc2Nyb2xsUG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFBvc2l0aW9uQ2hhbmdlZChvbGRQb3MsIHRoaXMuX3Njcm9sbFBvc2l0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVZpc2libGVJbmRpY2VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hlY2tUaHJlc2hvbGRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSByZWZsb3cgaWYgb25lIGhhcyBiZWVuIHNjaGVkdWxlZC5cbiAgICAgKi9cbiAgICByZWZsb3dJZk5lZWRlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdSZWZsb3cpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdSZWZsb3cgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3JlZmxvdygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjcm9sbCB0byB0aGUgY2hpbGQgYXQgdGhlIGdpdmVuIGluZGV4LCBhbmQgdGhlIGdpdmVuIHBvc2l0aW9uIHdpdGhpbiB0aGF0XG4gICAgICogY2hpbGQuXG4gICAgICovXG4gICAgc2Nyb2xsVG9JbmRleChpbmRleCwgcG9zaXRpb24gPSAnc3RhcnQnKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGluZGV4KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaW5kZXggPSBNYXRoLm1pbih0aGlzLnRvdGFsSXRlbXMsIE1hdGgubWF4KDAsIGluZGV4KSk7XG4gICAgICAgIHRoaXMuX3Njcm9sbFRvSW5kZXggPSBpbmRleDtcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAnbmVhcmVzdCcpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaW5kZXggPiB0aGlzLl9maXJzdCArIHRoaXMuX251bSAvIDIgPyAnZW5kJyA6ICdzdGFydCc7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbFRvQW5jaG9yID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsVG9BbmNob3IgPSAwLjU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbFRvQW5jaG9yID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncG9zaXRpb24gbXVzdCBiZSBvbmUgb2Y6IHN0YXJ0LCBjZW50ZXIsIGVuZCwgbmVhcmVzdCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlUmVmbG93KCk7XG4gICAgICAgIHRoaXMucmVmbG93SWZOZWVkZWQoKTtcbiAgICB9XG4gICAgYXN5bmMgZGlzcGF0Y2hFdmVudCguLi5hcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX2V2ZW50VGFyZ2V0UHJvbWlzZTtcbiAgICAgICAgdGhpcy5fZXZlbnRUYXJnZXQuZGlzcGF0Y2hFdmVudCguLi5hcmdzKTtcbiAgICB9XG4gICAgYXN5bmMgYWRkRXZlbnRMaXN0ZW5lciguLi5hcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX2V2ZW50VGFyZ2V0UHJvbWlzZTtcbiAgICAgICAgdGhpcy5fZXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lciguLi5hcmdzKTtcbiAgICB9XG4gICAgYXN5bmMgcmVtb3ZlRXZlbnRMaXN0ZW5lciguLi5hcmdzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX2V2ZW50VGFyZ2V0UHJvbWlzZTtcbiAgICAgICAgdGhpcy5fZXZlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciguLi5hcmdzKTtcbiAgICB9XG4gICAgdXBkYXRlSXRlbVNpemVzKF9zaXplcykge1xuICAgICAgICAvLyBPdmVycmlkZVxuICAgIH1cbiAgICBfaXRlbURpbTJDaGFuZ2VkKCkge1xuICAgICAgICAvLyBPdmVycmlkZVxuICAgIH1cbiAgICBfdmlld0RpbTJDaGFuZ2VkKCkge1xuICAgICAgICAvLyBPdmVycmlkZVxuICAgIH1cbiAgICBfZ2V0SXRlbVNpemUoX2lkeCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW3RoaXMuX3NpemVEaW1dOiB0aGlzLl9pdGVtRGltMSxcbiAgICAgICAgICAgIFt0aGlzLl9zZWNvbmRhcnlTaXplRGltXTogdGhpcy5faXRlbURpbTIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBzaXplIG9mIGFuIGl0ZW0gaW4gdGhlIHNjcm9sbGluZyBkaXJlY3Rpb24gKyBzcGFjZSBiZXR3ZWVuIGl0ZW1zLlxuICAgICAqL1xuICAgIGdldCBfZGVsdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtRGltMSArIHRoaXMuX3NwYWNpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb3Igd2lkdGggb2YgYW4gaXRlbSwgd2hpY2hldmVyIGNvcnJlc3BvbmRzIHRvIHRoZSBzY3JvbGxpbmcgZGlyZWN0aW9uLlxuICAgICAqL1xuICAgIGdldCBfaXRlbURpbTEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtU2l6ZVt0aGlzLl9zaXplRGltXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvciB3aWR0aCBvZiBhbiBpdGVtLCB3aGljaGV2ZXIgZG9lcyBOT1QgY29ycmVzcG9uZCB0byB0aGUgc2Nyb2xsaW5nIGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgX2l0ZW1EaW0yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbVNpemVbdGhpcy5fc2Vjb25kYXJ5U2l6ZURpbV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb3Igd2lkdGggb2YgdGhlIHZpZXdwb3J0LCB3aGljaGV2ZXIgY29ycmVzcG9uZHMgdG8gdGhlIHNjcm9sbGluZyBkaXJlY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IF92aWV3RGltMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0U2l6ZVt0aGlzLl9zaXplRGltXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvciB3aWR0aCBvZiB0aGUgdmlld3BvcnQsIHdoaWNoZXZlciBkb2VzIE5PVCBjb3JyZXNwb25kIHRvIHRoZSBzY3JvbGxpbmcgZGlyZWN0aW9uLlxuICAgICAqL1xuICAgIGdldCBfdmlld0RpbTIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3cG9ydFNpemVbdGhpcy5fc2Vjb25kYXJ5U2l6ZURpbV07XG4gICAgfVxuICAgIF9zY2hlZHVsZVJlZmxvdygpIHtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1JlZmxvdyA9IHRydWU7XG4gICAgfVxuICAgIF9yZWZsb3coKSB7XG4gICAgICAgIGNvbnN0IHsgX2ZpcnN0LCBfbGFzdCwgX3Njcm9sbFNpemUgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVNjcm9sbFNpemUoKTtcbiAgICAgICAgdGhpcy5fZ2V0QWN0aXZlSXRlbXMoKTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsSWZOZWVkZWQoKTtcbiAgICAgICAgaWYgKHRoaXMuX3Njcm9sbFNpemUgIT09IF9zY3JvbGxTaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0U2Nyb2xsU2l6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9maXJzdCA9PT0gLTEgJiYgdGhpcy5fbGFzdCA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGhhdmUgZGVmYXVsdCBlbXB0eSBvYmplY3QgZm9yIGVtaXRSYW5nZSBpbnN0ZWFkXG4gICAgICAgICAgICB0aGlzLl9lbWl0UmFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9maXJzdCAhPT0gX2ZpcnN0IHx8IHRoaXMuX2xhc3QgIT09IF9sYXN0IHx8XG4gICAgICAgICAgICB0aGlzLl9zcGFjaW5nQ2hhbmdlZCkge1xuICAgICAgICAgICAgLy8gVE9ETzogaGF2ZSBkZWZhdWx0IGVtcHR5IG9iamVjdCBmb3IgZW1pdFJhbmdlIGluc3RlYWRcbiAgICAgICAgICAgIHRoaXMuX2VtaXRSYW5nZSgpO1xuICAgICAgICAgICAgdGhpcy5fZW1pdENoaWxkUG9zaXRpb25zKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW1pdFNjcm9sbEVycm9yKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVzdGltYXRlcyB0aGUgdG90YWwgbGVuZ3RoIG9mIGFsbCBpdGVtcyBpbiB0aGUgc2Nyb2xsaW5nIGRpcmVjdGlvbiwgaW5jbHVkaW5nIHNwYWNpbmcuXG4gICAgICovXG4gICAgX3VwZGF0ZVNjcm9sbFNpemUoKSB7XG4gICAgICAgIC8vIEVuc3VyZSB3ZSBoYXZlIGF0IGxlYXN0IDFweCAtIHRoaXMgYWxsb3dzIGdldHRpbmcgYXQgbGVhc3QgMSBpdGVtIHRvIGJlXG4gICAgICAgIC8vIHJlbmRlcmVkLlxuICAgICAgICB0aGlzLl9zY3JvbGxTaXplID0gTWF0aC5tYXgoMSwgdGhpcy5fdG90YWxJdGVtcyAqIHRoaXMuX2RlbHRhKTtcbiAgICB9XG4gICAgX3Njcm9sbElmTmVlZGVkKCkge1xuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsVG9JbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX3Njcm9sbFRvSW5kZXg7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuX3Njcm9sbFRvQW5jaG9yO1xuICAgICAgICBjb25zdCBwb3MgPSB0aGlzLl9nZXRJdGVtUG9zaXRpb24oaW5kZXgpW3RoaXMuX3Bvc2l0aW9uRGltXTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX2dldEl0ZW1TaXplKGluZGV4KVt0aGlzLl9zaXplRGltXTtcbiAgICAgICAgY29uc3QgY3VyQW5jaG9yUG9zID0gdGhpcy5fc2Nyb2xsUG9zaXRpb24gKyB0aGlzLl92aWV3RGltMSAqIGFuY2hvcjtcbiAgICAgICAgY29uc3QgbmV3QW5jaG9yUG9zID0gcG9zICsgc2l6ZSAqIGFuY2hvcjtcbiAgICAgICAgLy8gRW5zdXJlIHNjcm9sbCBwb3NpdGlvbiBpcyBhbiBpbnRlZ2VyIHdpdGhpbiBzY3JvbGwgYm91bmRzLlxuICAgICAgICBjb25zdCBzY3JvbGxQb3NpdGlvbiA9IE1hdGguZmxvb3IoTWF0aC5taW4odGhpcy5fc2Nyb2xsU2l6ZSAtIHRoaXMuX3ZpZXdEaW0xLCBNYXRoLm1heCgwLCB0aGlzLl9zY3JvbGxQb3NpdGlvbiAtIGN1ckFuY2hvclBvcyArIG5ld0FuY2hvclBvcykpKTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsRXJyb3IgKz0gdGhpcy5fc2Nyb2xsUG9zaXRpb24gLSBzY3JvbGxQb3NpdGlvbjtcbiAgICAgICAgdGhpcy5fc2Nyb2xsUG9zaXRpb24gPSBzY3JvbGxQb3NpdGlvbjtcbiAgICB9XG4gICAgX2VtaXRSYW5nZShpblByb3BzID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGRldGFpbCA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgZmlyc3Q6IHRoaXMuX2ZpcnN0LFxuICAgICAgICAgICAgbGFzdDogdGhpcy5fbGFzdCxcbiAgICAgICAgICAgIG51bTogdGhpcy5fbnVtLFxuICAgICAgICAgICAgc3RhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZmlyc3RWaXNpYmxlOiB0aGlzLl9maXJzdFZpc2libGUsXG4gICAgICAgICAgICBsYXN0VmlzaWJsZTogdGhpcy5fbGFzdFZpc2libGUsXG4gICAgICAgIH0sIGluUHJvcHMpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdyYW5nZWNoYW5nZScsIHsgZGV0YWlsIH0pKTtcbiAgICB9XG4gICAgX2VtaXRTY3JvbGxTaXplKCkge1xuICAgICAgICBjb25zdCBkZXRhaWwgPSB7XG4gICAgICAgICAgICBbdGhpcy5fc2l6ZURpbV06IHRoaXMuX3Njcm9sbFNpemUsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3Njcm9sbHNpemVjaGFuZ2UnLCB7IGRldGFpbCB9KSk7XG4gICAgfVxuICAgIF9lbWl0U2Nyb2xsRXJyb3IoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zY3JvbGxFcnJvcikge1xuICAgICAgICAgICAgY29uc3QgZGV0YWlsID0ge1xuICAgICAgICAgICAgICAgIFt0aGlzLl9wb3NpdGlvbkRpbV06IHRoaXMuX3Njcm9sbEVycm9yLFxuICAgICAgICAgICAgICAgIFt0aGlzLl9zZWNvbmRhcnlQb3NpdGlvbkRpbV06IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnc2Nyb2xsZXJyb3JjaGFuZ2UnLCB7IGRldGFpbCB9KSk7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxFcnJvciA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IG9yIGVzdGltYXRlIHRoZSB0b3AgYW5kIGxlZnQgcG9zaXRpb25zIG9mIGl0ZW1zIGluIHRoZSBjdXJyZW50IHJhbmdlLlxuICAgICAqIEVtaXQgYW4gaXRlbXBvc2l0aW9uY2hhbmdlIGV2ZW50IHdpdGggdGhlc2UgcG9zaXRpb25zLlxuICAgICAqL1xuICAgIF9lbWl0Q2hpbGRQb3NpdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IGRldGFpbCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpZHggPSB0aGlzLl9maXJzdDsgaWR4IDw9IHRoaXMuX2xhc3Q7IGlkeCsrKSB7XG4gICAgICAgICAgICBkZXRhaWxbaWR4XSA9IHRoaXMuX2dldEl0ZW1Qb3NpdGlvbihpZHgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2l0ZW1wb3NpdGlvbmNoYW5nZScsIHsgZGV0YWlsIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIGl0ZW1zIHRvIGRpc3BsYXkuXG4gICAgICovXG4gICAgZ2V0IF9udW0oKSB7XG4gICAgICAgIGlmICh0aGlzLl9maXJzdCA9PT0gLTEgfHwgdGhpcy5fbGFzdCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXN0IC0gdGhpcy5fZmlyc3QgKyAxO1xuICAgIH1cbiAgICBfY2hlY2tUaHJlc2hvbGRzKCkge1xuICAgICAgICBpZiAodGhpcy5fdmlld0RpbTEgPT09IDAgJiYgdGhpcy5fbnVtID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGVSZWZsb3coKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWF4KDAsIHRoaXMuX3Njcm9sbFBvc2l0aW9uIC0gdGhpcy5fb3ZlcmhhbmcpO1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gTWF0aC5taW4odGhpcy5fc2Nyb2xsU2l6ZSwgdGhpcy5fc2Nyb2xsUG9zaXRpb24gKyB0aGlzLl92aWV3RGltMSArIHRoaXMuX292ZXJoYW5nKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9waHlzaWNhbE1pbiA+IG1pbiB8fCB0aGlzLl9waHlzaWNhbE1heCA8IG1heCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlUmVmbG93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgaW5kaWNlcyBvZiB0aGUgZmlyc3QgYW5kIGxhc3QgaXRlbXMgdG8gaW50ZXJzZWN0IHRoZSB2aWV3cG9ydC5cbiAgICAgKiBFbWl0IGEgdmlzaWJsZWluZGljZXNjaGFuZ2UgZXZlbnQgd2hlbiBlaXRoZXIgaW5kZXggY2hhbmdlcy5cbiAgICAgKi9cbiAgICBfdXBkYXRlVmlzaWJsZUluZGljZXMoKSB7XG4gICAgICAgIGxldCBmaXJzdFZpc2libGUgPSB0aGlzLl9maXJzdFZpc2libGU7XG4gICAgICAgIGxldCBsYXN0VmlzaWJsZSA9IHRoaXMuX2xhc3RWaXNpYmxlO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fZmlyc3Q7IGkgPD0gdGhpcy5fbGFzdDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtWSA9IHRoaXMuX2dldEl0ZW1Qb3NpdGlvbihpKVt0aGlzLl9wb3NpdGlvbkRpbV07XG4gICAgICAgICAgICBpZiAoaXRlbVkgPD0gdGhpcy5fc2Nyb2xsUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBmaXJzdFZpc2libGUgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW1ZIDwgdGhpcy5fc2Nyb2xsUG9zaXRpb24gKyB0aGlzLl92aWV3RGltMSkge1xuICAgICAgICAgICAgICAgIGxhc3RWaXNpYmxlID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBzY3JvbGxpbmcgaXMgb2NjdXJyaW5nIHZlcnkgcXVpY2tseSwgaXRlbSBwb3NpdGlvbnMgbWF5IGNoYW5nZVxuICAgICAgICAvLyBkdXJpbmcgdGhpcyBjYWxjdWxhdGlvbi4gSWdub3JlIHRoZSByZXN1bHRzIHdoZW4gdGhhdCBoYXBwZW5zLlxuICAgICAgICBpZiAoZmlyc3RWaXNpYmxlID4gbGFzdFZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlyc3RWaXNpYmxlICE9PSB0aGlzLl9maXJzdFZpc2libGUgfHwgbGFzdFZpc2libGUgIT09IHRoaXMuX2xhc3RWaXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9maXJzdFZpc2libGUgPSBmaXJzdFZpc2libGU7XG4gICAgICAgICAgICB0aGlzLl9sYXN0VmlzaWJsZSA9IGxhc3RWaXNpYmxlO1xuICAgICAgICAgICAgdGhpcy5fZW1pdFJhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3Njcm9sbFBvc2l0aW9uQ2hhbmdlZChvbGRQb3MsIG5ld1Bvcykge1xuICAgICAgICAvLyBXaGVuIGJvdGggdmFsdWVzIGFyZSBiaWdnZXIgdGhhbiB0aGUgbWF4IHNjcm9sbCBwb3NpdGlvbiwga2VlcCB0aGVcbiAgICAgICAgLy8gY3VycmVudCBfc2Nyb2xsVG9JbmRleCwgb3RoZXJ3aXNlIGludmFsaWRhdGUgaXQuXG4gICAgICAgIGNvbnN0IG1heFBvcyA9IHRoaXMuX3Njcm9sbFNpemUgLSB0aGlzLl92aWV3RGltMTtcbiAgICAgICAgaWYgKG9sZFBvcyA8IG1heFBvcyB8fCBuZXdQb3MgPCBtYXhQb3MpIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFRvSW5kZXggPSAtMTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTs7O0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7OztBQUdBO0FBQ0E7Ozs7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7O0FBR0E7QUFDQTs7Ozs7QUFJQTtBQUNBOzs7OztBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7Ozs7QUFHQTtBQUNBOzs7O0FBR0E7QUFDQTs7OztBQUdBO0FBQ0E7Ozs7QUFHQTtBQUNBOzs7O0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7OztBQUdBO0FBQ0E7Ozs7QUFHQTtBQUNBOzs7O0FBR0E7QUFDQTs7OztBQUdBO0FBQ0E7Ozs7QUFHQTtBQUNBOzs7O0FBR0E7QUFDQTs7Ozs7QUFJQTtBQUNBOzs7OztBQUlBO0FBQ0E7Ozs7QUFHQTtBQUNBOzs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUE5RkE7QUFBQTtBQUNBO0FBMExBOzs7QUEzTEE7QUErTEE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBcE1BO0FBQUE7QUFBQTtBQXdNQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFYQTtBQUNBO0FBWUE7QUFDQTtBQUFBO0FBQ0E7QUEvTkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBa09BO0FBQ0E7QUFuT0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQXNPQTtBQUNBO0FBdk9BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUEwT0E7QUFDQTtBQTNPQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBOE9BO0FBOU9BO0FBQUE7QUFBQTtBQWlQQTtBQWpQQTtBQUFBO0FBQUE7QUFvUEE7QUFwUEE7QUFBQTtBQUFBO0FBcVBBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7Ozs7QUEzUEE7QUFBQTtBQUFBO0FBMFJBO0FBQ0E7QUEzUkE7QUFBQTtBQUFBO0FBNFJBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7OztBQWhUQTtBQUFBO0FBQUE7QUFvVEE7QUFDQTtBQUNBO0FBQ0E7QUF2VEE7QUFBQTtBQUFBO0FBeVRBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRVQTtBQUFBO0FBQUE7QUF1VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFBQTtBQUFBO0FBQ0E7QUFqVkE7QUFBQTtBQUFBO0FBbVZBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQXZWQTtBQUFBO0FBQUE7QUF5VkE7QUFBQTtBQUNBO0FBQUE7QUFJQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFsV0E7QUFBQTtBQUFBO0FBdVdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7Ozs7QUE3V0E7QUFBQTtBQUFBO0FBdVhBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFsWUE7QUFBQTtBQUFBO0FBdVlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBNVpBO0FBQUE7QUFBQTtBQThaQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBcGFBO0FBQUE7QUFBQTtBQW1HQTtBQUNBO0FBcEdBO0FBc0dBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBM0dBO0FBQUE7QUFBQTtBQStHQTtBQUNBO0FBaEhBO0FBa0hBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUE3SEE7QUFBQTtBQUFBO0FBaUlBO0FBQ0E7QUFsSUE7QUFtSUE7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUEvSUE7QUFBQTtBQUFBO0FBbUpBO0FBQ0E7QUFwSkE7QUFzSkE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUEzSkE7QUFBQTtBQUFBO0FBK0pBO0FBQ0E7QUFoS0E7QUFpS0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7OztBQTNLQTtBQUFBO0FBQUE7QUErS0E7QUFDQTtBQWhMQTtBQWtMQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUExTEE7QUFBQTtBQUFBO0FBK1BBO0FBQ0E7QUFDQTs7OztBQWpRQTtBQUFBO0FBQUE7QUFxUUE7QUFDQTtBQUNBOzs7O0FBdlFBO0FBQUE7QUFBQTtBQTJRQTtBQUNBO0FBQ0E7Ozs7QUE3UUE7QUFBQTtBQUFBO0FBaVJBO0FBQ0E7QUFDQTs7OztBQW5SQTtBQUFBO0FBQUE7QUF1UkE7QUFDQTtBQXhSQTtBQUFBO0FBQUE7QUFpWEE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBclhBO0FBQ0E7QUFEQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/layouts/Layout1dBase.js\n");

/***/ }),

/***/ "./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/layouts/Layout1dGrid.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/layouts/Layout1dGrid.js ***!
  \**************************************************************************************/
/*! exports provided: Layout1dGrid */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Layout1dGrid\", function() { return Layout1dGrid; });\n/* harmony import */ var _Layout1dBase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Layout1dBase.js */ \"./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/layouts/Layout1dBase.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n/**\n * TODO @straversi: document and test this Layout.\n */\n\nvar Layout1dGrid = /*#__PURE__*/function (_Layout1dBase) {\n  _inherits(Layout1dGrid, _Layout1dBase);\n\n  var _super = _createSuper(Layout1dGrid);\n\n  function Layout1dGrid(config) {\n    var _this;\n\n    _classCallCheck(this, Layout1dGrid);\n\n    _this = _super.call(this, config);\n    _this._rolumns = 1;\n    return _this;\n  }\n\n  _createClass(Layout1dGrid, [{\n    key: \"updateItemSizes\",\n    value: function updateItemSizes(sizes) {\n      // Assume all items have the same size.\n      var size = Object.values(sizes)[0];\n\n      if (size) {\n        this.itemSize = size;\n      }\n    }\n  }, {\n    key: \"_viewDim2Changed\",\n    value: function _viewDim2Changed() {\n      this._defineGrid();\n    }\n  }, {\n    key: \"_itemDim2Changed\",\n    value: function _itemDim2Changed() {\n      this._defineGrid();\n    }\n  }, {\n    key: \"_getActiveItems\",\n    value: function _getActiveItems() {\n      var min = Math.max(0, this._scrollPosition - this._overhang);\n      var max = Math.min(this._scrollSize, this._scrollPosition + this._viewDim1 + this._overhang);\n      var firstCow = Math.floor(min / this._delta);\n      var lastCow = Math.ceil(max / this._delta) - 1;\n      this._first = firstCow * this._rolumns;\n      this._last = Math.min((lastCow + 1) * this._rolumns - 1, this._totalItems);\n      this._physicalMin = this._delta * firstCow;\n      this._physicalMax = this._delta * (lastCow + 1);\n    }\n  }, {\n    key: \"_getItemPosition\",\n    value: function _getItemPosition(idx) {\n      var _ref;\n\n      return _ref = {}, _defineProperty(_ref, this._positionDim, Math.floor(idx / this._rolumns) * this._delta), _defineProperty(_ref, this._secondaryPositionDim, this._spacing + idx % this._rolumns * (this._spacing + this._itemDim2)), _ref;\n    }\n  }, {\n    key: \"_defineGrid\",\n    value: function _defineGrid() {\n      var _spacing = this._spacing;\n      this._rolumns = Math.max(1, Math.floor(this._viewDim2 / this._itemDim2));\n\n      if (this._rolumns > 1) {\n        this._spacing = this._viewDim2 % (this._rolumns * this._itemDim2) / (this._rolumns + 1);\n      } else {\n        this._spacing = 0;\n      }\n\n      this._spacingChanged = !(_spacing === this._spacing);\n\n      this._scheduleReflow();\n    }\n  }, {\n    key: \"_updateScrollSize\",\n    value: function _updateScrollSize() {\n      this._scrollSize = Math.max(1, Math.ceil(this._totalItems / this._rolumns) * this._delta);\n    }\n  }]);\n\n  return Layout1dGrid;\n}(_Layout1dBase_js__WEBPACK_IMPORTED_MODULE_0__[\"Layout1dBase\"]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LXZpcnR1YWxpemVyL2xpYi91bmktdmlydHVhbGl6ZXIvbGliL2xheW91dHMvTGF5b3V0MWRHcmlkLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC12aXJ0dWFsaXplci9saWIvdW5pLXZpcnR1YWxpemVyL2xpYi9sYXlvdXRzL0xheW91dDFkR3JpZC5qcz84MTgwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExheW91dDFkQmFzZSB9IGZyb20gJy4vTGF5b3V0MWRCYXNlLmpzJztcbi8qKlxuICogVE9ETyBAc3RyYXZlcnNpOiBkb2N1bWVudCBhbmQgdGVzdCB0aGlzIExheW91dC5cbiAqL1xuZXhwb3J0IGNsYXNzIExheW91dDFkR3JpZCBleHRlbmRzIExheW91dDFkQmFzZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG4gICAgICAgIHRoaXMuX3JvbHVtbnMgPSAxO1xuICAgIH1cbiAgICB1cGRhdGVJdGVtU2l6ZXMoc2l6ZXMpIHtcbiAgICAgICAgLy8gQXNzdW1lIGFsbCBpdGVtcyBoYXZlIHRoZSBzYW1lIHNpemUuXG4gICAgICAgIGNvbnN0IHNpemUgPSBPYmplY3QudmFsdWVzKHNpemVzKVswXTtcbiAgICAgICAgaWYgKHNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbVNpemUgPSBzaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIF92aWV3RGltMkNoYW5nZWQoKSB7XG4gICAgICAgIHRoaXMuX2RlZmluZUdyaWQoKTtcbiAgICB9XG4gICAgX2l0ZW1EaW0yQ2hhbmdlZCgpIHtcbiAgICAgICAgdGhpcy5fZGVmaW5lR3JpZCgpO1xuICAgIH1cbiAgICBfZ2V0QWN0aXZlSXRlbXMoKSB7XG4gICAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWF4KDAsIHRoaXMuX3Njcm9sbFBvc2l0aW9uIC0gdGhpcy5fb3ZlcmhhbmcpO1xuICAgICAgICBjb25zdCBtYXggPSBNYXRoLm1pbih0aGlzLl9zY3JvbGxTaXplLCB0aGlzLl9zY3JvbGxQb3NpdGlvbiArIHRoaXMuX3ZpZXdEaW0xICsgdGhpcy5fb3ZlcmhhbmcpO1xuICAgICAgICBjb25zdCBmaXJzdENvdyA9IE1hdGguZmxvb3IobWluIC8gdGhpcy5fZGVsdGEpO1xuICAgICAgICBjb25zdCBsYXN0Q293ID0gTWF0aC5jZWlsKG1heCAvIHRoaXMuX2RlbHRhKSAtIDE7XG4gICAgICAgIHRoaXMuX2ZpcnN0ID0gZmlyc3RDb3cgKiB0aGlzLl9yb2x1bW5zO1xuICAgICAgICB0aGlzLl9sYXN0ID1cbiAgICAgICAgICAgIE1hdGgubWluKCgobGFzdENvdyArIDEpICogdGhpcy5fcm9sdW1ucykgLSAxLCB0aGlzLl90b3RhbEl0ZW1zKTtcbiAgICAgICAgdGhpcy5fcGh5c2ljYWxNaW4gPSB0aGlzLl9kZWx0YSAqIGZpcnN0Q293O1xuICAgICAgICB0aGlzLl9waHlzaWNhbE1heCA9IHRoaXMuX2RlbHRhICogKGxhc3RDb3cgKyAxKTtcbiAgICB9XG4gICAgX2dldEl0ZW1Qb3NpdGlvbihpZHgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFt0aGlzLl9wb3NpdGlvbkRpbV06IE1hdGguZmxvb3IoaWR4IC8gdGhpcy5fcm9sdW1ucykgKiB0aGlzLl9kZWx0YSxcbiAgICAgICAgICAgIFt0aGlzLl9zZWNvbmRhcnlQb3NpdGlvbkRpbV06IHRoaXMuX3NwYWNpbmcgK1xuICAgICAgICAgICAgICAgICgoaWR4ICUgdGhpcy5fcm9sdW1ucykgKiAodGhpcy5fc3BhY2luZyArIHRoaXMuX2l0ZW1EaW0yKSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2RlZmluZUdyaWQoKSB7XG4gICAgICAgIGNvbnN0IHsgX3NwYWNpbmcgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3JvbHVtbnMgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHRoaXMuX3ZpZXdEaW0yIC8gdGhpcy5faXRlbURpbTIpKTtcbiAgICAgICAgaWYgKHRoaXMuX3JvbHVtbnMgPiAxKSB7XG4gICAgICAgICAgICB0aGlzLl9zcGFjaW5nID0gKHRoaXMuX3ZpZXdEaW0yICUgKHRoaXMuX3JvbHVtbnMgKiB0aGlzLl9pdGVtRGltMikpIC9cbiAgICAgICAgICAgICAgICAodGhpcy5fcm9sdW1ucyArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc3BhY2luZyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3BhY2luZ0NoYW5nZWQgPSAhKF9zcGFjaW5nID09PSB0aGlzLl9zcGFjaW5nKTtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGVSZWZsb3coKTtcbiAgICB9XG4gICAgX3VwZGF0ZVNjcm9sbFNpemUoKSB7XG4gICAgICAgIHRoaXMuX3Njcm9sbFNpemUgPVxuICAgICAgICAgICAgTWF0aC5tYXgoMSwgTWF0aC5jZWlsKHRoaXMuX3RvdGFsSXRlbXMgLyB0aGlzLl9yb2x1bW5zKSAqIHRoaXMuX2RlbHRhKTtcbiAgICB9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7Ozs7QUFHQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFGQTtBQUdBO0FBQ0E7QUFMQTtBQUFBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBQUE7QUFBQTtBQWFBO0FBQ0E7QUFkQTtBQUFBO0FBQUE7QUFnQkE7QUFDQTtBQWpCQTtBQUFBO0FBQUE7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBNUJBO0FBQUE7QUFBQTtBQTZCQTtBQUNBO0FBQUE7QUFLQTtBQW5DQTtBQUFBO0FBQUE7QUFvQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFoREE7QUFBQTtBQUFBO0FBa0RBO0FBRUE7QUFwREE7QUFDQTtBQURBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/layouts/Layout1dGrid.js\n");

/***/ }),

/***/ "./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/polyfillLoaders/EventTarget.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/polyfillLoaders/EventTarget.js ***!
  \*********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return EventTarget; });\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nvar ET;\nfunction EventTarget() {\n  return _EventTarget.apply(this, arguments);\n}\n\nfunction _EventTarget() {\n  _EventTarget = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", ET || init());\n\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _EventTarget.apply(this, arguments);\n}\n\nfunction init() {\n  return _init.apply(this, arguments);\n}\n\nfunction _init() {\n  _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            ET = window.EventTarget;\n            _context2.prev = 1;\n            new ET();\n            _context2.next = 10;\n            break;\n\n          case 5:\n            _context2.prev = 5;\n            _context2.t0 = _context2[\"catch\"](1);\n            _context2.next = 9;\n            return __webpack_require__.e(/*! import() */ 82).then(__webpack_require__.t.bind(null, /*! event-target-shim */ \"./node_modules/event-target-shim/dist/event-target-shim.js\", 7));\n\n          case 9:\n            ET = _context2.sent.EventTarget;\n\n          case 10:\n            return _context2.abrupt(\"return\", ET);\n\n          case 11:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[1, 5]]);\n  }));\n  return _init.apply(this, arguments);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LXZpcnR1YWxpemVyL2xpYi91bmktdmlydHVhbGl6ZXIvbGliL3BvbHlmaWxsTG9hZGVycy9FdmVudFRhcmdldC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saXQtdmlydHVhbGl6ZXIvbGliL3VuaS12aXJ0dWFsaXplci9saWIvcG9seWZpbGxMb2FkZXJzL0V2ZW50VGFyZ2V0LmpzP2FlMDIiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IEVUO1xuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7XG4gICAgcmV0dXJuIEVUIHx8IGluaXQoKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgRVQgPSB3aW5kb3cuRXZlbnRUYXJnZXQ7XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IEVUKCk7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICBFVCA9IChhd2FpdCBpbXBvcnQoJ2V2ZW50LXRhcmdldC1zaGltJykpLkV2ZW50VGFyZ2V0O1xuICAgIH1cbiAgICByZXR1cm4gRVQ7XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7OztBQUdBOzs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQU1BO0FBQ0E7QUFQQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/polyfillLoaders/EventTarget.js\n");

/***/ }),

/***/ "./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/polyfillLoaders/ResizeObserver.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/polyfillLoaders/ResizeObserver.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ResizeObserver; });\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nvar RO;\nfunction ResizeObserver() {\n  return _ResizeObserver.apply(this, arguments);\n}\n\nfunction _ResizeObserver() {\n  _ResizeObserver = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", RO || init());\n\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _ResizeObserver.apply(this, arguments);\n}\n\nfunction init() {\n  return _init.apply(this, arguments);\n}\n\nfunction _init() {\n  _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            RO = window.ResizeObserver;\n            _context2.prev = 1;\n            new RO(function () {});\n            _context2.next = 10;\n            break;\n\n          case 5:\n            _context2.prev = 5;\n            _context2.t0 = _context2[\"catch\"](1);\n            _context2.next = 9;\n            return __webpack_require__.e(/*! import() */ 46).then(__webpack_require__.bind(null, /*! resize-observer-polyfill */ \"./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\"));\n\n          case 9:\n            RO = _context2.sent[\"default\"];\n\n          case 10:\n            return _context2.abrupt(\"return\", RO);\n\n          case 11:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[1, 5]]);\n  }));\n  return _init.apply(this, arguments);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LXZpcnR1YWxpemVyL2xpYi91bmktdmlydHVhbGl6ZXIvbGliL3BvbHlmaWxsTG9hZGVycy9SZXNpemVPYnNlcnZlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saXQtdmlydHVhbGl6ZXIvbGliL3VuaS12aXJ0dWFsaXplci9saWIvcG9seWZpbGxMb2FkZXJzL1Jlc2l6ZU9ic2VydmVyLmpzPzI3YzUiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IFJPO1xuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXIoKSB7XG4gICAgcmV0dXJuIFJPIHx8IGluaXQoKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgUk8gPSB3aW5kb3cuUmVzaXplT2JzZXJ2ZXI7XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IFJPKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIFJPID0gKGF3YWl0IGltcG9ydCgncmVzaXplLW9ic2VydmVyLXBvbHlmaWxsJykpLmRlZmF1bHQ7XG4gICAgfVxuICAgIHJldHVybiBSTztcbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7O0FBR0E7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBTUE7QUFDQTtBQVBBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/polyfillLoaders/ResizeObserver.js\n");

/***/ }),

/***/ "./node_modules/lit-virtualizer/lib/uni-virtualizer/uni-virtualizer.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/lit-virtualizer/lib/uni-virtualizer/uni-virtualizer.js ***!
  \*****************************************************************************/
/*! exports provided: VirtualRepeater, VirtualScroller, RangeChangeEvent, Layout1d, Layout1dGrid */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_VirtualRepeater_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/VirtualRepeater.js */ \"./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/VirtualRepeater.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"VirtualRepeater\", function() { return _lib_VirtualRepeater_js__WEBPACK_IMPORTED_MODULE_0__[\"VirtualRepeater\"]; });\n\n/* harmony import */ var _lib_VirtualScroller_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/VirtualScroller.js */ \"./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/VirtualScroller.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"VirtualScroller\", function() { return _lib_VirtualScroller_js__WEBPACK_IMPORTED_MODULE_1__[\"VirtualScroller\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RangeChangeEvent\", function() { return _lib_VirtualScroller_js__WEBPACK_IMPORTED_MODULE_1__[\"RangeChangeEvent\"]; });\n\n/* harmony import */ var _lib_layouts_Layout1d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/layouts/Layout1d.js */ \"./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/layouts/Layout1d.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Layout1d\", function() { return _lib_layouts_Layout1d_js__WEBPACK_IMPORTED_MODULE_2__[\"Layout1d\"]; });\n\n/* harmony import */ var _lib_layouts_Layout1dGrid_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/layouts/Layout1dGrid.js */ \"./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/layouts/Layout1dGrid.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Layout1dGrid\", function() { return _lib_layouts_Layout1dGrid_js__WEBPACK_IMPORTED_MODULE_3__[\"Layout1dGrid\"]; });\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LXZpcnR1YWxpemVyL2xpYi91bmktdmlydHVhbGl6ZXIvdW5pLXZpcnR1YWxpemVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC12aXJ0dWFsaXplci9saWIvdW5pLXZpcnR1YWxpemVyL3VuaS12aXJ0dWFsaXplci5qcz8zMzIxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IFZpcnR1YWxSZXBlYXRlciB9IGZyb20gJy4vbGliL1ZpcnR1YWxSZXBlYXRlci5qcyc7XG5leHBvcnQgeyBWaXJ0dWFsU2Nyb2xsZXIsIFJhbmdlQ2hhbmdlRXZlbnQgfSBmcm9tICcuL2xpYi9WaXJ0dWFsU2Nyb2xsZXIuanMnO1xuZXhwb3J0IHsgTGF5b3V0MWQgfSBmcm9tICcuL2xpYi9sYXlvdXRzL0xheW91dDFkLmpzJztcbmV4cG9ydCB7IExheW91dDFkR3JpZCB9IGZyb20gJy4vbGliL2xheW91dHMvTGF5b3V0MWRHcmlkLmpzJztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lit-virtualizer/lib/uni-virtualizer/uni-virtualizer.js\n");

/***/ }),

/***/ "./node_modules/lit-virtualizer/lit-virtualizer.js":
/*!*********************************************************!*\
  !*** ./node_modules/lit-virtualizer/lit-virtualizer.js ***!
  \*********************************************************/
/*! exports provided: repeat, scroll, Layout1d, Layout1dGrid, RangeChangeEvent, LitVirtualizer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_repeat_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/repeat.js */ \"./node_modules/lit-virtualizer/lib/repeat.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"repeat\", function() { return _lib_repeat_js__WEBPACK_IMPORTED_MODULE_0__[\"repeat\"]; });\n\n/* harmony import */ var _lib_scroll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/scroll.js */ \"./node_modules/lit-virtualizer/lib/scroll.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"scroll\", function() { return _lib_scroll_js__WEBPACK_IMPORTED_MODULE_1__[\"scroll\"]; });\n\n/* harmony import */ var _lib_uni_virtualizer_uni_virtualizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/uni-virtualizer/uni-virtualizer.js */ \"./node_modules/lit-virtualizer/lib/uni-virtualizer/uni-virtualizer.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Layout1d\", function() { return _lib_uni_virtualizer_uni_virtualizer_js__WEBPACK_IMPORTED_MODULE_2__[\"Layout1d\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Layout1dGrid\", function() { return _lib_uni_virtualizer_uni_virtualizer_js__WEBPACK_IMPORTED_MODULE_2__[\"Layout1dGrid\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RangeChangeEvent\", function() { return _lib_uni_virtualizer_uni_virtualizer_js__WEBPACK_IMPORTED_MODULE_2__[\"RangeChangeEvent\"]; });\n\n/* harmony import */ var _lib_lit_virtualizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/lit-virtualizer.js */ \"./node_modules/lit-virtualizer/lib/lit-virtualizer.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"LitVirtualizer\", function() { return _lib_lit_virtualizer_js__WEBPACK_IMPORTED_MODULE_3__[\"LitVirtualizer\"]; });\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LXZpcnR1YWxpemVyL2xpdC12aXJ0dWFsaXplci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saXQtdmlydHVhbGl6ZXIvbGl0LXZpcnR1YWxpemVyLmpzP2I4YmQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgcmVwZWF0IH0gZnJvbSAnLi9saWIvcmVwZWF0LmpzJztcbmV4cG9ydCB7IHNjcm9sbCB9IGZyb20gJy4vbGliL3Njcm9sbC5qcyc7XG5leHBvcnQgeyBMYXlvdXQxZCwgTGF5b3V0MWRHcmlkLCBSYW5nZUNoYW5nZUV2ZW50IH0gZnJvbSAnLi9saWIvdW5pLXZpcnR1YWxpemVyL3VuaS12aXJ0dWFsaXplci5qcyc7XG5leHBvcnQgeyBMaXRWaXJ0dWFsaXplciB9IGZyb20gJy4vbGliL2xpdC12aXJ0dWFsaXplci5qcyc7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lit-virtualizer/lit-virtualizer.js\n");

/***/ }),

/***/ "./node_modules/lit-virtualizer/node_modules/tslib/tslib.es6.js":
/*!**********************************************************************!*\
  !*** ./node_modules/lit-virtualizer/node_modules/tslib/tslib.es6.js ***!
  \**********************************************************************/
/*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __createBinding, __exportStar, __values, __read, __spread, __spreadArrays, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__extends\", function() { return __extends; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__assign\", function() { return _assign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__rest\", function() { return __rest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__decorate\", function() { return __decorate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__param\", function() { return __param; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__metadata\", function() { return __metadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__awaiter\", function() { return __awaiter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__generator\", function() { return __generator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__createBinding\", function() { return __createBinding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__exportStar\", function() { return __exportStar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__values\", function() { return __values; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__read\", function() { return __read; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__spread\", function() { return __spread; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__spreadArrays\", function() { return __spreadArrays; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__await\", function() { return __await; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__asyncGenerator\", function() { return __asyncGenerator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__asyncDelegator\", function() { return __asyncDelegator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__asyncValues\", function() { return __asyncValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__makeTemplateObject\", function() { return __makeTemplateObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__importStar\", function() { return __importStar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__importDefault\", function() { return __importDefault; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__classPrivateFieldGet\", function() { return __classPrivateFieldGet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__classPrivateFieldSet\", function() { return __classPrivateFieldSet; });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return _extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  _extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return _assign.apply(this, arguments);\n};\n\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\nfunction __param(paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n}\nfunction __metadata(metadataKey, metadataValue) {\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\nfunction __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\nfunction __createBinding(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n}\nfunction __exportStar(m, exports) {\n  for (var p in m) {\n    if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\nfunction __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) {\n    ar = ar.concat(__read(arguments[i]));\n  }\n\n  return ar;\n}\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n}\n;\nfunction __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []),\n      i,\n      q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i;\n\n  function verb(n) {\n    if (g[n]) i[n] = function (v) {\n      return new Promise(function (a, b) {\n        q.push([n, v, a, b]) > 1 || resume(n, v);\n      });\n    };\n  }\n\n  function resume(n, v) {\n    try {\n      step(g[n](v));\n    } catch (e) {\n      settle(q[0][3], e);\n    }\n  }\n\n  function step(r) {\n    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n  }\n\n  function fulfill(value) {\n    resume(\"next\", value);\n  }\n\n  function reject(value) {\n    resume(\"throw\", value);\n  }\n\n  function settle(f, v) {\n    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n  }\n}\nfunction __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) {\n    throw e;\n  }), verb(\"return\"), i[Symbol.iterator] = function () {\n    return this;\n  }, i;\n\n  function verb(n, f) {\n    i[n] = o[n] ? function (v) {\n      return (p = !p) ? {\n        value: __await(o[n](v)),\n        done: n === \"return\"\n      } : f ? f(v) : v;\n    } : f;\n  }\n}\nfunction __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n      i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n}\nfunction __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) {\n    Object.defineProperty(cooked, \"raw\", {\n      value: raw\n    });\n  } else {\n    cooked.raw = raw;\n  }\n\n  return cooked;\n}\n;\nfunction __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n}\nfunction __importDefault(mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n}\nfunction __classPrivateFieldGet(receiver, privateMap) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n\n  return privateMap.get(receiver);\n}\nfunction __classPrivateFieldSet(receiver, privateMap, value) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to set private field on non-instance\");\n  }\n\n  privateMap.set(receiver, value);\n  return value;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LXZpcnR1YWxpemVyL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGl0LXZpcnR1YWxpemVyL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanM/ZThkNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jcmVhdGVCaW5kaW5nKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdC5kZWZhdWx0ID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwKSB7XHJcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHByaXZhdGVNYXAsIHZhbHVlKSB7XHJcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xyXG4gICAgfVxyXG4gICAgcHJpdmF0ZU1hcC5zZXQocmVjZWl2ZXIsIHZhbHVlKTtcclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7OztBQWNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQVhBO0FBQ0E7QUFZQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWpCQTtBQUNBO0FBaUJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lit-virtualizer/node_modules/tslib/tslib.es6.js\n");

/***/ })

}]);