(self["webpackJsonp"] = self["webpackJsonp"] || []).push([["hui-dialog-suggest-card~more-info-dialog~panel-history~panel-lovelace"],{

/***/ "./src/components/entity/ha-chart-base.js":
/*!************************************************!*\
  !*** ./src/components/entity/ha-chart-base.js ***!
  \************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _polymer_iron_resizable_behavior_iron_resizable_behavior__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/iron-resizable-behavior/iron-resizable-behavior */ \"./node_modules/@polymer/iron-resizable-behavior/iron-resizable-behavior.js\");\n/* harmony import */ var _ha_icon_button__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ha-icon-button */ \"./src/components/ha-icon-button.ts\");\n/* harmony import */ var _polymer_polymer_lib_legacy_class__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @polymer/polymer/lib/legacy/class */ \"./node_modules/@polymer/polymer/lib/legacy/class.js\");\n/* harmony import */ var _polymer_polymer_lib_utils_async__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @polymer/polymer/lib/utils/async */ \"./node_modules/@polymer/polymer/lib/utils/async.js\");\n/* harmony import */ var _polymer_polymer_lib_utils_debounce__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @polymer/polymer/lib/utils/debounce */ \"./node_modules/@polymer/polymer/lib/utils/debounce.js\");\n/* harmony import */ var _polymer_polymer_lib_utils_html_tag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @polymer/polymer/lib/utils/html-tag */ \"./node_modules/@polymer/polymer/lib/utils/html-tag.js\");\n/* harmony import */ var _polymer_polymer_polymer_element__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @polymer/polymer/polymer-element */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n/* harmony import */ var _common_datetime_format_time__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../common/datetime/format_time */ \"./src/common/datetime/format_time.ts\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n      <style>\\n        :host {\\n          display: block;\\n        }\\n        .chartHeader {\\n          padding: 6px 0 0 0;\\n          width: 100%;\\n          display: flex;\\n          flex-direction: row;\\n        }\\n        .chartHeader > div {\\n          vertical-align: top;\\n          padding: 0 8px;\\n        }\\n        .chartHeader > div.chartTitle {\\n          padding-top: 8px;\\n          flex: 0 0 0;\\n          max-width: 30%;\\n        }\\n        .chartHeader > div.chartLegend {\\n          flex: 1 1;\\n          min-width: 70%;\\n        }\\n        :root {\\n          user-select: none;\\n          -moz-user-select: none;\\n          -webkit-user-select: none;\\n          -ms-user-select: none;\\n        }\\n        .chartTooltip {\\n          font-size: 90%;\\n          opacity: 1;\\n          position: absolute;\\n          background: rgba(80, 80, 80, 0.9);\\n          color: white;\\n          border-radius: 3px;\\n          pointer-events: none;\\n          transform: translate(-50%, 12px);\\n          z-index: 1000;\\n          width: 200px;\\n          transition: opacity 0.15s ease-in-out;\\n        }\\n        :host([rtl]) .chartTooltip {\\n          direction: rtl;\\n        }\\n        .chartLegend ul,\\n        .chartTooltip ul {\\n          display: inline-block;\\n          padding: 0 0px;\\n          margin: 5px 0 0 0;\\n          width: 100%;\\n        }\\n        .chartTooltip li {\\n          display: block;\\n          white-space: pre-line;\\n        }\\n        .chartTooltip .title {\\n          text-align: center;\\n          font-weight: 500;\\n        }\\n        .chartLegend li {\\n          display: inline-block;\\n          padding: 0 6px;\\n          max-width: 49%;\\n          text-overflow: ellipsis;\\n          white-space: nowrap;\\n          overflow: hidden;\\n          box-sizing: border-box;\\n        }\\n        .chartLegend li:nth-child(odd):last-of-type {\\n          /* Make last item take full width if it is odd-numbered. */\\n          max-width: 100%;\\n        }\\n        .chartLegend li[data-hidden] {\\n          text-decoration: line-through;\\n        }\\n        .chartLegend em,\\n        .chartTooltip em {\\n          border-radius: 5px;\\n          display: inline-block;\\n          height: 10px;\\n          margin-right: 4px;\\n          width: 10px;\\n        }\\n        :host([rtl]) .chartTooltip em {\\n          margin-right: inherit;\\n          margin-left: 4px;\\n        }\\n        ha-icon-button {\\n          color: var(--secondary-text-color);\\n        }\\n      </style>\\n      <template is=\\\"dom-if\\\" if=\\\"[[unit]]\\\">\\n        <div class=\\\"chartHeader\\\">\\n          <div class=\\\"chartTitle\\\">[[unit]]</div>\\n          <div class=\\\"chartLegend\\\">\\n            <ul>\\n              <template is=\\\"dom-repeat\\\" items=\\\"[[metas]]\\\">\\n                <li on-click=\\\"_legendClick\\\" data-hidden$=\\\"[[item.hidden]]\\\">\\n                  <em style$=\\\"background-color:[[item.bgColor]]\\\"></em>\\n                  [[item.label]]\\n                </li>\\n              </template>\\n            </ul>\\n          </div>\\n        </div>\\n      </template>\\n      <div id=\\\"chartTarget\\\" style=\\\"height:40px; width:100%\\\">\\n        <canvas id=\\\"chartCanvas\\\"></canvas>\\n        <div\\n          class$=\\\"chartTooltip [[tooltip.yAlign]]\\\"\\n          style$=\\\"opacity:[[tooltip.opacity]]; top:[[tooltip.top]]; left:[[tooltip.left]]; padding:[[tooltip.yPadding]]px [[tooltip.xPadding]]px\\\"\\n        >\\n          <div class=\\\"title\\\">[[tooltip.title]]</div>\\n          <div>\\n            <ul>\\n              <template is=\\\"dom-repeat\\\" items=\\\"[[tooltip.lines]]\\\">\\n                <li>\\n                  <em style$=\\\"background-color:[[item.bgColor]]\\\"></em\\n                  >[[item.text]]\\n                </li>\\n              </template>\\n            </ul>\\n          </div>\\n        </div>\\n      </div>\\n    \"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/* eslint-plugin-disable lit */\n\n\n\n\n\n\n\n // eslint-disable-next-line no-unused-vars\n\n/* global Chart moment Color */\n\nvar scriptsLoaded = null;\n\nvar HaChartBase = /*#__PURE__*/function (_mixinBehaviors) {\n  _inherits(HaChartBase, _mixinBehaviors);\n\n  var _super = _createSuper(HaChartBase);\n\n  function HaChartBase() {\n    _classCallCheck(this, HaChartBase);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(HaChartBase, [{\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      var _this = this;\n\n      _get(_getPrototypeOf(HaChartBase.prototype), \"connectedCallback\", this).call(this);\n\n      this._isAttached = true;\n      this.onPropsChange();\n\n      this._resizeListener = function () {\n        _this._debouncer = _polymer_polymer_lib_utils_debounce__WEBPACK_IMPORTED_MODULE_4__[\"Debouncer\"].debounce(_this._debouncer, _polymer_polymer_lib_utils_async__WEBPACK_IMPORTED_MODULE_3__[\"timeOut\"].after(10), function () {\n          if (_this._isAttached) {\n            _this.resizeChart();\n          }\n        });\n      };\n\n      if (typeof ResizeObserver === \"function\") {\n        this.resizeObserver = new ResizeObserver(function (entries) {\n          entries.forEach(function () {\n            _this._resizeListener();\n          });\n        });\n        this.resizeObserver.observe(this.$.chartTarget);\n      } else {\n        this.addEventListener(\"iron-resize\", this._resizeListener);\n      }\n\n      if (scriptsLoaded === null) {\n        scriptsLoaded = Promise.all(/*! import() | load_chart */[__webpack_require__.e(\"vendors~load_chart\"), __webpack_require__.e(\"load_chart\")]).then(__webpack_require__.bind(null, /*! ../../resources/ha-chart-scripts.js */ \"./src/resources/ha-chart-scripts.js\"));\n      }\n\n      scriptsLoaded.then(function (ChartModule) {\n        _this.ChartClass = ChartModule[\"default\"];\n\n        _this.onPropsChange();\n      });\n    }\n  }, {\n    key: \"disconnectedCallback\",\n    value: function disconnectedCallback() {\n      _get(_getPrototypeOf(HaChartBase.prototype), \"disconnectedCallback\", this).call(this);\n\n      this._isAttached = false;\n\n      if (this.resizeObserver) {\n        this.resizeObserver.unobserve(this.$.chartTarget);\n      }\n\n      this.removeEventListener(\"iron-resize\", this._resizeListener);\n\n      if (this._resizeTimer !== undefined) {\n        clearInterval(this._resizeTimer);\n        this._resizeTimer = undefined;\n      }\n    }\n  }, {\n    key: \"onPropsChange\",\n    value: function onPropsChange() {\n      if (!this._isAttached || !this.ChartClass || !this.data) {\n        return;\n      }\n\n      this.drawChart();\n    }\n  }, {\n    key: \"_customTooltips\",\n    value: function _customTooltips(tooltip) {\n      // Hide if no tooltip\n      if (tooltip.opacity === 0) {\n        this.set([\"tooltip\", \"opacity\"], 0);\n        return;\n      } // Set caret Position\n\n\n      if (tooltip.yAlign) {\n        this.set([\"tooltip\", \"yAlign\"], tooltip.yAlign);\n      } else {\n        this.set([\"tooltip\", \"yAlign\"], \"no-transform\");\n      }\n\n      var title = tooltip.title ? tooltip.title[0] || \"\" : \"\";\n      this.set([\"tooltip\", \"title\"], title);\n      var bodyLines = tooltip.body.map(function (n) {\n        return n.lines;\n      }); // Set Text\n\n      if (tooltip.body) {\n        this.set([\"tooltip\", \"lines\"], bodyLines.map(function (body, i) {\n          var colors = tooltip.labelColors[i];\n          return {\n            color: colors.borderColor,\n            bgColor: colors.backgroundColor,\n            text: body.join(\"\\n\")\n          };\n        }));\n      }\n\n      var parentWidth = this.$.chartTarget.clientWidth;\n      var positionX = tooltip.caretX;\n      var positionY = this._chart.canvas.offsetTop + tooltip.caretY;\n\n      if (tooltip.caretX + 100 > parentWidth) {\n        positionX = parentWidth - 100;\n      } else if (tooltip.caretX < 100) {\n        positionX = 100;\n      }\n\n      positionX += this._chart.canvas.offsetLeft; // Display, position, and set styles for font\n\n      this.tooltip = Object.assign({}, this.tooltip, {\n        opacity: 1,\n        left: \"\".concat(positionX, \"px\"),\n        top: \"\".concat(positionY, \"px\")\n      });\n    }\n  }, {\n    key: \"_legendClick\",\n    value: function _legendClick(event) {\n      event = event || window.event;\n      event.stopPropagation();\n      var target = event.target || event.srcElement;\n\n      while (target.nodeName !== \"LI\") {\n        // user clicked child, find parent LI\n        target = target.parentElement;\n      }\n\n      var index = event.model.itemsIndex;\n\n      var meta = this._chart.getDatasetMeta(index);\n\n      meta.hidden = meta.hidden === null ? !this._chart.data.datasets[index].hidden : null;\n      this.set([\"metas\", index, \"hidden\"], this._chart.isDatasetVisible(index) ? null : \"hidden\");\n\n      this._chart.update();\n    }\n  }, {\n    key: \"_drawLegend\",\n    value: function _drawLegend() {\n      var _this2 = this;\n\n      var chart = this._chart; // New data for old graph. Keep metadata.\n\n      var preserveVisibility = this._oldIdentifier && this.identifier === this._oldIdentifier;\n      this._oldIdentifier = this.identifier;\n      this.set(\"metas\", this._chart.data.datasets.map(function (x, i) {\n        return {\n          label: x.label,\n          color: x.color,\n          bgColor: x.backgroundColor,\n          hidden: preserveVisibility && i < _this2.metas.length ? _this2.metas[i].hidden : !chart.isDatasetVisible(i)\n        };\n      }));\n      var updateNeeded = false;\n\n      if (preserveVisibility) {\n        for (var i = 0; i < this.metas.length; i++) {\n          var meta = chart.getDatasetMeta(i);\n          if (!!meta.hidden !== !!this.metas[i].hidden) updateNeeded = true;\n          meta.hidden = this.metas[i].hidden ? true : null;\n        }\n      }\n\n      if (updateNeeded) {\n        chart.update();\n      }\n\n      this.unit = this.data.unit;\n    }\n  }, {\n    key: \"_formatTickValue\",\n    value: function _formatTickValue(value, index, values) {\n      if (values.length === 0) {\n        return value;\n      }\n\n      var date = new Date(values[index].value);\n      return Object(_common_datetime_format_time__WEBPACK_IMPORTED_MODULE_7__[\"formatTime\"])(date);\n    }\n  }, {\n    key: \"drawChart\",\n    value: function drawChart() {\n      var _this3 = this;\n\n      var data = this.data.data;\n      var ctx = this.$.chartCanvas;\n\n      if ((!data.datasets || !data.datasets.length) && !this._chart) {\n        return;\n      }\n\n      if (this.data.type !== \"timeline\" && data.datasets.length > 0) {\n        var cnt = data.datasets.length;\n        var colors = this.constructor.getColorList(cnt);\n\n        for (var loopI = 0; loopI < cnt; loopI++) {\n          data.datasets[loopI].borderColor = colors[loopI].rgbString();\n          data.datasets[loopI].backgroundColor = colors[loopI].alpha(0.6).rgbaString();\n        }\n      }\n\n      if (this._chart) {\n        this._customTooltips({\n          opacity: 0\n        });\n\n        this._chart.data = data;\n\n        this._chart.update({\n          duration: 0\n        });\n\n        if (this.isTimeline) {\n          this._chart.options.scales.yAxes[0].gridLines.display = data.length > 1;\n        } else if (this.data.legend === true) {\n          this._drawLegend();\n        }\n\n        this.resizeChart();\n      } else {\n        if (!data.datasets) {\n          return;\n        }\n\n        this._customTooltips({\n          opacity: 0\n        });\n\n        var plugins = [{\n          afterRender: function afterRender() {\n            return _this3._setRendered(true);\n          }\n        }];\n        var options = {\n          responsive: true,\n          maintainAspectRatio: false,\n          animation: {\n            duration: 0\n          },\n          hover: {\n            animationDuration: 0\n          },\n          responsiveAnimationDuration: 0,\n          tooltips: {\n            enabled: false,\n            custom: this._customTooltips.bind(this)\n          },\n          legend: {\n            display: false\n          },\n          line: {\n            spanGaps: true\n          },\n          elements: {\n            font: \"12px 'Roboto', 'sans-serif'\"\n          },\n          ticks: {\n            fontFamily: \"'Roboto', 'sans-serif'\"\n          }\n        };\n        options = Chart.helpers.merge(options, this.data.options);\n        options.scales.xAxes[0].ticks.callback = this._formatTickValue;\n\n        if (this.data.type === \"timeline\") {\n          this.set(\"isTimeline\", true);\n\n          if (this.data.colors !== undefined) {\n            this._colorFunc = this.constructor.getColorGenerator(this.data.colors.staticColors, this.data.colors.staticColorIndex);\n          }\n\n          if (this._colorFunc !== undefined) {\n            options.elements.colorFunction = this._colorFunc;\n          }\n\n          if (data.datasets.length === 1) {\n            if (options.scales.yAxes[0].ticks) {\n              options.scales.yAxes[0].ticks.display = false;\n            } else {\n              options.scales.yAxes[0].ticks = {\n                display: false\n              };\n            }\n\n            if (options.scales.yAxes[0].gridLines) {\n              options.scales.yAxes[0].gridLines.display = false;\n            } else {\n              options.scales.yAxes[0].gridLines = {\n                display: false\n              };\n            }\n          }\n\n          this.$.chartTarget.style.height = \"50px\";\n        } else {\n          this.$.chartTarget.style.height = \"160px\";\n        }\n\n        var chartData = {\n          type: this.data.type,\n          data: this.data.data,\n          options: options,\n          plugins: plugins\n        }; // Async resize after dom update\n\n        this._chart = new this.ChartClass(ctx, chartData);\n\n        if (this.isTimeline !== true && this.data.legend === true) {\n          this._drawLegend();\n        }\n\n        this.resizeChart();\n      }\n    }\n  }, {\n    key: \"resizeChart\",\n    value: function resizeChart() {\n      if (!this._chart) return; // Chart not ready\n\n      if (this._resizeTimer === undefined) {\n        this._resizeTimer = setInterval(this.resizeChart.bind(this), 10);\n        return;\n      }\n\n      clearInterval(this._resizeTimer);\n      this._resizeTimer = undefined;\n\n      this._resizeChart();\n    }\n  }, {\n    key: \"_resizeChart\",\n    value: function _resizeChart() {\n      var chartTarget = this.$.chartTarget;\n      var options = this.data;\n      var data = options.data;\n\n      if (data.datasets.length === 0) {\n        return;\n      }\n\n      if (!this.isTimeline) {\n        this._chart.resize();\n\n        return;\n      } // Recalculate chart height for Timeline chart\n\n\n      var areaTop = this._chart.chartArea.top;\n      var areaBot = this._chart.chartArea.bottom;\n      var height1 = this._chart.canvas.clientHeight;\n\n      if (areaBot > 0) {\n        this._axisHeight = height1 - areaBot + areaTop;\n      }\n\n      if (!this._axisHeight) {\n        chartTarget.style.height = \"50px\";\n\n        this._chart.resize();\n\n        this.resizeChart();\n        return;\n      }\n\n      if (this._axisHeight) {\n        var cnt = data.datasets.length;\n        var targetHeight = 30 * cnt + this._axisHeight + \"px\";\n\n        if (chartTarget.style.height !== targetHeight) {\n          chartTarget.style.height = targetHeight;\n        }\n\n        this._chart.resize();\n      }\n    } // Get HSL distributed color list\n\n  }, {\n    key: \"chart\",\n    get: function get() {\n      return this._chart;\n    }\n  }], [{\n    key: \"getColorList\",\n    value: function getColorList(count) {\n      var processL = false;\n\n      if (count > 10) {\n        processL = true;\n        count = Math.ceil(count / 2);\n      }\n\n      var h1 = 360 / count;\n      var result = [];\n\n      for (var loopI = 0; loopI < count; loopI++) {\n        result[loopI] = Color().hsl(h1 * loopI, 80, 38);\n\n        if (processL) {\n          result[loopI + count] = Color().hsl(h1 * loopI, 80, 62);\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"getColorGenerator\",\n    value: function getColorGenerator(staticColors, startIndex) {\n      // Known colors for static data,\n      // should add for very common state string manually.\n      // Palette modified from http://google.github.io/palette.js/ mpn65, Apache 2.0\n      var palette = [\"ff0029\", \"66a61e\", \"377eb8\", \"984ea3\", \"00d2d5\", \"ff7f00\", \"af8d00\", \"7f80cd\", \"b3e900\", \"c42e60\", \"a65628\", \"f781bf\", \"8dd3c7\", \"bebada\", \"fb8072\", \"80b1d3\", \"fdb462\", \"fccde5\", \"bc80bd\", \"ffed6f\", \"c4eaff\", \"cf8c00\", \"1b9e77\", \"d95f02\", \"e7298a\", \"e6ab02\", \"a6761d\", \"0097ff\", \"00d067\", \"f43600\", \"4ba93b\", \"5779bb\", \"927acc\", \"97ee3f\", \"bf3947\", \"9f5b00\", \"f48758\", \"8caed6\", \"f2b94f\", \"eff26e\", \"e43872\", \"d9b100\", \"9d7a00\", \"698cff\", \"d9d9d9\", \"00d27e\", \"d06800\", \"009f82\", \"c49200\", \"cbe8ff\", \"fecddf\", \"c27eb6\", \"8cd2ce\", \"c4b8d9\", \"f883b0\", \"a49100\", \"f48800\", \"27d0df\", \"a04a9b\"];\n\n      function getColorIndex(idx) {\n        // Reuse the color if index too large.\n        return Color(\"#\" + palette[idx % palette.length]);\n      }\n\n      var colorDict = {};\n      var colorIndex = 0;\n      if (startIndex > 0) colorIndex = startIndex;\n\n      if (staticColors) {\n        Object.keys(staticColors).forEach(function (c) {\n          var c1 = staticColors[c];\n\n          if (isFinite(c1)) {\n            colorDict[c.toLowerCase()] = getColorIndex(c1);\n          } else {\n            colorDict[c.toLowerCase()] = Color(staticColors[c]);\n          }\n        });\n      } // Custom color assign\n\n\n      function getColor(__, data) {\n        var ret;\n        var name = data[3];\n        if (name === null) return Color().hsl(0, 40, 38);\n        if (name === undefined) return Color().hsl(120, 40, 38);\n        var name1 = name.toLowerCase();\n\n        if (ret === undefined) {\n          ret = colorDict[name1];\n        }\n\n        if (ret === undefined) {\n          ret = getColorIndex(colorIndex);\n          colorIndex++;\n          colorDict[name1] = ret;\n        }\n\n        return ret;\n      }\n\n      return getColor;\n    }\n  }, {\n    key: \"template\",\n    get: function get() {\n      return Object(_polymer_polymer_lib_utils_html_tag__WEBPACK_IMPORTED_MODULE_5__[\"html\"])(_templateObject());\n    }\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return {\n        data: Object,\n        identifier: String,\n        rendered: {\n          type: Boolean,\n          notify: true,\n          value: false,\n          readOnly: true\n        },\n        metas: {\n          type: Array,\n          value: function value() {\n            return [];\n          }\n        },\n        tooltip: {\n          type: Object,\n          value: function value() {\n            return {\n              opacity: \"0\",\n              left: \"0\",\n              top: \"0\",\n              xPadding: \"5\",\n              yPadding: \"3\"\n            };\n          }\n        },\n        unit: Object,\n        rtl: {\n          type: Boolean,\n          reflectToAttribute: true\n        }\n      };\n    }\n  }, {\n    key: \"observers\",\n    get: function get() {\n      return [\"onPropsChange(data)\"];\n    }\n  }]);\n\n  return HaChartBase;\n}(Object(_polymer_polymer_lib_legacy_class__WEBPACK_IMPORTED_MODULE_2__[\"mixinBehaviors\"])([_polymer_iron_resizable_behavior_iron_resizable_behavior__WEBPACK_IMPORTED_MODULE_0__[\"IronResizableBehavior\"]], _polymer_polymer_polymer_element__WEBPACK_IMPORTED_MODULE_6__[\"PolymerElement\"]));\n\ncustomElements.define(\"ha-chart-base\", HaChartBase);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9lbnRpdHkvaGEtY2hhcnQtYmFzZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2VudGl0eS9oYS1jaGFydC1iYXNlLmpzPzE0ZGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LXBsdWdpbi1kaXNhYmxlIGxpdCAqL1xuaW1wb3J0IHsgSXJvblJlc2l6YWJsZUJlaGF2aW9yIH0gZnJvbSBcIkBwb2x5bWVyL2lyb24tcmVzaXphYmxlLWJlaGF2aW9yL2lyb24tcmVzaXphYmxlLWJlaGF2aW9yXCI7XG5pbXBvcnQgXCIuLi9oYS1pY29uLWJ1dHRvblwiO1xuaW1wb3J0IHsgbWl4aW5CZWhhdmlvcnMgfSBmcm9tIFwiQHBvbHltZXIvcG9seW1lci9saWIvbGVnYWN5L2NsYXNzXCI7XG5pbXBvcnQgeyB0aW1lT3V0IH0gZnJvbSBcIkBwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2FzeW5jXCI7XG5pbXBvcnQgeyBEZWJvdW5jZXIgfSBmcm9tIFwiQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvZGVib3VuY2VcIjtcbmltcG9ydCB7IGh0bWwgfSBmcm9tIFwiQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvaHRtbC10YWdcIjtcbmltcG9ydCB7IFBvbHltZXJFbGVtZW50IH0gZnJvbSBcIkBwb2x5bWVyL3BvbHltZXIvcG9seW1lci1lbGVtZW50XCI7XG5pbXBvcnQgeyBmb3JtYXRUaW1lIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9kYXRldGltZS9mb3JtYXRfdGltZVwiO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbi8qIGdsb2JhbCBDaGFydCBtb21lbnQgQ29sb3IgKi9cblxubGV0IHNjcmlwdHNMb2FkZWQgPSBudWxsO1xuXG5jbGFzcyBIYUNoYXJ0QmFzZSBleHRlbmRzIG1peGluQmVoYXZpb3JzKFxuICBbSXJvblJlc2l6YWJsZUJlaGF2aW9yXSxcbiAgUG9seW1lckVsZW1lbnRcbikge1xuICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkge1xuICAgIHJldHVybiBodG1sYFxuICAgICAgPHN0eWxlPlxuICAgICAgICA6aG9zdCB7XG4gICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIH1cbiAgICAgICAgLmNoYXJ0SGVhZGVyIHtcbiAgICAgICAgICBwYWRkaW5nOiA2cHggMCAwIDA7XG4gICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xuICAgICAgICB9XG4gICAgICAgIC5jaGFydEhlYWRlciA+IGRpdiB7XG4gICAgICAgICAgdmVydGljYWwtYWxpZ246IHRvcDtcbiAgICAgICAgICBwYWRkaW5nOiAwIDhweDtcbiAgICAgICAgfVxuICAgICAgICAuY2hhcnRIZWFkZXIgPiBkaXYuY2hhcnRUaXRsZSB7XG4gICAgICAgICAgcGFkZGluZy10b3A6IDhweDtcbiAgICAgICAgICBmbGV4OiAwIDAgMDtcbiAgICAgICAgICBtYXgtd2lkdGg6IDMwJTtcbiAgICAgICAgfVxuICAgICAgICAuY2hhcnRIZWFkZXIgPiBkaXYuY2hhcnRMZWdlbmQge1xuICAgICAgICAgIGZsZXg6IDEgMTtcbiAgICAgICAgICBtaW4td2lkdGg6IDcwJTtcbiAgICAgICAgfVxuICAgICAgICA6cm9vdCB7XG4gICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICAgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgfVxuICAgICAgICAuY2hhcnRUb29sdGlwIHtcbiAgICAgICAgICBmb250LXNpemU6IDkwJTtcbiAgICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiByZ2JhKDgwLCA4MCwgODAsIDAuOSk7XG4gICAgICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAxMnB4KTtcbiAgICAgICAgICB6LWluZGV4OiAxMDAwO1xuICAgICAgICAgIHdpZHRoOiAyMDBweDtcbiAgICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMTVzIGVhc2UtaW4tb3V0O1xuICAgICAgICB9XG4gICAgICAgIDpob3N0KFtydGxdKSAuY2hhcnRUb29sdGlwIHtcbiAgICAgICAgICBkaXJlY3Rpb246IHJ0bDtcbiAgICAgICAgfVxuICAgICAgICAuY2hhcnRMZWdlbmQgdWwsXG4gICAgICAgIC5jaGFydFRvb2x0aXAgdWwge1xuICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgICBwYWRkaW5nOiAwIDBweDtcbiAgICAgICAgICBtYXJnaW46IDVweCAwIDAgMDtcbiAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgfVxuICAgICAgICAuY2hhcnRUb29sdGlwIGxpIHtcbiAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICB3aGl0ZS1zcGFjZTogcHJlLWxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgLmNoYXJ0VG9vbHRpcCAudGl0bGUge1xuICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICBmb250LXdlaWdodDogNTAwO1xuICAgICAgICB9XG4gICAgICAgIC5jaGFydExlZ2VuZCBsaSB7XG4gICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICAgIHBhZGRpbmc6IDAgNnB4O1xuICAgICAgICAgIG1heC13aWR0aDogNDklO1xuICAgICAgICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuICAgICAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICB9XG4gICAgICAgIC5jaGFydExlZ2VuZCBsaTpudGgtY2hpbGQob2RkKTpsYXN0LW9mLXR5cGUge1xuICAgICAgICAgIC8qIE1ha2UgbGFzdCBpdGVtIHRha2UgZnVsbCB3aWR0aCBpZiBpdCBpcyBvZGQtbnVtYmVyZWQuICovXG4gICAgICAgICAgbWF4LXdpZHRoOiAxMDAlO1xuICAgICAgICB9XG4gICAgICAgIC5jaGFydExlZ2VuZCBsaVtkYXRhLWhpZGRlbl0ge1xuICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbGluZS10aHJvdWdoO1xuICAgICAgICB9XG4gICAgICAgIC5jaGFydExlZ2VuZCBlbSxcbiAgICAgICAgLmNoYXJ0VG9vbHRpcCBlbSB7XG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogNXB4O1xuICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgICBoZWlnaHQ6IDEwcHg7XG4gICAgICAgICAgbWFyZ2luLXJpZ2h0OiA0cHg7XG4gICAgICAgICAgd2lkdGg6IDEwcHg7XG4gICAgICAgIH1cbiAgICAgICAgOmhvc3QoW3J0bF0pIC5jaGFydFRvb2x0aXAgZW0ge1xuICAgICAgICAgIG1hcmdpbi1yaWdodDogaW5oZXJpdDtcbiAgICAgICAgICBtYXJnaW4tbGVmdDogNHB4O1xuICAgICAgICB9XG4gICAgICAgIGhhLWljb24tYnV0dG9uIHtcbiAgICAgICAgICBjb2xvcjogdmFyKC0tc2Vjb25kYXJ5LXRleHQtY29sb3IpO1xuICAgICAgICB9XG4gICAgICA8L3N0eWxlPlxuICAgICAgPHRlbXBsYXRlIGlzPVwiZG9tLWlmXCIgaWY9XCJbW3VuaXRdXVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2hhcnRIZWFkZXJcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2hhcnRUaXRsZVwiPltbdW5pdF1dPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNoYXJ0TGVnZW5kXCI+XG4gICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgIDx0ZW1wbGF0ZSBpcz1cImRvbS1yZXBlYXRcIiBpdGVtcz1cIltbbWV0YXNdXVwiPlxuICAgICAgICAgICAgICAgIDxsaSBvbi1jbGljaz1cIl9sZWdlbmRDbGlja1wiIGRhdGEtaGlkZGVuJD1cIltbaXRlbS5oaWRkZW5dXVwiPlxuICAgICAgICAgICAgICAgICAgPGVtIHN0eWxlJD1cImJhY2tncm91bmQtY29sb3I6W1tpdGVtLmJnQ29sb3JdXVwiPjwvZW0+XG4gICAgICAgICAgICAgICAgICBbW2l0ZW0ubGFiZWxdXVxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvdGVtcGxhdGU+XG4gICAgICA8ZGl2IGlkPVwiY2hhcnRUYXJnZXRcIiBzdHlsZT1cImhlaWdodDo0MHB4OyB3aWR0aDoxMDAlXCI+XG4gICAgICAgIDxjYW52YXMgaWQ9XCJjaGFydENhbnZhc1wiPjwvY2FudmFzPlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgY2xhc3MkPVwiY2hhcnRUb29sdGlwIFtbdG9vbHRpcC55QWxpZ25dXVwiXG4gICAgICAgICAgc3R5bGUkPVwib3BhY2l0eTpbW3Rvb2x0aXAub3BhY2l0eV1dOyB0b3A6W1t0b29sdGlwLnRvcF1dOyBsZWZ0OltbdG9vbHRpcC5sZWZ0XV07IHBhZGRpbmc6W1t0b29sdGlwLnlQYWRkaW5nXV1weCBbW3Rvb2x0aXAueFBhZGRpbmddXXB4XCJcbiAgICAgICAgPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0aXRsZVwiPltbdG9vbHRpcC50aXRsZV1dPC9kaXY+XG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgPHRlbXBsYXRlIGlzPVwiZG9tLXJlcGVhdFwiIGl0ZW1zPVwiW1t0b29sdGlwLmxpbmVzXV1cIj5cbiAgICAgICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgICAgICA8ZW0gc3R5bGUkPVwiYmFja2dyb3VuZC1jb2xvcjpbW2l0ZW0uYmdDb2xvcl1dXCI+PC9lbVxuICAgICAgICAgICAgICAgICAgPltbaXRlbS50ZXh0XV1cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICA8L3RlbXBsYXRlPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICBgO1xuICB9XG5cbiAgZ2V0IGNoYXJ0KCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFydDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogT2JqZWN0LFxuICAgICAgaWRlbnRpZmllcjogU3RyaW5nLFxuICAgICAgcmVuZGVyZWQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgfSxcbiAgICAgIG1ldGFzOiB7XG4gICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICB2YWx1ZTogKCkgPT4gW10sXG4gICAgICB9LFxuICAgICAgdG9vbHRpcDoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIHZhbHVlOiAoKSA9PiAoe1xuICAgICAgICAgIG9wYWNpdHk6IFwiMFwiLFxuICAgICAgICAgIGxlZnQ6IFwiMFwiLFxuICAgICAgICAgIHRvcDogXCIwXCIsXG4gICAgICAgICAgeFBhZGRpbmc6IFwiNVwiLFxuICAgICAgICAgIHlQYWRkaW5nOiBcIjNcIixcbiAgICAgICAgfSksXG4gICAgICB9LFxuICAgICAgdW5pdDogT2JqZWN0LFxuICAgICAgcnRsOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZXJzKCkge1xuICAgIHJldHVybiBbXCJvblByb3BzQ2hhbmdlKGRhdGEpXCJdO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICB0aGlzLl9pc0F0dGFjaGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9uUHJvcHNDaGFuZ2UoKTtcbiAgICB0aGlzLl9yZXNpemVMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2RlYm91bmNlciA9IERlYm91bmNlci5kZWJvdW5jZShcbiAgICAgICAgdGhpcy5fZGVib3VuY2VyLFxuICAgICAgICB0aW1lT3V0LmFmdGVyKDEwKSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLl9pc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZUNoYXJ0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICAgICAgZW50cmllcy5mb3JFYWNoKCgpID0+IHtcbiAgICAgICAgICB0aGlzLl9yZXNpemVMaXN0ZW5lcigpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuJC5jaGFydFRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImlyb24tcmVzaXplXCIsIHRoaXMuX3Jlc2l6ZUxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBpZiAoc2NyaXB0c0xvYWRlZCA9PT0gbnVsbCkge1xuICAgICAgc2NyaXB0c0xvYWRlZCA9IGltcG9ydChcbiAgICAgICAgLyogd2VicGFja0NodW5rTmFtZTogXCJsb2FkX2NoYXJ0XCIgKi8gXCIuLi8uLi9yZXNvdXJjZXMvaGEtY2hhcnQtc2NyaXB0cy5qc1wiXG4gICAgICApO1xuICAgIH1cbiAgICBzY3JpcHRzTG9hZGVkLnRoZW4oKENoYXJ0TW9kdWxlKSA9PiB7XG4gICAgICB0aGlzLkNoYXJ0Q2xhc3MgPSBDaGFydE1vZHVsZS5kZWZhdWx0O1xuICAgICAgdGhpcy5vblByb3BzQ2hhbmdlKCk7XG4gICAgfSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgIHRoaXMuX2lzQXR0YWNoZWQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5yZXNpemVPYnNlcnZlcikge1xuICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci51bm9ic2VydmUodGhpcy4kLmNoYXJ0VGFyZ2V0KTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpcm9uLXJlc2l6ZVwiLCB0aGlzLl9yZXNpemVMaXN0ZW5lcik7XG5cbiAgICBpZiAodGhpcy5fcmVzaXplVGltZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9yZXNpemVUaW1lcik7XG4gICAgICB0aGlzLl9yZXNpemVUaW1lciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBvblByb3BzQ2hhbmdlKCkge1xuICAgIGlmICghdGhpcy5faXNBdHRhY2hlZCB8fCAhdGhpcy5DaGFydENsYXNzIHx8ICF0aGlzLmRhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kcmF3Q2hhcnQoKTtcbiAgfVxuXG4gIF9jdXN0b21Ub29sdGlwcyh0b29sdGlwKSB7XG4gICAgLy8gSGlkZSBpZiBubyB0b29sdGlwXG4gICAgaWYgKHRvb2x0aXAub3BhY2l0eSA9PT0gMCkge1xuICAgICAgdGhpcy5zZXQoW1widG9vbHRpcFwiLCBcIm9wYWNpdHlcIl0sIDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBTZXQgY2FyZXQgUG9zaXRpb25cbiAgICBpZiAodG9vbHRpcC55QWxpZ24pIHtcbiAgICAgIHRoaXMuc2V0KFtcInRvb2x0aXBcIiwgXCJ5QWxpZ25cIl0sIHRvb2x0aXAueUFsaWduKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXQoW1widG9vbHRpcFwiLCBcInlBbGlnblwiXSwgXCJuby10cmFuc2Zvcm1cIik7XG4gICAgfVxuXG4gICAgY29uc3QgdGl0bGUgPSB0b29sdGlwLnRpdGxlID8gdG9vbHRpcC50aXRsZVswXSB8fCBcIlwiIDogXCJcIjtcbiAgICB0aGlzLnNldChbXCJ0b29sdGlwXCIsIFwidGl0bGVcIl0sIHRpdGxlKTtcblxuICAgIGNvbnN0IGJvZHlMaW5lcyA9IHRvb2x0aXAuYm9keS5tYXAoKG4pID0+IG4ubGluZXMpO1xuXG4gICAgLy8gU2V0IFRleHRcbiAgICBpZiAodG9vbHRpcC5ib2R5KSB7XG4gICAgICB0aGlzLnNldChcbiAgICAgICAgW1widG9vbHRpcFwiLCBcImxpbmVzXCJdLFxuICAgICAgICBib2R5TGluZXMubWFwKChib2R5LCBpKSA9PiB7XG4gICAgICAgICAgY29uc3QgY29sb3JzID0gdG9vbHRpcC5sYWJlbENvbG9yc1tpXTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29sb3I6IGNvbG9ycy5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgIGJnQ29sb3I6IGNvbG9ycy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICB0ZXh0OiBib2R5LmpvaW4oXCJcXG5cIiksXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudFdpZHRoID0gdGhpcy4kLmNoYXJ0VGFyZ2V0LmNsaWVudFdpZHRoO1xuICAgIGxldCBwb3NpdGlvblggPSB0b29sdGlwLmNhcmV0WDtcbiAgICBjb25zdCBwb3NpdGlvblkgPSB0aGlzLl9jaGFydC5jYW52YXMub2Zmc2V0VG9wICsgdG9vbHRpcC5jYXJldFk7XG4gICAgaWYgKHRvb2x0aXAuY2FyZXRYICsgMTAwID4gcGFyZW50V2lkdGgpIHtcbiAgICAgIHBvc2l0aW9uWCA9IHBhcmVudFdpZHRoIC0gMTAwO1xuICAgIH0gZWxzZSBpZiAodG9vbHRpcC5jYXJldFggPCAxMDApIHtcbiAgICAgIHBvc2l0aW9uWCA9IDEwMDtcbiAgICB9XG4gICAgcG9zaXRpb25YICs9IHRoaXMuX2NoYXJ0LmNhbnZhcy5vZmZzZXRMZWZ0O1xuICAgIC8vIERpc3BsYXksIHBvc2l0aW9uLCBhbmQgc2V0IHN0eWxlcyBmb3IgZm9udFxuICAgIHRoaXMudG9vbHRpcCA9IHtcbiAgICAgIC4uLnRoaXMudG9vbHRpcCxcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICBsZWZ0OiBgJHtwb3NpdGlvblh9cHhgLFxuICAgICAgdG9wOiBgJHtwb3NpdGlvbll9cHhgLFxuICAgIH07XG4gIH1cblxuICBfbGVnZW5kQ2xpY2soZXZlbnQpIHtcbiAgICBldmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQ7XG4gICAgd2hpbGUgKHRhcmdldC5ub2RlTmFtZSAhPT0gXCJMSVwiKSB7XG4gICAgICAvLyB1c2VyIGNsaWNrZWQgY2hpbGQsIGZpbmQgcGFyZW50IExJXG4gICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSBldmVudC5tb2RlbC5pdGVtc0luZGV4O1xuXG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NoYXJ0LmdldERhdGFzZXRNZXRhKGluZGV4KTtcbiAgICBtZXRhLmhpZGRlbiA9XG4gICAgICBtZXRhLmhpZGRlbiA9PT0gbnVsbCA/ICF0aGlzLl9jaGFydC5kYXRhLmRhdGFzZXRzW2luZGV4XS5oaWRkZW4gOiBudWxsO1xuICAgIHRoaXMuc2V0KFxuICAgICAgW1wibWV0YXNcIiwgaW5kZXgsIFwiaGlkZGVuXCJdLFxuICAgICAgdGhpcy5fY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpbmRleCkgPyBudWxsIDogXCJoaWRkZW5cIlxuICAgICk7XG4gICAgdGhpcy5fY2hhcnQudXBkYXRlKCk7XG4gIH1cblxuICBfZHJhd0xlZ2VuZCgpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuX2NoYXJ0O1xuICAgIC8vIE5ldyBkYXRhIGZvciBvbGQgZ3JhcGguIEtlZXAgbWV0YWRhdGEuXG4gICAgY29uc3QgcHJlc2VydmVWaXNpYmlsaXR5ID1cbiAgICAgIHRoaXMuX29sZElkZW50aWZpZXIgJiYgdGhpcy5pZGVudGlmaWVyID09PSB0aGlzLl9vbGRJZGVudGlmaWVyO1xuICAgIHRoaXMuX29sZElkZW50aWZpZXIgPSB0aGlzLmlkZW50aWZpZXI7XG4gICAgdGhpcy5zZXQoXG4gICAgICBcIm1ldGFzXCIsXG4gICAgICB0aGlzLl9jaGFydC5kYXRhLmRhdGFzZXRzLm1hcCgoeCwgaSkgPT4gKHtcbiAgICAgICAgbGFiZWw6IHgubGFiZWwsXG4gICAgICAgIGNvbG9yOiB4LmNvbG9yLFxuICAgICAgICBiZ0NvbG9yOiB4LmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgaGlkZGVuOlxuICAgICAgICAgIHByZXNlcnZlVmlzaWJpbGl0eSAmJiBpIDwgdGhpcy5tZXRhcy5sZW5ndGhcbiAgICAgICAgICAgID8gdGhpcy5tZXRhc1tpXS5oaWRkZW5cbiAgICAgICAgICAgIDogIWNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSksXG4gICAgICB9KSlcbiAgICApO1xuICAgIGxldCB1cGRhdGVOZWVkZWQgPSBmYWxzZTtcbiAgICBpZiAocHJlc2VydmVWaXNpYmlsaXR5KSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWV0YXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgICBpZiAoISFtZXRhLmhpZGRlbiAhPT0gISF0aGlzLm1ldGFzW2ldLmhpZGRlbikgdXBkYXRlTmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgbWV0YS5oaWRkZW4gPSB0aGlzLm1ldGFzW2ldLmhpZGRlbiA/IHRydWUgOiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodXBkYXRlTmVlZGVkKSB7XG4gICAgICBjaGFydC51cGRhdGUoKTtcbiAgICB9XG4gICAgdGhpcy51bml0ID0gdGhpcy5kYXRhLnVuaXQ7XG4gIH1cblxuICBfZm9ybWF0VGlja1ZhbHVlKHZhbHVlLCBpbmRleCwgdmFsdWVzKSB7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHZhbHVlc1tpbmRleF0udmFsdWUpO1xuICAgIHJldHVybiBmb3JtYXRUaW1lKGRhdGUpO1xuICB9XG5cbiAgZHJhd0NoYXJ0KCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGEuZGF0YTtcbiAgICBjb25zdCBjdHggPSB0aGlzLiQuY2hhcnRDYW52YXM7XG5cbiAgICBpZiAoKCFkYXRhLmRhdGFzZXRzIHx8ICFkYXRhLmRhdGFzZXRzLmxlbmd0aCkgJiYgIXRoaXMuX2NoYXJ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmRhdGEudHlwZSAhPT0gXCJ0aW1lbGluZVwiICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY250ID0gZGF0YS5kYXRhc2V0cy5sZW5ndGg7XG4gICAgICBjb25zdCBjb2xvcnMgPSB0aGlzLmNvbnN0cnVjdG9yLmdldENvbG9yTGlzdChjbnQpO1xuICAgICAgZm9yIChsZXQgbG9vcEkgPSAwOyBsb29wSSA8IGNudDsgbG9vcEkrKykge1xuICAgICAgICBkYXRhLmRhdGFzZXRzW2xvb3BJXS5ib3JkZXJDb2xvciA9IGNvbG9yc1tsb29wSV0ucmdiU3RyaW5nKCk7XG4gICAgICAgIGRhdGEuZGF0YXNldHNbbG9vcEldLmJhY2tncm91bmRDb2xvciA9IGNvbG9yc1tsb29wSV1cbiAgICAgICAgICAuYWxwaGEoMC42KVxuICAgICAgICAgIC5yZ2JhU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NoYXJ0KSB7XG4gICAgICB0aGlzLl9jdXN0b21Ub29sdGlwcyh7IG9wYWNpdHk6IDAgfSk7XG4gICAgICB0aGlzLl9jaGFydC5kYXRhID0gZGF0YTtcbiAgICAgIHRoaXMuX2NoYXJ0LnVwZGF0ZSh7IGR1cmF0aW9uOiAwIH0pO1xuICAgICAgaWYgKHRoaXMuaXNUaW1lbGluZSkge1xuICAgICAgICB0aGlzLl9jaGFydC5vcHRpb25zLnNjYWxlcy55QXhlc1swXS5ncmlkTGluZXMuZGlzcGxheSA9IGRhdGEubGVuZ3RoID4gMTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLmxlZ2VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9kcmF3TGVnZW5kKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2l6ZUNoYXJ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghZGF0YS5kYXRhc2V0cykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9jdXN0b21Ub29sdGlwcyh7IG9wYWNpdHk6IDAgfSk7XG4gICAgICBjb25zdCBwbHVnaW5zID0gW3sgYWZ0ZXJSZW5kZXI6ICgpID0+IHRoaXMuX3NldFJlbmRlcmVkKHRydWUpIH1dO1xuICAgICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgIHJlc3BvbnNpdmU6IHRydWUsXG4gICAgICAgIG1haW50YWluQXNwZWN0UmF0aW86IGZhbHNlLFxuICAgICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgfSxcbiAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICBhbmltYXRpb25EdXJhdGlvbjogMCxcbiAgICAgICAgfSxcbiAgICAgICAgcmVzcG9uc2l2ZUFuaW1hdGlvbkR1cmF0aW9uOiAwLFxuICAgICAgICB0b29sdGlwczoge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgIGN1c3RvbTogdGhpcy5fY3VzdG9tVG9vbHRpcHMuYmluZCh0aGlzKSxcbiAgICAgICAgfSxcbiAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIGxpbmU6IHtcbiAgICAgICAgICBzcGFuR2FwczogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgICBmb250OiBcIjEycHggJ1JvYm90bycsICdzYW5zLXNlcmlmJ1wiLFxuICAgICAgICB9LFxuICAgICAgICB0aWNrczoge1xuICAgICAgICAgIGZvbnRGYW1pbHk6IFwiJ1JvYm90bycsICdzYW5zLXNlcmlmJ1wiLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICAgIG9wdGlvbnMgPSBDaGFydC5oZWxwZXJzLm1lcmdlKG9wdGlvbnMsIHRoaXMuZGF0YS5vcHRpb25zKTtcbiAgICAgIG9wdGlvbnMuc2NhbGVzLnhBeGVzWzBdLnRpY2tzLmNhbGxiYWNrID0gdGhpcy5fZm9ybWF0VGlja1ZhbHVlO1xuICAgICAgaWYgKHRoaXMuZGF0YS50eXBlID09PSBcInRpbWVsaW5lXCIpIHtcbiAgICAgICAgdGhpcy5zZXQoXCJpc1RpbWVsaW5lXCIsIHRydWUpO1xuICAgICAgICBpZiAodGhpcy5kYXRhLmNvbG9ycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5fY29sb3JGdW5jID0gdGhpcy5jb25zdHJ1Y3Rvci5nZXRDb2xvckdlbmVyYXRvcihcbiAgICAgICAgICAgIHRoaXMuZGF0YS5jb2xvcnMuc3RhdGljQ29sb3JzLFxuICAgICAgICAgICAgdGhpcy5kYXRhLmNvbG9ycy5zdGF0aWNDb2xvckluZGV4XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY29sb3JGdW5jICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvcHRpb25zLmVsZW1lbnRzLmNvbG9yRnVuY3Rpb24gPSB0aGlzLl9jb2xvckZ1bmM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZGF0YXNldHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuc2NhbGVzLnlBeGVzWzBdLnRpY2tzKSB7XG4gICAgICAgICAgICBvcHRpb25zLnNjYWxlcy55QXhlc1swXS50aWNrcy5kaXNwbGF5ID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2NhbGVzLnlBeGVzWzBdLnRpY2tzID0geyBkaXNwbGF5OiBmYWxzZSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9ucy5zY2FsZXMueUF4ZXNbMF0uZ3JpZExpbmVzKSB7XG4gICAgICAgICAgICBvcHRpb25zLnNjYWxlcy55QXhlc1swXS5ncmlkTGluZXMuZGlzcGxheSA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zLnNjYWxlcy55QXhlc1swXS5ncmlkTGluZXMgPSB7IGRpc3BsYXk6IGZhbHNlIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuJC5jaGFydFRhcmdldC5zdHlsZS5oZWlnaHQgPSBcIjUwcHhcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuJC5jaGFydFRhcmdldC5zdHlsZS5oZWlnaHQgPSBcIjE2MHB4XCI7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGFydERhdGEgPSB7XG4gICAgICAgIHR5cGU6IHRoaXMuZGF0YS50eXBlLFxuICAgICAgICBkYXRhOiB0aGlzLmRhdGEuZGF0YSxcbiAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgcGx1Z2luczogcGx1Z2lucyxcbiAgICAgIH07XG4gICAgICAvLyBBc3luYyByZXNpemUgYWZ0ZXIgZG9tIHVwZGF0ZVxuICAgICAgdGhpcy5fY2hhcnQgPSBuZXcgdGhpcy5DaGFydENsYXNzKGN0eCwgY2hhcnREYXRhKTtcbiAgICAgIGlmICh0aGlzLmlzVGltZWxpbmUgIT09IHRydWUgJiYgdGhpcy5kYXRhLmxlZ2VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9kcmF3TGVnZW5kKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2l6ZUNoYXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgcmVzaXplQ2hhcnQoKSB7XG4gICAgaWYgKCF0aGlzLl9jaGFydCkgcmV0dXJuO1xuICAgIC8vIENoYXJ0IG5vdCByZWFkeVxuICAgIGlmICh0aGlzLl9yZXNpemVUaW1lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9yZXNpemVUaW1lciA9IHNldEludGVydmFsKHRoaXMucmVzaXplQ2hhcnQuYmluZCh0aGlzKSwgMTApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fcmVzaXplVGltZXIpO1xuICAgIHRoaXMuX3Jlc2l6ZVRpbWVyID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5fcmVzaXplQ2hhcnQoKTtcbiAgfVxuXG4gIF9yZXNpemVDaGFydCgpIHtcbiAgICBjb25zdCBjaGFydFRhcmdldCA9IHRoaXMuJC5jaGFydFRhcmdldDtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgZGF0YSA9IG9wdGlvbnMuZGF0YTtcblxuICAgIGlmIChkYXRhLmRhdGFzZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc1RpbWVsaW5lKSB7XG4gICAgICB0aGlzLl9jaGFydC5yZXNpemUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBSZWNhbGN1bGF0ZSBjaGFydCBoZWlnaHQgZm9yIFRpbWVsaW5lIGNoYXJ0XG4gICAgY29uc3QgYXJlYVRvcCA9IHRoaXMuX2NoYXJ0LmNoYXJ0QXJlYS50b3A7XG4gICAgY29uc3QgYXJlYUJvdCA9IHRoaXMuX2NoYXJ0LmNoYXJ0QXJlYS5ib3R0b207XG4gICAgY29uc3QgaGVpZ2h0MSA9IHRoaXMuX2NoYXJ0LmNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgaWYgKGFyZWFCb3QgPiAwKSB7XG4gICAgICB0aGlzLl9heGlzSGVpZ2h0ID0gaGVpZ2h0MSAtIGFyZWFCb3QgKyBhcmVhVG9wO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fYXhpc0hlaWdodCkge1xuICAgICAgY2hhcnRUYXJnZXQuc3R5bGUuaGVpZ2h0ID0gXCI1MHB4XCI7XG4gICAgICB0aGlzLl9jaGFydC5yZXNpemUoKTtcbiAgICAgIHRoaXMucmVzaXplQ2hhcnQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2F4aXNIZWlnaHQpIHtcbiAgICAgIGNvbnN0IGNudCA9IGRhdGEuZGF0YXNldHMubGVuZ3RoO1xuICAgICAgY29uc3QgdGFyZ2V0SGVpZ2h0ID0gMzAgKiBjbnQgKyB0aGlzLl9heGlzSGVpZ2h0ICsgXCJweFwiO1xuICAgICAgaWYgKGNoYXJ0VGFyZ2V0LnN0eWxlLmhlaWdodCAhPT0gdGFyZ2V0SGVpZ2h0KSB7XG4gICAgICAgIGNoYXJ0VGFyZ2V0LnN0eWxlLmhlaWdodCA9IHRhcmdldEhlaWdodDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NoYXJ0LnJlc2l6ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdldCBIU0wgZGlzdHJpYnV0ZWQgY29sb3IgbGlzdFxuICBzdGF0aWMgZ2V0Q29sb3JMaXN0KGNvdW50KSB7XG4gICAgbGV0IHByb2Nlc3NMID0gZmFsc2U7XG4gICAgaWYgKGNvdW50ID4gMTApIHtcbiAgICAgIHByb2Nlc3NMID0gdHJ1ZTtcbiAgICAgIGNvdW50ID0gTWF0aC5jZWlsKGNvdW50IC8gMik7XG4gICAgfVxuICAgIGNvbnN0IGgxID0gMzYwIC8gY291bnQ7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgbG9vcEkgPSAwOyBsb29wSSA8IGNvdW50OyBsb29wSSsrKSB7XG4gICAgICByZXN1bHRbbG9vcEldID0gQ29sb3IoKS5oc2woaDEgKiBsb29wSSwgODAsIDM4KTtcbiAgICAgIGlmIChwcm9jZXNzTCkge1xuICAgICAgICByZXN1bHRbbG9vcEkgKyBjb3VudF0gPSBDb2xvcigpLmhzbChoMSAqIGxvb3BJLCA4MCwgNjIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgc3RhdGljIGdldENvbG9yR2VuZXJhdG9yKHN0YXRpY0NvbG9ycywgc3RhcnRJbmRleCkge1xuICAgIC8vIEtub3duIGNvbG9ycyBmb3Igc3RhdGljIGRhdGEsXG4gICAgLy8gc2hvdWxkIGFkZCBmb3IgdmVyeSBjb21tb24gc3RhdGUgc3RyaW5nIG1hbnVhbGx5LlxuICAgIC8vIFBhbGV0dGUgbW9kaWZpZWQgZnJvbSBodHRwOi8vZ29vZ2xlLmdpdGh1Yi5pby9wYWxldHRlLmpzLyBtcG42NSwgQXBhY2hlIDIuMFxuICAgIGNvbnN0IHBhbGV0dGUgPSBbXG4gICAgICBcImZmMDAyOVwiLFxuICAgICAgXCI2NmE2MWVcIixcbiAgICAgIFwiMzc3ZWI4XCIsXG4gICAgICBcIjk4NGVhM1wiLFxuICAgICAgXCIwMGQyZDVcIixcbiAgICAgIFwiZmY3ZjAwXCIsXG4gICAgICBcImFmOGQwMFwiLFxuICAgICAgXCI3ZjgwY2RcIixcbiAgICAgIFwiYjNlOTAwXCIsXG4gICAgICBcImM0MmU2MFwiLFxuICAgICAgXCJhNjU2MjhcIixcbiAgICAgIFwiZjc4MWJmXCIsXG4gICAgICBcIjhkZDNjN1wiLFxuICAgICAgXCJiZWJhZGFcIixcbiAgICAgIFwiZmI4MDcyXCIsXG4gICAgICBcIjgwYjFkM1wiLFxuICAgICAgXCJmZGI0NjJcIixcbiAgICAgIFwiZmNjZGU1XCIsXG4gICAgICBcImJjODBiZFwiLFxuICAgICAgXCJmZmVkNmZcIixcbiAgICAgIFwiYzRlYWZmXCIsXG4gICAgICBcImNmOGMwMFwiLFxuICAgICAgXCIxYjllNzdcIixcbiAgICAgIFwiZDk1ZjAyXCIsXG4gICAgICBcImU3Mjk4YVwiLFxuICAgICAgXCJlNmFiMDJcIixcbiAgICAgIFwiYTY3NjFkXCIsXG4gICAgICBcIjAwOTdmZlwiLFxuICAgICAgXCIwMGQwNjdcIixcbiAgICAgIFwiZjQzNjAwXCIsXG4gICAgICBcIjRiYTkzYlwiLFxuICAgICAgXCI1Nzc5YmJcIixcbiAgICAgIFwiOTI3YWNjXCIsXG4gICAgICBcIjk3ZWUzZlwiLFxuICAgICAgXCJiZjM5NDdcIixcbiAgICAgIFwiOWY1YjAwXCIsXG4gICAgICBcImY0ODc1OFwiLFxuICAgICAgXCI4Y2FlZDZcIixcbiAgICAgIFwiZjJiOTRmXCIsXG4gICAgICBcImVmZjI2ZVwiLFxuICAgICAgXCJlNDM4NzJcIixcbiAgICAgIFwiZDliMTAwXCIsXG4gICAgICBcIjlkN2EwMFwiLFxuICAgICAgXCI2OThjZmZcIixcbiAgICAgIFwiZDlkOWQ5XCIsXG4gICAgICBcIjAwZDI3ZVwiLFxuICAgICAgXCJkMDY4MDBcIixcbiAgICAgIFwiMDA5ZjgyXCIsXG4gICAgICBcImM0OTIwMFwiLFxuICAgICAgXCJjYmU4ZmZcIixcbiAgICAgIFwiZmVjZGRmXCIsXG4gICAgICBcImMyN2ViNlwiLFxuICAgICAgXCI4Y2QyY2VcIixcbiAgICAgIFwiYzRiOGQ5XCIsXG4gICAgICBcImY4ODNiMFwiLFxuICAgICAgXCJhNDkxMDBcIixcbiAgICAgIFwiZjQ4ODAwXCIsXG4gICAgICBcIjI3ZDBkZlwiLFxuICAgICAgXCJhMDRhOWJcIixcbiAgICBdO1xuICAgIGZ1bmN0aW9uIGdldENvbG9ySW5kZXgoaWR4KSB7XG4gICAgICAvLyBSZXVzZSB0aGUgY29sb3IgaWYgaW5kZXggdG9vIGxhcmdlLlxuICAgICAgcmV0dXJuIENvbG9yKFwiI1wiICsgcGFsZXR0ZVtpZHggJSBwYWxldHRlLmxlbmd0aF0pO1xuICAgIH1cbiAgICBjb25zdCBjb2xvckRpY3QgPSB7fTtcbiAgICBsZXQgY29sb3JJbmRleCA9IDA7XG4gICAgaWYgKHN0YXJ0SW5kZXggPiAwKSBjb2xvckluZGV4ID0gc3RhcnRJbmRleDtcbiAgICBpZiAoc3RhdGljQ29sb3JzKSB7XG4gICAgICBPYmplY3Qua2V5cyhzdGF0aWNDb2xvcnMpLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgY29uc3QgYzEgPSBzdGF0aWNDb2xvcnNbY107XG4gICAgICAgIGlmIChpc0Zpbml0ZShjMSkpIHtcbiAgICAgICAgICBjb2xvckRpY3RbYy50b0xvd2VyQ2FzZSgpXSA9IGdldENvbG9ySW5kZXgoYzEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbG9yRGljdFtjLnRvTG93ZXJDYXNlKCldID0gQ29sb3Ioc3RhdGljQ29sb3JzW2NdKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEN1c3RvbSBjb2xvciBhc3NpZ25cbiAgICBmdW5jdGlvbiBnZXRDb2xvcihfXywgZGF0YSkge1xuICAgICAgbGV0IHJldDtcbiAgICAgIGNvbnN0IG5hbWUgPSBkYXRhWzNdO1xuICAgICAgaWYgKG5hbWUgPT09IG51bGwpIHJldHVybiBDb2xvcigpLmhzbCgwLCA0MCwgMzgpO1xuICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIENvbG9yKCkuaHNsKDEyMCwgNDAsIDM4KTtcbiAgICAgIGNvbnN0IG5hbWUxID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKHJldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldCA9IGNvbG9yRGljdFtuYW1lMV07XG4gICAgICB9XG4gICAgICBpZiAocmV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0ID0gZ2V0Q29sb3JJbmRleChjb2xvckluZGV4KTtcbiAgICAgICAgY29sb3JJbmRleCsrO1xuICAgICAgICBjb2xvckRpY3RbbmFtZTFdID0gcmV0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgcmV0dXJuIGdldENvbG9yO1xuICB9XG59XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoXCJoYS1jaGFydC1iYXNlXCIsIEhhQ2hhcnRCYXNlKTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUErS0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwUUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFHQTtBQUNBOzs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQUE7QUFVQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7O0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBdkJBO0FBMkJBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQS9XQTtBQUNBO0FBQ0E7OztBQStXQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTREQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7QUF6bUJBO0FBQ0E7QUFnSUE7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFBQTtBQUZBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQXhCQTtBQTZCQTs7O0FBRUE7QUFDQTtBQUNBOzs7O0FBN0tBO0FBQ0E7QUE4bUJBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/entity/ha-chart-base.js\n");

/***/ }),

/***/ "./src/components/state-history-chart-line.js":
/*!****************************************************!*\
  !*** ./src/components/state-history-chart-line.js ***!
  \****************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _polymer_polymer_lib_utils_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/lib/utils/debounce */ \"./node_modules/@polymer/polymer/lib/utils/debounce.js\");\n/* harmony import */ var _polymer_polymer_lib_utils_html_tag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @polymer/polymer/lib/utils/html-tag */ \"./node_modules/@polymer/polymer/lib/utils/html-tag.js\");\n/* harmony import */ var _polymer_polymer_polymer_element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @polymer/polymer/polymer-element */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n/* harmony import */ var _common_datetime_format_date_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/datetime/format_date_time */ \"./src/common/datetime/format_date_time.ts\");\n/* harmony import */ var _mixins_localize_mixin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../mixins/localize-mixin */ \"./src/mixins/localize-mixin.js\");\n/* harmony import */ var _entity_ha_chart_base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./entity/ha-chart-base */ \"./src/components/entity/ha-chart-base.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n      <style>\\n        :host {\\n          display: block;\\n          overflow: hidden;\\n          height: 0;\\n          transition: height 0.3s ease-in-out;\\n        }\\n      </style>\\n      <ha-chart-base\\n        id=\\\"chart\\\"\\n        data=\\\"[[chartData]]\\\"\\n        identifier=\\\"[[identifier]]\\\"\\n        rendered=\\\"{{rendered}}\\\"\\n      ></ha-chart-base>\\n    \"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n/* eslint-plugin-disable lit */\n\n\n\n\n\n\nvar StateHistoryChartLine = /*#__PURE__*/function (_LocalizeMixin) {\n  _inherits(StateHistoryChartLine, _LocalizeMixin);\n\n  var _super = _createSuper(StateHistoryChartLine);\n\n  function StateHistoryChartLine() {\n    _classCallCheck(this, StateHistoryChartLine);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(StateHistoryChartLine, [{\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      _get(_getPrototypeOf(StateHistoryChartLine.prototype), \"connectedCallback\", this).call(this);\n\n      this._isAttached = true;\n      this.drawChart();\n    }\n  }, {\n    key: \"dataChanged\",\n    value: function dataChanged() {\n      this.drawChart();\n    }\n  }, {\n    key: \"_onRenderedChanged\",\n    value: function _onRenderedChanged(rendered) {\n      if (rendered) this.animateHeight();\n    }\n  }, {\n    key: \"animateHeight\",\n    value: function animateHeight() {\n      var _this = this;\n\n      requestAnimationFrame(function () {\n        return requestAnimationFrame(function () {\n          _this.style.height = _this.$.chart.scrollHeight + \"px\";\n        });\n      });\n    }\n  }, {\n    key: \"drawChart\",\n    value: function drawChart() {\n      var _this2 = this;\n\n      var unit = this.unit;\n      var deviceStates = this.data;\n      var datasets = [];\n      var endTime;\n\n      if (!this._isAttached) {\n        return;\n      }\n\n      if (deviceStates.length === 0) {\n        return;\n      }\n\n      function safeParseFloat(value) {\n        var parsed = parseFloat(value);\n        return isFinite(parsed) ? parsed : null;\n      }\n\n      endTime = this.endTime || // Get the highest date from the last date of each device\n      new Date(Math.max.apply(null, deviceStates.map(function (devSts) {\n        return new Date(devSts.states[devSts.states.length - 1].last_changed);\n      })));\n\n      if (endTime > new Date()) {\n        endTime = new Date();\n      }\n\n      var names = this.names || {};\n      deviceStates.forEach(function (states) {\n        var domain = states.domain;\n        var name = names[states.entity_id] || states.name; // array containing [value1, value2, etc]\n\n        var prevValues;\n        var data = [];\n\n        function pushData(timestamp, datavalues) {\n          if (!datavalues) return;\n\n          if (timestamp > endTime) {\n            // Drop datapoints that are after the requested endTime. This could happen if\n            // endTime is \"now\" and client time is not in sync with server time.\n            return;\n          }\n\n          data.forEach(function (d, i) {\n            d.data.push({\n              x: timestamp,\n              y: datavalues[i]\n            });\n          });\n          prevValues = datavalues;\n        }\n\n        function addColumn(nameY, step, fill) {\n          var dataFill = false;\n          var dataStep = false;\n\n          if (fill) {\n            dataFill = \"origin\";\n          }\n\n          if (step) {\n            dataStep = \"before\";\n          }\n\n          data.push({\n            label: nameY,\n            fill: dataFill,\n            steppedLine: dataStep,\n            pointRadius: 0,\n            data: [],\n            unitText: unit\n          });\n        }\n\n        if (domain === \"thermostat\" || domain === \"climate\" || domain === \"water_heater\") {\n          var hasHvacAction = states.states.some(function (state) {\n            return state.attributes && state.attributes.hvac_action;\n          });\n          var isHeating = domain === \"climate\" && hasHvacAction ? function (state) {\n            return state.attributes.hvac_action === \"heating\";\n          } : function (state) {\n            return state.state === \"heat\";\n          };\n          var isCooling = domain === \"climate\" && hasHvacAction ? function (state) {\n            return state.attributes.hvac_action === \"cooling\";\n          } : function (state) {\n            return state.state === \"cool\";\n          };\n          var hasHeat = states.states.some(isHeating);\n          var hasCool = states.states.some(isCooling); // We differentiate between thermostats that have a target temperature\n          // range versus ones that have just a target temperature\n          // Using step chart by step-before so manually interpolation not needed.\n\n          var hasTargetRange = states.states.some(function (state) {\n            return state.attributes && state.attributes.target_temp_high !== state.attributes.target_temp_low;\n          });\n          addColumn(\"\".concat(_this2.hass.localize(\"ui.card.climate.current_temperature\", \"name\", name)), true);\n\n          if (hasHeat) {\n            addColumn(\"\".concat(_this2.hass.localize(\"ui.card.climate.heating\", \"name\", name)), true, true); // The \"heating\" series uses steppedArea to shade the area below the current\n            // temperature when the thermostat is calling for heat.\n          }\n\n          if (hasCool) {\n            addColumn(\"\".concat(_this2.hass.localize(\"ui.card.climate.cooling\", \"name\", name)), true, true); // The \"cooling\" series uses steppedArea to shade the area below the current\n            // temperature when the thermostat is calling for heat.\n          }\n\n          if (hasTargetRange) {\n            addColumn(\"\".concat(_this2.hass.localize(\"ui.card.climate.target_temperature_mode\", \"name\", name, \"mode\", _this2.hass.localize(\"ui.card.climate.high\"))), true);\n            addColumn(\"\".concat(_this2.hass.localize(\"ui.card.climate.target_temperature_mode\", \"name\", name, \"mode\", _this2.hass.localize(\"ui.card.climate.low\"))), true);\n          } else {\n            addColumn(\"\".concat(_this2.hass.localize(\"ui.card.climate.target_temperature_entity\", \"name\", name)), true);\n          }\n\n          states.states.forEach(function (state) {\n            if (!state.attributes) return;\n            var curTemp = safeParseFloat(state.attributes.current_temperature);\n            var series = [curTemp];\n\n            if (hasHeat) {\n              series.push(isHeating(state) ? curTemp : null);\n            }\n\n            if (hasCool) {\n              series.push(isCooling(state) ? curTemp : null);\n            }\n\n            if (hasTargetRange) {\n              var targetHigh = safeParseFloat(state.attributes.target_temp_high);\n              var targetLow = safeParseFloat(state.attributes.target_temp_low);\n              series.push(targetHigh, targetLow);\n              pushData(new Date(state.last_changed), series);\n            } else {\n              var target = safeParseFloat(state.attributes.temperature);\n              series.push(target);\n              pushData(new Date(state.last_changed), series);\n            }\n          });\n        } else {\n          // Only disable interpolation for sensors\n          var isStep = domain === \"sensor\";\n          addColumn(name, isStep);\n          var lastValue = null;\n          var lastDate = null;\n          var lastNullDate = null; // Process chart data.\n          // When state is `unknown`, calculate the value and break the line.\n\n          states.states.forEach(function (state) {\n            var value = safeParseFloat(state.state);\n            var date = new Date(state.last_changed);\n\n            if (value !== null && lastNullDate !== null) {\n              var dateTime = date.getTime();\n              var lastNullDateTime = lastNullDate.getTime();\n              var lastDateTime = lastDate.getTime();\n              var tmpValue = (value - lastValue) * ((lastNullDateTime - lastDateTime) / (dateTime - lastDateTime)) + lastValue;\n              pushData(lastNullDate, [tmpValue]);\n              pushData(new Date(lastNullDateTime + 1), [null]);\n              pushData(date, [value]);\n              lastDate = date;\n              lastValue = value;\n              lastNullDate = null;\n            } else if (value !== null && lastNullDate === null) {\n              pushData(date, [value]);\n              lastDate = date;\n              lastValue = value;\n            } else if (value === null && lastNullDate === null && lastValue !== null) {\n              lastNullDate = date;\n            }\n          });\n        } // Add an entry for final values\n\n\n        pushData(endTime, prevValues, false); // Concat two arrays\n\n        Array.prototype.push.apply(datasets, data);\n      });\n\n      var formatTooltipTitle = function formatTooltipTitle(items, data) {\n        var item = items[0];\n        var date = data.datasets[item.datasetIndex].data[item.index].x;\n        return Object(_common_datetime_format_date_time__WEBPACK_IMPORTED_MODULE_3__[\"formatDateTimeWithSeconds\"])(date, _this2.hass.language);\n      };\n\n      var chartOptions = {\n        type: \"line\",\n        unit: unit,\n        legend: !this.isSingleDevice,\n        options: {\n          scales: {\n            xAxes: [{\n              type: \"time\",\n              ticks: {\n                major: {\n                  fontStyle: \"bold\"\n                }\n              }\n            }],\n            yAxes: [{\n              ticks: {\n                maxTicksLimit: 7\n              }\n            }]\n          },\n          tooltips: {\n            mode: \"neareach\",\n            callbacks: {\n              title: formatTooltipTitle\n            }\n          },\n          hover: {\n            mode: \"neareach\"\n          },\n          layout: {\n            padding: {\n              top: 5\n            }\n          },\n          elements: {\n            line: {\n              tension: 0.1,\n              pointRadius: 0,\n              borderWidth: 1.5\n            },\n            point: {\n              hitRadius: 5\n            }\n          },\n          plugins: {\n            filler: {\n              propagate: true\n            }\n          }\n        },\n        data: {\n          labels: [],\n          datasets: datasets\n        }\n      };\n      this.chartData = chartOptions;\n    }\n  }], [{\n    key: \"template\",\n    get: function get() {\n      return Object(_polymer_polymer_lib_utils_html_tag__WEBPACK_IMPORTED_MODULE_1__[\"html\"])(_templateObject());\n    }\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return {\n        chartData: Object,\n        data: Object,\n        names: Object,\n        unit: String,\n        identifier: String,\n        isSingleDevice: {\n          type: Boolean,\n          value: false\n        },\n        endTime: Object,\n        rendered: {\n          type: Boolean,\n          value: false,\n          observer: \"_onRenderedChanged\"\n        }\n      };\n    }\n  }, {\n    key: \"observers\",\n    get: function get() {\n      return [\"dataChanged(data, endTime, isSingleDevice)\"];\n    }\n  }]);\n\n  return StateHistoryChartLine;\n}(Object(_mixins_localize_mixin__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(_polymer_polymer_polymer_element__WEBPACK_IMPORTED_MODULE_2__[\"PolymerElement\"]));\n\ncustomElements.define(\"state-history-chart-line\", StateHistoryChartLine);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9zdGF0ZS1oaXN0b3J5LWNoYXJ0LWxpbmUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9zdGF0ZS1oaXN0b3J5LWNoYXJ0LWxpbmUuanM/YjcyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXCJAcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9kZWJvdW5jZVwiO1xuaW1wb3J0IHsgaHRtbCB9IGZyb20gXCJAcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9odG1sLXRhZ1wiO1xuLyogZXNsaW50LXBsdWdpbi1kaXNhYmxlIGxpdCAqL1xuaW1wb3J0IHsgUG9seW1lckVsZW1lbnQgfSBmcm9tIFwiQHBvbHltZXIvcG9seW1lci9wb2x5bWVyLWVsZW1lbnRcIjtcbmltcG9ydCB7IGZvcm1hdERhdGVUaW1lV2l0aFNlY29uZHMgfSBmcm9tIFwiLi4vY29tbW9uL2RhdGV0aW1lL2Zvcm1hdF9kYXRlX3RpbWVcIjtcbmltcG9ydCBMb2NhbGl6ZU1peGluIGZyb20gXCIuLi9taXhpbnMvbG9jYWxpemUtbWl4aW5cIjtcbmltcG9ydCBcIi4vZW50aXR5L2hhLWNoYXJ0LWJhc2VcIjtcblxuY2xhc3MgU3RhdGVIaXN0b3J5Q2hhcnRMaW5lIGV4dGVuZHMgTG9jYWxpemVNaXhpbihQb2x5bWVyRWxlbWVudCkge1xuICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkge1xuICAgIHJldHVybiBodG1sYFxuICAgICAgPHN0eWxlPlxuICAgICAgICA6aG9zdCB7XG4gICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgICBoZWlnaHQ6IDA7XG4gICAgICAgICAgdHJhbnNpdGlvbjogaGVpZ2h0IDAuM3MgZWFzZS1pbi1vdXQ7XG4gICAgICAgIH1cbiAgICAgIDwvc3R5bGU+XG4gICAgICA8aGEtY2hhcnQtYmFzZVxuICAgICAgICBpZD1cImNoYXJ0XCJcbiAgICAgICAgZGF0YT1cIltbY2hhcnREYXRhXV1cIlxuICAgICAgICBpZGVudGlmaWVyPVwiW1tpZGVudGlmaWVyXV1cIlxuICAgICAgICByZW5kZXJlZD1cInt7cmVuZGVyZWR9fVwiXG4gICAgICA+PC9oYS1jaGFydC1iYXNlPlxuICAgIGA7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoYXJ0RGF0YTogT2JqZWN0LFxuICAgICAgZGF0YTogT2JqZWN0LFxuICAgICAgbmFtZXM6IE9iamVjdCxcbiAgICAgIHVuaXQ6IFN0cmluZyxcbiAgICAgIGlkZW50aWZpZXI6IFN0cmluZyxcblxuICAgICAgaXNTaW5nbGVEZXZpY2U6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgfSxcblxuICAgICAgZW5kVGltZTogT2JqZWN0LFxuICAgICAgcmVuZGVyZWQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICBvYnNlcnZlcjogXCJfb25SZW5kZXJlZENoYW5nZWRcIixcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZXJzKCkge1xuICAgIHJldHVybiBbXCJkYXRhQ2hhbmdlZChkYXRhLCBlbmRUaW1lLCBpc1NpbmdsZURldmljZSlcIl07XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgIHRoaXMuX2lzQXR0YWNoZWQgPSB0cnVlO1xuICAgIHRoaXMuZHJhd0NoYXJ0KCk7XG4gIH1cblxuICBkYXRhQ2hhbmdlZCgpIHtcbiAgICB0aGlzLmRyYXdDaGFydCgpO1xuICB9XG5cbiAgX29uUmVuZGVyZWRDaGFuZ2VkKHJlbmRlcmVkKSB7XG4gICAgaWYgKHJlbmRlcmVkKSB0aGlzLmFuaW1hdGVIZWlnaHQoKTtcbiAgfVxuXG4gIGFuaW1hdGVIZWlnaHQoKSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB0aGlzLnN0eWxlLmhlaWdodCA9IHRoaXMuJC5jaGFydC5zY3JvbGxIZWlnaHQgKyBcInB4XCI7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBkcmF3Q2hhcnQoKSB7XG4gICAgY29uc3QgdW5pdCA9IHRoaXMudW5pdDtcbiAgICBjb25zdCBkZXZpY2VTdGF0ZXMgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgZGF0YXNldHMgPSBbXTtcbiAgICBsZXQgZW5kVGltZTtcblxuICAgIGlmICghdGhpcy5faXNBdHRhY2hlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkZXZpY2VTdGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2FmZVBhcnNlRmxvYXQodmFsdWUpIHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgcmV0dXJuIGlzRmluaXRlKHBhcnNlZCkgPyBwYXJzZWQgOiBudWxsO1xuICAgIH1cblxuICAgIGVuZFRpbWUgPVxuICAgICAgdGhpcy5lbmRUaW1lIHx8XG4gICAgICAvLyBHZXQgdGhlIGhpZ2hlc3QgZGF0ZSBmcm9tIHRoZSBsYXN0IGRhdGUgb2YgZWFjaCBkZXZpY2VcbiAgICAgIG5ldyBEYXRlKFxuICAgICAgICBNYXRoLm1heC5hcHBseShcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIGRldmljZVN0YXRlcy5tYXAoXG4gICAgICAgICAgICAoZGV2U3RzKSA9PlxuICAgICAgICAgICAgICBuZXcgRGF0ZShkZXZTdHMuc3RhdGVzW2RldlN0cy5zdGF0ZXMubGVuZ3RoIC0gMV0ubGFzdF9jaGFuZ2VkKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICBpZiAoZW5kVGltZSA+IG5ldyBEYXRlKCkpIHtcbiAgICAgIGVuZFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IG5hbWVzID0gdGhpcy5uYW1lcyB8fCB7fTtcbiAgICBkZXZpY2VTdGF0ZXMuZm9yRWFjaCgoc3RhdGVzKSA9PiB7XG4gICAgICBjb25zdCBkb21haW4gPSBzdGF0ZXMuZG9tYWluO1xuICAgICAgY29uc3QgbmFtZSA9IG5hbWVzW3N0YXRlcy5lbnRpdHlfaWRdIHx8IHN0YXRlcy5uYW1lO1xuICAgICAgLy8gYXJyYXkgY29udGFpbmluZyBbdmFsdWUxLCB2YWx1ZTIsIGV0Y11cbiAgICAgIGxldCBwcmV2VmFsdWVzO1xuICAgICAgY29uc3QgZGF0YSA9IFtdO1xuXG4gICAgICBmdW5jdGlvbiBwdXNoRGF0YSh0aW1lc3RhbXAsIGRhdGF2YWx1ZXMpIHtcbiAgICAgICAgaWYgKCFkYXRhdmFsdWVzKSByZXR1cm47XG4gICAgICAgIGlmICh0aW1lc3RhbXAgPiBlbmRUaW1lKSB7XG4gICAgICAgICAgLy8gRHJvcCBkYXRhcG9pbnRzIHRoYXQgYXJlIGFmdGVyIHRoZSByZXF1ZXN0ZWQgZW5kVGltZS4gVGhpcyBjb3VsZCBoYXBwZW4gaWZcbiAgICAgICAgICAvLyBlbmRUaW1lIGlzIFwibm93XCIgYW5kIGNsaWVudCB0aW1lIGlzIG5vdCBpbiBzeW5jIHdpdGggc2VydmVyIHRpbWUuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEuZm9yRWFjaCgoZCwgaSkgPT4ge1xuICAgICAgICAgIGQuZGF0YS5wdXNoKHsgeDogdGltZXN0YW1wLCB5OiBkYXRhdmFsdWVzW2ldIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJldlZhbHVlcyA9IGRhdGF2YWx1ZXM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFkZENvbHVtbihuYW1lWSwgc3RlcCwgZmlsbCkge1xuICAgICAgICBsZXQgZGF0YUZpbGwgPSBmYWxzZTtcbiAgICAgICAgbGV0IGRhdGFTdGVwID0gZmFsc2U7XG4gICAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgICAgZGF0YUZpbGwgPSBcIm9yaWdpblwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGVwKSB7XG4gICAgICAgICAgZGF0YVN0ZXAgPSBcImJlZm9yZVwiO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEucHVzaCh7XG4gICAgICAgICAgbGFiZWw6IG5hbWVZLFxuICAgICAgICAgIGZpbGw6IGRhdGFGaWxsLFxuICAgICAgICAgIHN0ZXBwZWRMaW5lOiBkYXRhU3RlcCxcbiAgICAgICAgICBwb2ludFJhZGl1czogMCxcbiAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICB1bml0VGV4dDogdW5pdCxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgZG9tYWluID09PSBcInRoZXJtb3N0YXRcIiB8fFxuICAgICAgICBkb21haW4gPT09IFwiY2xpbWF0ZVwiIHx8XG4gICAgICAgIGRvbWFpbiA9PT0gXCJ3YXRlcl9oZWF0ZXJcIlxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGhhc0h2YWNBY3Rpb24gPSBzdGF0ZXMuc3RhdGVzLnNvbWUoXG4gICAgICAgICAgKHN0YXRlKSA9PiBzdGF0ZS5hdHRyaWJ1dGVzICYmIHN0YXRlLmF0dHJpYnV0ZXMuaHZhY19hY3Rpb25cbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBpc0hlYXRpbmcgPVxuICAgICAgICAgIGRvbWFpbiA9PT0gXCJjbGltYXRlXCIgJiYgaGFzSHZhY0FjdGlvblxuICAgICAgICAgICAgPyAoc3RhdGUpID0+IHN0YXRlLmF0dHJpYnV0ZXMuaHZhY19hY3Rpb24gPT09IFwiaGVhdGluZ1wiXG4gICAgICAgICAgICA6IChzdGF0ZSkgPT4gc3RhdGUuc3RhdGUgPT09IFwiaGVhdFwiO1xuICAgICAgICBjb25zdCBpc0Nvb2xpbmcgPVxuICAgICAgICAgIGRvbWFpbiA9PT0gXCJjbGltYXRlXCIgJiYgaGFzSHZhY0FjdGlvblxuICAgICAgICAgICAgPyAoc3RhdGUpID0+IHN0YXRlLmF0dHJpYnV0ZXMuaHZhY19hY3Rpb24gPT09IFwiY29vbGluZ1wiXG4gICAgICAgICAgICA6IChzdGF0ZSkgPT4gc3RhdGUuc3RhdGUgPT09IFwiY29vbFwiO1xuXG4gICAgICAgIGNvbnN0IGhhc0hlYXQgPSBzdGF0ZXMuc3RhdGVzLnNvbWUoaXNIZWF0aW5nKTtcbiAgICAgICAgY29uc3QgaGFzQ29vbCA9IHN0YXRlcy5zdGF0ZXMuc29tZShpc0Nvb2xpbmcpO1xuICAgICAgICAvLyBXZSBkaWZmZXJlbnRpYXRlIGJldHdlZW4gdGhlcm1vc3RhdHMgdGhhdCBoYXZlIGEgdGFyZ2V0IHRlbXBlcmF0dXJlXG4gICAgICAgIC8vIHJhbmdlIHZlcnN1cyBvbmVzIHRoYXQgaGF2ZSBqdXN0IGEgdGFyZ2V0IHRlbXBlcmF0dXJlXG5cbiAgICAgICAgLy8gVXNpbmcgc3RlcCBjaGFydCBieSBzdGVwLWJlZm9yZSBzbyBtYW51YWxseSBpbnRlcnBvbGF0aW9uIG5vdCBuZWVkZWQuXG4gICAgICAgIGNvbnN0IGhhc1RhcmdldFJhbmdlID0gc3RhdGVzLnN0YXRlcy5zb21lKFxuICAgICAgICAgIChzdGF0ZSkgPT5cbiAgICAgICAgICAgIHN0YXRlLmF0dHJpYnV0ZXMgJiZcbiAgICAgICAgICAgIHN0YXRlLmF0dHJpYnV0ZXMudGFyZ2V0X3RlbXBfaGlnaCAhPT1cbiAgICAgICAgICAgICAgc3RhdGUuYXR0cmlidXRlcy50YXJnZXRfdGVtcF9sb3dcbiAgICAgICAgKTtcblxuICAgICAgICBhZGRDb2x1bW4oXG4gICAgICAgICAgYCR7dGhpcy5oYXNzLmxvY2FsaXplKFxuICAgICAgICAgICAgXCJ1aS5jYXJkLmNsaW1hdGUuY3VycmVudF90ZW1wZXJhdHVyZVwiLFxuICAgICAgICAgICAgXCJuYW1lXCIsXG4gICAgICAgICAgICBuYW1lXG4gICAgICAgICAgKX1gLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGhhc0hlYXQpIHtcbiAgICAgICAgICBhZGRDb2x1bW4oXG4gICAgICAgICAgICBgJHt0aGlzLmhhc3MubG9jYWxpemUoXCJ1aS5jYXJkLmNsaW1hdGUuaGVhdGluZ1wiLCBcIm5hbWVcIiwgbmFtZSl9YCxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKTtcbiAgICAgICAgICAvLyBUaGUgXCJoZWF0aW5nXCIgc2VyaWVzIHVzZXMgc3RlcHBlZEFyZWEgdG8gc2hhZGUgdGhlIGFyZWEgYmVsb3cgdGhlIGN1cnJlbnRcbiAgICAgICAgICAvLyB0ZW1wZXJhdHVyZSB3aGVuIHRoZSB0aGVybW9zdGF0IGlzIGNhbGxpbmcgZm9yIGhlYXQuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0Nvb2wpIHtcbiAgICAgICAgICBhZGRDb2x1bW4oXG4gICAgICAgICAgICBgJHt0aGlzLmhhc3MubG9jYWxpemUoXCJ1aS5jYXJkLmNsaW1hdGUuY29vbGluZ1wiLCBcIm5hbWVcIiwgbmFtZSl9YCxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKTtcbiAgICAgICAgICAvLyBUaGUgXCJjb29saW5nXCIgc2VyaWVzIHVzZXMgc3RlcHBlZEFyZWEgdG8gc2hhZGUgdGhlIGFyZWEgYmVsb3cgdGhlIGN1cnJlbnRcbiAgICAgICAgICAvLyB0ZW1wZXJhdHVyZSB3aGVuIHRoZSB0aGVybW9zdGF0IGlzIGNhbGxpbmcgZm9yIGhlYXQuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzVGFyZ2V0UmFuZ2UpIHtcbiAgICAgICAgICBhZGRDb2x1bW4oXG4gICAgICAgICAgICBgJHt0aGlzLmhhc3MubG9jYWxpemUoXG4gICAgICAgICAgICAgIFwidWkuY2FyZC5jbGltYXRlLnRhcmdldF90ZW1wZXJhdHVyZV9tb2RlXCIsXG4gICAgICAgICAgICAgIFwibmFtZVwiLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBcIm1vZGVcIixcbiAgICAgICAgICAgICAgdGhpcy5oYXNzLmxvY2FsaXplKFwidWkuY2FyZC5jbGltYXRlLmhpZ2hcIilcbiAgICAgICAgICAgICl9YCxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApO1xuICAgICAgICAgIGFkZENvbHVtbihcbiAgICAgICAgICAgIGAke3RoaXMuaGFzcy5sb2NhbGl6ZShcbiAgICAgICAgICAgICAgXCJ1aS5jYXJkLmNsaW1hdGUudGFyZ2V0X3RlbXBlcmF0dXJlX21vZGVcIixcbiAgICAgICAgICAgICAgXCJuYW1lXCIsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIFwibW9kZVwiLFxuICAgICAgICAgICAgICB0aGlzLmhhc3MubG9jYWxpemUoXCJ1aS5jYXJkLmNsaW1hdGUubG93XCIpXG4gICAgICAgICAgICApfWAsXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDb2x1bW4oXG4gICAgICAgICAgICBgJHt0aGlzLmhhc3MubG9jYWxpemUoXG4gICAgICAgICAgICAgIFwidWkuY2FyZC5jbGltYXRlLnRhcmdldF90ZW1wZXJhdHVyZV9lbnRpdHlcIixcbiAgICAgICAgICAgICAgXCJuYW1lXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICl9YCxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGVzLnN0YXRlcy5mb3JFYWNoKChzdGF0ZSkgPT4ge1xuICAgICAgICAgIGlmICghc3RhdGUuYXR0cmlidXRlcykgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IGN1clRlbXAgPSBzYWZlUGFyc2VGbG9hdChzdGF0ZS5hdHRyaWJ1dGVzLmN1cnJlbnRfdGVtcGVyYXR1cmUpO1xuICAgICAgICAgIGNvbnN0IHNlcmllcyA9IFtjdXJUZW1wXTtcbiAgICAgICAgICBpZiAoaGFzSGVhdCkge1xuICAgICAgICAgICAgc2VyaWVzLnB1c2goaXNIZWF0aW5nKHN0YXRlKSA/IGN1clRlbXAgOiBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhc0Nvb2wpIHtcbiAgICAgICAgICAgIHNlcmllcy5wdXNoKGlzQ29vbGluZyhzdGF0ZSkgPyBjdXJUZW1wIDogbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYXNUYXJnZXRSYW5nZSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0SGlnaCA9IHNhZmVQYXJzZUZsb2F0KFxuICAgICAgICAgICAgICBzdGF0ZS5hdHRyaWJ1dGVzLnRhcmdldF90ZW1wX2hpZ2hcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRMb3cgPSBzYWZlUGFyc2VGbG9hdChzdGF0ZS5hdHRyaWJ1dGVzLnRhcmdldF90ZW1wX2xvdyk7XG4gICAgICAgICAgICBzZXJpZXMucHVzaCh0YXJnZXRIaWdoLCB0YXJnZXRMb3cpO1xuICAgICAgICAgICAgcHVzaERhdGEobmV3IERhdGUoc3RhdGUubGFzdF9jaGFuZ2VkKSwgc2VyaWVzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gc2FmZVBhcnNlRmxvYXQoc3RhdGUuYXR0cmlidXRlcy50ZW1wZXJhdHVyZSk7XG4gICAgICAgICAgICBzZXJpZXMucHVzaCh0YXJnZXQpO1xuICAgICAgICAgICAgcHVzaERhdGEobmV3IERhdGUoc3RhdGUubGFzdF9jaGFuZ2VkKSwgc2VyaWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT25seSBkaXNhYmxlIGludGVycG9sYXRpb24gZm9yIHNlbnNvcnNcbiAgICAgICAgY29uc3QgaXNTdGVwID0gZG9tYWluID09PSBcInNlbnNvclwiO1xuICAgICAgICBhZGRDb2x1bW4obmFtZSwgaXNTdGVwKTtcblxuICAgICAgICBsZXQgbGFzdFZhbHVlID0gbnVsbDtcbiAgICAgICAgbGV0IGxhc3REYXRlID0gbnVsbDtcbiAgICAgICAgbGV0IGxhc3ROdWxsRGF0ZSA9IG51bGw7XG5cbiAgICAgICAgLy8gUHJvY2VzcyBjaGFydCBkYXRhLlxuICAgICAgICAvLyBXaGVuIHN0YXRlIGlzIGB1bmtub3duYCwgY2FsY3VsYXRlIHRoZSB2YWx1ZSBhbmQgYnJlYWsgdGhlIGxpbmUuXG4gICAgICAgIHN0YXRlcy5zdGF0ZXMuZm9yRWFjaCgoc3RhdGUpID0+IHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHNhZmVQYXJzZUZsb2F0KHN0YXRlLnN0YXRlKTtcbiAgICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoc3RhdGUubGFzdF9jaGFuZ2VkKTtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgbGFzdE51bGxEYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRlVGltZSA9IGRhdGUuZ2V0VGltZSgpO1xuICAgICAgICAgICAgY29uc3QgbGFzdE51bGxEYXRlVGltZSA9IGxhc3ROdWxsRGF0ZS5nZXRUaW1lKCk7XG4gICAgICAgICAgICBjb25zdCBsYXN0RGF0ZVRpbWUgPSBsYXN0RGF0ZS5nZXRUaW1lKCk7XG4gICAgICAgICAgICBjb25zdCB0bXBWYWx1ZSA9XG4gICAgICAgICAgICAgICh2YWx1ZSAtIGxhc3RWYWx1ZSkgKlxuICAgICAgICAgICAgICAgICgobGFzdE51bGxEYXRlVGltZSAtIGxhc3REYXRlVGltZSkgL1xuICAgICAgICAgICAgICAgICAgKGRhdGVUaW1lIC0gbGFzdERhdGVUaW1lKSkgK1xuICAgICAgICAgICAgICBsYXN0VmFsdWU7XG4gICAgICAgICAgICBwdXNoRGF0YShsYXN0TnVsbERhdGUsIFt0bXBWYWx1ZV0pO1xuICAgICAgICAgICAgcHVzaERhdGEobmV3IERhdGUobGFzdE51bGxEYXRlVGltZSArIDEpLCBbbnVsbF0pO1xuICAgICAgICAgICAgcHVzaERhdGEoZGF0ZSwgW3ZhbHVlXSk7XG4gICAgICAgICAgICBsYXN0RGF0ZSA9IGRhdGU7XG4gICAgICAgICAgICBsYXN0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGxhc3ROdWxsRGF0ZSA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiBsYXN0TnVsbERhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHB1c2hEYXRhKGRhdGUsIFt2YWx1ZV0pO1xuICAgICAgICAgICAgbGFzdERhdGUgPSBkYXRlO1xuICAgICAgICAgICAgbGFzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIHZhbHVlID09PSBudWxsICYmXG4gICAgICAgICAgICBsYXN0TnVsbERhdGUgPT09IG51bGwgJiZcbiAgICAgICAgICAgIGxhc3RWYWx1ZSAhPT0gbnVsbFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgbGFzdE51bGxEYXRlID0gZGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgYW4gZW50cnkgZm9yIGZpbmFsIHZhbHVlc1xuICAgICAgcHVzaERhdGEoZW5kVGltZSwgcHJldlZhbHVlcywgZmFsc2UpO1xuXG4gICAgICAvLyBDb25jYXQgdHdvIGFycmF5c1xuICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZGF0YXNldHMsIGRhdGEpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgZm9ybWF0VG9vbHRpcFRpdGxlID0gKGl0ZW1zLCBkYXRhKSA9PiB7XG4gICAgICBjb25zdCBpdGVtID0gaXRlbXNbMF07XG4gICAgICBjb25zdCBkYXRlID0gZGF0YS5kYXRhc2V0c1tpdGVtLmRhdGFzZXRJbmRleF0uZGF0YVtpdGVtLmluZGV4XS54O1xuXG4gICAgICByZXR1cm4gZm9ybWF0RGF0ZVRpbWVXaXRoU2Vjb25kcyhkYXRlLCB0aGlzLmhhc3MubGFuZ3VhZ2UpO1xuICAgIH07XG5cbiAgICBjb25zdCBjaGFydE9wdGlvbnMgPSB7XG4gICAgICB0eXBlOiBcImxpbmVcIixcbiAgICAgIHVuaXQ6IHVuaXQsXG4gICAgICBsZWdlbmQ6ICF0aGlzLmlzU2luZ2xlRGV2aWNlLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBzY2FsZXM6IHtcbiAgICAgICAgICB4QXhlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiBcInRpbWVcIixcbiAgICAgICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgICAgICBtYWpvcjoge1xuICAgICAgICAgICAgICAgICAgZm9udFN0eWxlOiBcImJvbGRcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIHlBeGVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICAgICAgbWF4VGlja3NMaW1pdDogNyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgdG9vbHRpcHM6IHtcbiAgICAgICAgICBtb2RlOiBcIm5lYXJlYWNoXCIsXG4gICAgICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgICAgICB0aXRsZTogZm9ybWF0VG9vbHRpcFRpdGxlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgbW9kZTogXCJuZWFyZWFjaFwiLFxuICAgICAgICB9LFxuICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICBwYWRkaW5nOiB7XG4gICAgICAgICAgICB0b3A6IDUsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgICB0ZW5zaW9uOiAwLjEsXG4gICAgICAgICAgICBwb2ludFJhZGl1czogMCxcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiAxLjUsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwb2ludDoge1xuICAgICAgICAgICAgaGl0UmFkaXVzOiA1LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHBsdWdpbnM6IHtcbiAgICAgICAgICBmaWxsZXI6IHtcbiAgICAgICAgICAgIHByb3BhZ2F0ZTogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbGFiZWxzOiBbXSxcbiAgICAgICAgZGF0YXNldHM6IGRhdGFzZXRzLFxuICAgICAgfSxcbiAgICB9O1xuICAgIHRoaXMuY2hhcnREYXRhID0gY2hhcnRPcHRpb25zO1xuICB9XG59XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoXCJzdGF0ZS1oaXN0b3J5LWNoYXJ0LWxpbmVcIiwgU3RhdGVIaXN0b3J5Q2hhcnRMaW5lKTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUE4Q0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFIQTtBQUtBOzs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBSUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFBQTtBQUdBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFPQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFVQTtBQVVBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUZBO0FBU0E7QUFFQTtBQUNBO0FBREE7QUFEQTtBQVpBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFGQTtBQU1BO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBREE7QUFOQTtBQVVBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUE1Q0E7QUFrREE7QUFDQTtBQUNBO0FBRkE7QUF0REE7QUEyREE7QUFDQTs7O0FBcFhBO0FBQ0E7QUFnQkE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFiQTtBQW1CQTs7O0FBRUE7QUFDQTtBQUNBOzs7O0FBNUNBO0FBQ0E7QUFzWEEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/state-history-chart-line.js\n");

/***/ }),

/***/ "./src/components/state-history-chart-timeline.js":
/*!********************************************************!*\
  !*** ./src/components/state-history-chart-timeline.js ***!
  \********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _polymer_polymer_lib_utils_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/lib/utils/debounce */ \"./node_modules/@polymer/polymer/lib/utils/debounce.js\");\n/* harmony import */ var _polymer_polymer_lib_utils_html_tag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @polymer/polymer/lib/utils/html-tag */ \"./node_modules/@polymer/polymer/lib/utils/html-tag.js\");\n/* harmony import */ var _polymer_polymer_polymer_element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @polymer/polymer/polymer-element */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n/* harmony import */ var _common_datetime_format_date_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/datetime/format_date_time */ \"./src/common/datetime/format_date_time.ts\");\n/* harmony import */ var _common_util_compute_rtl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/util/compute_rtl */ \"./src/common/util/compute_rtl.ts\");\n/* harmony import */ var _mixins_localize_mixin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../mixins/localize-mixin */ \"./src/mixins/localize-mixin.js\");\n/* harmony import */ var _entity_ha_chart_base__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./entity/ha-chart-base */ \"./src/components/entity/ha-chart-base.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n      <style>\\n        :host {\\n          display: block;\\n          opacity: 0;\\n          transition: opacity 0.3s ease-in-out;\\n        }\\n        :host([rendered]) {\\n          opacity: 1;\\n        }\\n\\n        ha-chart-base {\\n          direction: ltr;\\n        }\\n      </style>\\n      <ha-chart-base\\n        data=\\\"[[chartData]]\\\"\\n        rendered=\\\"{{rendered}}\\\"\\n        rtl=\\\"{{rtl}}\\\"\\n      ></ha-chart-base>\\n    \"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n/* eslint-plugin-disable lit */\n\n\n\n\n\n\n\nvar StateHistoryChartTimeline = /*#__PURE__*/function (_LocalizeMixin) {\n  _inherits(StateHistoryChartTimeline, _LocalizeMixin);\n\n  var _super = _createSuper(StateHistoryChartTimeline);\n\n  function StateHistoryChartTimeline() {\n    _classCallCheck(this, StateHistoryChartTimeline);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(StateHistoryChartTimeline, [{\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      _get(_getPrototypeOf(StateHistoryChartTimeline.prototype), \"connectedCallback\", this).call(this);\n\n      this._isAttached = true;\n      this.drawChart();\n    }\n  }, {\n    key: \"dataChanged\",\n    value: function dataChanged() {\n      this.drawChart();\n    }\n  }, {\n    key: \"drawChart\",\n    value: function drawChart() {\n      var _this = this;\n\n      var staticColors = {\n        on: 1,\n        off: 0,\n        unavailable: \"#a0a0a0\",\n        unknown: \"#606060\",\n        idle: 2\n      };\n      var stateHistory = this.data;\n\n      if (!this._isAttached) {\n        return;\n      }\n\n      if (!stateHistory) {\n        stateHistory = [];\n      }\n\n      var startTime = new Date(stateHistory.reduce(function (minTime, stateInfo) {\n        return Math.min(minTime, new Date(stateInfo.data[0].last_changed));\n      }, new Date())); // end time is Math.max(startTime, last_event)\n\n      var endTime = this.endTime || new Date(stateHistory.reduce(function (maxTime, stateInfo) {\n        return Math.max(maxTime, new Date(stateInfo.data[stateInfo.data.length - 1].last_changed));\n      }, startTime));\n\n      if (endTime > new Date()) {\n        endTime = new Date();\n      }\n\n      var labels = [];\n      var datasets = []; // stateHistory is a list of lists of sorted state objects\n\n      var names = this.names || {};\n      stateHistory.forEach(function (stateInfo) {\n        var newLastChanged;\n        var prevState = null;\n        var locState = null;\n        var prevLastChanged = startTime;\n        var entityDisplay = names[stateInfo.entity_id] || stateInfo.name;\n        var dataRow = [];\n        stateInfo.data.forEach(function (state) {\n          var newState = state.state;\n          var timeStamp = new Date(state.last_changed);\n\n          if (newState === undefined || newState === \"\") {\n            newState = null;\n          }\n\n          if (timeStamp > endTime) {\n            // Drop datapoints that are after the requested endTime. This could happen if\n            // endTime is 'now' and client time is not in sync with server time.\n            return;\n          }\n\n          if (prevState !== null && newState !== prevState) {\n            newLastChanged = new Date(state.last_changed);\n            dataRow.push([prevLastChanged, newLastChanged, locState, prevState]);\n            prevState = newState;\n            locState = state.state_localize;\n            prevLastChanged = newLastChanged;\n          } else if (prevState === null) {\n            prevState = newState;\n            locState = state.state_localize;\n            prevLastChanged = new Date(state.last_changed);\n          }\n        });\n\n        if (prevState !== null) {\n          dataRow.push([prevLastChanged, endTime, locState, prevState]);\n        }\n\n        datasets.push({\n          data: dataRow\n        });\n        labels.push(entityDisplay);\n      });\n\n      var formatTooltipLabel = function formatTooltipLabel(item, data) {\n        var values = data.datasets[item.datasetIndex].data[item.index];\n        var start = Object(_common_datetime_format_date_time__WEBPACK_IMPORTED_MODULE_3__[\"formatDateTimeWithSeconds\"])(values[0], _this.hass.language);\n        var end = Object(_common_datetime_format_date_time__WEBPACK_IMPORTED_MODULE_3__[\"formatDateTimeWithSeconds\"])(values[1], _this.hass.language);\n        var state = values[2];\n        return [state, start, end];\n      };\n\n      var chartOptions = {\n        type: \"timeline\",\n        options: {\n          tooltips: {\n            callbacks: {\n              label: formatTooltipLabel\n            }\n          },\n          scales: {\n            xAxes: [{\n              ticks: {\n                major: {\n                  fontStyle: \"bold\"\n                }\n              }\n            }],\n            yAxes: [{\n              afterSetDimensions: function afterSetDimensions(yaxe) {\n                yaxe.maxWidth = yaxe.chart.width * 0.18;\n              },\n              position: this._computeRTL ? \"right\" : \"left\"\n            }]\n          }\n        },\n        data: {\n          labels: labels,\n          datasets: datasets\n        },\n        colors: {\n          staticColors: staticColors,\n          staticColorIndex: 3\n        }\n      };\n      this.chartData = chartOptions;\n    }\n  }, {\n    key: \"_computeRTL\",\n    value: function _computeRTL(hass) {\n      return Object(_common_util_compute_rtl__WEBPACK_IMPORTED_MODULE_4__[\"computeRTL\"])(hass);\n    }\n  }], [{\n    key: \"template\",\n    get: function get() {\n      return Object(_polymer_polymer_lib_utils_html_tag__WEBPACK_IMPORTED_MODULE_1__[\"html\"])(_templateObject());\n    }\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return {\n        hass: {\n          type: Object\n        },\n        chartData: Object,\n        data: {\n          type: Object,\n          observer: \"dataChanged\"\n        },\n        names: Object,\n        noSingle: Boolean,\n        endTime: Date,\n        rendered: {\n          type: Boolean,\n          value: false,\n          reflectToAttribute: true\n        },\n        rtl: {\n          reflectToAttribute: true,\n          computed: \"_computeRTL(hass)\"\n        }\n      };\n    }\n  }, {\n    key: \"observers\",\n    get: function get() {\n      return [\"dataChanged(data, endTime, localize, language)\"];\n    }\n  }]);\n\n  return StateHistoryChartTimeline;\n}(Object(_mixins_localize_mixin__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(_polymer_polymer_polymer_element__WEBPACK_IMPORTED_MODULE_2__[\"PolymerElement\"]));\n\ncustomElements.define(\"state-history-chart-timeline\", StateHistoryChartTimeline);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9zdGF0ZS1oaXN0b3J5LWNoYXJ0LXRpbWVsaW5lLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvc3RhdGUtaGlzdG9yeS1jaGFydC10aW1lbGluZS5qcz9mNzRiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBcIkBwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2RlYm91bmNlXCI7XG5pbXBvcnQgeyBodG1sIH0gZnJvbSBcIkBwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2h0bWwtdGFnXCI7XG4vKiBlc2xpbnQtcGx1Z2luLWRpc2FibGUgbGl0ICovXG5pbXBvcnQgeyBQb2x5bWVyRWxlbWVudCB9IGZyb20gXCJAcG9seW1lci9wb2x5bWVyL3BvbHltZXItZWxlbWVudFwiO1xuaW1wb3J0IHsgZm9ybWF0RGF0ZVRpbWVXaXRoU2Vjb25kcyB9IGZyb20gXCIuLi9jb21tb24vZGF0ZXRpbWUvZm9ybWF0X2RhdGVfdGltZVwiO1xuaW1wb3J0IHsgY29tcHV0ZVJUTCB9IGZyb20gXCIuLi9jb21tb24vdXRpbC9jb21wdXRlX3J0bFwiO1xuaW1wb3J0IExvY2FsaXplTWl4aW4gZnJvbSBcIi4uL21peGlucy9sb2NhbGl6ZS1taXhpblwiO1xuaW1wb3J0IFwiLi9lbnRpdHkvaGEtY2hhcnQtYmFzZVwiO1xuXG5jbGFzcyBTdGF0ZUhpc3RvcnlDaGFydFRpbWVsaW5lIGV4dGVuZHMgTG9jYWxpemVNaXhpbihQb2x5bWVyRWxlbWVudCkge1xuICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkge1xuICAgIHJldHVybiBodG1sYFxuICAgICAgPHN0eWxlPlxuICAgICAgICA6aG9zdCB7XG4gICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgb3BhY2l0eTogMDtcbiAgICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3MgZWFzZS1pbi1vdXQ7XG4gICAgICAgIH1cbiAgICAgICAgOmhvc3QoW3JlbmRlcmVkXSkge1xuICAgICAgICAgIG9wYWNpdHk6IDE7XG4gICAgICAgIH1cblxuICAgICAgICBoYS1jaGFydC1iYXNlIHtcbiAgICAgICAgICBkaXJlY3Rpb246IGx0cjtcbiAgICAgICAgfVxuICAgICAgPC9zdHlsZT5cbiAgICAgIDxoYS1jaGFydC1iYXNlXG4gICAgICAgIGRhdGE9XCJbW2NoYXJ0RGF0YV1dXCJcbiAgICAgICAgcmVuZGVyZWQ9XCJ7e3JlbmRlcmVkfX1cIlxuICAgICAgICBydGw9XCJ7e3J0bH19XCJcbiAgICAgID48L2hhLWNoYXJ0LWJhc2U+XG4gICAgYDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaGFzczoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICB9LFxuICAgICAgY2hhcnREYXRhOiBPYmplY3QsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgb2JzZXJ2ZXI6IFwiZGF0YUNoYW5nZWRcIixcbiAgICAgIH0sXG4gICAgICBuYW1lczogT2JqZWN0LFxuICAgICAgbm9TaW5nbGU6IEJvb2xlYW4sXG4gICAgICBlbmRUaW1lOiBEYXRlLFxuICAgICAgcmVuZGVyZWQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICB9LFxuICAgICAgcnRsOiB7XG4gICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgICAgY29tcHV0ZWQ6IFwiX2NvbXB1dGVSVEwoaGFzcylcIixcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZXJzKCkge1xuICAgIHJldHVybiBbXCJkYXRhQ2hhbmdlZChkYXRhLCBlbmRUaW1lLCBsb2NhbGl6ZSwgbGFuZ3VhZ2UpXCJdO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICB0aGlzLl9pc0F0dGFjaGVkID0gdHJ1ZTtcbiAgICB0aGlzLmRyYXdDaGFydCgpO1xuICB9XG5cbiAgZGF0YUNoYW5nZWQoKSB7XG4gICAgdGhpcy5kcmF3Q2hhcnQoKTtcbiAgfVxuXG4gIGRyYXdDaGFydCgpIHtcbiAgICBjb25zdCBzdGF0aWNDb2xvcnMgPSB7XG4gICAgICBvbjogMSxcbiAgICAgIG9mZjogMCxcbiAgICAgIHVuYXZhaWxhYmxlOiBcIiNhMGEwYTBcIixcbiAgICAgIHVua25vd246IFwiIzYwNjA2MFwiLFxuICAgICAgaWRsZTogMixcbiAgICB9O1xuICAgIGxldCBzdGF0ZUhpc3RvcnkgPSB0aGlzLmRhdGE7XG5cbiAgICBpZiAoIXRoaXMuX2lzQXR0YWNoZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXN0YXRlSGlzdG9yeSkge1xuICAgICAgc3RhdGVIaXN0b3J5ID0gW107XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRUaW1lID0gbmV3IERhdGUoXG4gICAgICBzdGF0ZUhpc3RvcnkucmVkdWNlKFxuICAgICAgICAobWluVGltZSwgc3RhdGVJbmZvKSA9PlxuICAgICAgICAgIE1hdGgubWluKG1pblRpbWUsIG5ldyBEYXRlKHN0YXRlSW5mby5kYXRhWzBdLmxhc3RfY2hhbmdlZCkpLFxuICAgICAgICBuZXcgRGF0ZSgpXG4gICAgICApXG4gICAgKTtcblxuICAgIC8vIGVuZCB0aW1lIGlzIE1hdGgubWF4KHN0YXJ0VGltZSwgbGFzdF9ldmVudClcbiAgICBsZXQgZW5kVGltZSA9XG4gICAgICB0aGlzLmVuZFRpbWUgfHxcbiAgICAgIG5ldyBEYXRlKFxuICAgICAgICBzdGF0ZUhpc3RvcnkucmVkdWNlKFxuICAgICAgICAgIChtYXhUaW1lLCBzdGF0ZUluZm8pID0+XG4gICAgICAgICAgICBNYXRoLm1heChcbiAgICAgICAgICAgICAgbWF4VGltZSxcbiAgICAgICAgICAgICAgbmV3IERhdGUoc3RhdGVJbmZvLmRhdGFbc3RhdGVJbmZvLmRhdGEubGVuZ3RoIC0gMV0ubGFzdF9jaGFuZ2VkKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICBzdGFydFRpbWVcbiAgICAgICAgKVxuICAgICAgKTtcblxuICAgIGlmIChlbmRUaW1lID4gbmV3IERhdGUoKSkge1xuICAgICAgZW5kVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxzID0gW107XG4gICAgY29uc3QgZGF0YXNldHMgPSBbXTtcbiAgICAvLyBzdGF0ZUhpc3RvcnkgaXMgYSBsaXN0IG9mIGxpc3RzIG9mIHNvcnRlZCBzdGF0ZSBvYmplY3RzXG4gICAgY29uc3QgbmFtZXMgPSB0aGlzLm5hbWVzIHx8IHt9O1xuICAgIHN0YXRlSGlzdG9yeS5mb3JFYWNoKChzdGF0ZUluZm8pID0+IHtcbiAgICAgIGxldCBuZXdMYXN0Q2hhbmdlZDtcbiAgICAgIGxldCBwcmV2U3RhdGUgPSBudWxsO1xuICAgICAgbGV0IGxvY1N0YXRlID0gbnVsbDtcbiAgICAgIGxldCBwcmV2TGFzdENoYW5nZWQgPSBzdGFydFRpbWU7XG4gICAgICBjb25zdCBlbnRpdHlEaXNwbGF5ID0gbmFtZXNbc3RhdGVJbmZvLmVudGl0eV9pZF0gfHwgc3RhdGVJbmZvLm5hbWU7XG5cbiAgICAgIGNvbnN0IGRhdGFSb3cgPSBbXTtcbiAgICAgIHN0YXRlSW5mby5kYXRhLmZvckVhY2goKHN0YXRlKSA9PiB7XG4gICAgICAgIGxldCBuZXdTdGF0ZSA9IHN0YXRlLnN0YXRlO1xuICAgICAgICBjb25zdCB0aW1lU3RhbXAgPSBuZXcgRGF0ZShzdGF0ZS5sYXN0X2NoYW5nZWQpO1xuICAgICAgICBpZiAobmV3U3RhdGUgPT09IHVuZGVmaW5lZCB8fCBuZXdTdGF0ZSA9PT0gXCJcIikge1xuICAgICAgICAgIG5ld1N0YXRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZVN0YW1wID4gZW5kVGltZSkge1xuICAgICAgICAgIC8vIERyb3AgZGF0YXBvaW50cyB0aGF0IGFyZSBhZnRlciB0aGUgcmVxdWVzdGVkIGVuZFRpbWUuIFRoaXMgY291bGQgaGFwcGVuIGlmXG4gICAgICAgICAgLy8gZW5kVGltZSBpcyAnbm93JyBhbmQgY2xpZW50IHRpbWUgaXMgbm90IGluIHN5bmMgd2l0aCBzZXJ2ZXIgdGltZS5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCAmJiBuZXdTdGF0ZSAhPT0gcHJldlN0YXRlKSB7XG4gICAgICAgICAgbmV3TGFzdENoYW5nZWQgPSBuZXcgRGF0ZShzdGF0ZS5sYXN0X2NoYW5nZWQpO1xuXG4gICAgICAgICAgZGF0YVJvdy5wdXNoKFtwcmV2TGFzdENoYW5nZWQsIG5ld0xhc3RDaGFuZ2VkLCBsb2NTdGF0ZSwgcHJldlN0YXRlXSk7XG5cbiAgICAgICAgICBwcmV2U3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgICBsb2NTdGF0ZSA9IHN0YXRlLnN0YXRlX2xvY2FsaXplO1xuICAgICAgICAgIHByZXZMYXN0Q2hhbmdlZCA9IG5ld0xhc3RDaGFuZ2VkO1xuICAgICAgICB9IGVsc2UgaWYgKHByZXZTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHByZXZTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICAgIGxvY1N0YXRlID0gc3RhdGUuc3RhdGVfbG9jYWxpemU7XG4gICAgICAgICAgcHJldkxhc3RDaGFuZ2VkID0gbmV3IERhdGUoc3RhdGUubGFzdF9jaGFuZ2VkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgZGF0YVJvdy5wdXNoKFtwcmV2TGFzdENoYW5nZWQsIGVuZFRpbWUsIGxvY1N0YXRlLCBwcmV2U3RhdGVdKTtcbiAgICAgIH1cbiAgICAgIGRhdGFzZXRzLnB1c2goeyBkYXRhOiBkYXRhUm93IH0pO1xuICAgICAgbGFiZWxzLnB1c2goZW50aXR5RGlzcGxheSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBmb3JtYXRUb29sdGlwTGFiZWwgPSAoaXRlbSwgZGF0YSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWVzID0gZGF0YS5kYXRhc2V0c1tpdGVtLmRhdGFzZXRJbmRleF0uZGF0YVtpdGVtLmluZGV4XTtcblxuICAgICAgY29uc3Qgc3RhcnQgPSBmb3JtYXREYXRlVGltZVdpdGhTZWNvbmRzKHZhbHVlc1swXSwgdGhpcy5oYXNzLmxhbmd1YWdlKTtcbiAgICAgIGNvbnN0IGVuZCA9IGZvcm1hdERhdGVUaW1lV2l0aFNlY29uZHModmFsdWVzWzFdLCB0aGlzLmhhc3MubGFuZ3VhZ2UpO1xuICAgICAgY29uc3Qgc3RhdGUgPSB2YWx1ZXNbMl07XG5cbiAgICAgIHJldHVybiBbc3RhdGUsIHN0YXJ0LCBlbmRdO1xuICAgIH07XG5cbiAgICBjb25zdCBjaGFydE9wdGlvbnMgPSB7XG4gICAgICB0eXBlOiBcInRpbWVsaW5lXCIsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHRvb2x0aXBzOiB7XG4gICAgICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgICAgICBsYWJlbDogZm9ybWF0VG9vbHRpcExhYmVsLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHNjYWxlczoge1xuICAgICAgICAgIHhBeGVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICAgICAgbWFqb3I6IHtcbiAgICAgICAgICAgICAgICAgIGZvbnRTdHlsZTogXCJib2xkXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgICB5QXhlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBhZnRlclNldERpbWVuc2lvbnM6ICh5YXhlKSA9PiB7XG4gICAgICAgICAgICAgICAgeWF4ZS5tYXhXaWR0aCA9IHlheGUuY2hhcnQud2lkdGggKiAwLjE4O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5fY29tcHV0ZVJUTCA/IFwicmlnaHRcIiA6IFwibGVmdFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbGFiZWxzOiBsYWJlbHMsXG4gICAgICAgIGRhdGFzZXRzOiBkYXRhc2V0cyxcbiAgICAgIH0sXG4gICAgICBjb2xvcnM6IHtcbiAgICAgICAgc3RhdGljQ29sb3JzOiBzdGF0aWNDb2xvcnMsXG4gICAgICAgIHN0YXRpY0NvbG9ySW5kZXg6IDMsXG4gICAgICB9LFxuICAgIH07XG4gICAgdGhpcy5jaGFydERhdGEgPSBjaGFydE9wdGlvbnM7XG4gIH1cblxuICBfY29tcHV0ZVJUTChoYXNzKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVSVEwoaGFzcyk7XG4gIH1cbn1cbmN1c3RvbUVsZW1lbnRzLmRlZmluZShcbiAgXCJzdGF0ZS1oaXN0b3J5LWNoYXJ0LXRpbWVsaW5lXCIsXG4gIFN0YXRlSGlzdG9yeUNoYXJ0VGltZWxpbmVcbik7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBc0RBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFNQTtBQUlBO0FBQUE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFEQTtBQURBO0FBUUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBWEE7QUFOQTtBQTBCQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBaENBO0FBcUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBNU1BO0FBQ0E7QUFxQkE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUZBO0FBakJBO0FBc0JBOzs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFwREE7QUFDQTtBQThNQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/state-history-chart-timeline.js\n");

/***/ }),

/***/ "./src/components/state-history-charts.js":
/*!************************************************!*\
  !*** ./src/components/state-history-charts.js ***!
  \************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _polymer_paper_spinner_paper_spinner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/paper-spinner/paper-spinner */ \"./node_modules/@polymer/paper-spinner/paper-spinner.js\");\n/* harmony import */ var _polymer_polymer_lib_utils_html_tag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @polymer/polymer/lib/utils/html-tag */ \"./node_modules/@polymer/polymer/lib/utils/html-tag.js\");\n/* harmony import */ var _polymer_polymer_polymer_element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @polymer/polymer/polymer-element */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n/* harmony import */ var _mixins_localize_mixin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../mixins/localize-mixin */ \"./src/mixins/localize-mixin.js\");\n/* harmony import */ var _state_history_chart_line__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./state-history-chart-line */ \"./src/components/state-history-chart-line.js\");\n/* harmony import */ var _state_history_chart_timeline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./state-history-chart-timeline */ \"./src/components/state-history-chart-timeline.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n      <style>\\n        :host {\\n          display: block;\\n          /* height of single timeline chart = 58px */\\n          min-height: 58px;\\n        }\\n        .info {\\n          text-align: center;\\n          line-height: 58px;\\n          color: var(--secondary-text-color);\\n        }\\n      </style>\\n      <template\\n        is=\\\"dom-if\\\"\\n        class=\\\"info\\\"\\n        if=\\\"[[_computeIsLoading(isLoadingData)]]\\\"\\n      >\\n        <div class=\\\"info\\\">\\n          [[localize('ui.components.history_charts.loading_history')]]\\n        </div>\\n      </template>\\n\\n      <template\\n        is=\\\"dom-if\\\"\\n        class=\\\"info\\\"\\n        if=\\\"[[_computeIsEmpty(isLoadingData, historyData)]]\\\"\\n      >\\n        <div class=\\\"info\\\">\\n          [[localize('ui.components.history_charts.no_history_found')]]\\n        </div>\\n      </template>\\n\\n      <template is=\\\"dom-if\\\" if=\\\"[[historyData.timeline.length]]\\\">\\n        <state-history-chart-timeline\\n          hass=\\\"[[hass]]\\\"\\n          data=\\\"[[historyData.timeline]]\\\"\\n          end-time=\\\"[[_computeEndTime(endTime, upToNow, historyData)]]\\\"\\n          no-single=\\\"[[noSingle]]\\\"\\n          names=\\\"[[names]]\\\"\\n        ></state-history-chart-timeline>\\n      </template>\\n\\n      <template is=\\\"dom-repeat\\\" items=\\\"[[historyData.line]]\\\">\\n        <state-history-chart-line\\n          hass=\\\"[[hass]]\\\"\\n          unit=\\\"[[item.unit]]\\\"\\n          data=\\\"[[item.data]]\\\"\\n          identifier=\\\"[[item.identifier]]\\\"\\n          is-single-device=\\\"[[_computeIsSingleLineChart(item.data, noSingle)]]\\\"\\n          end-time=\\\"[[_computeEndTime(endTime, upToNow, historyData)]]\\\"\\n          names=\\\"[[names]]\\\"\\n        ></state-history-chart-line>\\n      </template>\\n    \"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n/* eslint-plugin-disable lit */\n\n\n\n\n\n\nvar StateHistoryCharts = /*#__PURE__*/function (_LocalizeMixin) {\n  _inherits(StateHistoryCharts, _LocalizeMixin);\n\n  var _super = _createSuper(StateHistoryCharts);\n\n  function StateHistoryCharts() {\n    _classCallCheck(this, StateHistoryCharts);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(StateHistoryCharts, [{\n    key: \"_computeIsSingleLineChart\",\n    value: function _computeIsSingleLineChart(data, noSingle) {\n      return !noSingle && data && data.length === 1;\n    }\n  }, {\n    key: \"_computeIsEmpty\",\n    value: function _computeIsEmpty(isLoadingData, historyData) {\n      var historyDataEmpty = !historyData || !historyData.timeline || !historyData.line || historyData.timeline.length === 0 && historyData.line.length === 0;\n      return !isLoadingData && historyDataEmpty;\n    }\n  }, {\n    key: \"_computeIsLoading\",\n    value: function _computeIsLoading(isLoading) {\n      return isLoading && !this.historyData;\n    }\n  }, {\n    key: \"_computeEndTime\",\n    value: function _computeEndTime(endTime, upToNow) {\n      // We don't really care about the value of historyData, but if it change we want to update\n      // endTime.\n      return upToNow ? new Date() : endTime;\n    }\n  }], [{\n    key: \"template\",\n    get: function get() {\n      return Object(_polymer_polymer_lib_utils_html_tag__WEBPACK_IMPORTED_MODULE_1__[\"html\"])(_templateObject());\n    }\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return {\n        hass: Object,\n        historyData: {\n          type: Object,\n          value: null\n        },\n        names: Object,\n        isLoadingData: Boolean,\n        endTime: {\n          type: Object\n        },\n        upToNow: Boolean,\n        noSingle: Boolean\n      };\n    }\n  }]);\n\n  return StateHistoryCharts;\n}(Object(_mixins_localize_mixin__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_polymer_polymer_polymer_element__WEBPACK_IMPORTED_MODULE_2__[\"PolymerElement\"]));\n\ncustomElements.define(\"state-history-charts\", StateHistoryCharts);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9zdGF0ZS1oaXN0b3J5LWNoYXJ0cy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3N0YXRlLWhpc3RvcnktY2hhcnRzLmpzP2Q0NGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFwiQHBvbHltZXIvcGFwZXItc3Bpbm5lci9wYXBlci1zcGlubmVyXCI7XG5pbXBvcnQgeyBodG1sIH0gZnJvbSBcIkBwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2h0bWwtdGFnXCI7XG4vKiBlc2xpbnQtcGx1Z2luLWRpc2FibGUgbGl0ICovXG5pbXBvcnQgeyBQb2x5bWVyRWxlbWVudCB9IGZyb20gXCJAcG9seW1lci9wb2x5bWVyL3BvbHltZXItZWxlbWVudFwiO1xuaW1wb3J0IExvY2FsaXplTWl4aW4gZnJvbSBcIi4uL21peGlucy9sb2NhbGl6ZS1taXhpblwiO1xuaW1wb3J0IFwiLi9zdGF0ZS1oaXN0b3J5LWNoYXJ0LWxpbmVcIjtcbmltcG9ydCBcIi4vc3RhdGUtaGlzdG9yeS1jaGFydC10aW1lbGluZVwiO1xuXG5jbGFzcyBTdGF0ZUhpc3RvcnlDaGFydHMgZXh0ZW5kcyBMb2NhbGl6ZU1peGluKFBvbHltZXJFbGVtZW50KSB7XG4gIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIGh0bWxgXG4gICAgICA8c3R5bGU+XG4gICAgICAgIDpob3N0IHtcbiAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAvKiBoZWlnaHQgb2Ygc2luZ2xlIHRpbWVsaW5lIGNoYXJ0ID0gNThweCAqL1xuICAgICAgICAgIG1pbi1oZWlnaHQ6IDU4cHg7XG4gICAgICAgIH1cbiAgICAgICAgLmluZm8ge1xuICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICBsaW5lLWhlaWdodDogNThweDtcbiAgICAgICAgICBjb2xvcjogdmFyKC0tc2Vjb25kYXJ5LXRleHQtY29sb3IpO1xuICAgICAgICB9XG4gICAgICA8L3N0eWxlPlxuICAgICAgPHRlbXBsYXRlXG4gICAgICAgIGlzPVwiZG9tLWlmXCJcbiAgICAgICAgY2xhc3M9XCJpbmZvXCJcbiAgICAgICAgaWY9XCJbW19jb21wdXRlSXNMb2FkaW5nKGlzTG9hZGluZ0RhdGEpXV1cIlxuICAgICAgPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaW5mb1wiPlxuICAgICAgICAgIFtbbG9jYWxpemUoJ3VpLmNvbXBvbmVudHMuaGlzdG9yeV9jaGFydHMubG9hZGluZ19oaXN0b3J5JyldXVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvdGVtcGxhdGU+XG5cbiAgICAgIDx0ZW1wbGF0ZVxuICAgICAgICBpcz1cImRvbS1pZlwiXG4gICAgICAgIGNsYXNzPVwiaW5mb1wiXG4gICAgICAgIGlmPVwiW1tfY29tcHV0ZUlzRW1wdHkoaXNMb2FkaW5nRGF0YSwgaGlzdG9yeURhdGEpXV1cIlxuICAgICAgPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaW5mb1wiPlxuICAgICAgICAgIFtbbG9jYWxpemUoJ3VpLmNvbXBvbmVudHMuaGlzdG9yeV9jaGFydHMubm9faGlzdG9yeV9mb3VuZCcpXV1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L3RlbXBsYXRlPlxuXG4gICAgICA8dGVtcGxhdGUgaXM9XCJkb20taWZcIiBpZj1cIltbaGlzdG9yeURhdGEudGltZWxpbmUubGVuZ3RoXV1cIj5cbiAgICAgICAgPHN0YXRlLWhpc3RvcnktY2hhcnQtdGltZWxpbmVcbiAgICAgICAgICBoYXNzPVwiW1toYXNzXV1cIlxuICAgICAgICAgIGRhdGE9XCJbW2hpc3RvcnlEYXRhLnRpbWVsaW5lXV1cIlxuICAgICAgICAgIGVuZC10aW1lPVwiW1tfY29tcHV0ZUVuZFRpbWUoZW5kVGltZSwgdXBUb05vdywgaGlzdG9yeURhdGEpXV1cIlxuICAgICAgICAgIG5vLXNpbmdsZT1cIltbbm9TaW5nbGVdXVwiXG4gICAgICAgICAgbmFtZXM9XCJbW25hbWVzXV1cIlxuICAgICAgICA+PC9zdGF0ZS1oaXN0b3J5LWNoYXJ0LXRpbWVsaW5lPlxuICAgICAgPC90ZW1wbGF0ZT5cblxuICAgICAgPHRlbXBsYXRlIGlzPVwiZG9tLXJlcGVhdFwiIGl0ZW1zPVwiW1toaXN0b3J5RGF0YS5saW5lXV1cIj5cbiAgICAgICAgPHN0YXRlLWhpc3RvcnktY2hhcnQtbGluZVxuICAgICAgICAgIGhhc3M9XCJbW2hhc3NdXVwiXG4gICAgICAgICAgdW5pdD1cIltbaXRlbS51bml0XV1cIlxuICAgICAgICAgIGRhdGE9XCJbW2l0ZW0uZGF0YV1dXCJcbiAgICAgICAgICBpZGVudGlmaWVyPVwiW1tpdGVtLmlkZW50aWZpZXJdXVwiXG4gICAgICAgICAgaXMtc2luZ2xlLWRldmljZT1cIltbX2NvbXB1dGVJc1NpbmdsZUxpbmVDaGFydChpdGVtLmRhdGEsIG5vU2luZ2xlKV1dXCJcbiAgICAgICAgICBlbmQtdGltZT1cIltbX2NvbXB1dGVFbmRUaW1lKGVuZFRpbWUsIHVwVG9Ob3csIGhpc3RvcnlEYXRhKV1dXCJcbiAgICAgICAgICBuYW1lcz1cIltbbmFtZXNdXVwiXG4gICAgICAgID48L3N0YXRlLWhpc3RvcnktY2hhcnQtbGluZT5cbiAgICAgIDwvdGVtcGxhdGU+XG4gICAgYDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaGFzczogT2JqZWN0LFxuICAgICAgaGlzdG9yeURhdGE6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIH0sXG4gICAgICBuYW1lczogT2JqZWN0LFxuXG4gICAgICBpc0xvYWRpbmdEYXRhOiBCb29sZWFuLFxuXG4gICAgICBlbmRUaW1lOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIH0sXG5cbiAgICAgIHVwVG9Ob3c6IEJvb2xlYW4sXG4gICAgICBub1NpbmdsZTogQm9vbGVhbixcbiAgICB9O1xuICB9XG5cbiAgX2NvbXB1dGVJc1NpbmdsZUxpbmVDaGFydChkYXRhLCBub1NpbmdsZSkge1xuICAgIHJldHVybiAhbm9TaW5nbGUgJiYgZGF0YSAmJiBkYXRhLmxlbmd0aCA9PT0gMTtcbiAgfVxuXG4gIF9jb21wdXRlSXNFbXB0eShpc0xvYWRpbmdEYXRhLCBoaXN0b3J5RGF0YSkge1xuICAgIGNvbnN0IGhpc3RvcnlEYXRhRW1wdHkgPVxuICAgICAgIWhpc3RvcnlEYXRhIHx8XG4gICAgICAhaGlzdG9yeURhdGEudGltZWxpbmUgfHxcbiAgICAgICFoaXN0b3J5RGF0YS5saW5lIHx8XG4gICAgICAoaGlzdG9yeURhdGEudGltZWxpbmUubGVuZ3RoID09PSAwICYmIGhpc3RvcnlEYXRhLmxpbmUubGVuZ3RoID09PSAwKTtcbiAgICByZXR1cm4gIWlzTG9hZGluZ0RhdGEgJiYgaGlzdG9yeURhdGFFbXB0eTtcbiAgfVxuXG4gIF9jb21wdXRlSXNMb2FkaW5nKGlzTG9hZGluZykge1xuICAgIHJldHVybiBpc0xvYWRpbmcgJiYgIXRoaXMuaGlzdG9yeURhdGE7XG4gIH1cblxuICBfY29tcHV0ZUVuZFRpbWUoZW5kVGltZSwgdXBUb05vdykge1xuICAgIC8vIFdlIGRvbid0IHJlYWxseSBjYXJlIGFib3V0IHRoZSB2YWx1ZSBvZiBoaXN0b3J5RGF0YSwgYnV0IGlmIGl0IGNoYW5nZSB3ZSB3YW50IHRvIHVwZGF0ZVxuICAgIC8vIGVuZFRpbWUuXG4gICAgcmV0dXJuIHVwVG9Ob3cgPyBuZXcgRGF0ZSgpIDogZW5kVGltZTtcbiAgfVxufVxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwic3RhdGUtaGlzdG9yeS1jaGFydHNcIiwgU3RhdGVIaXN0b3J5Q2hhcnRzKTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQStFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFLQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQW5HQTtBQUNBO0FBdURBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBRUE7QUFFQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBZkE7QUFpQkE7Ozs7QUE3RUE7QUFDQTtBQXFHQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/state-history-charts.js\n");

/***/ }),

/***/ "./src/data/history.ts":
/*!*****************************!*\
  !*** ./src/data/history.ts ***!
  \*****************************/
/*! exports provided: fetchRecent, fetchDate, computeHistory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fetchRecent\", function() { return fetchRecent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fetchDate\", function() { return fetchDate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeHistory\", function() { return computeHistory; });\n/* harmony import */ var _common_entity_compute_state_display__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/entity/compute_state_display */ \"./src/common/entity/compute_state_display.ts\");\n/* harmony import */ var _common_entity_compute_state_domain__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/entity/compute_state_domain */ \"./src/common/entity/compute_state_domain.ts\");\n/* harmony import */ var _common_entity_compute_state_name__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/entity/compute_state_name */ \"./src/common/entity/compute_state_name.ts\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n\n\n\nvar DOMAINS_USE_LAST_UPDATED = [\"climate\", \"water_heater\"];\nvar LINE_ATTRIBUTES_TO_KEEP = [\"temperature\", \"current_temperature\", \"target_temp_low\", \"target_temp_high\", \"hvac_action\"];\nvar fetchRecent = function fetchRecent(hass, entityId, startTime, endTime) {\n  var skipInitialState = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var significantChangesOnly = arguments.length > 5 ? arguments[5] : undefined;\n  var minimalResponse = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;\n  var url = \"history/period\";\n\n  if (startTime) {\n    url += \"/\" + startTime.toISOString();\n  }\n\n  url += \"?filter_entity_id=\" + entityId;\n\n  if (endTime) {\n    url += \"&end_time=\" + endTime.toISOString();\n  }\n\n  if (skipInitialState) {\n    url += \"&skip_initial_state\";\n  }\n\n  if (significantChangesOnly !== undefined) {\n    url += \"&significant_changes_only=\".concat(Number(significantChangesOnly));\n  }\n\n  if (minimalResponse) {\n    url += \"&minimal_response\";\n  }\n\n  return hass.callApi(\"GET\", url);\n};\nvar fetchDate = function fetchDate(hass, startTime, endTime) {\n  return hass.callApi(\"GET\", \"history/period/\".concat(startTime.toISOString(), \"?end_time=\").concat(endTime.toISOString(), \"&minimal_response\"));\n};\n\nvar equalState = function equalState(obj1, obj2) {\n  return obj1.state === obj2.state && ( // Only compare attributes if both states have an attributes object.\n  // When `minimal_response` is sent, only the first and last state\n  // will have attributes except for domains in DOMAINS_USE_LAST_UPDATED.\n  !obj1.attributes || !obj2.attributes || LINE_ATTRIBUTES_TO_KEEP.every(function (attr) {\n    return obj1.attributes[attr] === obj2.attributes[attr];\n  }));\n};\n\nvar processTimelineEntity = function processTimelineEntity(localize, language, states) {\n  var data = [];\n  var last_element = states.length - 1;\n\n  var _iterator = _createForOfIteratorHelper(states),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var state = _step.value;\n\n      if (data.length > 0 && state.state === data[data.length - 1].state) {\n        continue;\n      } // Copy the data from the last element as its the newest\n      // and is only needed to localize the data\n\n\n      if (!state.entity_id) {\n        state.attributes = states[last_element].attributes;\n        state.entity_id = states[last_element].entity_id;\n      }\n\n      data.push({\n        state_localize: Object(_common_entity_compute_state_display__WEBPACK_IMPORTED_MODULE_0__[\"computeStateDisplay\"])(localize, state, language),\n        state: state.state,\n        last_changed: state.last_changed\n      });\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return {\n    name: Object(_common_entity_compute_state_name__WEBPACK_IMPORTED_MODULE_2__[\"computeStateName\"])(states[0]),\n    entity_id: states[0].entity_id,\n    data: data\n  };\n};\n\nvar processLineChartEntities = function processLineChartEntities(unit, entities) {\n  var data = [];\n\n  var _iterator2 = _createForOfIteratorHelper(entities),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var states = _step2.value;\n      var last = states[states.length - 1];\n      var domain = Object(_common_entity_compute_state_domain__WEBPACK_IMPORTED_MODULE_1__[\"computeStateDomain\"])(last);\n      var processedStates = [];\n\n      var _iterator3 = _createForOfIteratorHelper(states),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var state = _step3.value;\n          var processedState = void 0;\n\n          if (DOMAINS_USE_LAST_UPDATED.includes(domain)) {\n            processedState = {\n              state: state.state,\n              last_changed: state.last_updated,\n              attributes: {}\n            };\n\n            var _iterator4 = _createForOfIteratorHelper(LINE_ATTRIBUTES_TO_KEEP),\n                _step4;\n\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                var attr = _step4.value;\n\n                if (attr in state.attributes) {\n                  processedState.attributes[attr] = state.attributes[attr];\n                }\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n          } else {\n            processedState = state;\n          }\n\n          if (processedStates.length > 1 && equalState(processedState, processedStates[processedStates.length - 1]) && equalState(processedState, processedStates[processedStates.length - 2])) {\n            continue;\n          }\n\n          processedStates.push(processedState);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      data.push({\n        domain: domain,\n        name: Object(_common_entity_compute_state_name__WEBPACK_IMPORTED_MODULE_2__[\"computeStateName\"])(last),\n        entity_id: last.entity_id,\n        states: processedStates\n      });\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return {\n    unit: unit,\n    identifier: entities.map(function (states) {\n      return states[0].entity_id;\n    }).join(\"\"),\n    data: data\n  };\n};\n\nvar computeHistory = function computeHistory(hass, stateHistory, localize, language) {\n  var lineChartDevices = {};\n  var timelineDevices = [];\n\n  if (!stateHistory) {\n    return {\n      line: [],\n      timeline: []\n    };\n  }\n\n  stateHistory.forEach(function (stateInfo) {\n    if (stateInfo.length === 0) {\n      return;\n    }\n\n    var stateWithUnit = stateInfo.find(function (state) {\n      return state.attributes && \"unit_of_measurement\" in state.attributes;\n    });\n    var unit;\n\n    if (stateWithUnit) {\n      unit = stateWithUnit.attributes.unit_of_measurement;\n    } else if (Object(_common_entity_compute_state_domain__WEBPACK_IMPORTED_MODULE_1__[\"computeStateDomain\"])(stateInfo[0]) === \"climate\") {\n      unit = hass.config.unit_system.temperature;\n    } else if (Object(_common_entity_compute_state_domain__WEBPACK_IMPORTED_MODULE_1__[\"computeStateDomain\"])(stateInfo[0]) === \"water_heater\") {\n      unit = hass.config.unit_system.temperature;\n    }\n\n    if (!unit) {\n      timelineDevices.push(processTimelineEntity(localize, language, stateInfo));\n    } else if (unit in lineChartDevices) {\n      lineChartDevices[unit].push(stateInfo);\n    } else {\n      lineChartDevices[unit] = [stateInfo];\n    }\n  });\n  var unitStates = Object.keys(lineChartDevices).map(function (unit) {\n    return processLineChartEntities(unit, lineChartDevices[unit]);\n  });\n  return {\n    line: unitStates,\n    timeline: timelineDevices\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZGF0YS9oaXN0b3J5LnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvaGlzdG9yeS50cz80YTUyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEhhc3NFbnRpdHkgfSBmcm9tIFwiaG9tZS1hc3Npc3RhbnQtanMtd2Vic29ja2V0XCI7XG5pbXBvcnQgeyBjb21wdXRlU3RhdGVEaXNwbGF5IH0gZnJvbSBcIi4uL2NvbW1vbi9lbnRpdHkvY29tcHV0ZV9zdGF0ZV9kaXNwbGF5XCI7XG5pbXBvcnQgeyBjb21wdXRlU3RhdGVEb21haW4gfSBmcm9tIFwiLi4vY29tbW9uL2VudGl0eS9jb21wdXRlX3N0YXRlX2RvbWFpblwiO1xuaW1wb3J0IHsgY29tcHV0ZVN0YXRlTmFtZSB9IGZyb20gXCIuLi9jb21tb24vZW50aXR5L2NvbXB1dGVfc3RhdGVfbmFtZVwiO1xuaW1wb3J0IHsgTG9jYWxpemVGdW5jIH0gZnJvbSBcIi4uL2NvbW1vbi90cmFuc2xhdGlvbnMvbG9jYWxpemVcIjtcbmltcG9ydCB7IEhvbWVBc3Npc3RhbnQgfSBmcm9tIFwiLi4vdHlwZXNcIjtcblxuY29uc3QgRE9NQUlOU19VU0VfTEFTVF9VUERBVEVEID0gW1wiY2xpbWF0ZVwiLCBcIndhdGVyX2hlYXRlclwiXTtcbmNvbnN0IExJTkVfQVRUUklCVVRFU19UT19LRUVQID0gW1xuICBcInRlbXBlcmF0dXJlXCIsXG4gIFwiY3VycmVudF90ZW1wZXJhdHVyZVwiLFxuICBcInRhcmdldF90ZW1wX2xvd1wiLFxuICBcInRhcmdldF90ZW1wX2hpZ2hcIixcbiAgXCJodmFjX2FjdGlvblwiLFxuXTtcblxuZXhwb3J0IGludGVyZmFjZSBMaW5lQ2hhcnRTdGF0ZSB7XG4gIHN0YXRlOiBzdHJpbmc7XG4gIGxhc3RfY2hhbmdlZDogc3RyaW5nO1xuICBhdHRyaWJ1dGVzPzogeyBba2V5OiBzdHJpbmddOiBhbnkgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMaW5lQ2hhcnRFbnRpdHkge1xuICBkb21haW46IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBlbnRpdHlfaWQ6IHN0cmluZztcbiAgc3RhdGVzOiBMaW5lQ2hhcnRTdGF0ZVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExpbmVDaGFydFVuaXQge1xuICB1bml0OiBzdHJpbmc7XG4gIGlkZW50aWZpZXI6IHN0cmluZztcbiAgZGF0YTogTGluZUNoYXJ0RW50aXR5W107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGltZWxpbmVTdGF0ZSB7XG4gIHN0YXRlX2xvY2FsaXplOiBzdHJpbmc7XG4gIHN0YXRlOiBzdHJpbmc7XG4gIGxhc3RfY2hhbmdlZDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRpbWVsaW5lRW50aXR5IHtcbiAgbmFtZTogc3RyaW5nO1xuICBlbnRpdHlfaWQ6IHN0cmluZztcbiAgZGF0YTogVGltZWxpbmVTdGF0ZVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhpc3RvcnlSZXN1bHQge1xuICBsaW5lOiBMaW5lQ2hhcnRVbml0W107XG4gIHRpbWVsaW5lOiBUaW1lbGluZUVudGl0eVtdO1xufVxuXG5leHBvcnQgY29uc3QgZmV0Y2hSZWNlbnQgPSAoXG4gIGhhc3MsXG4gIGVudGl0eUlkLFxuICBzdGFydFRpbWUsXG4gIGVuZFRpbWUsXG4gIHNraXBJbml0aWFsU3RhdGUgPSBmYWxzZSxcbiAgc2lnbmlmaWNhbnRDaGFuZ2VzT25seT86IGJvb2xlYW4sXG4gIG1pbmltYWxSZXNwb25zZSA9IHRydWVcbik6IFByb21pc2U8SGFzc0VudGl0eVtdW10+ID0+IHtcbiAgbGV0IHVybCA9IFwiaGlzdG9yeS9wZXJpb2RcIjtcbiAgaWYgKHN0YXJ0VGltZSkge1xuICAgIHVybCArPSBcIi9cIiArIHN0YXJ0VGltZS50b0lTT1N0cmluZygpO1xuICB9XG4gIHVybCArPSBcIj9maWx0ZXJfZW50aXR5X2lkPVwiICsgZW50aXR5SWQ7XG4gIGlmIChlbmRUaW1lKSB7XG4gICAgdXJsICs9IFwiJmVuZF90aW1lPVwiICsgZW5kVGltZS50b0lTT1N0cmluZygpO1xuICB9XG4gIGlmIChza2lwSW5pdGlhbFN0YXRlKSB7XG4gICAgdXJsICs9IFwiJnNraXBfaW5pdGlhbF9zdGF0ZVwiO1xuICB9XG4gIGlmIChzaWduaWZpY2FudENoYW5nZXNPbmx5ICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cmwgKz0gYCZzaWduaWZpY2FudF9jaGFuZ2VzX29ubHk9JHtOdW1iZXIoc2lnbmlmaWNhbnRDaGFuZ2VzT25seSl9YDtcbiAgfVxuICBpZiAobWluaW1hbFJlc3BvbnNlKSB7XG4gICAgdXJsICs9IFwiJm1pbmltYWxfcmVzcG9uc2VcIjtcbiAgfVxuXG4gIHJldHVybiBoYXNzLmNhbGxBcGkoXCJHRVRcIiwgdXJsKTtcbn07XG5cbmV4cG9ydCBjb25zdCBmZXRjaERhdGUgPSAoXG4gIGhhc3M6IEhvbWVBc3Npc3RhbnQsXG4gIHN0YXJ0VGltZTogRGF0ZSxcbiAgZW5kVGltZTogRGF0ZVxuKTogUHJvbWlzZTxIYXNzRW50aXR5W11bXT4gPT4ge1xuICByZXR1cm4gaGFzcy5jYWxsQXBpKFxuICAgIFwiR0VUXCIsXG4gICAgYGhpc3RvcnkvcGVyaW9kLyR7c3RhcnRUaW1lLnRvSVNPU3RyaW5nKCl9P2VuZF90aW1lPSR7ZW5kVGltZS50b0lTT1N0cmluZygpfSZtaW5pbWFsX3Jlc3BvbnNlYFxuICApO1xufTtcblxuY29uc3QgZXF1YWxTdGF0ZSA9IChvYmoxOiBMaW5lQ2hhcnRTdGF0ZSwgb2JqMjogTGluZUNoYXJ0U3RhdGUpID0+XG4gIG9iajEuc3RhdGUgPT09IG9iajIuc3RhdGUgJiZcbiAgLy8gT25seSBjb21wYXJlIGF0dHJpYnV0ZXMgaWYgYm90aCBzdGF0ZXMgaGF2ZSBhbiBhdHRyaWJ1dGVzIG9iamVjdC5cbiAgLy8gV2hlbiBgbWluaW1hbF9yZXNwb25zZWAgaXMgc2VudCwgb25seSB0aGUgZmlyc3QgYW5kIGxhc3Qgc3RhdGVcbiAgLy8gd2lsbCBoYXZlIGF0dHJpYnV0ZXMgZXhjZXB0IGZvciBkb21haW5zIGluIERPTUFJTlNfVVNFX0xBU1RfVVBEQVRFRC5cbiAgKCFvYmoxLmF0dHJpYnV0ZXMgfHxcbiAgICAhb2JqMi5hdHRyaWJ1dGVzIHx8XG4gICAgTElORV9BVFRSSUJVVEVTX1RPX0tFRVAuZXZlcnkoXG4gICAgICAoYXR0cikgPT4gb2JqMS5hdHRyaWJ1dGVzIVthdHRyXSA9PT0gb2JqMi5hdHRyaWJ1dGVzIVthdHRyXVxuICAgICkpO1xuXG5jb25zdCBwcm9jZXNzVGltZWxpbmVFbnRpdHkgPSAoXG4gIGxvY2FsaXplOiBMb2NhbGl6ZUZ1bmMsXG4gIGxhbmd1YWdlOiBzdHJpbmcsXG4gIHN0YXRlczogSGFzc0VudGl0eVtdXG4pOiBUaW1lbGluZUVudGl0eSA9PiB7XG4gIGNvbnN0IGRhdGE6IFRpbWVsaW5lU3RhdGVbXSA9IFtdO1xuICBjb25zdCBsYXN0X2VsZW1lbnQgPSBzdGF0ZXMubGVuZ3RoIC0gMTtcblxuICBmb3IgKGNvbnN0IHN0YXRlIG9mIHN0YXRlcykge1xuICAgIGlmIChkYXRhLmxlbmd0aCA+IDAgJiYgc3RhdGUuc3RhdGUgPT09IGRhdGFbZGF0YS5sZW5ndGggLSAxXS5zdGF0ZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gQ29weSB0aGUgZGF0YSBmcm9tIHRoZSBsYXN0IGVsZW1lbnQgYXMgaXRzIHRoZSBuZXdlc3RcbiAgICAvLyBhbmQgaXMgb25seSBuZWVkZWQgdG8gbG9jYWxpemUgdGhlIGRhdGFcbiAgICBpZiAoIXN0YXRlLmVudGl0eV9pZCkge1xuICAgICAgc3RhdGUuYXR0cmlidXRlcyA9IHN0YXRlc1tsYXN0X2VsZW1lbnRdLmF0dHJpYnV0ZXM7XG4gICAgICBzdGF0ZS5lbnRpdHlfaWQgPSBzdGF0ZXNbbGFzdF9lbGVtZW50XS5lbnRpdHlfaWQ7XG4gICAgfVxuXG4gICAgZGF0YS5wdXNoKHtcbiAgICAgIHN0YXRlX2xvY2FsaXplOiBjb21wdXRlU3RhdGVEaXNwbGF5KGxvY2FsaXplLCBzdGF0ZSwgbGFuZ3VhZ2UpLFxuICAgICAgc3RhdGU6IHN0YXRlLnN0YXRlLFxuICAgICAgbGFzdF9jaGFuZ2VkOiBzdGF0ZS5sYXN0X2NoYW5nZWQsXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6IGNvbXB1dGVTdGF0ZU5hbWUoc3RhdGVzWzBdKSxcbiAgICBlbnRpdHlfaWQ6IHN0YXRlc1swXS5lbnRpdHlfaWQsXG4gICAgZGF0YSxcbiAgfTtcbn07XG5cbmNvbnN0IHByb2Nlc3NMaW5lQ2hhcnRFbnRpdGllcyA9IChcbiAgdW5pdCxcbiAgZW50aXRpZXM6IEhhc3NFbnRpdHlbXVtdXG4pOiBMaW5lQ2hhcnRVbml0ID0+IHtcbiAgY29uc3QgZGF0YTogTGluZUNoYXJ0RW50aXR5W10gPSBbXTtcblxuICBmb3IgKGNvbnN0IHN0YXRlcyBvZiBlbnRpdGllcykge1xuICAgIGNvbnN0IGxhc3Q6IEhhc3NFbnRpdHkgPSBzdGF0ZXNbc3RhdGVzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGRvbWFpbiA9IGNvbXB1dGVTdGF0ZURvbWFpbihsYXN0KTtcbiAgICBjb25zdCBwcm9jZXNzZWRTdGF0ZXM6IExpbmVDaGFydFN0YXRlW10gPSBbXTtcblxuICAgIGZvciAoY29uc3Qgc3RhdGUgb2Ygc3RhdGVzKSB7XG4gICAgICBsZXQgcHJvY2Vzc2VkU3RhdGU6IExpbmVDaGFydFN0YXRlO1xuXG4gICAgICBpZiAoRE9NQUlOU19VU0VfTEFTVF9VUERBVEVELmluY2x1ZGVzKGRvbWFpbikpIHtcbiAgICAgICAgcHJvY2Vzc2VkU3RhdGUgPSB7XG4gICAgICAgICAgc3RhdGU6IHN0YXRlLnN0YXRlLFxuICAgICAgICAgIGxhc3RfY2hhbmdlZDogc3RhdGUubGFzdF91cGRhdGVkLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBMSU5FX0FUVFJJQlVURVNfVE9fS0VFUCkge1xuICAgICAgICAgIGlmIChhdHRyIGluIHN0YXRlLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHByb2Nlc3NlZFN0YXRlLmF0dHJpYnV0ZXMhW2F0dHJdID0gc3RhdGUuYXR0cmlidXRlc1thdHRyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3NlZFN0YXRlID0gc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgcHJvY2Vzc2VkU3RhdGVzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgZXF1YWxTdGF0ZShcbiAgICAgICAgICBwcm9jZXNzZWRTdGF0ZSxcbiAgICAgICAgICBwcm9jZXNzZWRTdGF0ZXNbcHJvY2Vzc2VkU3RhdGVzLmxlbmd0aCAtIDFdXG4gICAgICAgICkgJiZcbiAgICAgICAgZXF1YWxTdGF0ZShwcm9jZXNzZWRTdGF0ZSwgcHJvY2Vzc2VkU3RhdGVzW3Byb2Nlc3NlZFN0YXRlcy5sZW5ndGggLSAyXSlcbiAgICAgICkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcHJvY2Vzc2VkU3RhdGVzLnB1c2gocHJvY2Vzc2VkU3RhdGUpO1xuICAgIH1cblxuICAgIGRhdGEucHVzaCh7XG4gICAgICBkb21haW4sXG4gICAgICBuYW1lOiBjb21wdXRlU3RhdGVOYW1lKGxhc3QpLFxuICAgICAgZW50aXR5X2lkOiBsYXN0LmVudGl0eV9pZCxcbiAgICAgIHN0YXRlczogcHJvY2Vzc2VkU3RhdGVzLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB1bml0LFxuICAgIGlkZW50aWZpZXI6IGVudGl0aWVzLm1hcCgoc3RhdGVzKSA9PiBzdGF0ZXNbMF0uZW50aXR5X2lkKS5qb2luKFwiXCIpLFxuICAgIGRhdGEsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgY29tcHV0ZUhpc3RvcnkgPSAoXG4gIGhhc3M6IEhvbWVBc3Npc3RhbnQsXG4gIHN0YXRlSGlzdG9yeTogSGFzc0VudGl0eVtdW10sXG4gIGxvY2FsaXplOiBMb2NhbGl6ZUZ1bmMsXG4gIGxhbmd1YWdlOiBzdHJpbmdcbik6IEhpc3RvcnlSZXN1bHQgPT4ge1xuICBjb25zdCBsaW5lQ2hhcnREZXZpY2VzOiB7IFt1bml0OiBzdHJpbmddOiBIYXNzRW50aXR5W11bXSB9ID0ge307XG4gIGNvbnN0IHRpbWVsaW5lRGV2aWNlczogVGltZWxpbmVFbnRpdHlbXSA9IFtdO1xuICBpZiAoIXN0YXRlSGlzdG9yeSkge1xuICAgIHJldHVybiB7IGxpbmU6IFtdLCB0aW1lbGluZTogW10gfTtcbiAgfVxuXG4gIHN0YXRlSGlzdG9yeS5mb3JFYWNoKChzdGF0ZUluZm8pID0+IHtcbiAgICBpZiAoc3RhdGVJbmZvLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXRlV2l0aFVuaXQgPSBzdGF0ZUluZm8uZmluZChcbiAgICAgIChzdGF0ZSkgPT4gc3RhdGUuYXR0cmlidXRlcyAmJiBcInVuaXRfb2ZfbWVhc3VyZW1lbnRcIiBpbiBzdGF0ZS5hdHRyaWJ1dGVzXG4gICAgKTtcblxuICAgIGxldCB1bml0OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgICBpZiAoc3RhdGVXaXRoVW5pdCkge1xuICAgICAgdW5pdCA9IHN0YXRlV2l0aFVuaXQuYXR0cmlidXRlcy51bml0X29mX21lYXN1cmVtZW50O1xuICAgIH0gZWxzZSBpZiAoY29tcHV0ZVN0YXRlRG9tYWluKHN0YXRlSW5mb1swXSkgPT09IFwiY2xpbWF0ZVwiKSB7XG4gICAgICB1bml0ID0gaGFzcy5jb25maWcudW5pdF9zeXN0ZW0udGVtcGVyYXR1cmU7XG4gICAgfSBlbHNlIGlmIChjb21wdXRlU3RhdGVEb21haW4oc3RhdGVJbmZvWzBdKSA9PT0gXCJ3YXRlcl9oZWF0ZXJcIikge1xuICAgICAgdW5pdCA9IGhhc3MuY29uZmlnLnVuaXRfc3lzdGVtLnRlbXBlcmF0dXJlO1xuICAgIH1cblxuICAgIGlmICghdW5pdCkge1xuICAgICAgdGltZWxpbmVEZXZpY2VzLnB1c2goXG4gICAgICAgIHByb2Nlc3NUaW1lbGluZUVudGl0eShsb2NhbGl6ZSwgbGFuZ3VhZ2UsIHN0YXRlSW5mbylcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICh1bml0IGluIGxpbmVDaGFydERldmljZXMpIHtcbiAgICAgIGxpbmVDaGFydERldmljZXNbdW5pdF0ucHVzaChzdGF0ZUluZm8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lQ2hhcnREZXZpY2VzW3VuaXRdID0gW3N0YXRlSW5mb107XG4gICAgfVxuICB9KTtcblxuICBjb25zdCB1bml0U3RhdGVzID0gT2JqZWN0LmtleXMobGluZUNoYXJ0RGV2aWNlcykubWFwKCh1bml0KSA9PlxuICAgIHByb2Nlc3NMaW5lQ2hhcnRFbnRpdGllcyh1bml0LCBsaW5lQ2hhcnREZXZpY2VzW3VuaXRdKVxuICApO1xuXG4gIHJldHVybiB7IGxpbmU6IHVuaXRTdGF0ZXMsIHRpbWVsaW5lOiB0aW1lbGluZURldmljZXMgfTtcbn07XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBNENBO0FBUUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFSQTtBQUNBO0FBVUE7QUFLQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBQ0E7QUFEQTtBQUlBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFyQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRkE7QUFBQTtBQUNBO0FBREE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUFBO0FBQ0E7QUFEQTtBQUtBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFGQTtBQUFBO0FBQ0E7QUFEQTtBQU9BO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcENBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQXFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQS9DQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFnREE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/data/history.ts\n");

/***/ })

}]);