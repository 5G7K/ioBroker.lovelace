(self["webpackJsonp"] = self["webpackJsonp"] || []).push([["vendors~hui-dialog-suggest-card~panel-lovelace"],{

/***/ "./node_modules/@polymer/paper-spinner/paper-spinner.js":
/*!**************************************************************!*\
  !*** ./node_modules/@polymer/paper-spinner/paper-spinner.js ***!
  \**************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _polymer_polymer_polymer_legacy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/polymer-legacy.js */ \"./node_modules/@polymer/polymer/polymer-legacy.js\");\n/* harmony import */ var _polymer_paper_styles_color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @polymer/paper-styles/color.js */ \"./node_modules/@polymer/paper-styles/color.js\");\n/* harmony import */ var _paper_spinner_styles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./paper-spinner-styles.js */ \"./node_modules/@polymer/paper-spinner/paper-spinner-styles.js\");\n/* harmony import */ var _polymer_polymer_lib_legacy_polymer_fn_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @polymer/polymer/lib/legacy/polymer-fn.js */ \"./node_modules/@polymer/polymer/lib/legacy/polymer-fn.js\");\n/* harmony import */ var _polymer_polymer_lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @polymer/polymer/lib/utils/html-tag.js */ \"./node_modules/@polymer/polymer/lib/utils/html-tag.js\");\n/* harmony import */ var _paper_spinner_behavior_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./paper-spinner-behavior.js */ \"./node_modules/@polymer/paper-spinner/paper-spinner-behavior.js\");\n/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n\nconst template = _polymer_polymer_lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_4__[\"html\"]`\n  <style include=\"paper-spinner-styles\"></style>\n\n  <div id=\"spinnerContainer\" class-name=\"[[__computeContainerClasses(active, __coolingDown)]]\" on-animationend=\"__reset\" on-webkit-animation-end=\"__reset\">\n    <div class=\"spinner-layer layer-1\">\n      <div class=\"circle-clipper left\">\n        <div class=\"circle\"></div>\n      </div>\n      <div class=\"circle-clipper right\">\n        <div class=\"circle\"></div>\n      </div>\n    </div>\n\n    <div class=\"spinner-layer layer-2\">\n      <div class=\"circle-clipper left\">\n        <div class=\"circle\"></div>\n      </div>\n      <div class=\"circle-clipper right\">\n        <div class=\"circle\"></div>\n      </div>\n    </div>\n\n    <div class=\"spinner-layer layer-3\">\n      <div class=\"circle-clipper left\">\n        <div class=\"circle\"></div>\n      </div>\n      <div class=\"circle-clipper right\">\n        <div class=\"circle\"></div>\n      </div>\n    </div>\n\n    <div class=\"spinner-layer layer-4\">\n      <div class=\"circle-clipper left\">\n        <div class=\"circle\"></div>\n      </div>\n      <div class=\"circle-clipper right\">\n        <div class=\"circle\"></div>\n      </div>\n    </div>\n  </div>\n`;\ntemplate.setAttribute('strip-whitespace', '');\n/**\nMaterial design: [Progress &\nactivity](https://www.google.com/design/spec/components/progress-activity.html)\n\nElement providing a multiple color material design circular spinner.\n\n    <paper-spinner active></paper-spinner>\n\nThe default spinner cycles between four layers of colors; by default they are\nblue, red, yellow and green. It can be customized to cycle between four\ndifferent colors. Use <paper-spinner-lite> for single color spinners.\n\n### Accessibility\n\nAlt attribute should be set to provide adequate context for accessibility. If\nnot provided, it defaults to 'loading'. Empty alt can be provided to mark the\nelement as decorative if alternative content is provided in another form (e.g. a\ntext block following the spinner).\n\n    <paper-spinner alt=\"Loading contacts list\" active></paper-spinner>\n\n### Styling\n\nThe following custom properties and mixins are available for styling:\n\nCustom property | Description | Default\n----------------|-------------|----------\n`--paper-spinner-layer-1-color` | Color of the first spinner rotation | `--google-blue-500`\n`--paper-spinner-layer-2-color` | Color of the second spinner rotation | `--google-red-500`\n`--paper-spinner-layer-3-color` | Color of the third spinner rotation | `--google-yellow-500`\n`--paper-spinner-layer-4-color` | Color of the fourth spinner rotation | `--google-green-500`\n`--paper-spinner-stroke-width` | The width of the spinner stroke | 3px\n\n@group Paper Elements\n@element paper-spinner\n@hero hero.svg\n@demo demo/index.html\n*/\n\nObject(_polymer_polymer_lib_legacy_polymer_fn_js__WEBPACK_IMPORTED_MODULE_3__[\"Polymer\"])({\n  _template: template,\n  is: 'paper-spinner',\n  behaviors: [_paper_spinner_behavior_js__WEBPACK_IMPORTED_MODULE_5__[\"PaperSpinnerBehavior\"]]\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItc3Bpbm5lci9wYXBlci1zcGlubmVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLXNwaW5uZXIvcGFwZXItc3Bpbm5lci5qcz85NTEyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbmh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dCBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG5odHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHQgVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlXG5mb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dCBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhc1xucGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc28gc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudFxuZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuaW1wb3J0ICdAcG9seW1lci9wb2x5bWVyL3BvbHltZXItbGVnYWN5LmpzJztcbmltcG9ydCAnQHBvbHltZXIvcGFwZXItc3R5bGVzL2NvbG9yLmpzJztcbmltcG9ydCAnLi9wYXBlci1zcGlubmVyLXN0eWxlcy5qcyc7XG5cbmltcG9ydCB7UG9seW1lcn0gZnJvbSAnQHBvbHltZXIvcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXItZm4uanMnO1xuaW1wb3J0IHtodG1sfSBmcm9tICdAcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9odG1sLXRhZy5qcyc7XG5cbmltcG9ydCB7UGFwZXJTcGlubmVyQmVoYXZpb3J9IGZyb20gJy4vcGFwZXItc3Bpbm5lci1iZWhhdmlvci5qcyc7XG5cbmNvbnN0IHRlbXBsYXRlID0gaHRtbGBcbiAgPHN0eWxlIGluY2x1ZGU9XCJwYXBlci1zcGlubmVyLXN0eWxlc1wiPjwvc3R5bGU+XG5cbiAgPGRpdiBpZD1cInNwaW5uZXJDb250YWluZXJcIiBjbGFzcy1uYW1lPVwiW1tfX2NvbXB1dGVDb250YWluZXJDbGFzc2VzKGFjdGl2ZSwgX19jb29saW5nRG93bildXVwiIG9uLWFuaW1hdGlvbmVuZD1cIl9fcmVzZXRcIiBvbi13ZWJraXQtYW5pbWF0aW9uLWVuZD1cIl9fcmVzZXRcIj5cbiAgICA8ZGl2IGNsYXNzPVwic3Bpbm5lci1sYXllciBsYXllci0xXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiY2lyY2xlLWNsaXBwZXIgbGVmdFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2lyY2xlXCI+PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJjaXJjbGUtY2xpcHBlciByaWdodFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2lyY2xlXCI+PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJzcGlubmVyLWxheWVyIGxheWVyLTJcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJjaXJjbGUtY2xpcHBlciBsZWZ0XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjaXJjbGVcIj48L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cImNpcmNsZS1jbGlwcGVyIHJpZ2h0XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjaXJjbGVcIj48L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cInNwaW5uZXItbGF5ZXIgbGF5ZXItM1wiPlxuICAgICAgPGRpdiBjbGFzcz1cImNpcmNsZS1jbGlwcGVyIGxlZnRcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNpcmNsZVwiPjwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwiY2lyY2xlLWNsaXBwZXIgcmlnaHRcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNpcmNsZVwiPjwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwic3Bpbm5lci1sYXllciBsYXllci00XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiY2lyY2xlLWNsaXBwZXIgbGVmdFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2lyY2xlXCI+PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJjaXJjbGUtY2xpcHBlciByaWdodFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2lyY2xlXCI+PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG5gO1xudGVtcGxhdGUuc2V0QXR0cmlidXRlKCdzdHJpcC13aGl0ZXNwYWNlJywgJycpO1xuXG4vKipcbk1hdGVyaWFsIGRlc2lnbjogW1Byb2dyZXNzICZcbmFjdGl2aXR5XShodHRwczovL3d3dy5nb29nbGUuY29tL2Rlc2lnbi9zcGVjL2NvbXBvbmVudHMvcHJvZ3Jlc3MtYWN0aXZpdHkuaHRtbClcblxuRWxlbWVudCBwcm92aWRpbmcgYSBtdWx0aXBsZSBjb2xvciBtYXRlcmlhbCBkZXNpZ24gY2lyY3VsYXIgc3Bpbm5lci5cblxuICAgIDxwYXBlci1zcGlubmVyIGFjdGl2ZT48L3BhcGVyLXNwaW5uZXI+XG5cblRoZSBkZWZhdWx0IHNwaW5uZXIgY3ljbGVzIGJldHdlZW4gZm91ciBsYXllcnMgb2YgY29sb3JzOyBieSBkZWZhdWx0IHRoZXkgYXJlXG5ibHVlLCByZWQsIHllbGxvdyBhbmQgZ3JlZW4uIEl0IGNhbiBiZSBjdXN0b21pemVkIHRvIGN5Y2xlIGJldHdlZW4gZm91clxuZGlmZmVyZW50IGNvbG9ycy4gVXNlIDxwYXBlci1zcGlubmVyLWxpdGU+IGZvciBzaW5nbGUgY29sb3Igc3Bpbm5lcnMuXG5cbiMjIyBBY2Nlc3NpYmlsaXR5XG5cbkFsdCBhdHRyaWJ1dGUgc2hvdWxkIGJlIHNldCB0byBwcm92aWRlIGFkZXF1YXRlIGNvbnRleHQgZm9yIGFjY2Vzc2liaWxpdHkuIElmXG5ub3QgcHJvdmlkZWQsIGl0IGRlZmF1bHRzIHRvICdsb2FkaW5nJy4gRW1wdHkgYWx0IGNhbiBiZSBwcm92aWRlZCB0byBtYXJrIHRoZVxuZWxlbWVudCBhcyBkZWNvcmF0aXZlIGlmIGFsdGVybmF0aXZlIGNvbnRlbnQgaXMgcHJvdmlkZWQgaW4gYW5vdGhlciBmb3JtIChlLmcuIGFcbnRleHQgYmxvY2sgZm9sbG93aW5nIHRoZSBzcGlubmVyKS5cblxuICAgIDxwYXBlci1zcGlubmVyIGFsdD1cIkxvYWRpbmcgY29udGFjdHMgbGlzdFwiIGFjdGl2ZT48L3BhcGVyLXNwaW5uZXI+XG5cbiMjIyBTdHlsaW5nXG5cblRoZSBmb2xsb3dpbmcgY3VzdG9tIHByb3BlcnRpZXMgYW5kIG1peGlucyBhcmUgYXZhaWxhYmxlIGZvciBzdHlsaW5nOlxuXG5DdXN0b20gcHJvcGVydHkgfCBEZXNjcmlwdGlvbiB8IERlZmF1bHRcbi0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tXG5gLS1wYXBlci1zcGlubmVyLWxheWVyLTEtY29sb3JgIHwgQ29sb3Igb2YgdGhlIGZpcnN0IHNwaW5uZXIgcm90YXRpb24gfCBgLS1nb29nbGUtYmx1ZS01MDBgXG5gLS1wYXBlci1zcGlubmVyLWxheWVyLTItY29sb3JgIHwgQ29sb3Igb2YgdGhlIHNlY29uZCBzcGlubmVyIHJvdGF0aW9uIHwgYC0tZ29vZ2xlLXJlZC01MDBgXG5gLS1wYXBlci1zcGlubmVyLWxheWVyLTMtY29sb3JgIHwgQ29sb3Igb2YgdGhlIHRoaXJkIHNwaW5uZXIgcm90YXRpb24gfCBgLS1nb29nbGUteWVsbG93LTUwMGBcbmAtLXBhcGVyLXNwaW5uZXItbGF5ZXItNC1jb2xvcmAgfCBDb2xvciBvZiB0aGUgZm91cnRoIHNwaW5uZXIgcm90YXRpb24gfCBgLS1nb29nbGUtZ3JlZW4tNTAwYFxuYC0tcGFwZXItc3Bpbm5lci1zdHJva2Utd2lkdGhgIHwgVGhlIHdpZHRoIG9mIHRoZSBzcGlubmVyIHN0cm9rZSB8IDNweFxuXG5AZ3JvdXAgUGFwZXIgRWxlbWVudHNcbkBlbGVtZW50IHBhcGVyLXNwaW5uZXJcbkBoZXJvIGhlcm8uc3ZnXG5AZGVtbyBkZW1vL2luZGV4Lmh0bWxcbiovXG5Qb2x5bWVyKHtcbiAgX3RlbXBsYXRlOiB0ZW1wbGF0ZSxcblxuICBpczogJ3BhcGVyLXNwaW5uZXInLFxuXG4gIGJlaGF2aW9yczogW1BhcGVyU3Bpbm5lckJlaGF2aW9yXVxufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBeUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNDQTtBQUNBO0FBRUE7QUFFQTtBQUxBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@polymer/paper-spinner/paper-spinner.js\n");

/***/ }),

/***/ "./node_modules/@thomasloven/round-slider/src/main.js":
/*!************************************************************!*\
  !*** ./node_modules/@thomasloven/round-slider/src/main.js ***!
  \************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var lit_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit-element */ \"./node_modules/lit-element/lit-element.js\");\n\n\nclass RoundSlider extends lit_element__WEBPACK_IMPORTED_MODULE_0__[\"LitElement\"] {\n  static get properties() {\n    return {\n      value: {\n        type: Number\n      },\n      high: {\n        type: Number\n      },\n      low: {\n        type: Number\n      },\n      min: {\n        type: Number\n      },\n      max: {\n        type: Number\n      },\n      step: {\n        type: Number\n      },\n      startAngle: {\n        type: Number\n      },\n      arcLength: {\n        type: Number\n      },\n      handleSize: {\n        type: Number\n      },\n      handleZoom: {\n        type: Number\n      },\n      readonly: {\n        type: Boolean\n      },\n      disabled: {\n        type: Boolean\n      },\n      dragging: {\n        type: Boolean,\n        reflect: true\n      },\n      rtl: {\n        type: Boolean\n      },\n      _scale: {\n        type: Number\n      },\n      valueLabel: {\n        type: String\n      },\n      lowLabel: {\n        type: String\n      },\n      highLabel: {\n        type: String\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.min = 0;\n    this.max = 100;\n    this.step = 1;\n    this.startAngle = 135;\n    this.arcLength = 270;\n    this.handleSize = 6;\n    this.handleZoom = 1.5;\n    this.readonly = false;\n    this.disabled = false;\n    this.dragging = false;\n    this.rtl = false;\n    this._scale = 1;\n    this.attachedListeners = false;\n  }\n\n  get _start() {\n    return this.startAngle * Math.PI / 180;\n  }\n\n  get _len() {\n    // Things get weird if length is more than a complete turn\n    return Math.min(this.arcLength * Math.PI / 180, 2 * Math.PI - 0.01);\n  }\n\n  get _end() {\n    return this._start + this._len;\n  }\n\n  get _showHandle() {\n    // If handle is shown\n    if (this.readonly) return false;\n    if (this.value == null && (this.high == null || this.low == null)) return false;\n    return true;\n  }\n\n  _angleInside(angle) {\n    // Check if an angle is on the arc\n    let a = (this.startAngle + this.arcLength / 2 - angle + 180 + 360) % 360 - 180;\n    return a < this.arcLength / 2 && a > -this.arcLength / 2;\n  }\n\n  _angle2xy(angle) {\n    if (this.rtl) return {\n      x: -Math.cos(angle),\n      y: Math.sin(angle)\n    };\n    return {\n      x: Math.cos(angle),\n      y: Math.sin(angle)\n    };\n  }\n\n  _xy2angle(x, y) {\n    if (this.rtl) x = -x;\n    return (Math.atan2(y, x) - this._start + 2 * Math.PI) % (2 * Math.PI);\n  }\n\n  _value2angle(value) {\n    value = Math.min(this.max, Math.max(this.min, value));\n    const fraction = (value - this.min) / (this.max - this.min);\n    return this._start + fraction * this._len;\n  }\n\n  _angle2value(angle) {\n    return Math.round((angle / this._len * (this.max - this.min) + this.min) / this.step) * this.step;\n  }\n\n  get _boundaries() {\n    // Get the maximum extents of the bar arc\n    const start = this._angle2xy(this._start);\n\n    const end = this._angle2xy(this._end);\n\n    let up = 1;\n    if (!this._angleInside(270)) up = Math.max(-start.y, -end.y);\n    let down = 1;\n    if (!this._angleInside(90)) down = Math.max(start.y, end.y);\n    let left = 1;\n    if (!this._angleInside(180)) left = Math.max(-start.x, -end.x);\n    let right = 1;\n    if (!this._angleInside(0)) right = Math.max(start.x, end.x);\n    return {\n      up,\n      down,\n      left,\n      right,\n      height: up + down,\n      width: left + right\n    };\n  }\n\n  _mouse2value(ev) {\n    const mouseX = ev.type.startsWith(\"touch\") ? ev.touches[0].clientX : ev.clientX;\n    const mouseY = ev.type.startsWith(\"touch\") ? ev.touches[0].clientY : ev.clientY;\n    const rect = this.shadowRoot.querySelector(\"svg\").getBoundingClientRect();\n    const boundaries = this._boundaries;\n    const x = mouseX - (rect.left + boundaries.left * rect.width / boundaries.width);\n    const y = mouseY - (rect.top + boundaries.up * rect.height / boundaries.height);\n\n    const angle = this._xy2angle(x, y);\n\n    const pos = this._angle2value(angle);\n\n    return pos;\n  }\n\n  dragStart(ev) {\n    if (!this._showHandle || this.disabled) return;\n    let handle = ev.target;\n    let cooldown = undefined; // Avoid double events mouseDown->focus\n\n    if (this._rotation && this._rotation.type !== \"focus\") return; // If the bar was touched, find the nearest handle and drag from that\n\n    if (handle.classList.contains(\"shadowpath\")) {\n      if (ev.type === \"touchstart\") cooldown = window.setTimeout(() => {\n        if (this._rotation) this._rotation.cooldown = undefined;\n      }, 200);\n\n      if (this.low == null) {\n        handle = this.shadowRoot.querySelector(\"#value\");\n      } else {\n        const mouse = this._mouse2value(ev);\n\n        if (Math.abs(mouse - this.low) < Math.abs(mouse - this.high)) {\n          handle = this.shadowRoot.querySelector(\"#low\");\n        } else {\n          handle = this.shadowRoot.querySelector(\"#high\");\n        }\n      }\n    } // If an invisible handle was clicked, switch to the visible counterpart\n\n\n    if (handle.classList.contains(\"overflow\")) handle = handle.nextElementSibling;\n    if (!handle.classList.contains(\"handle\")) return;\n    handle.setAttribute('stroke-width', 2 * this.handleSize * this.handleZoom * this._scale);\n    const min = handle.id === \"high\" ? this.low : this.min;\n    const max = handle.id === \"low\" ? this.high : this.max;\n    this._rotation = {\n      handle,\n      min,\n      max,\n      start: this[handle.id],\n      type: ev.type,\n      cooldown\n    };\n    this.dragging = true;\n  }\n\n  _cleanupRotation() {\n    const handle = this._rotation.handle;\n    handle.setAttribute('stroke-width', 2 * this.handleSize * this._scale);\n    this._rotation = false;\n    this.dragging = false;\n    handle.blur();\n  }\n\n  dragEnd(ev) {\n    if (!this._showHandle || this.disabled) return;\n    if (!this._rotation) return;\n    const handle = this._rotation.handle;\n\n    this._cleanupRotation();\n\n    let event = new CustomEvent('value-changed', {\n      detail: {\n        [handle.id]: this[handle.id]\n      }\n    });\n    this.dispatchEvent(event); // This makes the low handle render over the high handle if they both are\n    // close to the top end.  Otherwise if would be unclickable, and the high\n    // handle locked by the low.  Calcualtion is done in the dragEnd handler to\n    // avoid \"z fighting\" while dragging.\n\n    if (this.low && this.low >= 0.99 * this.max) this._reverseOrder = true;else this._reverseOrder = false;\n  }\n\n  drag(ev) {\n    if (!this._showHandle || this.disabled) return;\n    if (!this._rotation) return;\n\n    if (this._rotation.cooldown) {\n      window.clearTimeout(this._rotation.coldown);\n\n      this._cleanupRotation();\n\n      return;\n    }\n\n    if (this._rotation.type === \"focus\") return;\n    ev.preventDefault();\n\n    const pos = this._mouse2value(ev);\n\n    this._dragpos(pos);\n  }\n\n  _dragpos(pos) {\n    if (pos < this._rotation.min || pos > this._rotation.max) return;\n    const handle = this._rotation.handle;\n    this[handle.id] = pos;\n    let event = new CustomEvent('value-changing', {\n      detail: {\n        [handle.id]: pos\n      }\n    });\n    this.dispatchEvent(event);\n  }\n\n  _keyStep(ev) {\n    if (!this._showHandle || this.disabled) return;\n    if (!this._rotation) return;\n    const handle = this._rotation.handle;\n\n    if (ev.key === \"ArrowLeft\" || ev.key === \"ArrowDown\") {\n      ev.preventDefault();\n      if (this.rtl) this._dragpos(this[handle.id] + this.step);else this._dragpos(this[handle.id] - this.step);\n    }\n\n    if (ev.key === \"ArrowRight\" || ev.key === \"ArrowUp\") {\n      ev.preventDefault();\n      if (this.rtl) this._dragpos(this[handle.id] - this.step);else this._dragpos(this[handle.id] + this.step);\n    }\n\n    if (ev.key === \"Home\") {\n      ev.preventDefault();\n\n      this._dragpos(this.min);\n    }\n\n    if (ev.key === \"End\") {\n      ev.preventDefault();\n\n      this._dragpos(this.max);\n    }\n  }\n\n  firstUpdated() {\n    document.addEventListener('mouseup', this.dragEnd.bind(this));\n    document.addEventListener('touchend', this.dragEnd.bind(this), {\n      passive: false\n    });\n    document.addEventListener('mousemove', this.drag.bind(this));\n    document.addEventListener('touchmove', this.drag.bind(this), {\n      passive: false\n    });\n    document.addEventListener('keydown', this._keyStep.bind(this));\n  }\n\n  updated(changedProperties) {\n    // Adjust margin in the bar slider stroke width is greater than the handle size\n    if (this.shadowRoot.querySelector(\".slider\")) {\n      const styles = window.getComputedStyle(this.shadowRoot.querySelector(\".slider\"));\n\n      if (styles && styles['strokeWidth']) {\n        const stroke = parseFloat(styles['strokeWidth']);\n\n        if (stroke > this.handleSize * this.handleZoom) {\n          const view = this._boundaries;\n          const margin = `\n          ${stroke / 2 * Math.abs(view.up)}px\n          ${stroke / 2 * Math.abs(view.right)}px\n          ${stroke / 2 * Math.abs(view.down)}px\n          ${stroke / 2 * Math.abs(view.left)}px`;\n          this.shadowRoot.querySelector(\"svg\").style.margin = margin;\n        }\n      }\n    } // Workaround for vector-effect not working in IE and pre-Chromium Edge\n    // That's also why the _scale property exists\n\n\n    if (this.shadowRoot.querySelector(\"svg\") && this.shadowRoot.querySelector(\"svg\").style.vectorEffect === undefined) {\n      if (changedProperties.has(\"_scale\") && this._scale != 1) {\n        this.shadowRoot.querySelector(\"svg\").querySelectorAll(\"path\").forEach(e => {\n          if (e.getAttribute('stroke-width')) return;\n          const orig = parseFloat(getComputedStyle(e).getPropertyValue('stroke-width'));\n          e.style.strokeWidth = `${orig * this._scale}px`;\n        });\n      }\n\n      const rect = this.shadowRoot.querySelector(\"svg\").getBoundingClientRect();\n      const scale = Math.max(rect.width, rect.height);\n      this._scale = 2 / scale;\n    }\n  }\n\n  _renderArc(start, end) {\n    const diff = end - start;\n    start = this._angle2xy(start);\n    end = this._angle2xy(end + 0.001); // Safari doesn't like arcs with no length\n\n    return `\n      M ${start.x} ${start.y}\n      A 1 1,\n        0,\n        ${diff > Math.PI ? \"1\" : \"0\"} ${this.rtl ? \"0\" : \"1\"},\n        ${end.x} ${end.y}\n    `;\n  }\n\n  _renderHandle(id) {\n    const theta = this._value2angle(this[id]);\n\n    const pos = this._angle2xy(theta);\n\n    const label = {\n      value: this.valueLabel,\n      low: this.lowLabel,\n      high: this.highLabel\n    }[id] || \"\"; // Two handles are drawn. One visible, and one invisible that's twice as\n    // big. Makes it easier to click.\n\n    return lit_element__WEBPACK_IMPORTED_MODULE_0__[\"svg\"]`\n      <g class=\"${id} handle\">\n        <path\n          id=${id}\n          class=\"overflow\"\n          d=\"\n          M ${pos.x} ${pos.y}\n          L ${pos.x + 0.001} ${pos.y + 0.001}\n          \"\n          vector-effect=\"non-scaling-stroke\"\n          stroke=\"rgba(0,0,0,0)\"\n          stroke-width=\"${4 * this.handleSize * this._scale}\"\n          />\n        <path\n          id=${id}\n          class=\"handle\"\n          d=\"\n          M ${pos.x} ${pos.y}\n          L ${pos.x + 0.001} ${pos.y + 0.001}\n          \"\n          vector-effect=\"non-scaling-stroke\"\n          stroke-width=\"${2 * this.handleSize * this._scale}\"\n          tabindex=\"0\"\n          @focus=${this.dragStart}\n          @blur=${this.dragEnd}\n          role=\"slider\"\n          aria-valuemin=${this.min}\n          aria-valuemax=${this.max}\n          aria-valuenow=${this[id]}\n          aria-disabled=${this.disabled}\n          aria-label=${label || \"\"}\n          />\n        </g>\n      `;\n  }\n\n  render() {\n    const view = this._boundaries;\n    return lit_element__WEBPACK_IMPORTED_MODULE_0__[\"html\"]`\n      <svg\n        @mousedown=${this.dragStart}\n        @touchstart=${this.dragStart}\n        xmln=\"http://www.w3.org/2000/svg\"\n        viewBox=\"${-view.left} ${-view.up} ${view.width} ${view.height}\"\n        style=\"margin: ${this.handleSize * this.handleZoom}px;\"\n        ?disabled=${this.disabled}\n        focusable=\"false\"\n      >\n        <g class=\"slider\">\n          <path\n            class=\"path\"\n            d=${this._renderArc(this._start, this._end)}\n            vector-effect=\"non-scaling-stroke\"\n          />\n          <path\n            class=\"bar\"\n            vector-effect=\"non-scaling-stroke\"\n            d=${this._renderArc(this._value2angle(this.low != null ? this.low : this.min), this._value2angle(this.high != null ? this.high : this.value))}\n          />\n          <path\n            class=\"shadowpath\"\n            d=${this._renderArc(this._start, this._end)}\n            vector-effect=\"non-scaling-stroke\"\n            stroke=\"rgba(0,0,0,0)\"\n            stroke-width=\"${3 * this.handleSize * this._scale}\"\n            stroke-linecap=\"butt\"\n          />\n\n        </g>\n\n        <g class=\"handles\">\n        ${this._showHandle ? this.low != null ? this._reverseOrder ? lit_element__WEBPACK_IMPORTED_MODULE_0__[\"html\"]`${this._renderHandle(\"high\")} ${this._renderHandle(\"low\")}` : lit_element__WEBPACK_IMPORTED_MODULE_0__[\"html\"]`${this._renderHandle(\"low\")} ${this._renderHandle(\"high\")}` : lit_element__WEBPACK_IMPORTED_MODULE_0__[\"html\"]`${this._renderHandle(\"value\")}` : ``}\n        </g>\n      </svg>\n    `;\n  }\n\n  static get styles() {\n    return lit_element__WEBPACK_IMPORTED_MODULE_0__[\"css\"]`\n      :host {\n        display: inline-block;\n        width: 100%;\n      }\n      svg {\n        overflow: visible;\n        display: block;\n      }\n      path {\n        transition: stroke 1s ease-out, stroke-width 200ms ease-out;\n      }\n      .slider {\n        fill: none;\n        stroke-width: var(--round-slider-path-width, 3);\n        stroke-linecap: var(--round-slider-linecap, round);\n      }\n      .path {\n        stroke: var(--round-slider-path-color, lightgray);\n      }\n      .bar {\n        stroke: var(--round-slider-bar-color, deepskyblue);\n      }\n      svg[disabled] .bar {\n        stroke: var(--round-slider-disabled-bar-color, darkgray);\n      }\n      g.handles {\n        stroke: var(--round-slider-handle-color, var(--round-slider-bar-color, deepskyblue));\n        stroke-linecap: round;\n      }\n      g.low.handle {\n        stroke: var(--round-slider-low-handle-color);\n      }\n      g.high.handle {\n        stroke: var(--round-slider-high-handle-color);\n      }\n      svg[disabled] g.handles {\n        stroke: var(--round-slider-disabled-bar-color, darkgray);\n      }\n      .handle:focus {\n        outline: unset;\n      }\n    `;\n  }\n\n}\n\ncustomElements.define('round-slider', RoundSlider);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRob21hc2xvdmVuL3JvdW5kLXNsaWRlci9zcmMvbWFpbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGhvbWFzbG92ZW4vcm91bmQtc2xpZGVyL3NyYy9tYWluLmpzPzU2MzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgTGl0RWxlbWVudCxcbiAgaHRtbCxcbiAgY3NzLFxuICBzdmcsXG59IGZyb20gXCJsaXQtZWxlbWVudFwiO1xuXG5jbGFzcyBSb3VuZFNsaWRlciBleHRlbmRzIExpdEVsZW1lbnQge1xuXG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHt0eXBlOiBOdW1iZXJ9LFxuICAgICAgaGlnaDoge3R5cGU6IE51bWJlcn0sXG4gICAgICBsb3c6IHt0eXBlOiBOdW1iZXJ9LFxuICAgICAgbWluOiB7dHlwZTogTnVtYmVyfSxcbiAgICAgIG1heDoge3R5cGU6IE51bWJlcn0sXG4gICAgICBzdGVwOiB7dHlwZTogTnVtYmVyfSxcbiAgICAgIHN0YXJ0QW5nbGU6IHt0eXBlOiBOdW1iZXJ9LFxuICAgICAgYXJjTGVuZ3RoOiB7dHlwZTogTnVtYmVyfSxcbiAgICAgIGhhbmRsZVNpemU6IHt0eXBlOiBOdW1iZXJ9LFxuICAgICAgaGFuZGxlWm9vbToge3R5cGU6IE51bWJlcn0sXG4gICAgICByZWFkb25seToge3R5cGU6IEJvb2xlYW59LFxuICAgICAgZGlzYWJsZWQ6IHt0eXBlOiBCb29sZWFufSxcbiAgICAgIGRyYWdnaW5nOiB7dHlwZTogQm9vbGVhbiwgcmVmbGVjdDogdHJ1ZX0sXG4gICAgICBydGw6IHt0eXBlOiBCb29sZWFufSxcbiAgICAgIF9zY2FsZToge3R5cGU6IE51bWJlcn0sXG4gICAgICB2YWx1ZUxhYmVsOiB7dHlwZTogU3RyaW5nfSxcbiAgICAgIGxvd0xhYmVsOiB7dHlwZTogU3RyaW5nfSxcbiAgICAgIGhpZ2hMYWJlbDoge3R5cGU6IFN0cmluZ30sXG4gICAgfVxuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm1pbiA9IDA7XG4gICAgdGhpcy5tYXggPSAxMDA7XG4gICAgdGhpcy5zdGVwID0gMTtcbiAgICB0aGlzLnN0YXJ0QW5nbGUgPSAxMzU7XG4gICAgdGhpcy5hcmNMZW5ndGggPSAyNzA7XG4gICAgdGhpcy5oYW5kbGVTaXplID0gNjtcbiAgICB0aGlzLmhhbmRsZVpvb20gPSAxLjU7XG4gICAgdGhpcy5yZWFkb25seSA9IGZhbHNlO1xuICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5ydGwgPSBmYWxzZTtcbiAgICB0aGlzLl9zY2FsZSA9IDE7XG4gICAgdGhpcy5hdHRhY2hlZExpc3RlbmVycyA9IGZhbHNlO1xuICB9XG5cbiAgZ2V0IF9zdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydEFuZ2xlKk1hdGguUEkvMTgwO1xuICB9XG4gIGdldCBfbGVuKCkge1xuICAgIC8vIFRoaW5ncyBnZXQgd2VpcmQgaWYgbGVuZ3RoIGlzIG1vcmUgdGhhbiBhIGNvbXBsZXRlIHR1cm5cbiAgICByZXR1cm4gTWF0aC5taW4odGhpcy5hcmNMZW5ndGgqTWF0aC5QSS8xODAsIDIqTWF0aC5QSS0wLjAxKTtcbiAgfVxuICBnZXQgX2VuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnQgKyB0aGlzLl9sZW47XG4gIH1cblxuICBnZXQgX3Nob3dIYW5kbGUoKSB7XG4gICAgLy8gSWYgaGFuZGxlIGlzIHNob3duXG4gICAgaWYodGhpcy5yZWFkb25seSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmKHRoaXMudmFsdWUgPT0gbnVsbCAmJiAodGhpcy5oaWdoID09IG51bGwgfHwgdGhpcy5sb3cgPT0gbnVsbCkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIF9hbmdsZUluc2lkZShhbmdsZSkge1xuICAgIC8vIENoZWNrIGlmIGFuIGFuZ2xlIGlzIG9uIHRoZSBhcmNcbiAgICBsZXQgYSA9ICh0aGlzLnN0YXJ0QW5nbGUgKyB0aGlzLmFyY0xlbmd0aC8yIC0gYW5nbGUgKyAxODAgKyAzNjApICUgMzYwIC0gMTgwO1xuICAgIHJldHVybiAoYSA8IHRoaXMuYXJjTGVuZ3RoLzIgJiYgYSA+IC10aGlzLmFyY0xlbmd0aC8yKTtcbiAgfVxuICBfYW5nbGUyeHkoYW5nbGUpIHtcbiAgICBpZih0aGlzLnJ0bClcbiAgICAgIHJldHVybiB7eDogLU1hdGguY29zKGFuZ2xlKSwgeTogTWF0aC5zaW4oYW5nbGUpfVxuICAgIHJldHVybiB7eDogTWF0aC5jb3MoYW5nbGUpLCB5OiBNYXRoLnNpbihhbmdsZSl9XG4gIH1cbiAgX3h5MmFuZ2xlKHgseSkge1xuICAgIGlmKHRoaXMucnRsKVxuICAgICAgeCA9IC14O1xuICAgIHJldHVybiAoTWF0aC5hdGFuMih5LHgpIC0gdGhpcy5fc3RhcnQgKyAyKk1hdGguUEkpICUgKDIqTWF0aC5QSSk7XG4gIH1cblxuICBfdmFsdWUyYW5nbGUodmFsdWUpIHtcbiAgICB2YWx1ZSA9IE1hdGgubWluKHRoaXMubWF4LCBNYXRoLm1heCh0aGlzLm1pbiwgdmFsdWUpKTtcbiAgICBjb25zdCBmcmFjdGlvbiA9ICh2YWx1ZSAtIHRoaXMubWluKS8odGhpcy5tYXggLSB0aGlzLm1pbik7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0ICsgZnJhY3Rpb24gKiB0aGlzLl9sZW47XG4gIH1cbiAgX2FuZ2xlMnZhbHVlKGFuZ2xlKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoKGFuZ2xlL3RoaXMuX2xlbioodGhpcy5tYXggLSB0aGlzLm1pbikgKyB0aGlzLm1pbikvdGhpcy5zdGVwKSp0aGlzLnN0ZXA7XG4gIH1cblxuXG4gIGdldCBfYm91bmRhcmllcygpIHtcbiAgICAvLyBHZXQgdGhlIG1heGltdW0gZXh0ZW50cyBvZiB0aGUgYmFyIGFyY1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fYW5nbGUyeHkodGhpcy5fc3RhcnQpO1xuICAgIGNvbnN0IGVuZCA9IHRoaXMuX2FuZ2xlMnh5KHRoaXMuX2VuZCk7XG5cbiAgICBsZXQgdXAgPSAxO1xuICAgIGlmKCF0aGlzLl9hbmdsZUluc2lkZSgyNzApKVxuICAgICAgdXAgPSAgTWF0aC5tYXgoLXN0YXJ0LnksIC1lbmQueSk7XG5cbiAgICBsZXQgZG93biA9IDE7XG4gICAgaWYoIXRoaXMuX2FuZ2xlSW5zaWRlKDkwKSlcbiAgICAgIGRvd24gPSBNYXRoLm1heChzdGFydC55LCBlbmQueSk7XG5cbiAgICBsZXQgbGVmdCA9IDE7XG4gICAgaWYoIXRoaXMuX2FuZ2xlSW5zaWRlKDE4MCkpXG4gICAgICBsZWZ0ID0gTWF0aC5tYXgoLXN0YXJ0LngsIC1lbmQueCk7XG5cbiAgICBsZXQgcmlnaHQgPSAxO1xuICAgIGlmKCF0aGlzLl9hbmdsZUluc2lkZSgwKSlcbiAgICAgIHJpZ2h0ID0gTWF0aC5tYXgoc3RhcnQueCwgZW5kLngpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHVwLCBkb3duLCBsZWZ0LCByaWdodCxcbiAgICAgIGhlaWdodDogdXArZG93bixcbiAgICAgIHdpZHRoOiBsZWZ0K3JpZ2h0LFxuICAgIH07XG4gIH1cblxuICBfbW91c2UydmFsdWUoZXYpIHtcbiAgICBjb25zdCBtb3VzZVggPSAoZXYudHlwZS5zdGFydHNXaXRoKFwidG91Y2hcIikpID8gZXYudG91Y2hlc1swXS5jbGllbnRYIDogZXYuY2xpZW50WDtcbiAgICBjb25zdCBtb3VzZVkgPSAoZXYudHlwZS5zdGFydHNXaXRoKFwidG91Y2hcIikpID8gZXYudG91Y2hlc1swXS5jbGllbnRZIDogZXYuY2xpZW50WTtcblxuICAgIGNvbnN0IHJlY3QgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcInN2Z1wiKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBib3VuZGFyaWVzID0gdGhpcy5fYm91bmRhcmllcztcbiAgICBjb25zdCB4ID0gbW91c2VYIC0gKHJlY3QubGVmdCArIGJvdW5kYXJpZXMubGVmdCpyZWN0LndpZHRoL2JvdW5kYXJpZXMud2lkdGgpO1xuICAgIGNvbnN0IHkgPSBtb3VzZVkgLSAocmVjdC50b3AgKyBib3VuZGFyaWVzLnVwKnJlY3QuaGVpZ2h0L2JvdW5kYXJpZXMuaGVpZ2h0KTtcblxuICAgIGNvbnN0IGFuZ2xlID0gdGhpcy5feHkyYW5nbGUoeCx5KTtcbiAgICBjb25zdCBwb3MgPSB0aGlzLl9hbmdsZTJ2YWx1ZShhbmdsZSk7XG4gICAgcmV0dXJuIHBvcztcbiAgfVxuXG4gIGRyYWdTdGFydChldikge1xuICAgIGlmKCF0aGlzLl9zaG93SGFuZGxlIHx8IHRoaXMuZGlzYWJsZWQpIHJldHVybjtcbiAgICBsZXQgaGFuZGxlID0gZXYudGFyZ2V0O1xuICAgIGxldCBjb29sZG93biA9IHVuZGVmaW5lZDtcblxuICAgIC8vIEF2b2lkIGRvdWJsZSBldmVudHMgbW91c2VEb3duLT5mb2N1c1xuICAgIGlmKHRoaXMuX3JvdGF0aW9uICYmIHRoaXMuX3JvdGF0aW9uLnR5cGUgIT09IFwiZm9jdXNcIikgcmV0dXJuO1xuXG4gICAgLy8gSWYgdGhlIGJhciB3YXMgdG91Y2hlZCwgZmluZCB0aGUgbmVhcmVzdCBoYW5kbGUgYW5kIGRyYWcgZnJvbSB0aGF0XG4gICAgaWYoaGFuZGxlLmNsYXNzTGlzdC5jb250YWlucyhcInNoYWRvd3BhdGhcIikpIHtcbiAgICAgIGlmKGV2LnR5cGUgPT09IFwidG91Y2hzdGFydFwiKVxuICAgICAgICBjb29sZG93biA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZih0aGlzLl9yb3RhdGlvbikgdGhpcy5fcm90YXRpb24uY29vbGRvd24gPSB1bmRlZmluZWQ7XG4gICAgICAgIH0sIDIwMCk7XG4gICAgICBpZih0aGlzLmxvdyA9PSBudWxsKSB7XG4gICAgICAgIGhhbmRsZSA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiI3ZhbHVlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbW91c2UgPSB0aGlzLl9tb3VzZTJ2YWx1ZShldik7XG4gICAgICAgIGlmKE1hdGguYWJzKG1vdXNlLXRoaXMubG93KSA8IE1hdGguYWJzKG1vdXNlLXRoaXMuaGlnaCkpIHtcbiAgICAgICAgICBoYW5kbGUgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcIiNsb3dcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCIjaGlnaFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIGFuIGludmlzaWJsZSBoYW5kbGUgd2FzIGNsaWNrZWQsIHN3aXRjaCB0byB0aGUgdmlzaWJsZSBjb3VudGVycGFydFxuICAgIGlmKGhhbmRsZS5jbGFzc0xpc3QuY29udGFpbnMoXCJvdmVyZmxvd1wiKSlcbiAgICAgIGhhbmRsZSA9IGhhbmRsZS5uZXh0RWxlbWVudFNpYmxpbmc7XG5cbiAgICBpZighaGFuZGxlLmNsYXNzTGlzdC5jb250YWlucyhcImhhbmRsZVwiKSkgcmV0dXJuO1xuICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIDIqdGhpcy5oYW5kbGVTaXplKnRoaXMuaGFuZGxlWm9vbSp0aGlzLl9zY2FsZSk7XG5cbiAgICBjb25zdCBtaW4gPSBoYW5kbGUuaWQgPT09IFwiaGlnaFwiID8gdGhpcy5sb3cgOiB0aGlzLm1pbjtcbiAgICBjb25zdCBtYXggPSBoYW5kbGUuaWQgPT09IFwibG93XCIgPyB0aGlzLmhpZ2ggOiB0aGlzLm1heDtcbiAgICB0aGlzLl9yb3RhdGlvbiA9IHsgaGFuZGxlLCBtaW4sIG1heCwgc3RhcnQ6IHRoaXNbaGFuZGxlLmlkXSwgdHlwZTogZXYudHlwZSwgY29vbGRvd259O1xuICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICB9XG5cbiAgX2NsZWFudXBSb3RhdGlvbigpIHtcbiAgICBjb25zdCBoYW5kbGUgPSB0aGlzLl9yb3RhdGlvbi5oYW5kbGU7XG4gICAgaGFuZGxlLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgMip0aGlzLmhhbmRsZVNpemUqdGhpcy5fc2NhbGUpO1xuXG4gICAgdGhpcy5fcm90YXRpb24gPSBmYWxzZTtcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG5cbiAgICBoYW5kbGUuYmx1cigpO1xuICB9XG5cbiAgZHJhZ0VuZChldikge1xuICAgIGlmKCF0aGlzLl9zaG93SGFuZGxlIHx8IHRoaXMuZGlzYWJsZWQpIHJldHVybjtcbiAgICBpZighdGhpcy5fcm90YXRpb24pIHJldHVybjtcblxuICAgIGNvbnN0IGhhbmRsZSA9IHRoaXMuX3JvdGF0aW9uLmhhbmRsZTtcbiAgICB0aGlzLl9jbGVhbnVwUm90YXRpb24oKTtcblxuICAgIGxldCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgndmFsdWUtY2hhbmdlZCcsIHtcbiAgICAgIGRldGFpbDoge1xuICAgICAgICBbaGFuZGxlLmlkXSA6IHRoaXNbaGFuZGxlLmlkXSxcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXG4gICAgLy8gVGhpcyBtYWtlcyB0aGUgbG93IGhhbmRsZSByZW5kZXIgb3ZlciB0aGUgaGlnaCBoYW5kbGUgaWYgdGhleSBib3RoIGFyZVxuICAgIC8vIGNsb3NlIHRvIHRoZSB0b3AgZW5kLiAgT3RoZXJ3aXNlIGlmIHdvdWxkIGJlIHVuY2xpY2thYmxlLCBhbmQgdGhlIGhpZ2hcbiAgICAvLyBoYW5kbGUgbG9ja2VkIGJ5IHRoZSBsb3cuICBDYWxjdWFsdGlvbiBpcyBkb25lIGluIHRoZSBkcmFnRW5kIGhhbmRsZXIgdG9cbiAgICAvLyBhdm9pZCBcInogZmlnaHRpbmdcIiB3aGlsZSBkcmFnZ2luZy5cbiAgICBpZih0aGlzLmxvdyAmJiB0aGlzLmxvdyA+PSAwLjk5KnRoaXMubWF4KVxuICAgICAgdGhpcy5fcmV2ZXJzZU9yZGVyID0gdHJ1ZTtcbiAgICBlbHNlXG4gICAgICB0aGlzLl9yZXZlcnNlT3JkZXIgPSBmYWxzZTtcbiAgfVxuXG4gIGRyYWcoZXYpIHtcbiAgICBpZighdGhpcy5fc2hvd0hhbmRsZSB8fCB0aGlzLmRpc2FibGVkKSByZXR1cm47XG4gICAgaWYoIXRoaXMuX3JvdGF0aW9uKSByZXR1cm47XG4gICAgaWYodGhpcy5fcm90YXRpb24uY29vbGRvd24pIHtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fcm90YXRpb24uY29sZG93bik7XG4gICAgICB0aGlzLl9jbGVhbnVwUm90YXRpb24oKVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZih0aGlzLl9yb3RhdGlvbi50eXBlID09PSBcImZvY3VzXCIpIHJldHVybjtcblxuICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBjb25zdCBwb3MgPSB0aGlzLl9tb3VzZTJ2YWx1ZShldik7XG5cbiAgICB0aGlzLl9kcmFncG9zKHBvcyk7XG4gIH1cblxuICBfZHJhZ3Bvcyhwb3MpIHtcbiAgICBpZihwb3MgPCB0aGlzLl9yb3RhdGlvbi5taW4gfHwgcG9zID4gdGhpcy5fcm90YXRpb24ubWF4KSByZXR1cm47XG5cbiAgICBjb25zdCBoYW5kbGUgPSB0aGlzLl9yb3RhdGlvbi5oYW5kbGU7XG4gICAgdGhpc1toYW5kbGUuaWRdID0gcG9zO1xuXG4gICAgbGV0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCd2YWx1ZS1jaGFuZ2luZycsIHtcbiAgICAgIGRldGFpbDoge1xuICAgICAgICBbaGFuZGxlLmlkXSA6IHBvcyxcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9XG5cbiAgX2tleVN0ZXAoZXYpIHtcbiAgICBpZighdGhpcy5fc2hvd0hhbmRsZSB8fCB0aGlzLmRpc2FibGVkKSByZXR1cm47XG4gICAgaWYoIXRoaXMuX3JvdGF0aW9uKSByZXR1cm47XG4gICAgY29uc3QgaGFuZGxlID0gdGhpcy5fcm90YXRpb24uaGFuZGxlO1xuICAgIGlmKGV2LmtleSA9PT0gXCJBcnJvd0xlZnRcIiB8fCBldi5rZXkgPT09IFwiQXJyb3dEb3duXCIpIHtcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZih0aGlzLnJ0bClcbiAgICAgICAgdGhpcy5fZHJhZ3Bvcyh0aGlzW2hhbmRsZS5pZF0gKyB0aGlzLnN0ZXApO1xuICAgICAgZWxzZVxuICAgICAgICB0aGlzLl9kcmFncG9zKHRoaXNbaGFuZGxlLmlkXSAtIHRoaXMuc3RlcCk7XG4gICAgfVxuICAgIGlmKGV2LmtleSA9PT0gXCJBcnJvd1JpZ2h0XCIgfHwgZXYua2V5ID09PSBcIkFycm93VXBcIikge1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmKHRoaXMucnRsKVxuICAgICAgICB0aGlzLl9kcmFncG9zKHRoaXNbaGFuZGxlLmlkXSAtIHRoaXMuc3RlcCk7XG4gICAgICBlbHNlXG4gICAgICAgIHRoaXMuX2RyYWdwb3ModGhpc1toYW5kbGUuaWRdICsgdGhpcy5zdGVwKTtcbiAgICB9XG4gICAgaWYoZXYua2V5ID09PSBcIkhvbWVcIikge1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuX2RyYWdwb3ModGhpcy5taW4pO1xuICAgIH1cbiAgICBpZihldi5rZXkgPT09IFwiRW5kXCIpIHtcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLl9kcmFncG9zKHRoaXMubWF4KTtcbiAgICB9XG4gIH1cblxuICBmaXJzdFVwZGF0ZWQoKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuZHJhZ0VuZC5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuZHJhZ0VuZC5iaW5kKHRoaXMpLCB7cGFzc2l2ZTogZmFsc2V9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLmRyYWcuYmluZCh0aGlzKSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5kcmFnLmJpbmQodGhpcyksIHtwYXNzaXZlOiBmYWxzZX0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9rZXlTdGVwLmJpbmQodGhpcykpO1xuICB9XG5cbiAgdXBkYXRlZChjaGFuZ2VkUHJvcGVydGllcykge1xuXG4gICAgLy8gQWRqdXN0IG1hcmdpbiBpbiB0aGUgYmFyIHNsaWRlciBzdHJva2Ugd2lkdGggaXMgZ3JlYXRlciB0aGFuIHRoZSBoYW5kbGUgc2l6ZVxuICAgIGlmKHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiLnNsaWRlclwiKSkge1xuICAgICAgY29uc3Qgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCIuc2xpZGVyXCIpKTtcbiAgICAgIGlmIChzdHlsZXMgJiYgc3R5bGVzWydzdHJva2VXaWR0aCddKSB7XG4gICAgICAgIGNvbnN0IHN0cm9rZSA9IHBhcnNlRmxvYXQoc3R5bGVzWydzdHJva2VXaWR0aCddKVxuICAgICAgICBpZiAoc3Ryb2tlID4gdGhpcy5oYW5kbGVTaXplKnRoaXMuaGFuZGxlWm9vbSkge1xuICAgICAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLl9ib3VuZGFyaWVzO1xuICAgICAgICAgIGNvbnN0IG1hcmdpbiA9IGBcbiAgICAgICAgICAke3N0cm9rZS8yKk1hdGguYWJzKHZpZXcudXApfXB4XG4gICAgICAgICAgJHtzdHJva2UvMipNYXRoLmFicyh2aWV3LnJpZ2h0KX1weFxuICAgICAgICAgICR7c3Ryb2tlLzIqTWF0aC5hYnModmlldy5kb3duKX1weFxuICAgICAgICAgICR7c3Ryb2tlLzIqTWF0aC5hYnModmlldy5sZWZ0KX1weGA7XG4gICAgICAgICAgdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCJzdmdcIikuc3R5bGUubWFyZ2luID0gbWFyZ2luO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV29ya2Fyb3VuZCBmb3IgdmVjdG9yLWVmZmVjdCBub3Qgd29ya2luZyBpbiBJRSBhbmQgcHJlLUNocm9taXVtIEVkZ2VcbiAgICAvLyBUaGF0J3MgYWxzbyB3aHkgdGhlIF9zY2FsZSBwcm9wZXJ0eSBleGlzdHNcbiAgICBpZih0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcInN2Z1wiKVxuICAgICYmIHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwic3ZnXCIpLnN0eWxlLnZlY3RvckVmZmVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZihjaGFuZ2VkUHJvcGVydGllcy5oYXMoXCJfc2NhbGVcIikgJiYgdGhpcy5fc2NhbGUgIT0gMSkge1xuICAgICAgICB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcInN2Z1wiKS5xdWVyeVNlbGVjdG9yQWxsKFwicGF0aFwiKS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAgICAgaWYoZS5nZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcpKSByZXR1cm47XG4gICAgICAgICAgY29uc3Qgb3JpZyA9IHBhcnNlRmxvYXQoZ2V0Q29tcHV0ZWRTdHlsZShlKS5nZXRQcm9wZXJ0eVZhbHVlKCdzdHJva2Utd2lkdGgnKSk7XG4gICAgICAgICAgZS5zdHlsZS5zdHJva2VXaWR0aCA9IGAke29yaWcqdGhpcy5fc2NhbGV9cHhgO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcInN2Z1wiKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHNjYWxlID0gTWF0aC5tYXgocmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICAgICAgdGhpcy5fc2NhbGUgPSAyL3NjYWxlO1xuICAgIH1cblxuICB9XG5cbiAgX3JlbmRlckFyYyhzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgZGlmZiA9IGVuZC1zdGFydDtcbiAgICBzdGFydCA9IHRoaXMuX2FuZ2xlMnh5KHN0YXJ0KTtcbiAgICBlbmQgPSB0aGlzLl9hbmdsZTJ4eShlbmQrMC4wMDEpOyAvLyBTYWZhcmkgZG9lc24ndCBsaWtlIGFyY3Mgd2l0aCBubyBsZW5ndGhcbiAgICByZXR1cm4gYFxuICAgICAgTSAke3N0YXJ0Lnh9ICR7c3RhcnQueX1cbiAgICAgIEEgMSAxLFxuICAgICAgICAwLFxuICAgICAgICAkeyhkaWZmKSA+IE1hdGguUEkgPyBcIjFcIiA6IFwiMFwifSAke3RoaXMucnRsID8gXCIwXCIgOiBcIjFcIn0sXG4gICAgICAgICR7ZW5kLnh9ICR7ZW5kLnl9XG4gICAgYDtcbiAgfVxuXG4gIF9yZW5kZXJIYW5kbGUoaWQpIHtcbiAgICBjb25zdCB0aGV0YSA9IHRoaXMuX3ZhbHVlMmFuZ2xlKHRoaXNbaWRdKTtcbiAgICBjb25zdCBwb3MgPSB0aGlzLl9hbmdsZTJ4eSh0aGV0YSk7XG4gICAgY29uc3QgbGFiZWwgPSB7XG4gICAgICB2YWx1ZTogdGhpcy52YWx1ZUxhYmVsLFxuICAgICAgbG93OiB0aGlzLmxvd0xhYmVsLFxuICAgICAgaGlnaDogdGhpcy5oaWdoTGFiZWxcbiAgICB9W2lkXSB8fCBcIlwiO1xuXG4gICAgLy8gVHdvIGhhbmRsZXMgYXJlIGRyYXduLiBPbmUgdmlzaWJsZSwgYW5kIG9uZSBpbnZpc2libGUgdGhhdCdzIHR3aWNlIGFzXG4gICAgLy8gYmlnLiBNYWtlcyBpdCBlYXNpZXIgdG8gY2xpY2suXG4gICAgcmV0dXJuIHN2Z2BcbiAgICAgIDxnIGNsYXNzPVwiJHtpZH0gaGFuZGxlXCI+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgaWQ9JHtpZH1cbiAgICAgICAgICBjbGFzcz1cIm92ZXJmbG93XCJcbiAgICAgICAgICBkPVwiXG4gICAgICAgICAgTSAke3Bvcy54fSAke3Bvcy55fVxuICAgICAgICAgIEwgJHtwb3MueCswLjAwMX0gJHtwb3MueSswLjAwMX1cbiAgICAgICAgICBcIlxuICAgICAgICAgIHZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIlxuICAgICAgICAgIHN0cm9rZT1cInJnYmEoMCwwLDAsMClcIlxuICAgICAgICAgIHN0cm9rZS13aWR0aD1cIiR7NCp0aGlzLmhhbmRsZVNpemUqdGhpcy5fc2NhbGV9XCJcbiAgICAgICAgICAvPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGlkPSR7aWR9XG4gICAgICAgICAgY2xhc3M9XCJoYW5kbGVcIlxuICAgICAgICAgIGQ9XCJcbiAgICAgICAgICBNICR7cG9zLnh9ICR7cG9zLnl9XG4gICAgICAgICAgTCAke3Bvcy54KzAuMDAxfSAke3Bvcy55KzAuMDAxfVxuICAgICAgICAgIFwiXG4gICAgICAgICAgdmVjdG9yLWVmZmVjdD1cIm5vbi1zY2FsaW5nLXN0cm9rZVwiXG4gICAgICAgICAgc3Ryb2tlLXdpZHRoPVwiJHsyKnRoaXMuaGFuZGxlU2l6ZSp0aGlzLl9zY2FsZX1cIlxuICAgICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgICAgQGZvY3VzPSR7dGhpcy5kcmFnU3RhcnR9XG4gICAgICAgICAgQGJsdXI9JHt0aGlzLmRyYWdFbmR9XG4gICAgICAgICAgcm9sZT1cInNsaWRlclwiXG4gICAgICAgICAgYXJpYS12YWx1ZW1pbj0ke3RoaXMubWlufVxuICAgICAgICAgIGFyaWEtdmFsdWVtYXg9JHt0aGlzLm1heH1cbiAgICAgICAgICBhcmlhLXZhbHVlbm93PSR7dGhpc1tpZF19XG4gICAgICAgICAgYXJpYS1kaXNhYmxlZD0ke3RoaXMuZGlzYWJsZWR9XG4gICAgICAgICAgYXJpYS1sYWJlbD0ke2xhYmVsIHx8IFwiXCJ9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9nPlxuICAgICAgYFxuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB2aWV3ID0gdGhpcy5fYm91bmRhcmllcztcblxuICAgIHJldHVybiBodG1sYFxuICAgICAgPHN2Z1xuICAgICAgICBAbW91c2Vkb3duPSR7dGhpcy5kcmFnU3RhcnR9XG4gICAgICAgIEB0b3VjaHN0YXJ0PSR7dGhpcy5kcmFnU3RhcnR9XG4gICAgICAgIHhtbG49XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICAgIHZpZXdCb3g9XCIkey12aWV3LmxlZnR9ICR7LXZpZXcudXB9ICR7dmlldy53aWR0aH0gJHt2aWV3LmhlaWdodH1cIlxuICAgICAgICBzdHlsZT1cIm1hcmdpbjogJHt0aGlzLmhhbmRsZVNpemUqdGhpcy5oYW5kbGVab29tfXB4O1wiXG4gICAgICAgID9kaXNhYmxlZD0ke3RoaXMuZGlzYWJsZWR9XG4gICAgICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICAgID5cbiAgICAgICAgPGcgY2xhc3M9XCJzbGlkZXJcIj5cbiAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgY2xhc3M9XCJwYXRoXCJcbiAgICAgICAgICAgIGQ9JHt0aGlzLl9yZW5kZXJBcmModGhpcy5fc3RhcnQsIHRoaXMuX2VuZCl9XG4gICAgICAgICAgICB2ZWN0b3ItZWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCJcbiAgICAgICAgICAvPlxuICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICBjbGFzcz1cImJhclwiXG4gICAgICAgICAgICB2ZWN0b3ItZWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCJcbiAgICAgICAgICAgIGQ9JHt0aGlzLl9yZW5kZXJBcmMoXG4gICAgICAgICAgICAgIHRoaXMuX3ZhbHVlMmFuZ2xlKHRoaXMubG93ICE9IG51bGwgPyB0aGlzLmxvdyA6IHRoaXMubWluKSxcbiAgICAgICAgICAgICAgdGhpcy5fdmFsdWUyYW5nbGUodGhpcy5oaWdoICE9IG51bGwgPyB0aGlzLmhpZ2ggOiB0aGlzLnZhbHVlKVxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAvPlxuICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICBjbGFzcz1cInNoYWRvd3BhdGhcIlxuICAgICAgICAgICAgZD0ke3RoaXMuX3JlbmRlckFyYyh0aGlzLl9zdGFydCwgdGhpcy5fZW5kKX1cbiAgICAgICAgICAgIHZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIlxuICAgICAgICAgICAgc3Ryb2tlPVwicmdiYSgwLDAsMCwwKVwiXG4gICAgICAgICAgICBzdHJva2Utd2lkdGg9XCIkezMqdGhpcy5oYW5kbGVTaXplKnRoaXMuX3NjYWxlfVwiXG4gICAgICAgICAgICBzdHJva2UtbGluZWNhcD1cImJ1dHRcIlxuICAgICAgICAgIC8+XG5cbiAgICAgICAgPC9nPlxuXG4gICAgICAgIDxnIGNsYXNzPVwiaGFuZGxlc1wiPlxuICAgICAgICAkeyB0aGlzLl9zaG93SGFuZGxlXG4gICAgICAgICAgPyB0aGlzLmxvdyAhPSBudWxsXG4gICAgICAgICAgICAgID8gdGhpcy5fcmV2ZXJzZU9yZGVyXG4gICAgICAgICAgICAgICAgPyBodG1sYCR7dGhpcy5fcmVuZGVySGFuZGxlKFwiaGlnaFwiKX0gJHt0aGlzLl9yZW5kZXJIYW5kbGUoXCJsb3dcIil9YFxuICAgICAgICAgICAgICAgIDogaHRtbGAke3RoaXMuX3JlbmRlckhhbmRsZShcImxvd1wiKX0gJHt0aGlzLl9yZW5kZXJIYW5kbGUoXCJoaWdoXCIpfWBcbiAgICAgICAgICAgICAgOiBodG1sYCR7dGhpcy5fcmVuZGVySGFuZGxlKFwidmFsdWVcIil9YFxuICAgICAgICAgIDogYGBcbiAgICAgICAgfVxuICAgICAgICA8L2c+XG4gICAgICA8L3N2Zz5cbiAgICBgO1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHlsZXMoKSB7XG4gICAgcmV0dXJuIGNzc2BcbiAgICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgIH1cbiAgICAgIHN2ZyB7XG4gICAgICAgIG92ZXJmbG93OiB2aXNpYmxlO1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgIH1cbiAgICAgIHBhdGgge1xuICAgICAgICB0cmFuc2l0aW9uOiBzdHJva2UgMXMgZWFzZS1vdXQsIHN0cm9rZS13aWR0aCAyMDBtcyBlYXNlLW91dDtcbiAgICAgIH1cbiAgICAgIC5zbGlkZXIge1xuICAgICAgICBmaWxsOiBub25lO1xuICAgICAgICBzdHJva2Utd2lkdGg6IHZhcigtLXJvdW5kLXNsaWRlci1wYXRoLXdpZHRoLCAzKTtcbiAgICAgICAgc3Ryb2tlLWxpbmVjYXA6IHZhcigtLXJvdW5kLXNsaWRlci1saW5lY2FwLCByb3VuZCk7XG4gICAgICB9XG4gICAgICAucGF0aCB7XG4gICAgICAgIHN0cm9rZTogdmFyKC0tcm91bmQtc2xpZGVyLXBhdGgtY29sb3IsIGxpZ2h0Z3JheSk7XG4gICAgICB9XG4gICAgICAuYmFyIHtcbiAgICAgICAgc3Ryb2tlOiB2YXIoLS1yb3VuZC1zbGlkZXItYmFyLWNvbG9yLCBkZWVwc2t5Ymx1ZSk7XG4gICAgICB9XG4gICAgICBzdmdbZGlzYWJsZWRdIC5iYXIge1xuICAgICAgICBzdHJva2U6IHZhcigtLXJvdW5kLXNsaWRlci1kaXNhYmxlZC1iYXItY29sb3IsIGRhcmtncmF5KTtcbiAgICAgIH1cbiAgICAgIGcuaGFuZGxlcyB7XG4gICAgICAgIHN0cm9rZTogdmFyKC0tcm91bmQtc2xpZGVyLWhhbmRsZS1jb2xvciwgdmFyKC0tcm91bmQtc2xpZGVyLWJhci1jb2xvciwgZGVlcHNreWJsdWUpKTtcbiAgICAgICAgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xuICAgICAgfVxuICAgICAgZy5sb3cuaGFuZGxlIHtcbiAgICAgICAgc3Ryb2tlOiB2YXIoLS1yb3VuZC1zbGlkZXItbG93LWhhbmRsZS1jb2xvcik7XG4gICAgICB9XG4gICAgICBnLmhpZ2guaGFuZGxlIHtcbiAgICAgICAgc3Ryb2tlOiB2YXIoLS1yb3VuZC1zbGlkZXItaGlnaC1oYW5kbGUtY29sb3IpO1xuICAgICAgfVxuICAgICAgc3ZnW2Rpc2FibGVkXSBnLmhhbmRsZXMge1xuICAgICAgICBzdHJva2U6IHZhcigtLXJvdW5kLXNsaWRlci1kaXNhYmxlZC1iYXItY29sb3IsIGRhcmtncmF5KTtcbiAgICAgIH1cbiAgICAgIC5oYW5kbGU6Zm9jdXMge1xuICAgICAgICBvdXRsaW5lOiB1bnNldDtcbiAgICAgIH1cbiAgICBgO1xuICB9XG5cbn1cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgncm91bmQtc2xpZGVyJywgUm91bmRTbGlkZXIpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQU1BO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBbEJBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7OztBQUdBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU9BO0FBQ0E7QUFBQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOzs7O0FBSUE7OztBQUdBOzs7QUFHQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQTlCQTtBQWtDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7QUFPQTs7O0FBR0E7Ozs7Ozs7QUFPQTs7O0FBcENBO0FBK0NBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQTJDQTtBQUNBO0FBOWNBO0FBQ0E7QUErY0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@thomasloven/round-slider/src/main.js\n");

/***/ }),

/***/ "./node_modules/deep-freeze/index.js":
/*!*******************************************!*\
  !*** ./node_modules/deep-freeze/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function deepFreeze(o) {\n  Object.freeze(o);\n  Object.getOwnPropertyNames(o).forEach(function (prop) {\n    if (o.hasOwnProperty(prop) && o[prop] !== null && (typeof o[prop] === \"object\" || typeof o[prop] === \"function\") && !Object.isFrozen(o[prop])) {\n      deepFreeze(o[prop]);\n    }\n  });\n  return o;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcC1mcmVlemUvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcC1mcmVlemUvaW5kZXguanM/Yjg4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZXBGcmVlemUgKG8pIHtcbiAgT2JqZWN0LmZyZWV6ZShvKTtcblxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgaWYgKG8uaGFzT3duUHJvcGVydHkocHJvcClcbiAgICAmJiBvW3Byb3BdICE9PSBudWxsXG4gICAgJiYgKHR5cGVvZiBvW3Byb3BdID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvW3Byb3BdID09PSBcImZ1bmN0aW9uXCIpXG4gICAgJiYgIU9iamVjdC5pc0Zyb3plbihvW3Byb3BdKSkge1xuICAgICAgZGVlcEZyZWV6ZShvW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuICBcbiAgcmV0dXJuIG87XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/deep-freeze/index.js\n");

/***/ })

}]);